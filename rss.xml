<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://javaguide.cn/rss.xml" rel="self" type="application/rss+xml"/>
    <title>JavaGuide</title>
    <link>https://javaguide.cn/</link>
    <description>Java学习&amp;&amp;面试指南</description>
    <language>zh-CN</language>
    <pubDate>Wed, 05 Jan 2022 06:33:47 GMT</pubDate>
    <lastBuildDate>Wed, 05 Jan 2022 06:33:47 GMT</lastBuildDate>
    <generator>@mr-hope/vuepress-plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by Guide哥</copyright>
    <category>计算机基础</category>
    <category>数据库</category>
    <category>技术文章精选集</category>
    <category>IDEA指南</category>
    <category>Java</category>
    <category>框架</category>
    <category>开发工具</category>
    <item>
      <title>抄袭狗，你冬天睡觉脚必冷！！！</title>
      <link>https://javaguide.cn/about-the-author/dog-that-copies-other-people-essay/</link>
      <guid>https://javaguide.cn/about-the-author/dog-that-copies-other-people-essay/</guid>
      <source url="https://javaguide.cn/rss.xml">抄袭狗，你冬天睡觉脚必冷！！！</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="抄袭狗-你冬天睡觉脚必冷"> 抄袭狗，你冬天睡觉脚必冷！！！</h1>
<p>抄袭狗真的太烦了。。。</p>
<p>听朋友说我的文章在知乎又被盗了，原封不动地被别人用来引流。</p>
<p><img src="https://img-blog.csdnimg.cn/2e1416ba2d88460fbacc8ac265fef70a.png" alt="" /></p>
<p>而且！！！这还不是最气的。</p>
<p>这人还在文末注明的原出处还不是我的。。。</p>
<p><img src="https://img-blog.csdnimg.cn/6087471b7b9449dcb3c8b593953ad895.png" alt="" /></p>
<p>也就是说 CSDN 有另外一位抄袭狗盗了我的这篇文章并声明了原创，知乎抄袭狗又原封不动地搬运了这位 CSDN 抄袭狗的文章。</p>
<p>真可谓离谱他妈给离谱开门，离谱到家了。</p>
<p><img src="https://img-blog.csdnimg.cn/351cee184cac4af6a6e9f3ae18a4dd90.png" alt="" /></p>
<p>我打开知乎抄袭狗注明的原出处链接，好家伙，一模一样的内容，还表明了原创。</p>
<p><img src="https://img-blog.csdnimg.cn/f0740bfac9ea4490815d827c6a69e498.png" alt="" /></p>
<p>看了一下 CSDN 这位抄袭狗的文章，好家伙，把我高赞回答搬运了一个遍。。。真是很勤奋了。。。</p>
<p>CSDN 我就不想多说了，就一大型文章垃圾场，都是各种不规范转载，各种收费下载的垃圾资源。这号称国内流量最大的技术网站贼恶心，吃香太难看，能不用就不要用吧！</p>
<p>像我自己平时用 Google 搜索的时候，都是直接屏蔽掉 CSDN 这个站点的。只需要下载一个叫做 Personal Blocklist  的 Chrome 插件，然后将 blog.csdn.net 添加进黑名单就可以了。</p>
<p><img src="https://img-blog.csdnimg.cn/40ce678411834a708088d8d0af4dca1f.png" alt="" /></p>
<p>我的文章基本被盗完了，关键是我自己发没有什么流量，反而是盗我文章的那些人比我这个原作者流量还大。</p>
<p>这是什么世道，是人性的扭曲还是道德的沦丧？</p>
<p>不过，也没啥，CSDN 这垃圾网站不去发文也无妨。</p>
<p>看看 CSDN 热榜上的文章都是一些什么垃圾，不是各种广告就是一些毫无质量的拼凑文。</p>
<p><img src="https://img-blog.csdnimg.cn/ed9b415bbe7e49a5afde4825aa807a90.png" alt="" /></p>
<p>当然了，也有极少部分的高质量文章，比如涛哥、二哥、冰河、微观技术等博主的文章。</p>
<p>还有很多视频平台（比如抖音、哔哩哔哩）上面有很多博主直接把别人的原创拿来做个视频，用来引流或者吸粉。</p>
<p>今天提到的这篇被盗的文章曾经就被一个培训机构拿去做成了视频用来引流。</p>
<p><img src="https://img-blog.csdnimg.cn/58326aebd4514f8db9b8531f79642d6f.png" alt="" /></p>
<p>作为个体，咱也没啥办法，只能遇到一个举报一个。。。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/2e1416ba2d88460fbacc8ac265fef70a.png" type="image/png"/>
    </item>
    <item>
      <title>从毕业到入职半年的感受</title>
      <link>https://javaguide.cn/about-the-author/feelings-of-half-a-year-from-graduation-to-entry/</link>
      <guid>https://javaguide.cn/about-the-author/feelings-of-half-a-year-from-graduation-to-entry/</guid>
      <source url="https://javaguide.cn/rss.xml">从毕业到入职半年的感受</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="从毕业到入职半年的感受"> 从毕业到入职半年的感受</h1>
<p>如果大家看过我之前的介绍的话，就会知道我是 19 年毕业的几百万应届毕业生中的一员。这篇文章主要讲了一下我入职大半年的感受，文中有很多自己的主观感受，如果你们有任何不认同的地方都可以直接在评论区说出来， 会很尊重其他人的想法。</p>
<p>简单说一下自己的情况吧！我目前是在一家外企，每天的工作和大部分人一样就是做开发。毕业到现在，差不多也算是工作半年多了，也已经过了公司 6 个月的试用期。目前在公司做过两个偏向于业务方向的项目，其中一个正在做。你很难想象我在公司做的两个业务项目的后端都没有涉及到分布式/微服务，没有接触到 Redis、Kafka 等等比较“高大上”的技术在项目中的实际运用。</p>
<p>第一个项目做的是公司的内部项目——员工成长系统。抛去员工成长系统这个名字，实际上这个系统做的就是绩效考核比如你在某个项目组的表现。这个项目的技术是 Spring Boot+ JPA+Spring Security + K8S+Docker+React。第二个目前正在做的是一个集成游戏（cocos）、Web 管理端(Spring Boot+Vue)和小程序（Taro）项目。</p>
<p>是的，我在工作中的大部分时间都和 CRUD 有关，每天也会写前端页面。之前我认识的一个朋友 ，他听说我做的项目中大部分内容都是写业务代码之后就非常纳闷，他觉得单纯写业务代码得不到提升？what?你一个应届生，连业务代码都写不好你给我说这个！所以，<strong>我就很纳闷不知道为什么现在很多连业务代码都写不好的人为什么人听到 CRUD 就会反感？至少我觉得在我工作这段时间我的代码质量得到了提升、定位问题的能力有了很大的改进、对于业务有了更深的认识，自己也可以独立完成一些前端的开发了。</strong></p>
<p>其实，我个人觉得能把业务代码写好也没那么容易，抱怨自己天天做 CRUD 工作之前，看看自己 CRUD 的代码写好没。再换句话说，单纯写 CRUD 的过程中你搞懂了哪些你常用的注解或者类吗？这就像一个只会 <code>@Service</code>、<code>@Autowired</code>、<code>@RestController</code>等等最简单的注解的人说我已经掌握了 Spring Boot 一样。</p>
<p>不知道什么时候开始大家都会觉得有实际使用 Redis、MQ 的经验就很牛逼了， 这可能和当前的面试环境有关系。你需要和别人有差异，你想进大厂的话，好像就必须要这些技术比较在行，好吧，没有好像，自信点来说对于大部分求职者这些技术都是默认你必备的了。</p>
<p><strong>实话实说，我在大学的时候就陷入过这个“伪命题”中</strong>。在大学的时候，我大二因为加入了一个学校的偏技术方向的校媒才接触到 Java ，当时我们学习 Java 的目的就是开发一个校园通。 大二的时候，编程相当于才入门水平的我才接触 Java，花了一段时间才掌握 Java 基础。然后，就开始学习安卓开发。</p>
<p>到了大三上学期，我才真正确定要走 Java 后台的方向，找 Java 后台的开发工作。学习了 3 个月左右的 WEB 开发基础之后，我就开始学习分布式方面内容比如 Redis、Dubbo 这些。我当时是通过看书+视频+博客的方式学习的，自学过程中通过看视频自己做过两个完整的项目，一个普通的业务系统，一个是分布式的系统。<strong>我当时以为自己做完之后就很牛逼了，我觉得普通的 CRUD 工作已经不符合我当前的水平了。哈哈！现在看来，当时的我过于哈皮！</strong></p>
<p>这不！到了大三暑假跟着老师一起做项目的时候就出问题了。大三的时候，我们跟着老师做的是一个绩效考核系统，业务复杂程度中等。这个项目的技术用的是：SSM+Shiro+JSP。当时，做这个项目的时候我遇到各种问题，各种我以为我会写的代码都不会写了，甚至我写一个简单的 CRUD 都要花费好几天的时间。所以，那时候我都是边复习边学习边写代码。虽然很累，但是，那时候学到了很多，也让我在技术面前变得更加踏实。我觉得这“<strong>这个项目已经没有维护的可能性</strong>”这句话是我对我过的这个项目最大的否定了。</p>
<p>技术千变万化，掌握最核心的才是王道。我们前几年可能还在用 Spring 基于传统的 XML 开发，现在几乎大家都会用 Spring Boot 这个开发利器来提升开发速度，再比如几年前我们使用消息队列可能还在用 ActiveMQ，到今天几乎都没有人用它了，现在比较常用的就是 Rocket MQ、Kafka 。技术更新换代这么快的今天，你是无法把每一个框架/工具都学习一遍的， 。</p>
<p><strong>很多初学者上来就想通过做项目学习，特别是在公司，我觉得这个是不太可取的。</strong> 如果的 Java 基础或者 Spring Boot 基础不好的话，建议自己先提前学习一下之后再开始看视频或者通过其他方式做项目。 <strong>还有一点就是，我不知道为什么大家都会说边跟着项目边学习做的话效果最好，我觉得这个要加一个前提是你对这门技术有基本的了解或者说你对编程有了一定的了解。</strong></p>
<p><strong>划重点！！！在自己基础没打牢的情况下，单纯跟着视频做一点用没有。你会发现你看完视频之后，让你自己写代码的时候又不会写了。</strong></p>
<p>不知道其他公司的程序员是怎么样的？我感觉技术积累很大程度在乎平时，单纯依靠工作绝大部分情况只会加快自己做需求的熟练度，当然，写多了之后或多或少也会提升你对代码质量的认识（前提是你有这个意识）。</p>
<p>工作之余，我会利用业余时间来学习自己想学的东西。工作中的例子就是我刚进公司的第一个项目用到了 Spring Security+JWT ,因为当时自己对于这个技术不太了解，然后就在工作之外大概花了一周的时间学习写了一个 Demo 分享了出来,Github 地址：https://github.com/Snailclimb/spring-security-jwt-guide 。以次为契机，我还分享了</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485626&amp;idx=1&amp;sn=3247aa9000693dd692de8a04ccffeec1&amp;chksm=cea24771f9d5ce675ea0203633a95b68bfe412dc6a9d05f22d221161147b76161d1b470d54b3&amp;token=684071313&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">《一问带你区分清楚 Authentication,Authorization 以及 Cookie、Session、Token》</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485655&amp;idx=1&amp;sn=583eeeb081ea21a8ec6347c72aa223d6&amp;chksm=cea2471cf9d5ce0aa135f2fb9aa32d98ebb3338292beaccc1aae43d1178b16c0125eb4139ca4&amp;token=1737409938&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">JWT 身份认证优缺点分析以及常见问题解决方案</a></li>
</ul>
<p>另外一个最近的例子是因为肺炎疫情在家的这段时间，自学了 Kafka，并且正在准备写一系列的入门文章，目前已经完成了：</p>
<ol>
<li>大白话 Kafka 入门；</li>
<li>Kafka 安装和基本功能体验；</li>
<li>Spring Boot 整合 Kafka 发送和接受消息；</li>
<li>Spring Boot 整合 Kafka 发送和接受消息的一些事务、错误消息处理等等。</li>
</ol>
<p>还没完成的：</p>
<ol>
<li>
<p>Kafka 高级特性比如工作流程、Kafka 为什么快等等的分析；</p>
</li>
<li>
<p>源码阅读分析；</p>
</li>
<li>
<p>......</p>
</li>
</ol>
<p><strong>所以，我觉得技术的积累和沉淀很大程度在乎工作之外的时间(大佬和一些本身就特别厉害的除外)。</strong></p>
<p><strong>未来还有很长的路要走，即使再有精力也学不完你想学的所有技术，适当取舍、适当妥协，适当娱乐。</strong></p>
]]></content:encoded>
    </item>
    <item>
      <title>入职培训一个月后的感受</title>
      <link>https://javaguide.cn/about-the-author/feelings-after-one-month-of-induction-training/</link>
      <guid>https://javaguide.cn/about-the-author/feelings-after-one-month-of-induction-training/</guid>
      <source url="https://javaguide.cn/rss.xml">入职培训一个月后的感受</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="入职培训一个月后的感受"> 入职培训一个月后的感受</h1>
<p>不知不觉已经入职一个多月了，在入职之前我没有在某个公司实习过或者工作过，所以很多东西刚入职工作的我来说还是比较新颖的。学校到职场的转变，带来了角色的转变，其中的差别因人而异。对我而言，在学校的时候课堂上老师课堂上教的东西，自己会根据自己的兴趣选择性接受，甚至很多课程你不想去上的话，还可以逃掉。到了公司就不一样了，公司要求你会的技能你不得不学，除非你不想干了。在学校的时候大部分人编程的目的都是为了通过考试或者找到一份好工作，真正靠自己兴趣支撑起来的很少，到了工作岗位之后我们编程更多的是因为工作的要求，相比于学校的来说会一般会更有挑战而且压力更大。在学校的时候，我们最重要的就是对自己负责，我们不断学习知识去武装自己，但是到了公司之后我们不光要对自己负责，更要对公司负责，毕竟公司出钱请你过来，不是让你一直 on beach 的。</p>
<p>刚来公司的时候，因为公司要求，我换上了 Mac 电脑。由于之前一直用的是 Windows 系统，所以非常不习惯。刚开始用  Mac 系统的时候笨手笨脚，自己会很明显的感觉自己的编程效率降低了至少 3 成。当时内心还是挺不爽的，心里也总是抱怨为什么不直接用  Windows 系统或者 Linux 系统。不过也挺奇怪，大概一个星期之后，自己就开始慢慢适应使用 Mac 进行编程，甚至非常喜欢。我这里不想对比 Mac 和 Windows 编程体验哪一个更好，我觉得还是因人而异，相同价位的 Mac 的配置相比于  Windows确实要被甩几条街。不过 Mac 的编程和使用体验确实不错，当然你也可以选择使用  Linux 进行日常开发，相信一定很不错。 另外，Mac 不能玩一些主流网络游戏，对于一些克制不住自己想玩游戏的朋友是一个不错的选择。</p>
<p>不得不说 ThoughtWorks 的培训机制还是很不错的。应届生入职之后一般都会安排培训，与往年不同的是，今年的培训多了中国本地班（TWU-C）。作为本地班的第一期学员，说句心里话还是很不错。8周的培训，除了工作需要用到的基本技术比如ES6、SpringBoot等等之外，还会增加一些新员工基本技能的培训比如如何高效开会、如何给别人正确的提 Feedback、如何对代码进行重构、如何进行 TDD 等等。培训期间不定期的有活动，比如Weekend Trip、 City Tour、Cake time等等。最后三周还会有一个实际的模拟项目，这个项目基本和我们正式工作的实际项目差不多，我个人感觉很不错。目前这个项目已经正式完成了一个迭代，我觉得在做项目的过程中，收获最大的不是项目中使用的技术，而是如何进行团队合作、如何正确使用 Git 团队协同开发、一个完成的迭代是什么样子的、做项目的过程中可能遇到那些问题、一个项目运作的完整流程等等。</p>
<p>ThoughtWorks 非常提倡分享、提倡帮助他人成长，这一点在公司的这段时间深有感触。培训期间，我们每个人会有一个 Trainer 负责，Trainer 就是日常带我们上课和做项目的同事，一个 Trainer 大概会负责5-6个人。Trainer不定期都会给我们最近表现的  Feedback( 反馈) ，我个人觉得这个并不是这是走走形式，Trainer 们都很负责，很多时候都是在下班之后找我们聊天。同事们也都很热心，如果你遇到问题，向别人询问，其他人如果知道的话一般都会毫无保留的告诉你，如果遇到大部分都不懂的问题，甚至会组织一次技术 Session 分享。上周五我在我们小组内进行了一次关于 Feign 远程调用的技术分享，因为 team 里面大家对这部分知识都不太熟悉，但是后面的项目进展大概率会用到这部分知识。我刚好研究了这部分内容，所以就分享给了组内的其他同事，以便于项目更好的进行。</p>
<p>另外，ThoughtWorks 也是一家非常提倡 Feedback( 反馈) 文化的公司，反馈是告诉人们我们对他们的表现的看法以及他们应该如何更好地做到这一点。刚开始我并没有太在意，慢慢地自己确实感觉到正确的进行反馈对他人会有很大的帮助。因为人在做很多事情的时候，会很难发现别人很容易看到的一些小问题。就比如一个很有趣的现象一样，假如我们在做项目的时候没有测试这个角色，如果你完成了自己的模块，并且自己对这个模块测试了很多遍，你发现已经没啥问题了。但是，到了实际使用的时候会很大概率出现你之前从来没有注意的问题。解释这个问题的说法是：每个人的视野或多或少都是有盲点的，这与我们的关注点息息相关。对于自己做的东西，很多地方自己测试很多遍都不会发现，但是如果让其他人帮你进行测试的话，就很大可能会发现很多显而易见的问题。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/feedback.png" alt="" /></p>
<p>工作之后，平时更新公众号、专栏还有维护 Github 的时间变少了。实际上，很多时候下班回来后，都有自己的时间来干自己的事情，但是自己也总是找工作太累或者时间比较零散的接口来推掉了。到了今天，翻看 Github 突然发现 14 天前别人在 Github 上给我提的 pr 我还没有处理。这一点确实是自己没有做好的地方，没有合理安排好自己的时间。实际上自己有很多想写的东西，后面会慢慢将他们提上日程。工作之后，更加发现下班后的几个小时如何度过确实很重要 ，如果你觉得自己没有完成好自己白天该做的工作的话，下班后你可以继续忙白天没有忙完的工作，如果白天的工作对于你游刃有余的话，下班回来之后，你大可去干自己感兴趣的事情，学习自己感兴趣的技术。做任何事情都要基于自身的基础，切不可好高骛远。</p>
<p>工作之后身边也会有很多厉害的人，多从他人身上学习我觉得是每个职场人都应该做的。这一届和我们一起培训的同事中，有一些技术很厉害的，也有一些技术虽然不是那么厉害，但是组织能力以及团队协作能力特别厉害的。有一个特别厉害的同事，在我们还在学 SpringBoot 各种语法的时候，他自己利用业余时间写了一个简化版的 SpringBoot ，涵盖了 Spring 的一些常用注解比如 <code>@RestController</code>、<code>@Autowried</code>、<code>@Pathvairable</code>、<code>@RestquestParam</code>等等（已经联系这位同事，想让他开源一下，后面会第一时间同步到公众号，期待一下吧！）。我觉得这位同事对于编程是真的有兴趣，他好像从初中就开始接触编程了，对于各种底层知识也非常感兴趣，自己写过实现过很多比较底层的东西。他的梦想是在 Github 上造一个 20k Star 以上的轮子。我相信以这位同事的能力一定会达成目标的，在这里祝福这位同事，希望他可以尽快实现这个目标。</p>
<p>这是我入职一个多月之后的个人感受，很多地方都是一带而过，后面我会抽时间分享自己在公司或者业余学到的比较有用的知识给各位，希望看过的人都能有所收获。</p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/feedback.png" type="image/png"/>
    </item>
    <item>
      <title>我曾经也是网瘾少年</title>
      <link>https://javaguide.cn/about-the-author/internet-addiction-teenager/</link>
      <guid>https://javaguide.cn/about-the-author/internet-addiction-teenager/</guid>
      <source url="https://javaguide.cn/rss.xml">我曾经也是网瘾少年</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="我曾经也是网瘾少年"> 我曾经也是网瘾少年</h1>
<p>聊到高考，无数人都似乎有很多话说。今天就假借高考的名义，<strong>简单</strong>来聊聊我的求学经历吧！因为我自己的求学经历真的还不算平淡，甚至有点魔幻，所以还是有很多话想要说的。这篇文章大概会从我的初中一直介绍到大学，每一部分我都不会花太多篇幅。实际上，每一段经历我都可以增加很多“有趣”的经历，考虑到篇幅问题，以后有机会再慢慢说吧！</p>
<p>整个初中我都属于有点网瘾少年的状态，不过初三的时候稍微克制一些。到了高二下学期的时候，自己才对游戏没有真的没有那么沉迷了。</p>
<p>另外，关于大学的详细经历我已经在写了。想要知道我是如何从一个普通的不能再普通的少年慢慢成长起来的朋友不要错过~</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-08/0e370ac2-5f96-4e17-9ff4-8cc78ef72f19-20200802173544441.png" alt="" /></p>
<p><strong>以下所有内容皆是事实，没有任何夸大的地方，稍微有一点点魔幻。</strong></p>
<h2 id="_01-刚开始接触电脑"> 01 刚开始接触电脑</h2>
<p>最开始接触电脑是在我五年级的时候，那时候家里没电脑，都是在黑网吧玩的。我现在已经记不清当时是被哥哥还是姐姐带进网吧的了。</p>
<p>起初的时候，自己就是玩玩流行蝴蝶剑、单机摩托之类的单机游戏。但是，也没有到沉迷的地步，只是觉得这东西确实挺好玩的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-08/2a6021b9-e7a0-41c4-b69e-a652f7bc3e12-20200802173601289.png" alt="" /></p>
<p>开始有网瘾是在小学毕业的时候，在我玩了一款叫做 <strong>QQ 飞车</strong>的游戏之后（好像是六年级就开始玩了）。我艹，当时真的被这游戏吸引了。<strong>每天上课都幻想自己坐在车里面飘逸，没错，当时就觉得秋名山车神就是我啦！</strong></p>
<p>我记得，那时候上网还不要身份证，10 元办一张网卡就行了，网费也是一元一小时。但凡，我口袋里有余钱，我都会和我的小伙伴奔跑到网吧一起玩 QQ 飞车。Guide 的青回啊！说到这，我情不自禁地打开自己的 Windows 电脑，下载了 Wegame ，然后下载了 QQ 飞车。</p>
<p>到了初二的时候，就没玩 QQ 飞车了。我的等级也永久定格在了 <strong>120</strong> 级，这个等级在当时那个升级难的一匹的年代，算的上非常高的等级了。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/b488618c-3c25-4bc9-afd4-7324e27553bd-20200802175534614.png" alt="" /></p>
<h2 id="_02-初二网瘾爆发"> 02 初二网瘾爆发</h2>
<p>网瘾爆发是在上了初中之后。初二的时候，最为猖狂，自己当时真的是太痴迷 <strong>穿越火线</strong> 了，每天上课都在想像自己拿起枪横扫地方阵营的场景。除了周末在网吧度过之外，我经常每天早上还会起早去玩别人包夜留下的机子，毕竟那时候上学也没什么钱嘛！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/9e94bb35-650d-4cad-8e69-40043fb4ec3d-20200802173632800.png" alt="" /></p>
<p>那时候成绩挺差的。这样说吧！我当时在很普通的一个县级市的高中，全年级有 500 来人，我基本都是在 280 名左右。</p>
<p>而且，整个初二我都没有学物理。因为开学不久的一次物理课，物理老师误会我在上课吃东西还狡辩，闪了我一巴掌。从此，我上物理课就睡觉，平常的物理考试就交白卷。那时候心里一直记仇，想着以后自己长大了再把这个物理老师暴打一顿。</p>
<p>初中时候的觉悟是在初三上学期的时候，当时就突然意识到自己马上就要升高中了。为了让自己能在家附近上学，因为当时我家就在我们当地的二中附近（<em>附近网吧多是主要原因，哈哈</em>）。年级前 80 的话基本才有可能考得上二中。<strong>经过努力，初三上学期的第一次月考我直接从 280 多名进不到了年级 50 多名。当时，还因为进步太大，被当做进步之星在讲台上给整个年级做演讲。</strong> 那也是我第一次在这么多人面前讲话，挺紧张的，但是挺爽的。</p>
<p><strong>其实在初三的时候，我的网瘾还是很大。不过，我去玩游戏的前提都是自己把所有任务做完，并且上课听讲也很认真。</strong> 我参加高中提前考试前的一个晚上，我半夜12点乘着妈妈睡着，跑去了网吧玩CF到凌晨 3点多回来。那一次我被抓了现行，到家之后发现妈妈就坐在客厅等我，训斥一顿后，我就保证以后不再晚上偷偷跑出去了（<em>其实整个初二我通宵了无数次，每个周五晚上都回去通宵</em>）。</p>
<p><em>这里要说明一点：我的智商我自己有自知之明的，属于比较普通的水平吧！ 前进很大的主要原因是自己基础还行，特别是英语和物理。英语是因为自己喜欢，加上小学就学了很多初中的英语课程。 物理的话就很奇怪，虽然初二也不怎么听物理课，也不会物理，但是到了初三之后自己就突然开窍了。真的！我现在都感觉很奇怪。然后，到了高中之后，我的英语和物理依然是我最好的两门课。大学的兼职，我出去做家教都是教的高中物理。</em></p>
<p>后面，自己阴差阳错参加我们那个县级市的提前招生考试，然后就到了我们当地的二中，也没有参加中考。</p>
<h2 id="_03-高中生活"> 03 高中生活</h2>
<p>上了高中的之后，我上课就偷偷看小说，神印王座、斗罗大陆很多小说都是当时看的。中午和晚上回家之后，就在家里玩几把 DNF，当时家里也买了电脑。没记错的话，到我卸载 DNF 的时候已经练了 4 个满级的号。大量时间投入在游戏和小说上，我成功把自己从学校最好的小班玩到奥赛班，然后再到平行班。有点魔幻吧！</p>
<p>高中觉悟是在高二下学期的时候，当时是真的觉悟了，就突然觉得游戏不香了，觉得 DNF 也不好玩了。我妈妈当时还很诧异，还奇怪地问我：“怎么不玩游戏了？”（<em>我妈属于不怎么管我玩游戏的，她觉得这东西还是要靠自觉</em>）。</p>
<p><em>当时，自己就感觉这游戏没啥意思了。内心的真实写照是：“我练了再多的满级的DNF账号有啥用啊？以后有钱了，直接氪金不久能很牛逼嘛！” 就突然觉悟了！</em></p>
<p>然后，我就开始牟足劲学习。当时，理科平行班大概有 7 个，每次考试都是平行班之间会单独拍一个名次。 后面的话，自己基本每次都能在平行班得第一，并且很多时候都是领先第二名个 30 来分。因为成绩还算亮眼，高三上学期快结束的时候，我就向年级主任申请去了奥赛班。</p>
<h2 id="_04-高考前的失眠"> 04 高考前的失眠</h2>
<blockquote>
<p><strong>失败之后，不要抱怨外界因素，自始至终实际都是自己的问题，自己不够强大！</strong> 然后，高考前的失眠也是我自己问题，要怪只能怪自己，别的没有任何接口。</p>
</blockquote>
<p>我的高考经历其实还蛮坎坷的，毫不夸张的说，高考那今天可能是我到现在为止，经历的最难熬的时候，特别是在晚上。</p>
<p>我在高考那几天晚上都经历了失眠，想睡都睡不着那种痛苦想必很多人或许都体验过。</p>
<p>其实我在之前是从来没有过失眠的经历的。高考前夕，因为害怕自己睡不着，所以，我提前让妈妈去买了几瓶老师推荐的安神补脑液。我到现在还记得这个安神补脑液是敖东牌的。</p>
<p>高考那几天的失眠，我觉得可能和我喝了老师推荐的安神补脑液有关系，又或者是我自己太过于紧张了。因为那几天睡觉总会感觉有很多蚂蚁在身上爬一样，然后还起了一些小痘痘。</p>
<p>然后，这里要格外说明一点，避免引起误导： <strong>睡不着本身就是自身的问题，上述言论并没有责怪这个补脑液的意思。</strong> 另外， 这款安神补脑液我去各个平台都查了一下，发现大家对他的评价都挺好，和我们老师当时推荐的理由差不多。如果大家需要改善睡眠的话，可以咨询相关医生之后尝试一下。</p>
<h2 id="_05-还算充实的大学生活"> 05 还算充实的大学生活</h2>
<p>高考成绩出来之后，比一本线高了 20 多分。自己挺不满意的，因为比平时考差了太多。加上自己泪点很低，就哭了一上午之后。后面，自我安慰说以后到了大学好好努力也是一样的。然后，我的第一志愿学校就报了长江大学，第一志愿专业就报了计算机专业。</p>
<p>后面，就开始了自己还算充实的大学生活。</p>
<p>大一的时候，满腔热血，对于高考结果的不满意，化作了我每天早起的动力。雷打不动，每天早上 6点左右就出去背英语单词。这也奠定了我后面的四六级都是一次过，并且六级的成绩还算不错。大一那年的暑假，我还去了孝感当了主管，几乎从无到有办了 5 个家教点。不过，其中两个家教点的话，是去年都已经办过的，没有其他几个那么费心。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/5a47eb4614934a25b8ea1a83cafac43d-20200802173912511.png" alt="被我的学生 diss" /></p>
<p>大二的时候，加了学校一个偏技术方向的传媒组织（做网站、APP 之类的工作），后面成功当了副站长。在大二的时候，我才开始因为组织需要而接触 Java，不过当时主要学的是安卓开发。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/b16201d0-37d4-462a-a5e6-bf95ca503d39-20200802174034108.png" alt="" /></p>
<p>大三的时候，正式确定自己要用 Java 语言找工作，并且要走 Java 后台（当时感觉安卓后台在求职时长太不吃香了）。我每天都在寝室学习 Java 后台开发，自己看视频，看书，做项目。我的开源项目 JavaGuide 和公众号都是这一年创建的。这一年，我大部分时间都是在寝室学习。带上耳机之后，即使室友在玩游戏或者追剧，都不会对我有什么影响。</p>
<p>我记得当时自己独立做项目的时候，遇到了很多问题。<strong>就很多时候，你看书很容易就明白的东西，等到你实践的时候，总是会遇到一些小问题。我一般都是通过 Google 搜索解决的，用好搜索引擎真的能解决自己 99% 的问题。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-08/d30eef29-3a73-483d-9a4a-d63f41271fb4-20200802174048832.png" alt="" /></p>
<p>大四的时候，开始找工作。我是参加的秋招，开始的较晚，基本很多公司都没有 HC 了。这点需要 diss 一下学校了，你其他地方都很好，但是，大四的时候就不要再上课点名了吧！然后，<strong>希望国内的学校尽量能多给学生点机会吧！很多人连春招和秋招都不清楚，毕业了连实习都没实习过。</strong></p>
<h2 id="_06-一些心里话"> 06 一些心里话</h2>
<p>关于大学要努力学习专业知识、多去读书馆这类的鸡汤，Guide 就不多说了。就谈几条自己写这篇文章的时候，想到了一些心理话吧！</p>
<ol>
<li><strong>不要抱怨学校</strong> ：高考之后，不论你是 985、211 还是普通一本，再或者是 二本、三本，都不重要了，好好享受高考之后的生活。如果你觉得自己考的不满意的话，就去复读，没必要天天抱怨，复读的一年在你的人生长河里根本算不了什么的！</li>
<li><strong>克制</strong> ：大学的时候，克制住自己，诱惑太多了。你不去上课，在寝室睡到中午，都没人管你。你的努力不要只是感动自己！追求形式的努力不过是你打得幌子而已。到了社会之后，这个说法依然适用！ 说一个真实的发生在我身边的事情吧！高中的时候有一个特别特别特别努力的同班同学，家里的条件也很差，大学之前没有接触过手机和游戏。后来到了大学之后，因为接触了手机还有手机游戏，每天沉迷，不去上课。最后，直接就导致大学没读完就离开了。我听完我的好朋友给我说了之后，非常非常非常诧异！真的太可惜了！</li>
<li><strong>不要总抱怨自己迷茫，多和优秀的学长学姐沟通交流。</strong></li>
<li><strong>不知道做什么的时候，就把手头的事情做好比如你的专业课学习。</strong></li>
</ol>
<p><em>不论以前的自己是什么样，自己未来变成什么样自己是可以决定的，未来的路也终究还是要自己走。大环境下，大部分人都挺难的，当 996 成为了常态，Life Balance 是不可能的了。我们只能试着寻求一种平衡，试着去热爱自己现在所做的事情。</em></p>
<p><strong>往后余生，爱家人，亦爱自己；好好生活，不忧不恼。</strong></p>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-08/0e370ac2-5f96-4e17-9ff4-8cc78ef72f19-20200802173544441.png" type="image/png"/>
    </item>
    <item>
      <title>1049天,100K Star！简单复盘</title>
      <link>https://javaguide.cn/about-the-author/javaguide-100k-star/</link>
      <guid>https://javaguide.cn/about-the-author/javaguide-100k-star/</guid>
      <source url="https://javaguide.cn/rss.xml">1049天,100K Star！简单复盘</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1049天-100k-star-简单复盘"> 1049天,100K Star！简单复盘</h1>
<p>2021-03-21，晚上12点，肝完了我正在做的一个项目的前端的某块功能，我随手打开了<a href="https://github.com/Snailclimb" target="_blank" rel="noopener noreferrer">我的 Github 主页</a>。</p>
<p>好家伙！几天没注意，<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener noreferrer">JavaGuide</a> 这个项目直接上了 100K star。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/1&e=1643644799&token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:zANqh9HQEvvLPm6smyrjvjAt-Ik=.png" alt="JavaGuide 100k 里程碑" /></p>
<p>其实，这个真没啥好嘚瑟的。因为，教程类的含金量其实是比较低的，Star 数量比较多主要也是因为受众面比较广，大家觉得不错，点个 star 就相当于收藏了。很多特别优秀的框架，star 数量可能只有几 K。所以，单纯看 star 数量没啥意思，就当看个笑话吧！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/20210323132635635.png" alt="" /></p>
<p>维护这个项目的过程中，也被某些人 diss 过：“md项目，没啥含金量，给国人丢脸！”。</p>
<p>对于说这类话的人，我觉得对我没啥影响，就持续完善，把 JavaGuide 做的更好吧！其实，国外的很多项目也是纯 MD 啊！就比如外国的朋友发起的 awesome 系列、求职面试系列。无需多说，行动自证！凎！</p>
<p>开源非常重要的一点就是协作。如果你开源了一个项目之后，就不再维护，别人给你提交 issue/pr，你都不处理，那开源也没啥意义了！</p>
<p>我的公号的小伙伴都是通过这个项目关注我的，趁着午休，简单复盘一下，也算是对关注这个项目的小伙伴负责。</p>
<p>我在大三开始准备秋招面试的时候，创建了 JavaGuide 这个项目，<strong>2018-05-07</strong>  这一天我提交了<strong>第 1 个 commit</strong>。</p>
<p>到今天（2021-03-23）为止，这个仓库已经累计有 <strong>2933</strong> 次 commit，累计有 <strong>207</strong> 位朋友参与到了项目中来。</p>
<p><img src="https://img-blog.csdnimg.cn/20210323131344793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="" /></p>
<p>累计有 <strong>511</strong> 个 <strong>issue</strong> 和 <strong>575</strong> 个 <strong>pr</strong>。所有的 pr 都已经被处理，仅有15 个左右的 issue 我还未抽出时间处理。</p>
<p><img src="https://img-blog.csdnimg.cn/20210323131632291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="" /></p>
<p>其实，相比于 star 数量，你看看仓库的 issue 和 pr 更能说明你的项目是否有价值。</p>
<p>那些到处骗 star 甚至是 刷 star 的行为，我就不多说了，有点丢人。人家觉得你的项目还不错，能提供价值，自然就给你点 star 了。</p>
<p><strong>未来几年，我还是会持续完善 JavaGuide。</strong></p>
<p><strong>希望自己以后能开源一些有价值的轮子吧！继续加油！</strong></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/1&e=1643644799&token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:zANqh9HQEvvLPm6smyrjvjAt-Ik=.png" type="image/png"/>
    </item>
    <item>
      <title>某培训机构盗我文章做成视频还上了B站热门</title>
      <link>https://javaguide.cn/about-the-author/my-article-was-stolen-and-made-into-video-and-it-became-popular/</link>
      <guid>https://javaguide.cn/about-the-author/my-article-was-stolen-and-made-into-video-and-it-became-popular/</guid>
      <source url="https://javaguide.cn/rss.xml">某培训机构盗我文章做成视频还上了B站热门</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="某培训机构盗我文章做成视频还上了b站热门"> 某培训机构盗我文章做成视频还上了B站热门</h1>
<p>时间回到 2021-02-25，我在刷哔哩哔哩的时候发现，哔哩哔哩某UP主（某培训机构），擅自将我在知乎的一个回答做成了视频。</p>
<p>原滋原味啊！我艹。甚至，连我开头的自我调侃还加上了！真的牛皮！</p>
<p>你盗我原创，视频你用心做好点也行啊！至少也可以让这么优质的内容得到传播嘛！</p>
<p>结果，好家伙，视频做的像坨屎一样，配音也贼违和!</p>
<p>麻烦这个培训机构看到这篇文章之后可以考虑换一个人做类似恶心的事情哈！这人完全没脑子啊！</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-db6b9cf323930786fa2bec8b1e1bfaad732.png" alt="" /></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6395603ab441b74511c6eda28efee8937d7.png" alt="" /></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-921f60a5c7cee2c5c2eb30f4f7048f648e1.png" alt="" /></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-acc82a797bd01e27f5b7d5d327b32a21d4e.png" alt="" /></p>
<p>我随便找了一个视频看，发现也还是盗用别人的原创。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-48d0c5ab086265ae19b7396bc59de2c2daf.png" alt="" /></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-366abf0656007ff96551064104e60740a41.png" alt="" /></p>
<p>其他的视频就不用多看了，是否还是剽窃别人的原创，原封不动地做成视频，大家心里应该有数。</p>
<p>他们这样做的目的就是一个：<strong>引流到自己的QQ群，然后忽悠你买课程。</strong></p>
<p>我并不认为是这完全都是培训机构的问题。培训机构的员工为了流量而做这种恶心的事情，也导致了现在这种事情被越来越频繁地发生。</p>
<p>所以，你会发现，哔哩哔哩和知乎上有越来越多培训机构的小号，到处剽窃原创，盗发。</p>
<p>我身边很多原创号主的文章都经常被某些培训机构盗发。</p>
<p>有时候真的会比较生气，毕竟你自己辛辛苦苦的原创，别人复制粘贴一下就白嫖了！</p>
<p>但是，我相信，这种靠剽窃别人原创来吸引流量的行为，终究只是跳梁小丑的行为罢了！</p>
<p>只有那些用心输出内容的创作者，才能走的更远，更安稳！</p>
<p>后来，我在我的公众号上发了一篇名为<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247500005&amp;idx=1&amp;sn=7351e22619654492d3cf567bff9d87f0&amp;chksm=cea18f2ef9d606384e0265b9318e004646c03b8a69f2801698d2f9e0e6bdfec0a1185ac3ab17&amp;token=2146952532&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">《好家伙！某培训机构盗我文章做成视频还上了热门》</a> 的文章，吐槽自己的原创被某机构白嫖。</p>
<p>谁能想到，培训机构的人竟然找人来让我删文章了！讲真，这俩人是真的奇葩啊！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/8f8ccafcf5b764a2289a9c276c30728d.png" alt="" /></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/a0a4a45d7ec7b1a2622b2a38629e9b09.png" alt="" /></p>
<p>还让我格局大点？我去你丫的！明明就是我的原创，你自己不删，反而找人联系我删除！有脑子不？</p>
<p>其实，我这人是比较好说话的，现实生活中脾气也是出了名的好（前提是没有触犯到我的原则的情况）。</p>
<p>搞笑的是！他们在让我删文的同时，他们 B 站盗发的视频还都在，还在继续为他们引流。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/86f659a93ce5b639526c8d2bd20b2fbe.png" alt="" /></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/be6e0fd23146de3f6224b4d853c59ce7.png" alt="" /></p>
<p>如果他们把账号注销了，我或许还能考虑放一手。但是，文章是肯定不会删的。</p>
<p>现在，看后续情况吧！我随时可以动用法律来维护自己的权益，只是看我想不想，毕竟也挺麻烦对吧！</p>
<p>大家不用担心，这都是小事，我女朋友就是学法律的，国内的某法学双一流学校。</p>
<p>咱不怕事！凎！！！</p>
]]></content:encoded>
      <enclosure url="https://oscimg.oschina.net/oscnet/up-db6b9cf323930786fa2bec8b1e1bfaad732.png" type="image/png"/>
    </item>
    <item>
      <title>个人介绍 Q&amp;A</title>
      <link>https://javaguide.cn/about-the-author/</link>
      <guid>https://javaguide.cn/about-the-author/</guid>
      <source url="https://javaguide.cn/rss.xml">个人介绍 Q&amp;A</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="个人介绍-q-a"> 个人介绍 Q&amp;A</h1>
<p>大家好，我是 Gudie哥！这篇文章我会通过 Q&amp;A 的形式简单介绍一下我自己。</p>
<h2 id="我是什么时候毕业的"> 我是什么时候毕业的？</h2>
<p>很多老读者应该比较清楚，我是 19 年本科毕业的，刚毕业就去了某家外企“养老”。</p>
<p>我的学校背景是比较差的，高考失利，勉强过了一本线 20 来分，去了荆州的一所很普通的双非一本。不过，还好我没有因为学校而放弃自己，反倒是比身边的同学都要更努力，整个大学还算过的比较充实。</p>
<p>下面这张是当时拍的毕业照（后排最中间的就是我）：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/个人介绍.png" alt="" /></p>
<h2 id="为什么要做-javaguide-这个项目"> 为什么要做 JavaGuide 这个项目？</h2>
<p>我从大二坚持写作，坚持分享让我收获了 30w+ 的读者以及一笔不错的副业收入。</p>
<p>2018 年，我还在读大三的时候，JavaGuide 开源项目&amp;公众号诞生了。很难想到，日后，他们会陪伴我度过这么长的时间。</p>
<p>开源 JavaGuide 初始想法源于自己的个人那一段比较迷茫的学习经历。主要目的是为了通过这个开源平台来帮助一些在学习 Java 以及面试过程中遇到问题的小伙伴。</p>
<ul>
<li><strong>对于 Java 初学者来说：</strong> 本文档倾向于给你提供一个比较详细的学习路径，让你对于 Java 整体的知识体系有一个初步认识。另外，本文的一些文章也是你学习和复习 Java 知识不错的实践；</li>
<li><strong>对于非 Java 初学者来说：</strong> 本文档更适合回顾知识，准备面试，搞清面试应该把重心放在那些问题上。要搞清楚这个道理：提前知道那些面试常见，不是为了背下来应付面试，而是为了让你可以更有针对的学习重点。</li>
</ul>
<h2 id="如何看待-javaguide-的-star-数量很多"> 如何看待 JavaGuide 的 star 数量很多？</h2>
<p><a href="https://github.com/Snailclimb" target="_blank" rel="noopener noreferrer">JavaGuide</a> 目前已经是 Java 领域 star 数量最多的几个项目之一，登顶过很多次 Github Trending。</p>
<p>不过，这个真心没啥好嘚瑟的。因为，教程类的含金量其实是比较低的，star 数量比较多主要也是因为受众面比较广，大家觉得不错，点个 star 就相当于收藏了。很多特别优秀的框架，star 数量可能只有几 K。所以，单纯看 star 数量没啥意思，就当看个笑话吧！</p>
<p>维护这个项目的过程中，也被某些人 diss 过：“md 项目，没啥含金量，给国人丢脸！”。</p>
<p>对于说这类话的人，我觉得对我没啥影响，就持续完善，把 JavaGuide 做的更好吧！其实，国外的很多项目也是纯 MD 啊！就比如外国的朋友发起的 awesome 系列、求职面试系列。无需多说，行动自证！凎！</p>
<p>开源非常重要的一点就是协作。如果你开源了一个项目之后，就不再维护，别人给你提交 issue/pr，你都不处理，那开源也没啥意义了！</p>
<h2 id="我在大学期间赚了多少钱"> 我在大学期间赚了多少钱？</h2>
<p>在校期间，我还通过办培训班、接私活、技术培训、编程竞赛等方式变现 20w+，成功实现“经济独立”。我用自己赚的钱去了重庆、三亚、恩施、青岛等地旅游，还给家里补贴了很多，减轻了父母的负担。</p>
<p>下面这张是我大三去三亚的时候拍的：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/psc.jpeg" alt="" /></p>
<p>其实，我在大学就这么努力地开始赚钱，也主要是因为家庭条件太一般，父母赚钱都太辛苦了！也正是因为我自己迫切地想要减轻父母的负担，所以才会去尝试这么多赚钱的方法。</p>
<p>我发现做咱们程序员这行的，很多人的家庭条件都挺一般，选择这个行业的很大原因不是因为自己喜欢，而是为了多赚点钱。</p>
<p>如果你也想通过接私活变现的话，可以在我的公众号后台回复“<strong>接私活</strong>”来了解详细情况。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/1d38ea3b-da2a-41df-9ac4-087356e9b5b4-20200802185910087.png" alt="" /></p>
<h2 id="为什么自称-guide哥"> 为什么自称 Guide哥？</h2>
<p>可能是因为我的项目名字叫做 JavaGudie , 所以导致有很多人称呼我为 <strong>Guide哥</strong>。</p>
<p>后面，为了读者更方便称呼，我就将自己的笔名改成了 <strong>Guide哥</strong>。</p>
<p>我早期写文章用的笔名是 SnailClimb 。很多人不知道这个名字是啥意思，给大家拆解一下就清楚了。SnailClimb=Snail（蜗牛）+Climb(攀登)。我从小就非常喜欢听周杰伦的歌曲，特别是他的《蜗牛》🐌 这首歌曲，另外，当年我高考发挥的算是比较失常，上了大学之后还算是比较“奋青”，所以，我就给自己起的笔名叫做 SnailClimb ，寓意自己要不断向上攀登，嘿嘿😁</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37599546f3b34b92a32db579a225aa45~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<h2 id="我坚持写了多久博客"> 我坚持写了多久博客？</h2>
<p>时间真快啊！我自己是从大二开始写博客的。那时候就是随意地在博客平台上发发自己的学习笔记和自己写的程序。就比如 <a href="https://javaguide.cn/cs-basics/network/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%80%81%E5%B8%88%E7%9A%84%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener noreferrer">谢希仁老师的《计算机网络》内容总结</a> 这篇文章就是我在大二学习计算机网络这门课的时候对照着教材总结的。</p>
<p>身边也有很多小伙伴经常问我：“我现在写博客还晚么？”</p>
<p>我觉得哈！如果你想做什么事情，尽量少问迟不迟，多问自己值不值得，只要你觉得有意义，就尽快开始做吧！人生很奇妙，我们每一步的重大决定，都会对自己未来的人生轨迹产生影响。是好还是坏，也只有我们自己知道了！</p>
<p>对我自己来说，坚持写博客这一项决定对我人生轨迹产生的影响是非常正面的！所以，我也推荐大家养成坚持写博客的习惯。</p>
<h2 id="后记"> 后记</h2>
<p>凡心所向，素履所往，生如逆旅，一苇以航。</p>
<p>生活本就是有苦有甜。共勉！</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D.png" type="image/png"/>
    </item>
    <item>
      <title>几道常见的字符串算法题</title>
      <link>https://javaguide.cn/cs-basics/algorithms/%E5%87%A0%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E9%A2%98/</link>
      <guid>https://javaguide.cn/cs-basics/algorithms/%E5%87%A0%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E9%A2%98/</guid>
      <source url="https://javaguide.cn/rss.xml">几道常见的字符串算法题</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="几道常见的字符串算法题"> 几道常见的字符串算法题</h1>
<blockquote>
<p>授权转载！</p>
<ul>
<li>本文作者：wwwxmu</li>
<li>原文地址:https://www.weiweiblog.cn/13string/</li>
</ul>
</blockquote>
<h2 id="_1-kmp-算法"> 1. KMP 算法</h2>
<p>谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p>
<p>具体算法细节请参考：</p>
<ul>
<li><strong>字符串匹配的KMP算法:</strong> http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</li>
<li><strong>从头到尾彻底理解KMP:</strong> https://blog.csdn.net/v_july_v/article/details/7041827</li>
<li><strong>如何更好的理解和掌握 KMP 算法?:</strong> https://www.zhihu.com/question/21923021</li>
<li><strong>KMP 算法详细解析:</strong>  https://blog.sengxian.com/algorithms/kmp</li>
<li><strong>图解 KMP 算法:</strong> http://blog.jobbole.com/76611/</li>
<li><strong>汪都能听懂的KMP字符串匹配算法【双语字幕】:</strong> https://www.bilibili.com/video/av3246487/?from=search&amp;seid=17173603269940723925</li>
<li><strong>KMP字符串匹配算法1:</strong> https://www.bilibili.com/video/av11866460?from=search&amp;seid=12730654434238709250</li>
</ul>
<p><strong>除此之外，再来了解一下BM算法！</strong></p>
<blockquote>
<p>BM算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。
《字符串匹配的KMP算法》:http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</p>
</blockquote>
<h2 id="_2-替换空格"> 2. 替换空格</h2>
<blockquote>
<p>剑指offer：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<p>这里我提供了两种方法：①常规方法；②利用 API 解决。</p>
<div><pre><code><span>//https://www.weiweiblog.cn/replacespace/</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

  <span>/**
   * 第一种方法：常规方法。利用String.charAt(i)以及String.valueOf(char).equals(" "
   * )遍历字符串并判断元素是否为空格。是则替换为"%20",否则不替换
   */</span>
  <span>public</span> <span>static</span> <span>String</span> <span>replaceSpace</span><span>(</span><span>StringBuffer</span> str<span>)</span> <span>{</span>

    <span>int</span> length <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
    <span>// System.out.println("length=" + length);</span>
    <span>StringBuffer</span> result <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>char</span> b <span>=</span> str<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>
      <span>if</span> <span>(</span><span>String</span><span>.</span><span>valueOf</span><span>(</span>b<span>)</span><span>.</span><span>equals</span><span>(</span><span>" "</span><span>)</span><span>)</span> <span>{</span>
        result<span>.</span><span>append</span><span>(</span><span>"%20"</span><span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        result<span>.</span><span>append</span><span>(</span>b<span>)</span><span>;</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> result<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>

  <span>}</span>

  <span>/**
   * 第二种方法：利用API替换掉所用空格，一行代码解决问题
   */</span>
  <span>public</span> <span>static</span> <span>String</span> <span>replaceSpace2</span><span>(</span><span>StringBuffer</span> str<span>)</span> <span>{</span>
    
    <span>return</span> str<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>replaceAll</span><span>(</span><span>"\\s"</span><span>,</span> <span>"%20"</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>对于替换固定字符（比如空格）的情况，第二种方法其实可以使用 <code>replace</code> 方法替换，性能更好!</p>
<div><pre><code>str<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>replace</span><span>(</span><span>" "</span><span>,</span><span>"%20"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="_3-最长公共前缀"> 3. 最长公共前缀</h2>
<blockquote>
<p>Leetcode:  编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。</p>
</blockquote>
<p>示例 1:</p>
<div><pre><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出: &quot;fl&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>示例 2:</p>
<div><pre><code>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出: &quot;&quot;
解释: 输入不存在公共前缀。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>思路很简单！先利用Arrays.sort(strs)为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可！</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
	<span>public</span> <span>static</span> <span>String</span> <span>replaceSpace</span><span>(</span><span>String</span><span>[</span><span>]</span> strs<span>)</span> <span>{</span>

		<span>// 如果检查值不合法及就返回空串</span>
		<span>if</span> <span>(</span><span>!</span><span>checkStrs</span><span>(</span>strs<span>)</span><span>)</span> <span>{</span>
			<span>return</span> <span>""</span><span>;</span>
		<span>}</span>
		<span>// 数组长度</span>
		<span>int</span> len <span>=</span> strs<span>.</span>length<span>;</span>
		<span>// 用于保存结果</span>
		<span>StringBuilder</span> res <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
		<span>// 给字符串数组的元素按照升序排序(包含数字的话，数字会排在前面)</span>
		<span>Arrays</span><span>.</span><span>sort</span><span>(</span>strs<span>)</span><span>;</span>
		<span>int</span> m <span>=</span> strs<span>[</span><span>0</span><span>]</span><span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
		<span>int</span> n <span>=</span> strs<span>[</span>len <span>-</span> <span>1</span><span>]</span><span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
		<span>int</span> num <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>m<span>,</span> n<span>)</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> num<span>;</span> i<span>++</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span>strs<span>[</span><span>0</span><span>]</span><span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>==</span> strs<span>[</span>len <span>-</span> <span>1</span><span>]</span><span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>
				res<span>.</span><span>append</span><span>(</span>strs<span>[</span><span>0</span><span>]</span><span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span><span>;</span>
			<span>}</span> <span>else</span>
				<span>break</span><span>;</span>

		<span>}</span>
		<span>return</span> res<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>

	<span>}</span>

	<span>private</span> <span>static</span> <span>boolean</span> <span>chechStrs</span><span>(</span><span>String</span><span>[</span><span>]</span> strs<span>)</span> <span>{</span>
		<span>boolean</span> flag <span>=</span> <span>false</span><span>;</span>
		<span>if</span> <span>(</span>strs <span>!=</span> <span>null</span><span>)</span> <span>{</span>
			<span>// 遍历strs检查元素值</span>
			<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> strs<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
				<span>if</span> <span>(</span>strs<span>[</span>i<span>]</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span> strs<span>[</span>i<span>]</span><span>.</span><span>length</span><span>(</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
					flag <span>=</span> <span>true</span><span>;</span>
				<span>}</span> <span>else</span> <span>{</span>
					flag <span>=</span> <span>false</span><span>;</span>
					<span>break</span><span>;</span>
				<span>}</span>
			<span>}</span>
		<span>}</span>
		<span>return</span> flag<span>;</span>
	<span>}</span>

	<span>// 测试</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>String</span><span>[</span><span>]</span> strs <span>=</span> <span>{</span> <span>"customer"</span><span>,</span> <span>"car"</span><span>,</span> <span>"cat"</span> <span>}</span><span>;</span>
		<span>// String[] strs = { "customer", "car", null };//空串</span>
		<span>// String[] strs = {};//空串</span>
		<span>// String[] strs = null;//空串</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Main</span><span>.</span><span>replaceSpace</span><span>(</span>strs<span>)</span><span>)</span><span>;</span><span>// c</span>
	<span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_4-回文串"> 4. 回文串</h2>
<h3 id="_4-1-最长回文串"> 4.1. 最长回文串</h3>
<blockquote>
<p>LeetCode:  给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如<code>&quot;Aa&quot;</code>不能当做一个回文字符串。注
意:假设字符串的长度不会超过 1010。</p>
</blockquote>
<blockquote>
<p>回文串：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。——百度百科  地址：https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin</p>
</blockquote>
<p>示例 1:</p>
<div><pre><code>输入:
&quot;abccccdd&quot;

输出:
7

解释:
我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>我们上面已经知道了什么是回文串？现在我们考虑一下可以构成回文串的两种情况：</p>
<ul>
<li>字符出现次数为双数的组合</li>
<li><strong>字符出现次数为偶数的组合+单个字符中出现次数最多且为奇数次的字符</strong> （参见 <strong><a href="https://github.com/Snailclimb/JavaGuide/issues/665" target="_blank" rel="noopener noreferrer">issue665</a></strong> ）</li>
</ul>
<p>统计字符出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。首先将字符串转变为字符数组。然后遍历该数组，判断对应字符是否在hashset中，如果不在就加进去，如果在就让count++，然后移除该字符！这样就能找到出现次数为双数的字符个数。</p>
<div><pre><code><span>//https://leetcode-cn.com/problems/longest-palindrome/description/</span>
<span>class</span> <span>Solution</span> <span>{</span>
  <span>public</span>  <span>int</span> <span>longestPalindrome</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
      <span>return</span> <span>0</span><span>;</span>
    <span>// 用于存放字符</span>
    <span>HashSet</span><span><span>&lt;</span><span>Character</span><span>></span></span> hashset <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>Character</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>char</span><span>[</span><span>]</span> chars <span>=</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> count <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> chars<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span>hashset<span>.</span><span>contains</span><span>(</span>chars<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span><span>// 如果hashset没有该字符就保存进去</span>
        hashset<span>.</span><span>add</span><span>(</span>chars<span>[</span>i<span>]</span><span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span><span>// 如果有,就让count++（说明找到了一个成对的字符），然后把该字符移除</span>
        hashset<span>.</span><span>remove</span><span>(</span>chars<span>[</span>i<span>]</span><span>)</span><span>;</span>
        count<span>++</span><span>;</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> hashset<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>?</span> count <span>*</span> <span>2</span> <span>:</span> count <span>*</span> <span>2</span> <span>+</span> <span>1</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="_4-2-验证回文串"> 4.2. 验证回文串</h3>
<blockquote>
<p>LeetCode: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。</p>
</blockquote>
<p>示例 1:</p>
<div><pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>示例 2:</p>
<div><pre><code>输入: &quot;race a car&quot;
输出: false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>//https://leetcode-cn.com/problems/valid-palindrome/description/</span>
<span>class</span> <span>Solution</span> <span>{</span>
  <span>public</span>  <span>boolean</span> <span>isPalindrome</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
      <span>return</span> <span>true</span><span>;</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> r<span>)</span> <span>{</span>
      <span>// 从头和尾开始向中间遍历</span>
      <span>if</span> <span>(</span><span>!</span><span>Character</span><span>.</span><span>isLetterOrDigit</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>l<span>)</span><span>)</span><span>)</span> <span>{</span><span>// 字符不是字母和数字的情况</span>
        l<span>++</span><span>;</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span><span>Character</span><span>.</span><span>isLetterOrDigit</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>r<span>)</span><span>)</span><span>)</span> <span>{</span><span>// 字符不是字母和数字的情况</span>
        r<span>--</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>// 判断二者是否相等</span>
        <span>if</span> <span>(</span><span>Character</span><span>.</span><span>toLowerCase</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>l<span>)</span><span>)</span> <span>!=</span> <span>Character</span><span>.</span><span>toLowerCase</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>r<span>)</span><span>)</span><span>)</span>
          <span>return</span> <span>false</span><span>;</span>
        l<span>++</span><span>;</span>
        r<span>--</span><span>;</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="_4-3-最长回文子串"> 4.3. 最长回文子串</h3>
<blockquote>
<p>Leetcode: LeetCode: 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>
</blockquote>
<p>示例 1：</p>
<div><pre><code>输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot;也是一个有效答案。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>示例 2：</p>
<div><pre><code>输入: &quot;cbbd&quot;
输出: &quot;bb&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。</p>
<div><pre><code><span>//https://leetcode-cn.com/problems/longest-palindromic-substring/description/</span>
<span>class</span> <span>Solution</span> <span>{</span>
  <span>private</span> <span>int</span> index<span>,</span> len<span>;</span>

  <span>public</span> <span>String</span> <span>longestPalindrome</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> <span>2</span><span>)</span>
      <span>return</span> s<span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>PalindromeHelper</span><span>(</span>s<span>,</span> i<span>,</span> i<span>)</span><span>;</span>
      <span>PalindromeHelper</span><span>(</span>s<span>,</span> i<span>,</span> i <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> s<span>.</span><span>substring</span><span>(</span>index<span>,</span> index <span>+</span> len<span>)</span><span>;</span>
  <span>}</span>

  <span>public</span> <span>void</span> <span>PalindromeHelper</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> l<span>,</span> <span>int</span> r<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>l <span>>=</span> <span>0</span> <span>&amp;&amp;</span> r <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>&amp;&amp;</span> s<span>.</span><span>charAt</span><span>(</span>l<span>)</span> <span>==</span> s<span>.</span><span>charAt</span><span>(</span>r<span>)</span><span>)</span> <span>{</span>
      l<span>--</span><span>;</span>
      r<span>++</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>len <span>&lt;</span> r <span>-</span> l <span>-</span> <span>1</span><span>)</span> <span>{</span>
      index <span>=</span> l <span>+</span> <span>1</span><span>;</span>
      len <span>=</span> r <span>-</span> l <span>-</span> <span>1</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="_4-4-最长回文子序列"> 4.4. 最长回文子序列</h3>
<blockquote>
<p>LeetCode: 最长回文子序列
给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。
<strong>最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，&quot;bbbb&quot;可以是字符串&quot;bbbab&quot;的子序列但不是子串。</strong></p>
</blockquote>
<p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p>
<p>示例 1:</p>
<div><pre><code>输入:
&quot;bbbab&quot;
输出:
4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一个可能的最长回文子序列为 &quot;bbbb&quot;。</p>
<p>示例 2:</p>
<div><pre><code>输入:
&quot;cbbd&quot;
输出:
2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一个可能的最长回文子序列为 &quot;bb&quot;。</p>
<p><strong>动态规划：</strong>  dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</p>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>longestPalindromeSubseq</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> <span>[</span><span>]</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>len<span>]</span><span>[</span>len<span>]</span><span>;</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> len <span>-</span> <span>1</span><span>;</span> i<span>>=</span><span>0</span><span>;</span> i<span>--</span><span>)</span><span>{</span>
            dp<span>[</span>i<span>]</span><span>[</span>i<span>]</span> <span>=</span> <span>1</span><span>;</span>
            <span>for</span><span>(</span><span>int</span> j <span>=</span> i<span>+</span><span>1</span><span>;</span> j <span>&lt;</span> len<span>;</span> j<span>++</span><span>)</span><span>{</span>
                <span>if</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>==</span> s<span>.</span><span>charAt</span><span>(</span>j<span>)</span><span>)</span>
                    dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>i<span>+</span><span>1</span><span>]</span><span>[</span>j<span>-</span><span>1</span><span>]</span> <span>+</span> <span>2</span><span>;</span>
                <span>else</span>
                    dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>i<span>+</span><span>1</span><span>]</span><span>[</span>j<span>]</span><span>,</span> dp<span>[</span>i<span>]</span><span>[</span>j<span>-</span><span>1</span><span>]</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> dp<span>[</span><span>0</span><span>]</span><span>[</span>len<span>-</span><span>1</span><span>]</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="_5-括号匹配深度"> 5. 括号匹配深度</h2>
<blockquote>
<p>爱奇艺 2018 秋招 Java：
一个合法的括号匹配序列有以下定义:</p>
<ol>
<li>空串&quot;&quot;是一个合法的括号匹配序列</li>
<li>如果&quot;X&quot;和&quot;Y&quot;都是合法的括号匹配序列,&quot;XY&quot;也是一个合法的括号匹配序列</li>
<li>如果&quot;X&quot;是一个合法的括号匹配序列,那么&quot;(X)&quot;也是一个合法的括号匹配序列</li>
<li>每个合法的括号序列都可以由以上规则生成。</li>
</ol>
</blockquote>
<blockquote>
<p>例如: &quot;&quot;,&quot;()&quot;,&quot;()()&quot;,&quot;((()))&quot;都是合法的括号序列
对于一个合法的括号序列我们又有以下定义它的深度:</p>
<ol>
<li>空串&quot;&quot;的深度是0</li>
<li>如果字符串&quot;X&quot;的深度是x,字符串&quot;Y&quot;的深度是y,那么字符串&quot;XY&quot;的深度为max(x,y)</li>
<li>如果&quot;X&quot;的深度是x,那么字符串&quot;(X)&quot;的深度是x+1</li>
</ol>
</blockquote>
<blockquote>
<p>例如: &quot;()()()&quot;的深度是1,&quot;((()))&quot;的深度是3。牛牛现在给你一个合法的括号序列,需要你计算出其深度。</p>
</blockquote>
<div><pre><code>输入描述:
输入包括一个合法的括号序列s,s长度length(2 ≤ length ≤ 50),序列中只包含&#39;(&#39;和&#39;)&#39;。

输出描述:
输出一个正整数,即这个序列的深度。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>示例：</p>
<div><pre><code>输入:
(())
输出:
2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>代码如下：</p>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>

<span>/**
 * https://www.nowcoder.com/test/8246651/summary
 * 
 * @author Snailclimb
 * @date 2018年9月6日
 * @Description: TODO 求给定合法括号序列的深度
 */</span>
<span>public</span> <span>class</span> <span>Main</span> <span>{</span>
  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>Scanner</span> sc <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
    <span>String</span> s <span>=</span> sc<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> cnt <span>=</span> <span>0</span><span>,</span> max <span>=</span> <span>0</span><span>,</span> i<span>;</span>
    <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>==</span> <span>'('</span><span>)</span>
        cnt<span>++</span><span>;</span>
      <span>else</span>
        cnt<span>--</span><span>;</span>
      max <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>max<span>,</span> cnt<span>)</span><span>;</span>
    <span>}</span>
    sc<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>max<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id="_6-把字符串转换成整数"> 6. 把字符串转换成整数</h2>
<blockquote>
<p>剑指offer:  将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
</blockquote>
<div><pre><code><span>//https://www.weiweiblog.cn/strtoint/</span>
<span>public</span> <span>class</span> <span>Main</span> <span>{</span>

  <span>public</span> <span>static</span> <span>int</span> <span>StrToInt</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>str<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
      <span>return</span> <span>0</span><span>;</span>
    <span>char</span><span>[</span><span>]</span> chars <span>=</span> str<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
    <span>// 判断是否存在符号位</span>
    <span>int</span> flag <span>=</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>chars<span>[</span><span>0</span><span>]</span> <span>==</span> <span>'+'</span><span>)</span>
      flag <span>=</span> <span>1</span><span>;</span>
    <span>else</span> <span>if</span> <span>(</span>chars<span>[</span><span>0</span><span>]</span> <span>==</span> <span>'-'</span><span>)</span>
      flag <span>=</span> <span>2</span><span>;</span>
    <span>int</span> start <span>=</span> flag <span>></span> <span>0</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>;</span>
    <span>int</span> res <span>=</span> <span>0</span><span>;</span><span>// 保存结果</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> start<span>;</span> i <span>&lt;</span> chars<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>Character</span><span>.</span><span>isDigit</span><span>(</span>chars<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span><span>// 调用Character.isDigit(char)方法判断是否是数字，是返回True，否则False</span>
        <span>int</span> temp <span>=</span> chars<span>[</span>i<span>]</span> <span>-</span> <span>'0'</span><span>;</span>
        res <span>=</span> res <span>*</span> <span>10</span> <span>+</span> temp<span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
      <span>}</span>
    <span>}</span>
   <span>return</span> flag <span>!=</span> <span>2</span> <span>?</span> res <span>:</span> <span>-</span>res<span>;</span>

  <span>}</span>

  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>// TODO Auto-generated method stub</span>
    <span>String</span> s <span>=</span> <span>"-12312312"</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用库函数转换："</span> <span>+</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>s<span>)</span><span>)</span><span>;</span>
    <span>int</span> res <span>=</span> <span>Main<span>.</span>StrToInt</span><span>(</span>s<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用自己写的方法转换："</span> <span>+</span> res<span>)</span><span>;</span>

  <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>几道常见的链表算法题</title>
      <link>https://javaguide.cn/cs-basics/algorithms/%E5%87%A0%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98/</link>
      <guid>https://javaguide.cn/cs-basics/algorithms/%E5%87%A0%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98/</guid>
      <source url="https://javaguide.cn/rss.xml">几道常见的链表算法题</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="几道常见的链表算法题"> 几道常见的链表算法题</h1>
<h2 id="_1-两数相加"> 1. 两数相加</h2>
<h3 id="题目描述"> 题目描述</h3>
<blockquote>
<p>Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
</blockquote>
<p>示例：</p>
<div><pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="问题分析"> 问题分析</h3>
<p>Leetcode官方详细解答地址：</p>
<p>https://leetcode-cn.com/problems/add-two-numbers/solution/</p>
<blockquote>
<p>要对头结点进行操作时，考虑创建哑节点dummy，使用dummy-&gt;next表示真正的头节点。这样可以避免处理头节点为空的边界问题。</p>
</blockquote>
<p>我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐
位相加的过程。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-20/34910956.jpg" alt="图1，对两数相加方法的可视化: 342 + 465 = 807342+465=807， 每个结点都包含一个数字，并且数字按位逆序存储。" /></p>
<h3 id="solution"> Solution</h3>
<p><strong>我们首先从最低有效位也就是列表 l1和 l2 的表头开始相加。注意需要考虑到进位的情况！</strong></p>
<div><pre><code><span>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
 <span>//https://leetcode-cn.com/problems/add-two-numbers/description/</span>
<span>class</span> <span>Solution</span> <span>{</span>
<span>public</span> <span>ListNode</span> <span>addTwoNumbers</span><span>(</span><span>ListNode</span> l1<span>,</span> <span>ListNode</span> l2<span>)</span> <span>{</span>
    <span>ListNode</span> dummyHead <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>ListNode</span> p <span>=</span> l1<span>,</span> q <span>=</span> l2<span>,</span> curr <span>=</span> dummyHead<span>;</span>
    <span>//carry 表示进位数</span>
    <span>int</span> carry <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>p <span>!=</span> <span>null</span> <span>||</span> q <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>int</span> x <span>=</span> <span>(</span>p <span>!=</span> <span>null</span><span>)</span> <span>?</span> p<span>.</span>val <span>:</span> <span>0</span><span>;</span>
        <span>int</span> y <span>=</span> <span>(</span>q <span>!=</span> <span>null</span><span>)</span> <span>?</span> q<span>.</span>val <span>:</span> <span>0</span><span>;</span>
        <span>int</span> sum <span>=</span> carry <span>+</span> x <span>+</span> y<span>;</span>
        <span>//进位数</span>
        carry <span>=</span> sum <span>/</span> <span>10</span><span>;</span>
        <span>//新节点的数值为sum % 10</span>
        curr<span>.</span>next <span>=</span> <span>new</span> <span>ListNode</span><span>(</span>sum <span>%</span> <span>10</span><span>)</span><span>;</span>
        curr <span>=</span> curr<span>.</span>next<span>;</span>
        <span>if</span> <span>(</span>p <span>!=</span> <span>null</span><span>)</span> p <span>=</span> p<span>.</span>next<span>;</span>
        <span>if</span> <span>(</span>q <span>!=</span> <span>null</span><span>)</span> q <span>=</span> q<span>.</span>next<span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>carry <span>></span> <span>0</span><span>)</span> <span>{</span>
        curr<span>.</span>next <span>=</span> <span>new</span> <span>ListNode</span><span>(</span>carry<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> dummyHead<span>.</span>next<span>;</span>
<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h2 id="_2-翻转链表"> 2. 翻转链表</h2>
<h3 id="题目描述-2"> 题目描述</h3>
<blockquote>
<p>剑指 offer:输入一个链表，反转链表后，输出链表的所有元素。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-20/81431871.jpg" alt="翻转链表" /></p>
<h3 id="问题分析-2"> 问题分析</h3>
<p>这道算法题，说直白点就是：如何让后一个节点指向前一个节点！在下面的代码中定义了一个 next 节点，该节点主要是保存要反转到头的那个节点，防止链表 “断裂”。</p>
<h3 id="solution-2"> Solution</h3>
<div><pre><code><span>public</span> <span>class</span> <span>ListNode</span> <span>{</span>
  <span>int</span> val<span>;</span>
  <span>ListNode</span> next <span>=</span> <span>null</span><span>;</span>

  <span>ListNode</span><span>(</span><span>int</span> val<span>)</span> <span>{</span>
    <span>this</span><span>.</span>val <span>=</span> val<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>/**
 * 
 * @author Snailclimb
 * @date 2018年9月19日
 * @Description: TODO
 */</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

  <span>public</span> <span>ListNode</span> <span>ReverseList</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>

    <span>ListNode</span> next <span>=</span> <span>null</span><span>;</span>
    <span>ListNode</span> pre <span>=</span> <span>null</span><span>;</span>

    <span>while</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      <span>// 保存要反转到头的那个节点</span>
      next <span>=</span> head<span>.</span>next<span>;</span>
      <span>// 要反转的那个节点指向已经反转的上一个节点(备注:第一次反转的时候会指向null)</span>
      head<span>.</span>next <span>=</span> pre<span>;</span>
      <span>// 上一个已经反转到头部的节点</span>
      pre <span>=</span> head<span>;</span>
      <span>// 一直向链表尾走</span>
      head <span>=</span> next<span>;</span>
    <span>}</span>
    <span>return</span> pre<span>;</span>
  <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>测试方法：</p>
<div><pre><code>  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

    <span>ListNode</span> a <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>ListNode</span> b <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>2</span><span>)</span><span>;</span>
    <span>ListNode</span> c <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>3</span><span>)</span><span>;</span>
    <span>ListNode</span> d <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>4</span><span>)</span><span>;</span>
    <span>ListNode</span> e <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>5</span><span>)</span><span>;</span>
    a<span>.</span>next <span>=</span> b<span>;</span>
    b<span>.</span>next <span>=</span> c<span>;</span>
    c<span>.</span>next <span>=</span> d<span>;</span>
    d<span>.</span>next <span>=</span> e<span>;</span>
    <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>.</span><span>ReverseList</span><span>(</span>a<span>)</span><span>;</span>
    <span>while</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e<span>.</span>val<span>)</span><span>;</span>
      e <span>=</span> e<span>.</span>next<span>;</span>
    <span>}</span>
  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>输出：</p>
<div><pre><code>5
4
3
2
1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="_3-链表中倒数第k个节点"> 3. 链表中倒数第k个节点</h2>
<h3 id="题目描述-3"> 题目描述</h3>
<blockquote>
<p>剑指offer: 输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<h3 id="问题分析-3"> 问题分析</h3>
<blockquote>
<p><strong>链表中倒数第k个节点也就是正数第(L-K+1)个节点，知道了只一点，这一题基本就没问题！</strong></p>
</blockquote>
<p>首先两个节点/指针，一个节点 node1 先开始跑，指针 node1 跑到 k-1 个节点后，另一个节点 node2 开始跑，当 node1 跑到最后时，node2 所指的节点就是倒数第k个节点也就是正数第(L-K+1)个节点。</p>
<h3 id="solution-3"> Solution</h3>
<div><pre><code><span>/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/</span>

<span>// 时间复杂度O(n),一次遍历即可</span>
<span>// https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
  <span>public</span> <span>ListNode</span> <span>FindKthToTail</span><span>(</span><span>ListNode</span> head<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>// 如果链表为空或者k小于等于0</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> k <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
      <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>// 声明两个指向头结点的节点</span>
    <span>ListNode</span> node1 <span>=</span> head<span>,</span> node2 <span>=</span> head<span>;</span>
    <span>// 记录节点的个数</span>
    <span>int</span> count <span>=</span> <span>0</span><span>;</span>
    <span>// 记录k值，后面要使用</span>
    <span>int</span> index <span>=</span> k<span>;</span>
    <span>// p指针先跑，并且记录节点数，当node1节点跑了k-1个节点后，node2节点开始跑，</span>
    <span>// 当node1节点跑到最后时，node2节点所指的节点就是倒数第k个节点</span>
    <span>while</span> <span>(</span>node1 <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      node1 <span>=</span> node1<span>.</span>next<span>;</span>
      count<span>++</span><span>;</span>
      <span>if</span> <span>(</span>k <span>&lt;</span> <span>1</span><span>)</span> <span>{</span>
        node2 <span>=</span> node2<span>.</span>next<span>;</span>
      <span>}</span>
      k<span>--</span><span>;</span>
    <span>}</span>
    <span>// 如果节点个数小于所求的倒数第k个节点，则返回空</span>
    <span>if</span> <span>(</span>count <span>&lt;</span> index<span>)</span>
      <span>return</span> <span>null</span><span>;</span>
    <span>return</span> node2<span>;</span>

  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_4-删除链表的倒数第n个节点"> 4. 删除链表的倒数第N个节点</h2>
<blockquote>
<p>Leetcode:给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
</blockquote>
<p><strong>示例：</strong></p>
<div><pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>说明：</strong></p>
<p>给定的 n 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<p>该题在 leetcode 上有详细解答，具体可参考 Leetcode.</p>
<h3 id="问题分析-4"> 问题分析</h3>
<p>我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)个结点，其中 L是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-20/94354387.jpg" alt="图 1. 删除列表中的第 L - n + 1 个元素" /></p>
<h3 id="solution-4"> Solution</h3>
<p><strong>两次遍历法</strong></p>
<p>首先我们将添加一个 <strong>哑结点</strong> 作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n) 个结点那里。<strong>我们把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。</strong></p>
<div><pre><code><span>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span>// https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
  <span>public</span> <span>ListNode</span> <span>removeNthFromEnd</span><span>(</span><span>ListNode</span> head<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
    <span>// 哑结点，哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部</span>
    <span>ListNode</span> dummy <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>// 哑结点指向头结点</span>
    dummy<span>.</span>next <span>=</span> head<span>;</span>
    <span>// 保存链表长度</span>
    <span>int</span> length <span>=</span> <span>0</span><span>;</span>
    <span>ListNode</span> len <span>=</span> head<span>;</span>
    <span>while</span> <span>(</span>len <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      length<span>++</span><span>;</span>
      len <span>=</span> len<span>.</span>next<span>;</span>
    <span>}</span>
    length <span>=</span> length <span>-</span> n<span>;</span>
    <span>ListNode</span> target <span>=</span> dummy<span>;</span>
    <span>// 找到 L-n 位置的节点</span>
    <span>while</span> <span>(</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>
      target <span>=</span> target<span>.</span>next<span>;</span>
      length<span>--</span><span>;</span>
    <span>}</span>
    <span>// 把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点</span>
    target<span>.</span>next <span>=</span> target<span>.</span>next<span>.</span>next<span>;</span>
    <span>return</span> dummy<span>.</span>next<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(L)</strong> ：该算法对列表进行了两次遍历，首先计算了列表的长度 LL 其次找到第 (L - n)(L−n) 个结点。 操作执行了 2L-n2L−n 步，时间复杂度为 O(L)O(L)。</li>
<li><strong>空间复杂度 O(1)</strong> ：我们只用了常量级的额外空间。</li>
</ul>
<p><strong>进阶——一次遍历法：</strong></p>
<blockquote>
<p>链表中倒数第N个节点也就是正数第(L-N+1)个节点。</p>
</blockquote>
<p>其实这种方法就和我们上面第四题找“链表中倒数第k个节点”所用的思想是一样的。<strong>基本思路就是：</strong>  定义两个节点 node1、node2;node1 节点先跑，node1节点 跑到第 n+1 个节点的时候,node2 节点开始跑.当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点（L代表总链表长度，也就是倒数第 n+1 个节点）</p>
<div><pre><code><span>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
  <span>public</span> <span>ListNode</span> <span>removeNthFromEnd</span><span>(</span><span>ListNode</span> head<span>,</span> <span>int</span> n<span>)</span> <span>{</span>

    <span>ListNode</span> dummy <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>0</span><span>)</span><span>;</span>
    dummy<span>.</span>next <span>=</span> head<span>;</span>
    <span>// 声明两个指向头结点的节点</span>
    <span>ListNode</span> node1 <span>=</span> dummy<span>,</span> node2 <span>=</span> dummy<span>;</span>

    <span>// node1 节点先跑，node1节点 跑到第 n 个节点的时候,node2 节点开始跑</span>
    <span>// 当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点，也就是倒数第 n+1（L代表总链表长度）</span>
    <span>while</span> <span>(</span>node1 <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      node1 <span>=</span> node1<span>.</span>next<span>;</span>
      <span>if</span> <span>(</span>n <span>&lt;</span> <span>1</span> <span>&amp;&amp;</span> node1 <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        node2 <span>=</span> node2<span>.</span>next<span>;</span>
      <span>}</span>
      n<span>--</span><span>;</span>
    <span>}</span>

    node2<span>.</span>next <span>=</span> node2<span>.</span>next<span>.</span>next<span>;</span>

    <span>return</span> dummy<span>.</span>next<span>;</span>

  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id="_5-合并两个排序的链表"> 5. 合并两个排序的链表</h2>
<h3 id="题目描述-4"> 题目描述</h3>
<blockquote>
<p>剑指offer:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<h3 id="问题分析-5"> 问题分析</h3>
<p>我们可以这样分析:</p>
<ol>
<li>假设我们有两个链表 A,B；</li>
<li>A的头节点A1的值与B的头结点B1的值比较，假设A1小，则A1为头节点；</li>
<li>A2再和B1比较，假设B1小,则，A1指向B1；</li>
<li>A2再和B2比较
就这样循环往复就行了，应该还算好理解。</li>
</ol>
<p>考虑通过递归的方式实现！</p>
<h3 id="solution-5"> Solution</h3>
<p><strong>递归版本：</strong></p>
<div><pre><code><span>/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/</span>
<span>//https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
<span>public</span> <span>ListNode</span> <span>Merge</span><span>(</span><span>ListNode</span> list1<span>,</span><span>ListNode</span> list2<span>)</span> <span>{</span>
       <span>if</span><span>(</span>list1 <span>==</span> <span>null</span><span>)</span><span>{</span>
           <span>return</span> list2<span>;</span>
       <span>}</span>
       <span>if</span><span>(</span>list2 <span>==</span> <span>null</span><span>)</span><span>{</span>
           <span>return</span> list1<span>;</span>
       <span>}</span>
       <span>if</span><span>(</span>list1<span>.</span>val <span>&lt;=</span> list2<span>.</span>val<span>)</span><span>{</span>
           list1<span>.</span>next <span>=</span> <span>Merge</span><span>(</span>list1<span>.</span>next<span>,</span> list2<span>)</span><span>;</span>
           <span>return</span> list1<span>;</span>
       <span>}</span><span>else</span><span>{</span>
           list2<span>.</span>next <span>=</span> <span>Merge</span><span>(</span>list1<span>,</span> list2<span>.</span>next<span>)</span><span>;</span>
           <span>return</span> list2<span>;</span>
       <span>}</span>       
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div>]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-20/34910956.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>剑指offer部分编程题</title>
      <link>https://javaguide.cn/cs-basics/algorithms/%E5%89%91%E6%8C%87offer%E9%83%A8%E5%88%86%E7%BC%96%E7%A8%8B%E9%A2%98/</link>
      <guid>https://javaguide.cn/cs-basics/algorithms/%E5%89%91%E6%8C%87offer%E9%83%A8%E5%88%86%E7%BC%96%E7%A8%8B%E9%A2%98/</guid>
      <source url="https://javaguide.cn/rss.xml">剑指offer部分编程题</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="剑指offer部分编程题"> 剑指offer部分编程题</h1>
<h2 id="斐波那契数列"> 斐波那契数列</h2>
<p><strong>题目描述：</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。
n&lt;=39</p>
<p><strong>问题分析：</strong></p>
<p>可以肯定的是这一题通过递归的方式是肯定能做出来，但是这样会有一个很大的问题，那就是递归大量的重复计算会导致内存溢出。另外可以使用迭代法，用fn1和fn2保存计算过程中的结果，并复用起来。下面我会把两个方法示例代码都给出来并给出两个方法的运行时间对比。</p>
<p><strong>示例代码：</strong></p>
<p>采用迭代法：</p>
<div><pre><code><span>int</span> <span>Fibonacci</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>number <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>number <span>==</span> <span>1</span> <span>||</span> number <span>==</span> <span>2</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>int</span> first <span>=</span> <span>1</span><span>,</span> second <span>=</span> <span>1</span><span>,</span> third <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>3</span><span>;</span> i <span>&lt;=</span> number<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        third <span>=</span> first <span>+</span> second<span>;</span>
        first <span>=</span> second<span>;</span>
        second <span>=</span> third<span>;</span>
    <span>}</span>
    <span>return</span> third<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>采用递归：</p>
<div><pre><code><span>public</span> <span>int</span> <span>Fibonacci</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>n <span>==</span> <span>1</span><span>||</span>n<span>==</span><span>2</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>return</span> <span>Fibonacci</span><span>(</span>n <span>-</span> <span>2</span><span>)</span> <span>+</span> <span>Fibonacci</span><span>(</span>n <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="跳台阶问题"> 跳台阶问题</h2>
<p><strong>题目描述：</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>问题分析：</strong></p>
<p>正常分析法：</p>
<blockquote>
<p>a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);
b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)
c.由a，b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)
d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</p>
</blockquote>
<p>找规律分析法：</p>
<blockquote>
<p>f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5，  可以总结出f(n) = f(n-1) + f(n-2)的规律。但是为什么会出现这样的规律呢？假设现在6个台阶，我们可以从第5跳一步到6，这样的话有多少种方案跳到5就有多少种方案跳到6，另外我们也可以从4跳两步跳到6，跳到4有多少种方案的话，就有多少种方案跳到6，其他的不能从3跳到6什么的啦，所以最后就是f(6) = f(5) + f(4)；这样子也很好理解变态跳台阶的问题了。</p>
</blockquote>
<p><strong>所以这道题其实就是斐波那契数列的问题。</strong></p>
<p>代码只需要在上一题的代码稍做修改即可。和上一题唯一不同的就是这一题的初始元素变为 1 2 3 5 8.....而上一题为1 1 2  3 5 .......。另外这一题也可以用递归做，但是递归效率太低，所以我这里只给出了迭代方式的代码。</p>
<p><strong>示例代码：</strong></p>
<div><pre><code><span>int</span> <span>jumpFloor</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>number <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>number <span>==</span> <span>1</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>number <span>==</span> <span>2</span><span>)</span> <span>{</span>
        <span>return</span> <span>2</span><span>;</span>
    <span>}</span>
    <span>int</span> first <span>=</span> <span>1</span><span>,</span> second <span>=</span> <span>2</span><span>,</span> third <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>3</span><span>;</span> i <span>&lt;=</span> number<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        third <span>=</span> first <span>+</span> second<span>;</span>
        first <span>=</span> second<span>;</span>
        second <span>=</span> third<span>;</span>
    <span>}</span>
    <span>return</span> third<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="变态跳台阶问题"> 变态跳台阶问题</h2>
<p><strong>题目描述：</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>问题分析：</strong></p>
<p>假设n&gt;=2，第一步有n种跳法：跳1级、跳2级、到跳n级
跳1级，剩下n-1级，则剩下跳法是f(n-1)
跳2级，剩下n-2级，则剩下跳法是f(n-2)
......
跳n-1级，剩下1级，则剩下跳法是f(1)
跳n级，剩下0级，则剩下跳法是f(0)
所以在n&gt;=2的情况下：
f(n)=f(n-1)+f(n-2)+...+f(1)
因为f(n-1)=f(n-2)+f(n-3)+...+f(1)
所以f(n)=2*f(n-1) 又f(1)=1,所以可得<strong>f(n)=2^(number-1)</strong></p>
<p><strong>示例代码：</strong></p>
<div><pre><code><span>int</span> <span>JumpFloorII</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>
    <span>return</span> <span>1</span> <span>&lt;&lt;</span> <span>--</span>number<span>;</span><span>//2^(number-1)用位移操作进行，更快</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>补充：</strong></p>
<p>java中有三种移位运算符：</p>
<ol>
<li>“&lt;&lt;” :     <strong>左移运算符</strong>，等同于乘2的n次方</li>
<li>“&gt;&gt;”:     <strong>右移运算符</strong>，等同于除2的n次方</li>
<li>“&gt;&gt;&gt;” :  <strong>无符号右移运算符</strong>，不管移动前最高位是0还是1，右移后左侧产生的空位部分都以0来填充。与&gt;&gt;类似。</li>
</ol>
<div><pre><code><span>int</span> a <span>=</span> <span>16</span><span>;</span>
<span>int</span> b <span>=</span> a <span>&lt;&lt;</span> <span>2</span><span>;</span><span>//左移2，等同于16 * 2的2次方，也就是16 * 4</span>
<span>int</span> c <span>=</span> a <span>>></span> <span>2</span><span>;</span><span>//右移2，等同于16 / 2的2次方，也就是16 / 4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="二维数组查找"> 二维数组查找</h2>
<p><strong>题目描述：</strong></p>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>问题解析：</strong></p>
<p>这一道题还是比较简单的，我们需要考虑的是如何做，效率最快。这里有一种很好理解的思路：</p>
<blockquote>
<p>矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，
因此从左下角开始查找，当要查找数字比左下角数字大时。右移
要查找数字比左下角数字小时，上移。这样找的速度最快。</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<div><pre><code><span>public</span> <span>boolean</span> <span>Find</span><span>(</span><span>int</span> target<span>,</span> <span>int</span> <span>[</span><span>]</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
    <span>//基本思路从左下角开始找，这样速度最快</span>
    <span>int</span> row <span>=</span> array<span>.</span>length<span>-</span><span>1</span><span>;</span><span>//行</span>
    <span>int</span> column <span>=</span> <span>0</span><span>;</span><span>//列</span>
    <span>//当行数大于0，当前列数小于总列数时循环条件成立</span>
    <span>while</span><span>(</span><span>(</span>row <span>>=</span> <span>0</span><span>)</span><span>&amp;&amp;</span> <span>(</span>column<span>&lt;</span> array<span>[</span><span>0</span><span>]</span><span>.</span>length<span>)</span><span>)</span><span>{</span>
        <span>if</span><span>(</span>array<span>[</span>row<span>]</span><span>[</span>column<span>]</span> <span>></span> target<span>)</span><span>{</span>
            row<span>--</span><span>;</span>
        <span>}</span><span>else</span> <span>if</span><span>(</span>array<span>[</span>row<span>]</span><span>[</span>column<span>]</span> <span>&lt;</span> target<span>)</span><span>{</span>
            column<span>++</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="替换空格"> 替换空格</h2>
<p><strong>题目描述：</strong></p>
<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>问题分析：</strong></p>
<p>这道题不难，我们可以通过循环判断字符串的字符是否为空格，是的话就利用append()方法添加追加“%20”，否则还是追加原字符。</p>
<p>或者最简单的方法就是利用：replaceAll(String regex,String replacement)方法了，一行代码就可以解决。</p>
<p><strong>示例代码：</strong></p>
<p>常规做法：</p>
<div><pre><code><span>public</span> <span>String</span> <span>replaceSpace</span><span>(</span><span>StringBuffer</span> str<span>)</span> <span>{</span>
    <span>StringBuffer</span> out <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> str<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>char</span> b <span>=</span> str<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>
        <span>if</span><span>(</span><span>String</span><span>.</span><span>valueOf</span><span>(</span>b<span>)</span><span>.</span><span>equals</span><span>(</span><span>" "</span><span>)</span><span>)</span><span>{</span>
            out<span>.</span><span>append</span><span>(</span><span>"%20"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            out<span>.</span><span>append</span><span>(</span>b<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> out<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>     
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>一行代码解决：</p>
<div><pre><code><span>public</span> <span>String</span> <span>replaceSpace</span><span>(</span><span>StringBuffer</span> str<span>)</span> <span>{</span>
    <span>//return str.toString().replaceAll(" ", "%20");</span>
    <span>//public String replaceAll(String regex,String replacement)</span>
    <span>//用给定的替换替换与给定的regular expression匹配的此字符串的每个子字符串。 </span>
    <span>//\ 转义字符. 如果你要使用 "\" 本身, 则应该使用 "\\". String类型中的空格用“\s”表示，所以我这里猜测"\\s"就是代表空格的意思</span>
    <span>return</span> str<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>replaceAll</span><span>(</span><span>"\\s"</span><span>,</span> <span>"%20"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="数值的整数次方"> 数值的整数次方</h2>
<p><strong>题目描述：</strong></p>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p><strong>问题解析：</strong></p>
<p>这道题算是比较麻烦和难一点的一个了。我这里采用的是<strong>二分幂</strong>思想，当然也可以采用<strong>快速幂</strong>。
更具剑指offer书中细节，该题的解题思路如下：
1.当底数为0且指数&lt;0时，会出现对0求倒数的情况，需进行错误处理，设置一个全局变量；
2.判断底数是否等于0，由于base为double型，所以不能直接用==判断
3.优化求幂函数（二分幂）。
当n为偶数，a^n =（a^n/2）*（a^n/2）；
当n为奇数，a^n = a^[(n-1)/2] * a^[(n-1)/2] * a。时间复杂度O(logn)</p>
<p><strong>时间复杂度</strong>：O(logn)</p>
<p><strong>示例代码：</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span> 
      <span>boolean</span> invalidInput<span>=</span><span>false</span><span>;</span>    
      <span>public</span> <span>double</span> <span>Power</span><span>(</span><span>double</span> base<span>,</span> <span>int</span> exponent<span>)</span> <span>{</span>
          <span>//如果底数等于0并且指数小于0</span>
          <span>//由于base为double型，不能直接用==判断</span>
        <span>if</span><span>(</span><span>equal</span><span>(</span>base<span>,</span><span>0.0</span><span>)</span><span>&amp;&amp;</span>exponent<span>&lt;</span><span>0</span><span>)</span><span>{</span>
            invalidInput<span>=</span><span>true</span><span>;</span>
            <span>return</span> <span>0.0</span><span>;</span>
        <span>}</span>
        <span>int</span> absexponent<span>=</span>exponent<span>;</span>
         <span>//如果指数小于0，将指数转正</span>
        <span>if</span><span>(</span>exponent<span>&lt;</span><span>0</span><span>)</span>
            absexponent<span>=</span><span>-</span>exponent<span>;</span>
         <span>//getPower方法求出base的exponent次方。</span>
        <span>double</span> res<span>=</span><span>getPower</span><span>(</span>base<span>,</span>absexponent<span>)</span><span>;</span>
         <span>//如果指数小于0，所得结果为上面求的结果的倒数</span>
        <span>if</span><span>(</span>exponent<span>&lt;</span><span>0</span><span>)</span>
            res<span>=</span><span>1.0</span><span>/</span>res<span>;</span>
        <span>return</span> res<span>;</span>
  <span>}</span>
    <span>//比较两个double型变量是否相等的方法</span>
    <span>boolean</span> <span>equal</span><span>(</span><span>double</span> num1<span>,</span><span>double</span> num2<span>)</span><span>{</span>
        <span>if</span><span>(</span>num1<span>-</span>num2<span>></span><span>-</span><span>0.000001</span><span>&amp;&amp;</span>num1<span>-</span>num2<span>&lt;</span><span>0.000001</span><span>)</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>else</span>
            <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>//求出b的e次方的方法</span>
    <span>double</span> <span>getPower</span><span>(</span><span>double</span> b<span>,</span><span>int</span> e<span>)</span><span>{</span>
        <span>//如果指数为0，返回1</span>
        <span>if</span><span>(</span>e<span>==</span><span>0</span><span>)</span>
            <span>return</span> <span>1.0</span><span>;</span>
        <span>//如果指数为1，返回b</span>
        <span>if</span><span>(</span>e<span>==</span><span>1</span><span>)</span>
            <span>return</span> b<span>;</span>
        <span>//e>>1相等于e/2，这里就是求a^n =（a^n/2）*（a^n/2）</span>
        <span>double</span> result<span>=</span><span>getPower</span><span>(</span>b<span>,</span>e<span>>></span><span>1</span><span>)</span><span>;</span>
        result<span>*=</span>result<span>;</span>
        <span>//如果指数n为奇数，则要再乘一次底数base</span>
        <span>if</span><span>(</span><span>(</span>e<span>&amp;</span><span>1</span><span>)</span><span>==</span><span>1</span><span>)</span>
            result<span>*=</span>b<span>;</span>
        <span>return</span> result<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>当然这一题也可以采用笨方法：累乘。不过这种方法的时间复杂度为O（n），这样没有前一种方法效率高。</p>
<div><pre><code><span>// 使用累乘</span>
<span>public</span> <span>double</span> <span>powerAnother</span><span>(</span><span>double</span> base<span>,</span> <span>int</span> exponent<span>)</span> <span>{</span>
    <span>double</span> result <span>=</span> <span>1.0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>Math</span><span>.</span><span>abs</span><span>(</span>exponent<span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        result <span>*=</span> base<span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>exponent <span>>=</span> <span>0</span><span>)</span>
        <span>return</span> result<span>;</span>
    <span>else</span>
        <span>return</span> <span>1</span> <span>/</span> result<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="调整数组顺序使奇数位于偶数前面"> 调整数组顺序使奇数位于偶数前面</h2>
<p><strong>题目描述：</strong></p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><strong>问题解析：</strong></p>
<p>这道题有挺多种解法的，给大家介绍一种我觉得挺好理解的方法：
我们首先统计奇数的个数假设为n,然后新建一个等长数组，然后通过循环判断原数组中的元素为偶数还是奇数。如果是则从数组下标0的元素开始，把该奇数添加到新数组；如果是偶数则从数组下标为n的元素开始把该偶数添加到新数组中。</p>
<p><strong>示例代码：</strong></p>
<p>时间复杂度为O（n），空间复杂度为O（n）的算法</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>void</span> <span>reOrderArray</span><span>(</span><span>int</span> <span>[</span><span>]</span> array<span>)</span> <span>{</span>
        <span>//如果数组长度等于0或者等于1，什么都不做直接返回</span>
        <span>if</span><span>(</span>array<span>.</span>length<span>==</span><span>0</span><span>||</span>array<span>.</span>length<span>==</span><span>1</span><span>)</span> 
            <span>return</span><span>;</span>
        <span>//oddCount：保存奇数个数</span>
        <span>//oddBegin：奇数从数组头部开始添加</span>
        <span>int</span> oddCount<span>=</span><span>0</span><span>,</span>oddBegin<span>=</span><span>0</span><span>;</span>
        <span>//新建一个数组</span>
        <span>int</span><span>[</span><span>]</span> newArray<span>=</span><span>new</span> <span>int</span><span>[</span>array<span>.</span>length<span>]</span><span>;</span>
        <span>//计算出（数组中的奇数个数）开始添加元素</span>
        <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>array<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>if</span><span>(</span><span>(</span>array<span>[</span>i<span>]</span><span>&amp;</span><span>1</span><span>)</span><span>==</span><span>1</span><span>)</span> oddCount<span>++</span><span>;</span>
        <span>}</span>
        <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>array<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>//如果数为基数新数组从头开始添加元素</span>
            <span>//如果为偶数就从oddCount（数组中的奇数个数）开始添加元素</span>
            <span>if</span><span>(</span><span>(</span>array<span>[</span>i<span>]</span><span>&amp;</span><span>1</span><span>)</span><span>==</span><span>1</span><span>)</span> 
                newArray<span>[</span>oddBegin<span>++</span><span>]</span><span>=</span>array<span>[</span>i<span>]</span><span>;</span>
            <span>else</span> newArray<span>[</span>oddCount<span>++</span><span>]</span><span>=</span>array<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
        <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>array<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            array<span>[</span>i<span>]</span><span>=</span>newArray<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id="链表中倒数第k个节点"> 链表中倒数第k个节点</h2>
<p><strong>题目描述：</strong></p>
<p>输入一个链表，输出该链表中倒数第k个结点</p>
<p><strong>问题分析：</strong></p>
<p><strong>一句话概括：</strong>
两个指针一个指针p1先开始跑，指针p1跑到k-1个节点后，另一个节点p2开始跑，当p1跑到最后时，p2所指的指针就是倒数第k个节点。</p>
<p><strong>思想的简单理解：</strong>
前提假设：链表的结点个数(长度)为n。
规律一：要找到倒数第k个结点，需要向前走多少步呢？比如倒数第一个结点，需要走n步，那倒数第二个结点呢？很明显是向前走了n-1步，所以可以找到规律是找到倒数第k个结点，需要向前走n-k+1步。</p>
<p><strong>算法开始：</strong></p>
<ol>
<li>设两个都指向head的指针p1和p2，当p1走了k-1步的时候，停下来。p2之前一直不动。</li>
<li>p1的下一步是走第k步，这个时候，p2开始一起动了。至于为什么p2这个时候动呢？看下面的分析。</li>
<li>当p1走到链表的尾部时，即p1走了n步。由于我们知道p2是在p1走了k-1步才开始动的，也就是说p1和p2永远差k-1步。所以当p1走了n步时，p2走的应该是在n-(k-1)步。即p2走了n-k+1步，此时巧妙的是p2正好指向的是规律一的倒数第k个结点处。
这样是不是很好理解了呢？</li>
</ol>
<p><strong>考察内容：</strong></p>
<p>链表+代码的鲁棒性</p>
<p><strong>示例代码：</strong></p>
<div><pre><code><span>/*
//链表类
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/</span>

<span>//时间复杂度O(n),一次遍历即可</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>ListNode</span> <span>FindKthToTail</span><span>(</span><span>ListNode</span> head<span>,</span><span>int</span> k<span>)</span> <span>{</span>
        <span>ListNode</span> pre<span>=</span><span>null</span><span>,</span>p<span>=</span><span>null</span><span>;</span>
        <span>//两个指针都指向头结点</span>
        p<span>=</span>head<span>;</span>
        pre<span>=</span>head<span>;</span>
        <span>//记录k值</span>
        <span>int</span> a<span>=</span>k<span>;</span>
        <span>//记录节点的个数</span>
        <span>int</span> count<span>=</span><span>0</span><span>;</span>
        <span>//p指针先跑，并且记录节点数，当p指针跑了k-1个节点后，pre指针开始跑，</span>
        <span>//当p指针跑到最后时，pre所指指针就是倒数第k个节点</span>
        <span>while</span><span>(</span>p<span>!=</span><span>null</span><span>)</span><span>{</span>
            p<span>=</span>p<span>.</span>next<span>;</span>
            count<span>++</span><span>;</span>
            <span>if</span><span>(</span>k<span>&lt;</span><span>1</span><span>)</span><span>{</span>
                pre<span>=</span>pre<span>.</span>next<span>;</span>
            <span>}</span>
            k<span>--</span><span>;</span>
        <span>}</span>
        <span>//如果节点个数小于所求的倒数第k个节点，则返回空</span>
        <span>if</span><span>(</span>count<span>&lt;</span>a<span>)</span> <span>return</span> <span>null</span><span>;</span>
        <span>return</span> pre<span>;</span>
            
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h2 id="反转链表"> 反转链表</h2>
<p><strong>题目描述：</strong></p>
<p>输入一个链表，反转链表后，输出链表的所有元素。</p>
<p><strong>问题分析：</strong></p>
<p>链表的很常规的一道题，这一道题思路不算难，但自己实现起来真的可能会感觉无从下手，我是参考了别人的代码。
思路就是我们根据链表的特点，前一个节点指向下一个节点的特点，把后面的节点移到前面来。
就比如下图：我们把1节点和2节点互换位置，然后再将3节点指向2节点，4节点指向3节点，这样以来下面的链表就被反转了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/844773c7300e4373922bb1a6ae2a55a3~tplv-k3u1fbpfcp-zoom-1.image" alt="链表" /></p>
<p><strong>考察内容：</strong></p>
<p>链表+代码的鲁棒性</p>
<p><strong>示例代码：</strong></p>
<div><pre><code><span>/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>ListNode</span> <span>ReverseList</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
       <span>ListNode</span> next <span>=</span> <span>null</span><span>;</span>
       <span>ListNode</span> pre <span>=</span> <span>null</span><span>;</span>
        <span>while</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>
              <span>//保存要反转到头来的那个节点</span>
               next <span>=</span> head<span>.</span>next<span>;</span>
               <span>//要反转的那个节点指向已经反转的上一个节点</span>
               head<span>.</span>next <span>=</span> pre<span>;</span>
               <span>//上一个已经反转到头部的节点</span>
               pre <span>=</span> head<span>;</span>
               <span>//一直向链表尾走</span>
               head <span>=</span> next<span>;</span>
        <span>}</span>
        <span>return</span> pre<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id="合并两个排序的链表"> 合并两个排序的链表</h2>
<p><strong>题目描述：</strong></p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p><strong>问题分析：</strong></p>
<p>我们可以这样分析:</p>
<ol>
<li>假设我们有两个链表 A,B；</li>
<li>A的头节点A1的值与B的头结点B1的值比较，假设A1小，则A1为头节点；</li>
<li>A2再和B1比较，假设B1小,则，A1指向B1；</li>
<li>A2再和B2比较。。。。。。。
就这样循环往复就行了，应该还算好理解。</li>
</ol>
<p><strong>考察内容：</strong></p>
<p>链表+代码的鲁棒性</p>
<p><strong>示例代码：</strong></p>
<p>非递归版本：</p>
<div><pre><code><span>/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>ListNode</span> <span>Merge</span><span>(</span><span>ListNode</span> list1<span>,</span><span>ListNode</span> list2<span>)</span> <span>{</span>
       <span>//list1为空，直接返回list2</span>
       <span>if</span><span>(</span>list1 <span>==</span> <span>null</span><span>)</span><span>{</span>
            <span>return</span> list2<span>;</span>
        <span>}</span>
        <span>//list2为空，直接返回list1</span>
        <span>if</span><span>(</span>list2 <span>==</span> <span>null</span><span>)</span><span>{</span>
            <span>return</span> list1<span>;</span>
        <span>}</span>
        <span>ListNode</span> mergeHead <span>=</span> <span>null</span><span>;</span>
        <span>ListNode</span> current <span>=</span> <span>null</span><span>;</span>   
        <span>//当list1和list2不为空时</span>
        <span>while</span><span>(</span>list1<span>!=</span><span>null</span> <span>&amp;&amp;</span> list2<span>!=</span><span>null</span><span>)</span><span>{</span>
            <span>//取较小值作头结点 </span>
            <span>if</span><span>(</span>list1<span>.</span>val <span>&lt;=</span> list2<span>.</span>val<span>)</span><span>{</span>
                <span>if</span><span>(</span>mergeHead <span>==</span> <span>null</span><span>)</span><span>{</span>
                   mergeHead <span>=</span> current <span>=</span> list1<span>;</span>
                <span>}</span><span>else</span><span>{</span>
                   current<span>.</span>next <span>=</span> list1<span>;</span>
                    <span>//current节点保存list1节点的值因为下一次还要用</span>
                   current <span>=</span> list1<span>;</span>
                <span>}</span>
                <span>//list1指向下一个节点</span>
                list1 <span>=</span> list1<span>.</span>next<span>;</span>
            <span>}</span><span>else</span><span>{</span>
                <span>if</span><span>(</span>mergeHead <span>==</span> <span>null</span><span>)</span><span>{</span>
                   mergeHead <span>=</span> current <span>=</span> list2<span>;</span>
                <span>}</span><span>else</span><span>{</span>
                   current<span>.</span>next <span>=</span> list2<span>;</span>
                     <span>//current节点保存list2节点的值因为下一次还要用</span>
                   current <span>=</span> list2<span>;</span>
                <span>}</span>
                <span>//list2指向下一个节点</span>
                list2 <span>=</span> list2<span>.</span>next<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>if</span><span>(</span>list1 <span>==</span> <span>null</span><span>)</span><span>{</span>
            current<span>.</span>next <span>=</span> list2<span>;</span>
        <span>}</span><span>else</span><span>{</span>
            current<span>.</span>next <span>=</span> list1<span>;</span>
        <span>}</span>
        <span>return</span> mergeHead<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><p>递归版本：</p>
<div><pre><code><span>public</span> <span>ListNode</span> <span>Merge</span><span>(</span><span>ListNode</span> list1<span>,</span><span>ListNode</span> list2<span>)</span> <span>{</span>
    <span>if</span><span>(</span>list1 <span>==</span> <span>null</span><span>)</span><span>{</span>
        <span>return</span> list2<span>;</span>
    <span>}</span>
    <span>if</span><span>(</span>list2 <span>==</span> <span>null</span><span>)</span><span>{</span>
        <span>return</span> list1<span>;</span>
    <span>}</span>
    <span>if</span><span>(</span>list1<span>.</span>val <span>&lt;=</span> list2<span>.</span>val<span>)</span><span>{</span>
        list1<span>.</span>next <span>=</span> <span>Merge</span><span>(</span>list1<span>.</span>next<span>,</span> list2<span>)</span><span>;</span>
        <span>return</span> list1<span>;</span>
    <span>}</span><span>else</span><span>{</span>
        list2<span>.</span>next <span>=</span> <span>Merge</span><span>(</span>list1<span>,</span> list2<span>.</span>next<span>)</span><span>;</span>
        <span>return</span> list2<span>;</span>
    <span>}</span>       
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="用两个栈实现队列"> 用两个栈实现队列</h2>
<p><strong>题目描述：</strong></p>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p><strong>问题分析：</strong></p>
<p>先来回顾一下栈和队列的基本特点：
**栈：**后进先出（LIFO）
<strong>队列：</strong> 先进先出
很明显我们需要根据JDK给我们提供的栈的一些基本方法来实现。先来看一下Stack类的一些基本方法：
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-4-4/5985000.jpg" alt="Stack类的一些常见方法" /></p>
<p>既然题目给了我们两个栈，我们可以这样考虑当push的时候将元素push进stack1，pop的时候我们先把stack1的元素pop到stack2，然后再对stack2执行pop操作，这样就可以保证是先进先出的。（负[pop]负[pop]得正[先进先出]）</p>
<p><strong>考察内容：</strong></p>
<p>队列+栈</p>
<p>示例代码：</p>
<div><pre><code><span>//左程云的《程序员代码面试指南》的答案</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Stack</span><span>;</span>
 
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack1 <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack2 <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
     
    <span>//当执行push操作时，将元素添加到stack1</span>
    <span>public</span> <span>void</span> <span>push</span><span>(</span><span>int</span> node<span>)</span> <span>{</span>
        stack1<span>.</span><span>push</span><span>(</span>node<span>)</span><span>;</span>
    <span>}</span>
     
    <span>public</span> <span>int</span> <span>pop</span><span>(</span><span>)</span> <span>{</span>
        <span>//如果两个队列都为空则抛出异常,说明用户没有push进任何元素</span>
        <span>if</span><span>(</span>stack1<span>.</span><span>empty</span><span>(</span><span>)</span><span>&amp;&amp;</span>stack2<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span><span>{</span>
            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>"Queue is empty!"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>//如果stack2不为空直接对stack2执行pop操作，</span>
        <span>if</span><span>(</span>stack2<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span><span>{</span>
            <span>while</span><span>(</span><span>!</span>stack1<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span><span>{</span>
                <span>//将stack1的元素按后进先出push进stack2里面</span>
                stack2<span>.</span><span>push</span><span>(</span>stack1<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
          <span>return</span> stack2<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="栈的压入-弹出序列"> 栈的压入,弹出序列</h2>
<p><strong>题目描述：</strong></p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p><strong>题目分析：</strong></p>
<p>这道题想了半天没有思路，参考了Alias的答案，他的思路写的也很详细应该很容易看懂。
作者：Alias
https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106
来源：牛客网</p>
<p>【思路】借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p>
<p>举例：</p>
<p>入栈1,2,3,4,5</p>
<p>出栈4,5,3,2,1</p>
<p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p>
<p>此时栈顶2≠4，继续入栈3</p>
<p>此时栈顶3≠4，继续入栈4</p>
<p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p>
<p>此时栈顶3≠5，继续入栈5</p>
<p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p>
<p>….
依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。</p>
<p><strong>考察内容：</strong></p>
<p>栈</p>
<p><strong>示例代码：</strong></p>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Stack</span><span>;</span>
<span>//这道题没想出来，参考了Alias同学的答案：https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106</span>
<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>boolean</span> <span>IsPopOrder</span><span>(</span><span>int</span> <span>[</span><span>]</span> pushA<span>,</span><span>int</span> <span>[</span><span>]</span> popA<span>)</span> <span>{</span>
        <span>if</span><span>(</span>pushA<span>.</span>length <span>==</span> <span>0</span> <span>||</span> popA<span>.</span>length <span>==</span> <span>0</span><span>)</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> s <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>//用于标识弹出序列的位置</span>
        <span>int</span> popIndex <span>=</span> <span>0</span><span>;</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i<span>&lt;</span> pushA<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            s<span>.</span><span>push</span><span>(</span>pushA<span>[</span>i<span>]</span><span>)</span><span>;</span>
            <span>//如果栈不为空，且栈顶元素等于弹出序列</span>
            <span>while</span><span>(</span><span>!</span>s<span>.</span><span>empty</span><span>(</span><span>)</span> <span>&amp;&amp;</span>s<span>.</span><span>peek</span><span>(</span><span>)</span> <span>==</span> popA<span>[</span>popIndex<span>]</span><span>)</span><span>{</span>
                <span>//出栈</span>
                s<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
                <span>//弹出序列向后一位</span>
                popIndex<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> s<span>.</span><span>empty</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div>]]></content:encoded>
      <enclosure url="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/844773c7300e4373922bb1a6ae2a55a3~tplv-k3u1fbpfcp-zoom-1.image" type="image/"/>
    </item>
    <item>
      <title>图</title>
      <link>https://javaguide.cn/cs-basics/data-structure/%E5%9B%BE/</link>
      <guid>https://javaguide.cn/cs-basics/data-structure/%E5%9B%BE/</guid>
      <source url="https://javaguide.cn/rss.xml">图</source>
      <category>计算机基础</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="图"> 图</h1>
<blockquote>
<p>开头还是求点赞，求转发！原创优质公众号，希望大家能让更多人看到我们的文章。</p>
<p>图片都是我们手绘的，可以说非常用心了！</p>
</blockquote>
<p>图是一种较为复杂的非线性结构。 <strong>为啥说其较为复杂呢？</strong></p>
<p>根据前面的内容，我们知道：</p>
<ul>
<li>线性数据结构的元素满足唯一的线性关系，每个元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继。</li>
<li>树形数据结构的元素之间有着明显的层次关系。</li>
</ul>
<p>但是，图形结构的元素之间的关系是任意的。</p>
<p><strong>何为图呢？</strong> 简单来说，图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：<strong>G(V,E)</strong>，其中，G表示一个图，V表示顶点的集合，E表示边的集合。</p>
<p>下图所展示的就是图这种数据结构，并且还是一张有向图。</p>
<p><img src="./pictures/图/图.png" alt="图" /></p>
<p>图在我们日常生活中的例子很多！比如我们在社交软件上好友关系就可以用图来表示。</p>
<h2 id="图的基本概念"> 图的基本概念</h2>
<h3 id="顶点"> 顶点</h3>
<p>图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）</p>
<p>对应到好友关系图，每一个用户就代表一个顶点。</p>
<h3 id="边"> 边</h3>
<p>顶点之间的关系用边表示。</p>
<p>对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。</p>
<h3 id="度"> 度</h3>
<p>度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。</p>
<p>对应到好友关系图，度就代表了某个人的好友数量。</p>
<h3 id="无向图和有向图"> 无向图和有向图</h3>
<p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。</p>
<p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。</p>
<h3 id="无权图和带权图"> 无权图和带权图</h3>
<p>对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。</p>
<p>对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。</p>
<p>下图就是一个带权有向图。</p>
<p><img src="./pictures/图/带权有向图.png" alt="带权有向图" /></p>
<h2 id="图的存储"> 图的存储</h2>
<h3 id="邻接矩阵存储"> 邻接矩阵存储</h3>
<p>邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。</p>
<p>如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 <code>A[i][j]=n</code> 。</p>
<p>在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，<code>A[i][j]</code>=1，当顶点i和顶点j没有关系时，<code>A[i][j]</code>=0。如下图所示：</p>
<p><img src="./pictures/图/无向图的邻接矩阵存储.png" alt="无向图的邻接矩阵存储" /></p>
<p>值得注意的是：<strong>无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。</strong></p>
<p><img src="./pictures/图/有向图的邻接矩阵存储.png" alt="有向图的邻接矩阵存储" /></p>
<p>邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间，</p>
<h3 id="邻接表存储"> 邻接表存储</h3>
<p>针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—<strong>邻接表</strong> 。</p>
<p>邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 <strong>邻接表</strong>。如下图所示：</p>
<p><img src="./pictures/图/无向图的邻接表存储.png" alt="无向图的邻接表存储" /></p>
<p><img src="./pictures/图/有向图的邻接表存储.png" alt="有向图的邻接表存储" /></p>
<p>大家可以数一数邻接表中所存储的元素的个数以及图中边的条数，你会发现：</p>
<ul>
<li>在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。</li>
<li>在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。</li>
</ul>
<h2 id="图的搜索"> 图的搜索</h2>
<h3 id="广度优先搜索"> 广度优先搜索</h3>
<p>广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：</p>
<p><img src="./pictures/图/广度优先搜索图示.png" alt="广度优先搜索图示" /></p>
<p><strong>广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列</strong> 。具体过程如下图所示：</p>
<p><strong>第1步：</strong></p>
<p><img src="./pictures/图/广度优先搜索1.png" alt="广度优先搜索1" /></p>
<p><strong>第2步：</strong></p>
<p><img src="./pictures/图/广度优先搜索2.png" alt="广度优先搜索2" /></p>
<p><strong>第3步：</strong></p>
<p><img src="./pictures/图/广度优先搜索3.png" alt="广度优先搜索3" /></p>
<p><strong>第4步：</strong></p>
<p><img src="./pictures/图/广度优先搜索4.png" alt="广度优先搜索4" /></p>
<p><strong>第5步：</strong></p>
<p><img src="./pictures/图/广度优先搜索5.png" alt="广度优先搜索5" /></p>
<p><strong>第6步：</strong></p>
<p><img src="./pictures/图/广度优先搜索6.png" alt="广度优先搜索6" /></p>
<h3 id="深度优先搜索"> 深度优先搜索</h3>
<p>深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：</p>
<p><img src="./pictures/图/深度优先搜索图示.png" alt="深度优先搜索图示" /></p>
<p><strong>和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈</strong> 。具体过程如下图所示：</p>
<p><strong>第1步：</strong></p>
<p><img src="./pictures/图/深度优先搜索1.png" alt="深度优先搜索1" /></p>
<p><strong>第2步：</strong></p>
<p><img src="./pictures/图/深度优先搜索2.png" alt="深度优先搜索1" /></p>
<p><strong>第3步：</strong></p>
<p><img src="./pictures/图/深度优先搜索3.png" alt="深度优先搜索1" /></p>
<p><strong>第4步：</strong></p>
<p><img src="./pictures/图/深度优先搜索4.png" alt="深度优先搜索1" /></p>
<p><strong>第5步：</strong></p>
<p><img src="./pictures/图/深度优先搜索5.png" alt="深度优先搜索1" /></p>
<p><strong>第6步：</strong></p>
<p><img src="./pictures/图/深度优先搜索6.png" alt="深度优先搜索1" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>布隆过滤器</title>
      <link>https://javaguide.cn/cs-basics/data-structure/bloom-filter/</link>
      <guid>https://javaguide.cn/cs-basics/data-structure/bloom-filter/</guid>
      <source url="https://javaguide.cn/rss.xml">布隆过滤器</source>
      <category>计算机基础</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="布隆过滤器"> 布隆过滤器</h1>
<p>海量数据处理以及缓存穿透这两个场景让我认识了 布隆过滤器 ，我查阅了一些资料来了解它，但是很多现成资料并不满足我的需求，所以就决定自己总结一篇关于布隆过滤器的文章。希望通过这篇文章让更多人了解布隆过滤器，并且会实际去使用它！</p>
<p>下面我们将分为几个方面来介绍布隆过滤器：</p>
<ol>
<li>什么是布隆过滤器？</li>
<li>布隆过滤器的原理介绍。</li>
<li>布隆过滤器使用场景。</li>
<li>通过 Java 编程手动实现布隆过滤器。</li>
<li>利用 Google 开源的 Guava 中自带的布隆过滤器。</li>
<li>Redis 中的布隆过滤器。</li>
</ol>
<h2 id="什么是布隆过滤器"> 什么是布隆过滤器？</h2>
<p>首先，我们需要了解布隆过滤器的概念。</p>
<p>布隆过滤器（Bloom Filter）是一个叫做 Bloom 的老哥于 1970 年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-bit数组.png" alt="布隆过滤器示意图" /></p>
<p>位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。</p>
<p>总结：<strong>一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。</strong></p>
<h2 id="布隆过滤器的原理介绍"> 布隆过滤器的原理介绍</h2>
<p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>举个简单的例子：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-hash运算.png" alt="布隆过滤器hash计算" /></p>
<p>如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。</p>
<p>如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
<p><strong>不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。</strong></p>
<p>综上，我们可以得出：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<h2 id="布隆过滤器使用场景"> 布隆过滤器使用场景</h2>
<ol>
<li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。</li>
<li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</li>
</ol>
<h2 id="编码实战"> 编码实战</h2>
<h3 id="通过-java-编程手动实现布隆过滤器"> 通过 Java 编程手动实现布隆过滤器</h3>
<p>我们上面已经说了布隆过滤器的原理，知道了布隆过滤器的原理之后就可以自己手动实现一个了。</p>
<p>如果你想要手动实现一个的话，你需要：</p>
<ol>
<li>一个合适大小的位数组保存数据</li>
<li>几个不同的哈希函数</li>
<li>添加元素到位数组（布隆过滤器）的方法实现</li>
<li>判断给定元素是否存在于位数组（布隆过滤器）的方法实现。</li>
</ol>
<p>下面给出一个我觉得写的还算不错的代码（参考网上已有代码改进得到，对于所有类型对象皆适用）：</p>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>BitSet</span><span>;</span>

<span>public</span> <span>class</span> <span>MyBloomFilter</span> <span>{</span>

    <span>/**
     * 位数组的大小
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_SIZE <span>=</span> <span>2</span> <span>&lt;&lt;</span> <span>24</span><span>;</span>
    <span>/**
     * 通过这个数组可以创建 6 个不同的哈希函数
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span><span>[</span><span>]</span> SEEDS <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>3</span><span>,</span> <span>13</span><span>,</span> <span>46</span><span>,</span> <span>71</span><span>,</span> <span>91</span><span>,</span> <span>134</span><span>}</span><span>;</span>

    <span>/**
     * 位数组。数组中的元素只能是 0 或者 1
     */</span>
    <span>private</span> <span>BitSet</span> bits <span>=</span> <span>new</span> <span>BitSet</span><span>(</span>DEFAULT_SIZE<span>)</span><span>;</span>

    <span>/**
     * 存放包含 hash 函数的类的数组
     */</span>
    <span>private</span> <span>SimpleHash</span><span>[</span><span>]</span> func <span>=</span> <span>new</span> <span>SimpleHash</span><span>[</span>SEEDS<span>.</span>length<span>]</span><span>;</span>

    <span>/**
     * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样
     */</span>
    <span>public</span> <span>MyBloomFilter</span><span>(</span><span>)</span> <span>{</span>
        <span>// 初始化多个不同的 Hash 函数</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> SEEDS<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            func<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>SimpleHash</span><span>(</span>DEFAULT_SIZE<span>,</span> SEEDS<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * 添加元素到位数组
     */</span>
    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>Object</span> value<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>SimpleHash</span> f <span>:</span> func<span>)</span> <span>{</span>
            bits<span>.</span><span>set</span><span>(</span>f<span>.</span><span>hash</span><span>(</span>value<span>)</span><span>,</span> <span>true</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * 判断指定元素是否存在于位数组
     */</span>
    <span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> value<span>)</span> <span>{</span>
        <span>boolean</span> ret <span>=</span> <span>true</span><span>;</span>
        <span>for</span> <span>(</span><span>SimpleHash</span> f <span>:</span> func<span>)</span> <span>{</span>
            ret <span>=</span> ret <span>&amp;&amp;</span> bits<span>.</span><span>get</span><span>(</span>f<span>.</span><span>hash</span><span>(</span>value<span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> ret<span>;</span>
    <span>}</span>

    <span>/**
     * 静态内部类。用于 hash 操作！
     */</span>
    <span>public</span> <span>static</span> <span>class</span> <span>SimpleHash</span> <span>{</span>

        <span>private</span> <span>int</span> cap<span>;</span>
        <span>private</span> <span>int</span> seed<span>;</span>

        <span>public</span> <span>SimpleHash</span><span>(</span><span>int</span> cap<span>,</span> <span>int</span> seed<span>)</span> <span>{</span>
            <span>this</span><span>.</span>cap <span>=</span> cap<span>;</span>
            <span>this</span><span>.</span>seed <span>=</span> seed<span>;</span>
        <span>}</span>

        <span>/**
         * 计算 hash 值
         */</span>
        <span>public</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> value<span>)</span> <span>{</span>
            <span>int</span> h<span>;</span>
            <span>return</span> <span>(</span>value <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>Math</span><span>.</span><span>abs</span><span>(</span>seed <span>*</span> <span>(</span>cap <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> <span>(</span><span>(</span>h <span>=</span> value<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><p>测试：</p>
<div><pre><code><span>String</span> value1 <span>=</span> <span>"https://javaguide.cn/"</span><span>;</span>
<span>String</span> value2 <span>=</span> <span>"https://github.com/Snailclimb"</span><span>;</span>
<span>MyBloomFilter</span> filter <span>=</span> <span>new</span> <span>MyBloomFilter</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>contains</span><span>(</span>value1<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>contains</span><span>(</span>value2<span>)</span><span>)</span><span>;</span>
filter<span>.</span><span>add</span><span>(</span>value1<span>)</span><span>;</span>
filter<span>.</span><span>add</span><span>(</span>value2<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>contains</span><span>(</span>value1<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>contains</span><span>(</span>value2<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Output:</p>
<div><pre><code>false
false
true
true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>测试：</p>
<div><pre><code><span>Integer</span> value1 <span>=</span> <span>13423</span><span>;</span>
<span>Integer</span> value2 <span>=</span> <span>22131</span><span>;</span>
<span>MyBloomFilter</span> filter <span>=</span> <span>new</span> <span>MyBloomFilter</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>contains</span><span>(</span>value1<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>contains</span><span>(</span>value2<span>)</span><span>)</span><span>;</span>
filter<span>.</span><span>add</span><span>(</span>value1<span>)</span><span>;</span>
filter<span>.</span><span>add</span><span>(</span>value2<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>contains</span><span>(</span>value1<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>contains</span><span>(</span>value2<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Output:</p>
<div><pre><code><span>false</span>
<span>false</span>
<span>true</span>
<span>true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="利用-google-开源的-guava-中自带的布隆过滤器"> 利用 Google 开源的 Guava 中自带的布隆过滤器</h3>
<p>自己实现的目的主要是为了让自己搞懂布隆过滤器的原理，Guava 中布隆过滤器的实现算是比较权威的，所以实际项目中我们不需要手动实现一个布隆过滤器。</p>
<p>首先我们需要在项目中引入 Guava 的依赖：</p>
<div><pre><code><span><span>&lt;</span>dependency<span>></span></span>
    <span><span>&lt;</span>groupId<span>></span></span>com<span>.</span>google<span>.</span>guava<span>&lt;</span><span>/</span>groupId<span>></span>
    <span><span>&lt;</span>artifactId<span>></span></span>guava<span>&lt;</span><span>/</span>artifactId<span>></span>
    <span><span>&lt;</span>version<span>></span></span><span>28.0</span><span>-</span>jre<span>&lt;</span><span>/</span>version<span>></span>
<span>&lt;</span><span>/</span>dependency<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>实际使用如下：</p>
<p>我们创建了一个最多存放 最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）</p>
<div><pre><code><span>// 创建布隆过滤器对象</span>
<span>BloomFilter</span><span><span>&lt;</span><span>Integer</span><span>></span></span> filter <span>=</span> <span>BloomFilter</span><span>.</span><span>create</span><span>(</span>
    <span>Funnels</span><span>.</span><span>integerFunnel</span><span>(</span><span>)</span><span>,</span>
    <span>1500</span><span>,</span>
    <span>0.01</span><span>)</span><span>;</span>
<span>// 判断指定元素是否存在</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>mightContain</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>mightContain</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>
<span>// 将元素添加进布隆过滤器</span>
filter<span>.</span><span>put</span><span>(</span><span>1</span><span>)</span><span>;</span>
filter<span>.</span><span>put</span><span>(</span><span>2</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>mightContain</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>mightContain</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>在我们的示例中，当 <code>mightContain()</code> 方法返回 <em>true</em> 时，我们可以 99％确定该元素在过滤器中，当过滤器返回 <em>false</em> 时，我们可以 100％确定该元素不存在于过滤器中。</p>
<p><strong>Guava 提供的布隆过滤器的实现还是很不错的（想要详细了解的可以看一下它的源码实现），但是它有一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 Redis 中的布隆过滤器了。</strong></p>
<h2 id="redis-中的布隆过滤器"> Redis 中的布隆过滤器</h2>
<h3 id="介绍"> 介绍</h3>
<p>Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。布隆过滤器就是其中的 Module。详情可以查看 Redis 官方对 Redis Modules 的介绍 ：https://redis.io/modules</p>
<p>另外，官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module，地址：https://github.com/RedisBloom/RedisBloom
其他还有：</p>
<ul>
<li>redis-lua-scaling-bloom-filter（lua 脚本实现）：https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter</li>
<li>pyreBloom（Python 中的快速 Redis 布隆过滤器） ：https://github.com/seomoz/pyreBloom</li>
<li>......</li>
</ul>
<p>RedisBloom 提供了多种语言的客户端支持，包括：Python、Java、JavaScript 和 PHP。</p>
<h3 id="使用-docker-安装"> 使用 Docker 安装</h3>
<p>如果我们需要体验 Redis 中的布隆过滤器非常简单，通过 Docker 就可以了！我们直接在 Google 搜索 <strong>docker redis bloomfilter</strong> 然后在排除广告的第一条搜素结果就找到了我们想要的答案（这是我平常解决问题的一种方式，分享一下），具体地址：https://hub.docker.com/r/redislabs/rebloom/ （介绍的很详细 ）。</p>
<p><strong>具体操作如下：</strong></p>
<div><pre><code>➜  ~ docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest
➜  ~ docker exec -it redis-redisbloom bash
root@21396d02c252:/data# redis-cli
127.0.0.1:6379&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="常用命令一览"> 常用命令一览</h3>
<blockquote>
<p>注意： key : 布隆过滤器的名称，item : 添加的元素。</p>
</blockquote>
<ol>
<li><strong><code>BF.ADD</code></strong>：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：<code>BF.ADD {key} {item}</code>。</li>
<li><strong><code>BF.MADD</code></strong> : 将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式<code>BF.ADD</code>与之相同，只不过它允许多个输入并返回多个值。格式：<code>BF.MADD {key} {item} [item ...]</code> 。</li>
<li><strong><code>BF.EXISTS</code></strong> : 确定元素是否在布隆过滤器中存在。格式：<code>BF.EXISTS {key} {item}</code>。</li>
<li><strong><code>BF.MEXISTS</code></strong> ： 确定一个或者多个元素是否在布隆过滤器中存在格式：<code>BF.MEXISTS {key} {item} [item ...]</code>。</li>
</ol>
<p>另外， <code>BF. RESERVE</code> 命令需要单独介绍一下：</p>
<p>这个命令的格式如下：</p>
<p><code>BF. RESERVE {key} {error_rate} {capacity} [EXPANSION expansion]</code> 。</p>
<p>下面简单介绍一下每个参数的具体含义：</p>
<ol>
<li>key：布隆过滤器的名称</li>
<li>error_rate : 期望的误报率。该值必须介于 0 到 1 之间。例如，对于期望的误报率 0.1％（1000 中为 1），error_rate 应该设置为 0.001。该数字越接近零，则每个项目的内存消耗越大，并且每个操作的 CPU 使用率越高。</li>
<li>capacity: 过滤器的容量。当实际存储的元素个数超过这个值之后，性能将开始下降。实际的降级将取决于超出限制的程度。随着过滤器元素数量呈指数增长，性能将线性下降。</li>
</ol>
<p>可选参数：</p>
<ul>
<li>expansion：如果创建了一个新的子过滤器，则其大小将是当前过滤器的大小乘以<code>expansion</code>。默认扩展值为 2。这意味着每个后续子过滤器将是前一个子过滤器的两倍。</li>
</ul>
<h3 id="实际使用"> 实际使用</h3>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> BF.ADD myFilter java
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> BF.ADD myFilter javaguide
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> BF.EXISTS myFilter java
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> BF.EXISTS myFilter javaguide
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> BF.EXISTS myFilter github
<span>(</span>integer<span>)</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-bit数组.png" type="image/png"/>
    </item>
    <item>
      <title>堆</title>
      <link>https://javaguide.cn/cs-basics/data-structure/%E5%A0%86/</link>
      <guid>https://javaguide.cn/cs-basics/data-structure/%E5%A0%86/</guid>
      <source url="https://javaguide.cn/rss.xml">堆</source>
      <category>计算机基础</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="堆"> 堆</h1>
<h2 id="什么是堆"> 什么是堆</h2>
<p>堆是一种满足以下条件的树：</p>
<p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p>
<blockquote>
<p>大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。</p>
</blockquote>
<p><strong>!!!特别提示：</strong></p>
<ul>
<li>很多博客说堆是完全二叉树，其实并非如此，<strong>堆不一定是完全二叉树</strong>，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。</li>
<li>（<strong>二叉</strong>）堆是一个数组，它可以被看成是一个 <strong>近似的完全二叉树</strong>。——《算法导论》第三版</li>
</ul>
<p>大家可以尝试判断下面给出的图是否是堆？</p>
<p><img src="./pictures/堆/堆1.png" alt="" /></p>
<p>第1个和第2个是堆。第1个是最大堆，每个节点都比子树中所有节点大。第2个是最小堆，每个节点都比子树中所有节点小。</p>
<p>第3个不是，第三个中，根结点1比2和15小，而15却比3大，19比5大，不满足堆的性质。</p>
<h2 id="堆的用途"> 堆的用途</h2>
<p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p>
<p>有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 <code>O(nlog(n))</code>，查找最大值或者最小值时间复杂度都是 <code>O(1)</code>，但是，涉及到更新（插入或删除）数据时，时间复杂度为 <code>O(n)</code>，即使是使用复杂度为 <code>O(log(n))</code> 的二分法找到要插入或者删除的数据，在移动数据时也需要 <code>O(n)</code> 的时间复杂度。</p>
<p><strong>相对于有序数组而言，堆的主要优势在于更新数据效率较高。</strong> 堆的初始化时间复杂度为 <code>O(nlog(n))</code>，堆可以做到<code>O(1)</code>时间复杂度取出最大值或者最小值，<code>O(log(n))</code>时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。</p>
<h2 id="堆的分类"> 堆的分类</h2>
<p>堆分为 <strong>最大堆</strong> 和 <strong>最小堆</strong>。二者的区别在于节点的排序方式。</p>
<ul>
<li><strong>最大堆</strong> ：堆中的每一个节点的值都大于等于子树中所有节点的值</li>
<li><strong>最小堆</strong> ：堆中的每一个节点的值都小于等于子树中所有节点的值</li>
</ul>
<p>如下图所示，图1是最大堆，图2是最小堆</p>
<p><img src="./pictures/堆/堆2.png" alt="" /></p>
<h2 id="堆的存储"> 堆的存储</h2>
<p>之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 <code>2*i</code>，右子节点序号为 <code>2*i+1</code>）。</p>
<p>为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：</p>
<p><img src="./pictures/堆/堆的存储.png" alt="堆的存储" /></p>
<h2 id="堆的操作"> 堆的操作</h2>
<p>堆的更新操作主要包括两种 :  <strong>插入元素</strong> 和 <strong>删除堆顶元素</strong>。操作过程需要着重掌握和理解。</p>
<blockquote>
<p>在进入正题之前，再重申一遍，堆是一个公平的公司，有能力的人自然会走到与他能力所匹配的位置</p>
</blockquote>
<h3 id="插入元素"> 插入元素</h3>
<blockquote>
<p>插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起</p>
</blockquote>
<p><strong>1.将要插入的元素放到最后</strong></p>
<p><img src="./pictures/堆/堆-插入元素1.png" alt="堆-插入元素-1" /></p>
<blockquote>
<p>有能力的人会逐渐升职加薪，是金子总会发光的！！！</p>
</blockquote>
<p><strong>2.从底向上，如果父结点比该元素大，则该节点和父结点交换，直到无法交换</strong></p>
<p><img src="./pictures/堆/堆-插入元素2.png" alt="堆-插入元素2" /></p>
<p><img src="./pictures/堆/堆-插入元素3.png" alt="堆-插入元素3" /></p>
<h3 id="删除堆顶元素"> 删除堆顶元素</h3>
<p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p>
<p>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为&quot;<strong>堆化</strong>&quot;，堆化的方法分为两种：</p>
<ul>
<li>一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。</li>
<li>另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。</li>
</ul>
<h4 id="自底向上堆化"> 自底向上堆化</h4>
<blockquote>
<p>在堆这个公司中，会出现老大离职的现象，老大离职之后，他的位置就空出来了</p>
</blockquote>
<p>首先删除堆顶元素，使得数组中下标为1的位置空出。</p>
<p><img src="./pictures/堆/删除堆顶元素1.png" alt="删除堆顶元素1" /></p>
<blockquote>
<p>那么他的位置由谁来接替呢，当然是他的直接下属了，谁能力强就让谁上呗</p>
</blockquote>
<p>比较根结点的左子节点和右子节点，也就是下标为2,3的数组元素，将较大的元素填充到根结点(下标为1)的位置。</p>
<p><img src="./pictures/堆/删除堆顶元素2.png" alt="删除堆顶元素2" /></p>
<blockquote>
<p>这个时候又空出一个位置了，老规矩，谁有能力谁上</p>
</blockquote>
<p>一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部</p>
<p><img src="./pictures/堆/删除堆顶元素3.png" alt="删除堆顶元素3" /></p>
<p>这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。</p>
<h4 id="自顶向下堆化"> 自顶向下堆化</h4>
<p>自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。</p>
<p><img src="./pictures/堆/删除堆顶元素4.png" alt="删除堆顶元素4" /></p>
<p>然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。</p>
<p><img src="./pictures/堆/删除堆顶元素5.png" alt="删除堆顶元素5" /></p>
<p><img src="./pictures/堆/删除堆顶元素6.png" alt="删除堆顶元素6" /></p>
<h3 id="堆的操作总结"> 堆的操作总结</h3>
<ul>
<li><strong>插入元素</strong> ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</li>
<li><strong>删除堆顶元素</strong> ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</li>
</ul>
<h2 id="堆排序"> 堆排序</h2>
<p>堆排序的过程分为两步：</p>
<ul>
<li>第一步是建堆，将一个无序的数组建立为一个堆</li>
<li>第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。</li>
</ul>
<h3 id="建堆"> 建堆</h3>
<p>如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。</p>
<p>首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为n，那么我们需要对n/2到1的节点进行自顶向下（沉底）堆化。</p>
<p>具体过程如下图：</p>
<p><img src="./pictures/堆/建堆1.png" alt="建堆1" /></p>
<p>将初始的无序数组抽象为一棵树，图中的节点个数为6，所以4,5,6节点为叶节点，1,2,3节点为非叶节点，所以要对1-3号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从3号节点开始，一直到1号节点。
3号节点堆化结果：</p>
<p><img src="./pictures/堆/建堆2.png" alt="建堆1" /></p>
<p>2号节点堆化结果：</p>
<p><img src="./pictures/堆/建堆3.png" alt="建堆1" /></p>
<p>1号节点堆化结果：</p>
<p><img src="./pictures/堆/建堆4.png" alt="建堆1" /></p>
<p>至此，数组所对应的树已经成为了一个最大堆，建堆完成！</p>
<h3 id="排序"> 排序</h3>
<p>由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p>
<p>现在思考两个问题：</p>
<ul>
<li>删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？</li>
<li>取出的堆顶元素存在哪，新建一个数组存？</li>
</ul>
<p>先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。</p>
<p>机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。</p>
<p>详细过程如下图所示：</p>
<p>取出第一个元素并堆化：</p>
<p><img src="./pictures/堆/堆排序1.png" alt="堆排序1" /></p>
<p>取出第二个元素并堆化：</p>
<p><img src="./pictures/堆/堆排序2.png" alt="堆排序2" /></p>
<p>取出第三个元素并堆化：</p>
<p><img src="./pictures/堆/堆排序3.png" alt="堆排序3" /></p>
<p>取出第四个元素并堆化：</p>
<p><img src="./pictures/堆/堆排序4.png" alt="堆排序4" /></p>
<p>取出第五个元素并堆化：</p>
<p><img src="./pictures/堆/堆排序5.png" alt="堆排序5" /></p>
<p>取出第六个元素并堆化：</p>
<p><img src="./pictures/堆/堆排序6.png" alt="堆排序6" /></p>
<p>堆排序完成！</p>
]]></content:encoded>
    </item>
    <item>
      <title>树</title>
      <link>https://javaguide.cn/cs-basics/data-structure/%E6%A0%91/</link>
      <guid>https://javaguide.cn/cs-basics/data-structure/%E6%A0%91/</guid>
      <source url="https://javaguide.cn/rss.xml">树</source>
      <category>计算机基础</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="树"> 树</h1>
<p>树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。</p>
<p>一棵树具有以下特点：</p>
<ol>
<li>一棵树中的任意两个结点有且仅有唯一的一条路径连通。</li>
<li>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</li>
<li>一棵树不包含回路。</li>
</ol>
<p>下图就是一颗树，并且是一颗二叉树。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/二叉树-2.png" alt="二叉树" /></p>
<p>如上图所示，通过上面这张图说明一下树中的常用概念：</p>
<ul>
<li><strong>节点</strong> ：树中的每个元素都可以统称为节点。</li>
<li><strong>根节点</strong> ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。</li>
<li><strong>父节点</strong> ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。</li>
<li><strong>子节点</strong> ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。</li>
<li><strong>兄弟节点</strong> ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。</li>
<li><strong>叶子节点</strong> ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。</li>
<li><strong>节点的高度</strong> ：该节点到叶子节点的最长路径所包含的边数。</li>
<li><strong>节点的深度</strong> ：根节点到该节点的路径所包含的边数</li>
<li><strong>节点的层数</strong> ：节点的深度+1。</li>
<li><strong>树的高度</strong> ：根节点的高度。</li>
</ul>
<h2 id="二叉树的分类"> 二叉树的分类</h2>
<p><strong>二叉树</strong>（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p>
<p><strong>二叉树</strong> 的分支通常被称作“<strong>左子树</strong>”或“<strong>右子树</strong>”。并且，<strong>二叉树</strong> 的分支具有左右次序，不能随意颠倒。</p>
<p><strong>二叉树</strong> 的第 i 层至多拥有 <code>2^(i-1)</code> 个节点，深度为 k 的二叉树至多总共有 <code>2^k-1</code> 个节点</p>
<h3 id="满二叉树"> 满二叉树</h3>
<p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 <strong>满二叉树</strong>。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 <strong>满二叉树</strong>。如下图所示：</p>
<p><img src="./pictures/树/满二叉树.png" alt="" /></p>
<h3 id="完全二叉树"> 完全二叉树</h3>
<p>除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 <strong>完全二叉树</strong> 。</p>
<p>大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。如下图所示：</p>
<p><img src="./pictures/树/完全二叉树.png" alt="" /></p>
<p>完全二叉树有一个很好的性质：<strong>父结点和子节点的序号有着对应关系。</strong></p>
<p>细心的小伙伴可能发现了，当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。</p>
<h3 id="平衡二叉树"> 平衡二叉树</h3>
<p><strong>平衡二叉树</strong> 是一棵二叉排序树，且具有以下性质：</p>
<ol>
<li>可以是一棵空树</li>
<li>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</li>
</ol>
<p>平衡二叉树的常用实现方法有 <strong>红黑树</strong>、<strong>AVL 树</strong>、<strong>替罪羊树</strong>、<strong>加权平衡树</strong>、<strong>伸展树</strong> 等。</p>
<p>在给大家展示平衡二叉树之前，先给大家看一棵树：</p>
<p><img src="./pictures/树/斜树.png" alt="" /></p>
<p><strong>你管这玩意儿叫树？？？</strong></p>
<p>没错，这玩意儿还真叫树，只不过这棵树已经退化为一个链表了，我们管它叫 <strong>斜树</strong>。</p>
<p><strong>如果这样，那我为啥不直接用链表呢?</strong></p>
<p>谁说不是呢？</p>
<p>二叉树相比于链表，由于父子节点以及兄弟节点之间往往具有某种特殊的关系，这种关系使得我们在树中对数据进行<strong>搜索</strong>和<strong>修改</strong>时，相对于链表更加快捷便利。</p>
<p>但是，如果二叉树退化为一个链表了，那么那么树所具有的优秀性质就难以表现出来，效率也会大打折，为了避免这样的情况，我们希望每个做 “家长”（父结点） 的，都 <strong>一碗水端平</strong>，分给左儿子和分给右儿子的尽可能一样多，相差最多不超过一层，如下图所示：</p>
<p><img src="./pictures/树/平衡二叉树.png" alt="" /></p>
<h2 id="二叉树的存储"> 二叉树的存储</h2>
<p>二叉树的存储主要分为 <strong>链式存储</strong> 和 <strong>顺序存储</strong> 两种：</p>
<h3 id="链式存储"> 链式存储</h3>
<p>和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。</p>
<p>每个节点包括三个属性：</p>
<ul>
<li>数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。</li>
<li>左节点指针 left</li>
<li>右节点指针 right。</li>
</ul>
<p>可是 JAVA 没有指针啊！</p>
<p>那就直接引用对象呗（别问我对象哪里找）</p>
<p><img src="./pictures/树/链式存储二叉树.png" alt="" /></p>
<h3 id="顺序存储"> 顺序存储</h3>
<p>顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2 _ i 的位置，它的右子节点存储在下标为 2 _ i+1 的位置。</p>
<p>一棵完全二叉树的数组顺序存储如下图所示：</p>
<p><img src="./pictures/树/顺序存储.png" alt="" /></p>
<p>大家可以试着填写一下存储如下二叉树的数组，比较一下和完全二叉树的顺序存储有何区别：</p>
<p><img src="./pictures/树/顺序存储2.png" alt="" /></p>
<p>可以看到，如果我们要存储的二叉树不是完全二叉树，在数组中就会出现空隙，导致内存利用率降低</p>
<h2 id="二叉树的遍历"> 二叉树的遍历</h2>
<h3 id="先序遍历"> 先序遍历</h3>
<p><img src="./pictures/树/先序遍历.png" alt="" /></p>
<p>二叉树的先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，我们可以递归实现先序遍历。</p>
<p>代码如下：</p>
<div><pre><code><span>public</span> <span>void</span> <span>preOrder</span><span>(</span><span>TreeNode</span> root<span>)</span><span>{</span>
	<span>if</span><span>(</span>root <span>==</span> <span>null</span><span>)</span><span>{</span>
		<span>return</span><span>;</span>
	<span>}</span>
	system<span>.</span>out<span>.</span><span>println</span><span>(</span>root<span>.</span>data<span>)</span><span>;</span>
	<span>preOrder</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
	<span>preOrder</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="中序遍历"> 中序遍历</h3>
<p><img src="./pictures/树/中序遍历.png" alt="" /></p>
<p>二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树，大家可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间，如下图所示：</p>
<p><img src="./pictures/树/中序遍历2.png" alt="" /></p>
<p>代码如下：</p>
<div><pre><code><span>public</span> <span>void</span> <span>inOrder</span><span>(</span><span>TreeNode</span> root<span>)</span><span>{</span>
	<span>if</span><span>(</span>root <span>==</span> <span>null</span><span>)</span><span>{</span>
		<span>return</span><span>;</span>
	<span>}</span>
	<span>inOrder</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
	system<span>.</span>out<span>.</span><span>println</span><span>(</span>root<span>.</span>data<span>)</span><span>;</span>
	<span>inOrder</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="后序遍历"> 后序遍历</h3>
<p><img src="./pictures/树/后序遍历.png" alt="" /></p>
<p>二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值</p>
<p>代码如下：</p>
<div><pre><code><span>public</span> <span>void</span> <span>postOrder</span><span>(</span><span>TreeNode</span> root<span>)</span><span>{</span>
	<span>if</span><span>(</span>root <span>==</span> <span>null</span><span>)</span><span>{</span>
		<span>return</span><span>;</span>
	<span>}</span>
	<span>postOrder</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
	<span>postOrder</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
	system<span>.</span>out<span>.</span><span>println</span><span>(</span>root<span>.</span>data<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/二叉树-2.png" type="image/png"/>
    </item>
    <item>
      <title>红黑树</title>
      <link>https://javaguide.cn/cs-basics/data-structure/%E7%BA%A2%E9%BB%91%E6%A0%91/</link>
      <guid>https://javaguide.cn/cs-basics/data-structure/%E7%BA%A2%E9%BB%91%E6%A0%91/</guid>
      <source url="https://javaguide.cn/rss.xml">红黑树</source>
      <category>计算机基础</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="红黑树"> 红黑树</h1>
<p><strong>红黑树特点</strong> :</p>
<ol>
<li>每个节点非红即黑；</li>
<li>根节点总是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）；</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>
</ol>
<p><strong>红黑树的应用</strong> ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。</p>
<p><strong>为什么要用红黑树？</strong> 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 <a href="https://juejin.im/post/5a27c6946fb9a04509096248#comment" target="_blank" rel="noopener noreferrer">漫画：什么是红黑树？</a>（也介绍到了二叉查找树，非常推荐）</p>
<p><strong>相关阅读</strong> ：<a href="https://zhuanlan.zhihu.com/p/24367771" target="_blank" rel="noopener noreferrer">《红黑树深入剖析及Java实现》</a>（美团点评技术团队）</p>
]]></content:encoded>
    </item>
    <item>
      <title>线性数据结构 :数组、链表、栈、队列</title>
      <link>https://javaguide.cn/cs-basics/data-structure/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <guid>https://javaguide.cn/cs-basics/data-structure/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <source url="https://javaguide.cn/rss.xml">线性数据结构 :数组、链表、栈、队列</source>
      <category>计算机基础</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="线性数据结构-数组、链表、栈、队列"> 线性数据结构 :数组、链表、栈、队列</h1>
<blockquote>
<p>开头还是求点赞，求转发！原创优质公众号，希望大家能让更多人看到我们的文章。</p>
<p>图片都是我们手绘的，可以说非常用心了！</p>
</blockquote>
<h2 id="_1-数组"> 1. 数组</h2>
<p><strong>数组（Array）</strong> 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。</p>
<p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p>
<p>数组的特点是：<strong>提供随机访问</strong> 并且容量有限。</p>
<div><pre><code>假如数组的长度为 n。
访问：<span>O</span>（<span>1</span>）<span>//访问特定位置的元素</span>
插入：<span>O</span>（n ）<span>//最坏的情况发生在插入发生在数组的首部并需要移动所有元素时</span>
删除：<span>O</span>（n）<span>//最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/数组.png" alt="数组" /></p>
<h2 id="_2-链表"> 2. 链表</h2>
<h3 id="_2-1-链表简介"> 2.1. 链表简介</h3>
<p><strong>链表（LinkedList）</strong> 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p>
<p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。</p>
<p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p>
<h3 id="_2-2-链表分类"> 2.2. 链表分类</h3>
<p><strong>常见链表分类：</strong></p>
<ol>
<li>单链表</li>
<li>双向链表</li>
<li>循环链表</li>
<li>双向循环链表</li>
</ol>
<div><pre><code>假如链表中有n个元素。
访问：<span>O</span>（n）<span>//访问特定位置的元素</span>
插入删除：<span>O</span>（<span>1</span>）<span>//必须要要知道插入元素的位置</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="_2-2-1-单链表"> 2.2.1. 单链表</h4>
<p><strong>单链表</strong> 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/单链表2.png" alt="单链表" /></p>
<h4 id="_2-2-2-循环链表"> 2.2.2. 循环链表</h4>
<p><strong>循环链表</strong> 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/循环链表2.png" alt="循环链表" /></p>
<h4 id="_2-2-3-双向链表"> 2.2.3. 双向链表</h4>
<p><strong>双向链表</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向链表.png" alt="双向链表" /></p>
<h4 id="_2-2-4-双向循环链表"> 2.2.4. 双向循环链表</h4>
<p><strong>双向循环链表</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向循环链表.png" alt="双向循环链表" /></p>
<h3 id="_2-3-应用场景"> 2.3. 应用场景</h3>
<ul>
<li>如果需要支持随机访问的话，链表没办法做到。</li>
<li>如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适。</li>
<li>如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。</li>
</ul>
<h3 id="_2-4-数组-vs-链表"> 2.4. 数组 vs 链表</h3>
<ul>
<li>数组支持随机访问，而链表不支持。</li>
<li>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</li>
<li>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</li>
</ul>
<h2 id="_3-栈"> 3. 栈</h2>
<h3 id="_3-1-栈简介"> 3.1. 栈简介</h3>
<p><strong>栈</strong> (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 <strong>后进先出（LIFO, Last In First Out）</strong> 的原理运作。<strong>在栈中，push 和 pop 的操作都发生在栈顶。</strong></p>
<p>栈常用一维数组或链表来实现，用数组实现的栈叫作 <strong>顺序栈</strong> ，用链表实现的栈叫作 <strong>链式栈</strong> 。</p>
<div><pre><code>假设堆栈中有n个元素。
访问：<span>O</span>（n）<span>//最坏情况</span>
插入删除：<span>O</span>（<span>1</span>）<span>//顶端插入和删除元素</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/栈.png" alt="栈" /></p>
<h3 id="_3-2-栈的常见应用常见应用场景"> 3.2. 栈的常见应用常见应用场景</h3>
<p>当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 <strong>后进先出（LIFO, Last In First Out）</strong> 的特性时，我们就可以使用栈这个数据结构。</p>
<h4 id="_3-2-1-实现浏览器的回退和前进功能"> 3.2.1. 实现浏览器的回退和前进功能</h4>
<p>我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/栈实现浏览器倒退和前进.png" alt="栈实现浏览器倒退和前进" /></p>
<h4 id="_3-2-2-检查符号是否成对出现"> 3.2.2. 检查符号是否成对出现</h4>
<blockquote>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串，判断该字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>比如 &quot;()&quot;、&quot;()[]{}&quot;、&quot;{[]}&quot; 都是有效字符串，而 &quot;(]&quot; 、&quot;([)]&quot; 则不是。</p>
</blockquote>
<p>这个问题实际是 Leetcode 的一道题目，我们可以利用栈 <code>Stack</code> 来解决这个问题。</p>
<ol>
<li>首先我们将括号间的对应规则存放在 <code>Map</code> 中，这一点应该毋容置疑；</li>
<li>创建一个栈。遍历字符串，如果字符是左括号就直接加入<code>stack</code>中，否则将<code>stack</code> 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果<code>stack</code>为空，返回 <code>true</code>。</li>
</ol>
<div><pre><code><span>public</span> <span>boolean</span> <span>isValid</span><span>(</span><span>String</span> s<span>)</span><span>{</span>
    <span>// 括号之间的对应规则</span>
    <span>HashMap</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Character</span><span>></span></span> mappings <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Character</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    mappings<span>.</span><span>put</span><span>(</span><span>')'</span><span>,</span> <span>'('</span><span>)</span><span>;</span>
    mappings<span>.</span><span>put</span><span>(</span><span>'}'</span><span>,</span> <span>'{'</span><span>)</span><span>;</span>
    mappings<span>.</span><span>put</span><span>(</span><span>']'</span><span>,</span> <span>'['</span><span>)</span><span>;</span>
    <span>Stack</span><span><span>&lt;</span><span>Character</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>Character</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>char</span><span>[</span><span>]</span> chars <span>=</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> chars<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>mappings<span>.</span><span>containsKey</span><span>(</span>chars<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>
            <span>char</span> topElement <span>=</span> stack<span>.</span><span>empty</span><span>(</span><span>)</span> <span>?</span> <span>'#'</span> <span>:</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>topElement <span>!=</span> mappings<span>.</span><span>get</span><span>(</span>chars<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>
                <span>return</span> <span>false</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>else</span> <span>{</span>
            stack<span>.</span><span>push</span><span>(</span>chars<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h4 id="_3-2-3-反转字符串"> 3.2.3. 反转字符串</h4>
<p>将字符串中的每个字符先入栈再出栈就可以了。</p>
<h4 id="_3-2-4-维护函数调用"> 3.2.4. 维护函数调用</h4>
<p>最后一个被调用的函数必须先完成执行，符合栈的 <strong>后进先出（LIFO, Last In First Out）</strong> 特性。</p>
<h3 id="_3-3-栈的实现"> 3.3. 栈的实现</h3>
<p>栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。</p>
<p>下面我们使用数组来实现一个栈，并且这个栈具有<code>push()</code>、<code>pop()</code>（返回栈顶元素并出栈）、<code>peek()</code> （返回栈顶元素不出栈）、<code>isEmpty()</code>、<code>size()</code>这些基本的方法。</p>
<blockquote>
<p>提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用<code>Arrays.copyOf()</code>进行扩容；</p>
</blockquote>
<div><pre><code><span>public</span> <span>class</span> <span>MyStack</span> <span>{</span>
    <span>private</span> <span>int</span><span>[</span><span>]</span> storage<span>;</span><span>//存放栈中元素的数组</span>
    <span>private</span> <span>int</span> capacity<span>;</span><span>//栈的容量</span>
    <span>private</span> <span>int</span> count<span>;</span><span>//栈中元素数量</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> GROW_FACTOR <span>=</span> <span>2</span><span>;</span>

    <span>//不带初始容量的构造方法。默认容量为8</span>
    <span>public</span> <span>MyStack</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>capacity <span>=</span> <span>8</span><span>;</span>
        <span>this</span><span>.</span>storage<span>=</span><span>new</span> <span>int</span><span>[</span><span>8</span><span>]</span><span>;</span>
        <span>this</span><span>.</span>count <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>//带初始容量的构造方法</span>
    <span>public</span> <span>MyStack</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>initialCapacity <span>&lt;</span> <span>1</span><span>)</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Capacity too small."</span><span>)</span><span>;</span>

        <span>this</span><span>.</span>capacity <span>=</span> initialCapacity<span>;</span>
        <span>this</span><span>.</span>storage <span>=</span> <span>new</span> <span>int</span><span>[</span>initialCapacity<span>]</span><span>;</span>
        <span>this</span><span>.</span>count <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>//入栈</span>
    <span>public</span> <span>void</span> <span>push</span><span>(</span><span>int</span> value<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>count <span>==</span> capacity<span>)</span> <span>{</span>
            <span>ensureCapacity</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        storage<span>[</span>count<span>++</span><span>]</span> <span>=</span> value<span>;</span>
    <span>}</span>

    <span>//确保容量大小</span>
    <span>private</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>)</span> <span>{</span>
        <span>int</span> newCapacity <span>=</span> capacity <span>*</span> GROW_FACTOR<span>;</span>
        storage <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>storage<span>,</span> newCapacity<span>)</span><span>;</span>
        capacity <span>=</span> newCapacity<span>;</span>
    <span>}</span>

    <span>//返回栈顶元素并出栈</span>
    <span>private</span> <span>int</span> <span>pop</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>count <span>==</span> <span>0</span><span>)</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Stack is empty."</span><span>)</span><span>;</span>
        count<span>--</span><span>;</span>
        <span>return</span> storage<span>[</span>count<span>]</span><span>;</span>
    <span>}</span>

    <span>//返回栈顶元素不出栈</span>
    <span>private</span> <span>int</span> <span>peek</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>count <span>==</span> <span>0</span><span>)</span><span>{</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Stack is empty."</span><span>)</span><span>;</span>
        <span>}</span><span>else</span> <span>{</span>
            <span>return</span> storage<span>[</span>count<span>-</span><span>1</span><span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>//判断栈是否为空</span>
    <span>private</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> count <span>==</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>//返回栈中元素的个数</span>
    <span>private</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> count<span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br></div></div><p>验证</p>
<div><pre><code><span>MyStack</span> myStack <span>=</span> <span>new</span> <span>MyStack</span><span>(</span><span>3</span><span>)</span><span>;</span>
myStack<span>.</span><span>push</span><span>(</span><span>1</span><span>)</span><span>;</span>
myStack<span>.</span><span>push</span><span>(</span><span>2</span><span>)</span><span>;</span>
myStack<span>.</span><span>push</span><span>(</span><span>3</span><span>)</span><span>;</span>
myStack<span>.</span><span>push</span><span>(</span><span>4</span><span>)</span><span>;</span>
myStack<span>.</span><span>push</span><span>(</span><span>5</span><span>)</span><span>;</span>
myStack<span>.</span><span>push</span><span>(</span><span>6</span><span>)</span><span>;</span>
myStack<span>.</span><span>push</span><span>(</span><span>7</span><span>)</span><span>;</span>
myStack<span>.</span><span>push</span><span>(</span><span>8</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myStack<span>.</span><span>peek</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//8</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myStack<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//8</span>
<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>8</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myStack<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myStack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//true</span>
myStack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span><span>//报错：java.lang.IllegalArgumentException: Stack is empty.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="_4-队列"> 4. 队列</h2>
<h3 id="_4-1-队列简介"> 4.1. 队列简介</h3>
<p><strong>队列</strong> 是 <strong>先进先出( FIFO，First In, First Out)</strong> 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 <strong>顺序队列</strong> ，用链表实现的队列叫作 <strong>链式队列</strong> 。<strong>队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue</strong></p>
<p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p>
<div><pre><code>假设队列中有n个元素。
访问：<span>O</span>（n）<span>//最坏情况</span>
插入删除：<span>O</span>（<span>1</span>）<span>//后端插入前端删除元素</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/队列.png" alt="队列" /></p>
<h3 id="_4-2-队列分类"> 4.2. 队列分类</h3>
<h4 id="_4-2-1-单队列"> 4.2.1. 单队列</h4>
<p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <strong>顺序队列（数组实现）</strong> 和 <strong>链式队列（链表实现）</strong>。</p>
<p><strong>顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。</strong></p>
<p>假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 <strong>”假溢出“</strong> 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。</p>
<blockquote>
<p>为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向对头元素，rear 指针指向队列最后一个元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/顺序队列假溢出1.png" alt="顺序队列假溢出" /></p>
<h4 id="_4-2-2-循环队列"> 4.2.2. 循环队列</h4>
<p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。</p>
<p>还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/循环队列.png" alt="循环队列" /></p>
<p>顺序队列中，我们说 <code>front==rear</code> 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：</p>
<ol>
<li>可以设置一个标志变量 <code>flag</code>,当 <code>front==rear</code> 并且 <code>flag=0</code> 的时候队列为空，当<code>front==rear</code> 并且 <code>flag=1</code> 的时候队列为满。</li>
<li>队列为空的时候就是 <code>front==rear</code> ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是： <code>(rear+1) % QueueSize= front</code> 。</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/循环队列-堆满.png" alt="循环队列-队满" /></p>
<h3 id="_4-3-常见应用场景"> 4.3. 常见应用场景</h3>
<p>当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。</p>
<ul>
<li><strong>阻塞队列：</strong> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</li>
<li><strong>线程池中的请求/任务队列：</strong> 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：<code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出<code>java.util.concurrent.RejectedExecutionException</code> 异常。</li>
<li>Linux 内核进程队列（按优先级排队）</li>
<li>现实生活中的派对，播放器上的播放列表;</li>
<li>消息队列</li>
<li>等等......</li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/数组.png" type="image/png"/>
    </item>
    <item>
      <title>HTTPS中的TLS</title>
      <link>https://javaguide.cn/cs-basics/network/HTTPS%E4%B8%AD%E7%9A%84TLS/</link>
      <guid>https://javaguide.cn/cs-basics/network/HTTPS%E4%B8%AD%E7%9A%84TLS/</guid>
      <source url="https://javaguide.cn/rss.xml">HTTPS中的TLS</source>
      <category>计算机基础</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1-ssl-与-tls"> 1. SSL 与 TLS</h1>
<p>SSL：（Secure Socket Layer） 安全套接层，于 1994 年由网景公司设计，并于 1995 年发布了 3.0 版本<br>
TLS：（Transport Layer Security）传输层安全性协议，是 IETF 在 SSL3.0 的基础上设计的协议<br>
以下全部使用 TLS 来表示</p>
<h1 id="_2-从网络协议的角度理解-https"> 2. 从网络协议的角度理解 HTTPS</h1>
<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/七层.png" alt="此图并不准确" /><br>
HTTP：HyperText Transfer Protocol 超文本传输协议<br>
HTTPS：Hypertext Transfer Protocol Secure 超文本传输安全协议<br>
TLS：位于 HTTP 和 TCP 之间的协议，其内部有 TLS握手协议、TLS记录协议<br>
HTTPS 经由 HTTP 进行通信，但利用 TLS 来保证安全，即 HTTPS = HTTP + TLS</p>
<h1 id="_3-从密码学的角度理解-https"> 3. 从密码学的角度理解 HTTPS</h1>
<p>HTTPS 使用 TLS 保证安全，这里的“安全”分两部分，一是传输内容加密、二是服务端的身份认证</p>
<h2 id="_3-1-tls-工作流程"> 3.1. TLS 工作流程</h2>
<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/tls流程.png" alt="此图并不准确" /><br>
此为服务端单向认证，还有客户端/服务端双向认证，流程类似，只不过客户端也有自己的证书，并发送给服务器进行验证</p>
<h2 id="_3-2-密码基础"> 3.2. 密码基础</h2>
<h3 id="_3-2-1-伪随机数生成器"> 3.2.1. 伪随机数生成器</h3>
<p>为什么叫伪随机数，因为没有真正意义上的随机数，具体可以参考 Random/TheadLocalRandom<br>
它的主要作用在于生成对称密码的秘钥、用于公钥密码生成秘钥对</p>
<h3 id="_3-2-2-消息认证码"> 3.2.2. 消息认证码</h3>
<p>消息认证码主要用于验证消息的完整性与消息的认证，其中消息的认证指“消息来自正确的发送者”</p>
<blockquote>
<p>消息认证码用于验证和认证，而不是加密</p>
</blockquote>
<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/消息认证码过程.png" alt="消息认证码过程" /></p>
<ol>
<li>发送者与接收者事先共享秘钥</li>
<li>发送者根据发送消息计算 MAC 值</li>
<li>发送者发送消息和 MAC 值</li>
<li>接收者根据接收到的消息计算 MAC 值</li>
<li>接收者根据自己计算的 MAC 值与收到的 MAC 对比</li>
<li>如果对比成功，说明消息完整，并来自于正确的发送者</li>
</ol>
<h3 id="_3-2-3-数字签名"> 3.2.3. 数字签名</h3>
<p>消息认证码的缺点在于<strong>无法防止否认</strong>，因为共享秘钥被 client、server 两端拥有，server 可以伪造 client 发送给自己的消息（自己给自己发送消息），为了解决这个问题，我们需要它们有各自的秘钥不被第二个知晓（这样也解决了共享秘钥的配送问题）</p>
<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/数字签名过程.png" alt="数字签名过程" /></p>
<blockquote>
<p>数字签名和消息认证码都<strong>不是为了加密</strong><br>
可以将单向散列函数获取散列值的过程理解为使用 md5 摘要算法获取摘要的过程</p>
</blockquote>
<p>使用自己的私钥对自己所认可的消息生成一个该消息专属的签名，这就是数字签名，表明我承认该消息来自自己<br>
注意：<strong>私钥用于加签，公钥用于解签，每个人都可以解签，查看消息的归属人</strong></p>
<h3 id="_3-2-4-公钥密码"> 3.2.4. 公钥密码</h3>
<p>公钥密码也叫非对称密码，由公钥和私钥组成，它最开始是为了解决秘钥的配送传输安全问题，即，我们不配送私钥，只配送公钥，私钥由本人保管<br>
它与数字签名相反，公钥密码的私钥用于解密、公钥用于加密，每个人都可以用别人的公钥加密，但只有对应的私钥才能解开密文<br>
client：明文 + 公钥 = 密文<br>
server：密文 + 私钥 = 明文<br>
注意：<strong>公钥用于加密，私钥用于解密，只有私钥的归属者，才能查看消息的真正内容</strong></p>
<h3 id="_3-2-5-证书"> 3.2.5. 证书</h3>
<p>证书：全称公钥证书（Public-Key Certificate, PKC）,里面保存着归属者的基本信息，以及证书过期时间、归属者的公钥，并由认证机构（Certification Authority, <strong>CA</strong>）施加数字签名，表明，某个认证机构认定该公钥的确属于此人</p>
<blockquote>
<p>想象这个场景：你想在支付宝页面交易，你需要支付宝的公钥进行加密通信，于是你从百度上搜索关键字“支付宝公钥”，你获得了支什宝的公钥，这个时候，支什宝通过中间人攻击，让你访问到了他们支什宝的页面，最后你在这个支什宝页面完美的使用了支什宝的公钥完成了与支什宝的交易
<img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/dns中间人攻击.png" alt="证书过程" /></p>
</blockquote>
<p>在上面的场景中，你可以理解支付宝证书就是由支付宝的公钥、和给支付宝颁发证书的企业的数字签名组成<br>
任何人都可以给自己或别人的公钥添加自己的数字签名，表明：我拿我的尊严担保，我的公钥/别人的公钥是真的，至于信不信那是另一回事了</p>
<h3 id="_3-2-6-密码小结"> 3.2.6. 密码小结</h3>
<table>
<thead>
<tr>
<th style="text-align:left">密码</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">组成</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">消息认证码</td>
<td style="text-align:left">确认消息的完整、并对消息的来源认证</td>
<td style="text-align:left">共享秘钥+消息的散列值</td>
</tr>
<tr>
<td style="text-align:left">数字签名</td>
<td style="text-align:left">对消息的散列值签名</td>
<td style="text-align:left">公钥+私钥+消息的散列值</td>
</tr>
<tr>
<td style="text-align:left">公钥密码</td>
<td style="text-align:left">解决秘钥的配送问题</td>
<td style="text-align:left">公钥+私钥+消息</td>
</tr>
<tr>
<td style="text-align:left">证书</td>
<td style="text-align:left">解决公钥的归属问题</td>
<td style="text-align:left">公钥密码中的公钥+数字签名</td>
</tr>
</tbody>
</table>
<h2 id="_3-3-tls-使用的密码技术"> 3.3. TLS 使用的密码技术</h2>
<ol>
<li>伪随机数生成器：秘钥生成随机性，更难被猜测</li>
<li>对称密码：对称密码使用的秘钥就是由伪随机数生成，相较于非对称密码，效率更高</li>
<li>消息认证码：保证消息信息的完整性、以及验证消息信息的来源</li>
<li>公钥密码：证书技术使用的就是公钥密码</li>
<li>数字签名：验证证书的签名，确定由真实的某个 CA 颁发</li>
<li>证书：解决公钥的真实归属问题，降低中间人攻击概率</li>
</ol>
<h2 id="_3-4-tls-总结"> 3.4. TLS 总结</h2>
<p>TLS 是一系列密码工具的框架，作为框架，它也是非常的灵活，体现在每个工具套件它都可以替换，即：客户端与服务端之间协商密码套件，从而更难的被攻破，例如使用不同方式的对称密码，或者公钥密码、数字签名生成方式、单向散列函数技术的替换等</p>
<h1 id="_4-rsa-简单示例"> 4. RSA 简单示例</h1>
<p>RSA 是一种公钥密码算法，我们简单的走一遍它的加密解密过程<br>
加密算法：密文 = (明文^E) mod N，其中公钥为{E,N}，即”求明文的E次方的对 N 的余数“<br>
解密算法：明文 = (密文^D) mod N，其中秘钥为{D,N}，即”求密文的D次方的对 N 的余数“<br>
例：我们已知公钥为{5,323}，私钥为{29,323}，明文为300，请写出加密和解密的过程：</p>
<blockquote>
<p>加密：密文 = 123 ^ 5 mod 323 = 225<br>
解密：明文 = 225 ^ 29 mod 323 = [[(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 4) mod 323]] mod 323 = (4 * 4 * 4 * 4 * 4 * 290) mod 323 = 123</p>
</blockquote>
<h1 id="_5-参考"> 5. 参考</h1>
<ol>
<li>SSL加密发生在哪里：<a href="https://security.stackexchange.com/questions/19681/where-does-ssl-encryption-take-place" target="_blank" rel="noopener noreferrer">https://security.stackexchange.com/questions/19681/where-does-ssl-encryption-take-place</a></li>
<li>TLS工作流程：<a href="https://blog.csdn.net/ustccw/article/details/76691248" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/ustccw/article/details/76691248</a></li>
<li>《图解密码技术》：<a href="https://book.douban.com/subject/26822106/" target="_blank" rel="noopener noreferrer">https://book.douban.com/subject/26822106/</a> 豆瓣评分 9.5</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>计算机网络常见面试题</title>
      <link>https://javaguide.cn/cs-basics/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <guid>https://javaguide.cn/cs-basics/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <source url="https://javaguide.cn/rss.xml">计算机网络常见面试题</source>
      <category>计算机基础</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="一-osi-与-tcp-ip-各层的结构与功能-都有哪些协议"> 一 OSI 与 TCP/IP 各层的结构与功能, 都有哪些协议?</h2>
<p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/五层体系结构.png" alt="五层体系结构" /></p>
<p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p>
<h3 id="_1-1-应用层"> 1.1 应用层</h3>
<p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。<strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如</strong>域名系统 DNS</strong>，支持万维网应用的 <strong>HTTP 协议</strong>，支持电子邮件的 <strong>SMTP 协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>
<p><strong>域名系统</strong></p>
<blockquote>
<p>域名系统(Domain Name System 缩写 DNS，Domain Name 被译为域名)是因特网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco 公司的域名是 www.cisco.com 等。</p>
</blockquote>
<p><strong>HTTP 协议</strong></p>
<blockquote>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p>
</blockquote>
<h3 id="_1-2-运输层"> 1.2 运输层</h3>
<p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p><strong>运输层主要使用以下两种协议:</strong></p>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）--提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）--提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>
</ol>
<p><strong>TCP 与 UDP 的对比见问题三。</strong></p>
<h3 id="_1-3-网络层"> 1.3 网络层</h3>
<p><strong>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>
<p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP 层</strong>。</p>
<h3 id="_1-4-数据链路层"> 1.4 数据链路层</h3>
<p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。
控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h3 id="_1-5-物理层"> 1.5 物理层</h3>
<p>在物理层上所传送的数据单位是比特。</p>
<p><strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p>在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定单指 TCP 和 IP 这两个具体的协议，而往往表示互联网所使用的整个 TCP/IP 协议族。</p>
<h3 id="_1-6-总结一下"> 1.6 总结一下</h3>
<p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下（图片来源于网络）。</p>
<p><img src="./images/七层体系结构图.png" alt="七层体系结构图" /></p>
<h2 id="二-tcp-三次握手和四次挥手-面试常客"> 二 TCP 三次握手和四次挥手(面试常客)</h2>
<p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p>
<h3 id="_2-1-tcp-三次握手漫画图解"> 2.1 TCP 三次握手漫画图解</h3>
<p>如下图所示，下面的两个机器人通过 3 次握手确定了对方能正确接收和发送消息(图片来源：《图解 HTTP》)。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/三次握手.png" alt="TCP三次握手" /></p>
<p><strong>简单示意图：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/三次握手2.png" alt="TCP三次握手" /></p>
<ul>
<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>
</ul>
<p><strong>详细示意图（图片来源不详）</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0c9f470819684156cfdc27c682db4def.png" alt="" /></p>
<h3 id="_2-2-为什么要三次握手"> 2.2 为什么要三次握手</h3>
<p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h3 id="_2-3-第-2-次握手传回了-ack-为什么还要传回-syn"> 2.3 第 2 次握手传回了 ACK，为什么还要传回 SYN？</h3>
<p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。”</p>
<blockquote>
<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="_2-5-为什么要四次挥手"> 2.5 为什么要四次挥手</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/TCP四次挥手.png" alt="TCP四次挥手" /></p>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li>
</ul>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>
<h2 id="三-tcp-udp-协议的区别"> 三 TCP, UDP 协议的区别</h2>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别" /></p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h2 id="四-tcp-协议如何保证可靠传输"> 四 TCP 协议如何保证可靠传输</h2>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h3 id="_4-1-arq-协议"> 4.1 ARQ 协议</h3>
<p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<h4 id="停止等待-arq-协议"> 停止等待 ARQ 协议</h4>
<p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 简单</li>
<li><strong>缺点：</strong> 信道利用率低，等待时间长</li>
</ul>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组, 接收方在规定时间内收到, 并且回复确认. 发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>
</ul>
<h4 id="连续-arq-协议"> 连续 ARQ 协议</h4>
<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
<h3 id="_4-2-滑动窗口和流量控制"> 4.2 滑动窗口和流量控制</h3>
<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="_4-3-拥塞控制"> 4.3 拥塞控制</h3>
<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li>
<li><strong>快重传与快恢复：</strong>
在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h2 id="五-在浏览器中输入-url-地址-显示主页的过程-面试常客"> 五 在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程(面试常客)</h2>
<p>百度好像最喜欢问这个问题。</p>
<blockquote>
<p>打开一个网页，整个过程会使用哪些协议？</p>
</blockquote>
<p>图解（图片来源：《图解 HTTP》）：</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url输入到展示出来的过程.jpg" style="zoom:50%; " />
<blockquote>
<p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000006879700</a></li>
</ul>
<h2 id="六-状态码"> 六 状态码</h2>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/状态码.png" alt="状态码" /></p>
<h2 id="七-各种协议与-http-协议之间的关系"> 七 各种协议与 HTTP 协议之间的关系</h2>
<p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>
<p>图片来源：《图解 HTTP》</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/各种协议与HTTP协议之间的关系.png" alt="各种协议与HTTP协议之间的关系" /></p>
<h2 id="八-http-长连接-短连接"> 八 HTTP 长连接, 短连接</h2>
<p>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</p>
<p>而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：</p>
<div><pre><code>Connection:keep-alive
</code></pre>
<div><span>1</span><br></div></div><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p>
<p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener noreferrer">《HTTP 长连接、短连接究竟是什么？》</a></p>
<h2 id="九-http-是不保存状态的协议-如何保存用户状态"> 九 HTTP 是不保存状态的协议, 如何保存用户状态?</h2>
<p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HTTP是无状态的.png" alt="HTTP是无状态协议" /></p>
<h2 id="十-cookie-的作用是什么-和-session-有什么区别"> 十 Cookie 的作用是什么? 和 Session 有什么区别？</h2>
<p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p><strong>Cookie 一般用来保存用户信息</strong> 比如 ① 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；② 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2 id="十一-http-1-0-和-http-1-1-的主要区别是什么"> 十一 HTTP 1.0 和 HTTP 1.1 的主要区别是什么?</h2>
<blockquote>
<p>这部分回答引用这篇文章 <a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?</a> 的一些内容。</p>
</blockquote>
<p>HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：</p>
<ol>
<li><strong>长连接</strong> : <strong>在 HTTP/1.0 中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于 TCP/IP 协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1 起，默认使用长连接</strong> ,默认开启 Connection： keep-alive。 <strong>HTTP/1.1 的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li><strong>错误状态响应码</strong> :在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>缓存处理</strong> :在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<h2 id="十二-uri-和-url-的区别是什么"> 十二 URI 和 URL 的区别是什么?</h2>
<ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="十三-http-和-https-的区别"> 十三 HTTP 和 HTTPS 的区别？</h2>
<ol>
<li><strong>端口</strong> ：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li>
<li><strong>安全性和资源消耗：</strong> HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。</li>
</ul>
</li>
</ol>
<h2 id="建议"> 建议</h2>
<p>非常推荐大家看一下 《图解 HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="https://blog.csdn.net/qq_16209077/article/details/52718250" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_16209077/article/details/52718250</a></li>
<li><a href="https://blog.csdn.net/zixiaomuwu/article/details/60965466" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/zixiaomuwu/article/details/60965466</a></li>
<li><a href="https://blog.csdn.net/turn__back/article/details/73743641" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/turn__back/article/details/73743641</a></li>
<li><a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/五层体系结构.png" type="image/png"/>
    </item>
    <item>
      <title>谢希仁老师的《计算机网络》内容总结</title>
      <link>https://javaguide.cn/cs-basics/network/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%80%81%E5%B8%88%E7%9A%84%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/cs-basics/network/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%80%81%E5%B8%88%E7%9A%84%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">谢希仁老师的《计算机网络》内容总结</source>
      <category>计算机基础</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文是我在大二学习计算机网络期间整理， 大部分内容都来自于谢希仁老师的《计算机网络》这本书。</p>
<p>为了内容更容易理解，我对之前的整理进行了一波重构，并配上了一些相关的示意图便于理解。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e7177b00248e30dc49bd6061093a0590.png" alt="" /></p>


<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h2 id="_1-计算机网络概述"> 1. 计算机网络概述</h2>
<h3 id="_1-1-基本术语"> 1.1. 基本术语</h3>
<ol>
<li><strong>结点 （node）</strong> ：网络中的结点可以是计算机，集线器，交换机或路由器等。</li>
<li><strong>链路（link ）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</li>
<li><strong>主机（host）</strong> ：连接在因特网上的计算机。</li>
<li><strong>ISP（Internet Service Provider）</strong> ：因特网服务提供者（提供商）。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b83f6951e3f8f4bcde5b227257d603a8.png" alt="ISP (Internet Service Provider) Definition" /></p>
<ol start="5">
<li><strong>IXP（Internet eXchange Point）</strong> ： 互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7a9568a9e94001fc110801addc8c4ec0.png" alt="IXP Traffic Levels During the Stratos Skydive — RIPE Labs" /></p>
<p style="text-align:center;font-size:13px;color:gray">https://labs.ripe.net/Members/fergalc/ixp-traffic-during-stratos-skydive</p>
<ol start="6">
<li><strong>RFC(Request For Comments)</strong> ：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。</li>
<li><strong>广域网 WAN（Wide Area Network）</strong> ：任务是通过长距离运送主机发送的数据。</li>
<li><strong>城域网 MAN（Metropolitan Area Network）</strong>：用来将多个局域网进行互连。</li>
<li><strong>局域网 LAN（Local Area Network）</strong> ： 学校或企业大多拥有多个互连的局域网。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/25a5789f8e18995c649f2f864d51e7a9.png" alt="MAN &amp; WMAN | Red de área metropolitana, Redes informaticas, Par trenzado" /></p>
<p style="text-align:center;font-size:13px;color:gray">http://conexionesmanwman.blogspot.com/</p>
<ol start="10">
<li><strong>个人区域网 PAN（Personal Area Network）</strong> ：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5c99dd6011439b1fab6cd2fece155dd5.png" alt="Advantages and disadvantages of personal area network (PAN) - IT Release" /></p>
<p style="text-align:center;font-size:13px;color:gray">https://www.itrelease.com/2018/07/advantages-and-disadvantages-of-personal-area-network-pan/</p>
<ol start="12">
<li><strong>分组（packet ）</strong> ：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</li>
<li><strong>存储转发（store and forward ）</strong> ：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201025142342169.gif#pic_center" alt="" /></p>
<ol start="14">
<li><strong>带宽（bandwidth）</strong> ：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</li>
<li><strong>吞吐量（throughput ）</strong> ：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</li>
</ol>
<h3 id="_1-2-重要知识点总结"> 1.2. 重要知识点总结</h3>
<ol>
<li><strong>计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</strong></li>
<li>小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</li>
<li>路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</li>
<li>互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</li>
<li>计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</li>
<li>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</li>
<li>按照作用范围的不同，计算机网络分为广域网 WAN，城域网 MAN，局域网 LAN，个人区域网 PAN。</li>
<li><strong>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</strong></li>
<li>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</li>
<li><strong>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</strong></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2020102514243717.png#pic_center" alt="s" /></p>
<p>下面的内容会介绍计算机网络的五层体系结构：<strong>物理层+数据链路层+网络层（网际层）+运输层+应用层</strong>。</p>
<h2 id="_2-物理层-physical-layer"> 2. 物理层（Physical Layer）</h2>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4749289d6e152bab1c8a8ccfc946a797.png" alt="物理层" /></p>
<h3 id="_2-1-基本术语"> 2.1. 基本术语</h3>
<ol>
<li><strong>数据（data）</strong> :运送消息的实体。</li>
<li><strong>信号（signal）</strong> ：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</li>
<li><strong>码元（ code）</strong> ：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</li>
<li><strong>单工（simplex ）</strong> : 只能有一个方向的通信而没有反方向的交互。</li>
<li><strong>半双工（half duplex ）</strong> ：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li><strong>全双工（full duplex）</strong> : 通信的双方可以同时发送和接收信息。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c5be4756d2d6f46cbb6d785d5b86faf1.png" alt="" /></p>
<ol start="7">
<li><strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/aef3aac72e86c1ee6ccb8a91647f656c.png" alt="" /></p>
<ol start="8">
<li><strong>奈氏准则</strong> : 在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li>
<li><strong>香农定理</strong> ：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</li>
<li><strong>基带信号（baseband signal）</strong> : 来自信源的信号。指没有经过调制的数字信号或模拟信号。</li>
<li><strong>带通（频带）信号（bandpass signal）</strong> ：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</li>
<li><strong>调制（modulation ）</strong> : 对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</li>
<li><strong>信噪比（signal-to-noise ratio ）</strong> : 指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。</li>
<li><strong>信道复用（channel multiplexing ）</strong> ：指多个用户共享同一个信道。（并不一定是同时）。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a4889adaad3314f882e2cfab5f382064.png" alt="信道复用技术" /></p>
<ol start="15">
<li><strong>比特率（bit rate ）</strong> ：单位时间（每秒）内传送的比特数。</li>
<li><strong>波特率（baud rate）</strong> ：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</li>
<li><strong>复用（multiplexing）</strong> ：共享信道的方法。</li>
<li><strong>ADSL（Asymmetric Digital Subscriber Line ）</strong> ：非对称数字用户线。</li>
<li><strong>光纤同轴混合网（HFC 网）</strong> :在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</li>
</ol>
<h3 id="_2-2-重要知识点总结"> 2.2. 重要知识点总结</h3>
<ol>
<li><strong>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</strong></li>
<li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li>
<li><strong>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电气或电磁的表现。</strong></li>
<li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li>
<li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li>
<li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li>
<li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li>
<li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li>
<li>为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</li>
</ol>
<h3 id="_2-3-补充"> 2.3. 补充</h3>
<h4 id="_2-3-1-物理层主要做啥"> 2.3.1. 物理层主要做啥？</h4>
<p>物理层主要做的事情就是 <strong>透明地传送比特流</strong>。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状和尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能的各种可能事件的出现顺序）。</p>
<p><strong>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</strong> 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p>
<h4 id="_2-3-2-几种常用的信道复用技术"> 2.3.2. 几种常用的信道复用技术</h4>
<ol>
<li><strong>频分复用(FDM)</strong> ：所有用户在同样的时间占用不同的带宽资源。</li>
<li><strong>时分复用（TDM）</strong> ：所有用户在不同的时间占用同样的频带宽度（分时不分频）。</li>
<li><strong>统计时分复用 (Statistic TDM)</strong> ：改进的时分复用，能够明显提高信道的利用率。</li>
<li><strong>码分复用(CDM)</strong> ： 用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li>
<li><strong>波分复用( WDM)</strong> ：波分复用就是光的频分复用。</li>
</ol>
<h4 id="_2-3-3-几种常用的宽带接入技术-主要是-adsl-和-fttx"> 2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx</h4>
<p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ADSL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到······）。</p>
<h2 id="_3-数据链路层-data-link-layer"> 3. 数据链路层（Data Link Layer）</h2>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/2-data-link-layer.svg" alt="数据链路层" /></p>
<h3 id="_3-1-基本术语"> 3.1. 基本术语</h3>
<ol>
<li><strong>链路（link）</strong> ：一个结点到相邻结点的一段物理链路。</li>
<li><strong>数据链路（data link）</strong> ：把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路。</li>
<li><strong>循环冗余检验 CRC（Cyclic Redundancy Check）</strong> ：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。</li>
<li><strong>帧（frame）</strong> ：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</li>
<li><strong>MTU（Maximum Transfer Uint ）</strong> ：最大传送单元。帧的数据部分的的长度上限。</li>
<li><strong>误码率 BER（Bit Error Rate ）</strong> ：在一段时间内，传输错误的比特占所传输比特总数的比率。</li>
<li><strong>PPP（Point-to-Point Protocol ）</strong> ：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路层协议。以下是 PPP 帧的示意图：
<img src="https://img-blog.csdnimg.cn/img_convert/298dbdeb16f98cec02c3954d8d95c1d6.png" alt="PPP" /></li>
<li><strong>MAC 地址（Media Access Control 或者 Medium Access Control）</strong> ：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。”</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/002b2e6e45d66e805008fafc310afef0.png" alt="ARP (Address Resolution Protocol) explained" /></p>
<ol start="9">
<li><strong>网桥（bridge）</strong> ：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</li>
<li><strong>交换机（switch ）</strong> ：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</li>
</ol>
<h3 id="_3-2-重要知识点总结"> 3.2. 重要知识点总结</h3>
<ol>
<li>链路是从一个结点到相邻结点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</li>
<li>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</li>
<li>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></li>
<li><strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</li>
<li><strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</li>
<li>PPPoE 是为宽带上网的主机使用的链路层协议</li>
<li><strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></li>
<li>计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</li>
<li>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</li>
<li>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上的各站点平等地争用以太网信道</li>
<li>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</li>
<li>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</li>
</ol>
<h3 id="_3-3-补充"> 3.3. 补充</h3>
<ol>
<li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP 协议以及 CSMA/CD 协议）的特点</li>
<li>数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong></li>
<li>以太网的 MAC 层硬件地址</li>
<li>适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合</li>
</ol>
<h2 id="_4-网络层-network-layer"> 4. 网络层（Network Layer）</h2>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fbf78bdcf3db11526ac1a234a8b98234.png" alt="网络层" /></p>
<h3 id="_4-1-基本术语"> 4.1. 基本术语</h3>
<ol>
<li><strong>虚电路（Virtual Circuit）</strong> : 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li>
<li><strong>IP（Internet Protocol ）</strong> : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有 ARP，RARP，ICMP，IGMP。</li>
<li><strong>ARP（Address Resolution Protocol）</strong> : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。</li>
<li><strong>ICMP（Internet Control Message Protocol ）</strong> ：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。</li>
<li><strong>子网掩码（subnet mask ）</strong> ：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</li>
<li><strong>CIDR（ Classless Inter-Domain Routing ）</strong>：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。</li>
<li><strong>默认路由（default route）</strong> ：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</li>
<li><strong>路由选择算法（Virtual Circuit）</strong> ：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</li>
</ol>
<h3 id="_4-2-重要知识点总结"> 4.2. 重要知识点总结</h3>
<ol>
<li><strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</strong></li>
<li>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</li>
<li>分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</li>
<li>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</li>
<li><strong>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去以广播方式发送 ARP 请求分组</strong></li>
<li>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法在 IP 地址后面加上斜线“/”，然后写上前缀所占的位数。前缀（或网络前缀）用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</li>
<li>网际控制报文协议是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</li>
<li><strong>要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议-IPv6。</strong> IPv6 所带来的变化有 ① 更大的地址空间（采用 128 位地址）② 灵活的首部格式 ③ 改进的选项 ④ 支持即插即用 ⑤ 支持资源的预分配 ⑥IPv6 的首部改为 8 字节对齐。</li>
<li><strong>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密。</strong></li>
<li>MPLS 的特点是：① 支持面向连接的服务质量 ② 支持流量工程，平衡网络负载 ③ 有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</li>
</ol>
<h2 id="_5-传输层-transport-layer"> 5. 传输层（Transport Layer）</h2>
<p><img src="https://img-blog.csdnimg.cn/img_convert/09eb87a29bed99775ef5bde5eb216971.png" alt="传输层" /></p>
<h3 id="_5-1-基本术语"> 5.1. 基本术语</h3>
<ol>
<li><strong>进程（process）</strong> ：指计算机中正在运行的程序实体。</li>
<li><strong>应用进程互相通信</strong> ：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</li>
<li><strong>传输层的复用与分用</strong> ：复用指发送方不同的进程都可以通过同一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</li>
<li><strong>TCP（Transmission Control Protocol）</strong> ：传输控制协议。</li>
<li><strong>UDP（User Datagram Protocol）</strong> ：用户数据报协议。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2bd5bf90676c338864807ade87b7bdea.png" alt="TCP和UDP" /></p>
<ol start="6">
<li><strong>端口（port）</strong> ：端口的目的是为了确认对方机器的哪个进程在与自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。</li>
<li><strong>停止等待协议（stop-and-wait）</strong> ：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</li>
<li><strong>流量控制</strong> : 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li>
<li><strong>拥塞控制</strong> ：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li>
</ol>
<h3 id="_5-2-重要知识点总结"> 5.2. 重要知识点总结</h3>
<ol>
<li><strong>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</strong></li>
<li><strong>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</strong></li>
<li>运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</li>
<li><strong>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，难以避免地增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</strong></li>
<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</li>
<li>运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</li>
<li>运输层的端口号分为服务器端使用的端口号（0˜1023 指派给熟知端口，1024˜49151 是登记端口号）和客户端暂时使用的端口号（49152˜65535）</li>
<li><strong>UDP 的主要特点是 ① 无连接 ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</strong></li>
<li><strong>TCP 的主要特点是 ① 面向连接 ② 每一条 TCP 连接只能是一对一的 ③ 提供可靠交付 ④ 提供全双工通信 ⑤ 面向字节流</strong></li>
<li><strong>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一地被通信两端的两个端点所确定。</strong></li>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</li>
<li>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li>
<li>TCP 报文段的前 20 个字节是固定的，后面有 4n 字节是根据需要增加的选项。因此，TCP 首部的最小长度是 20 字节。</li>
<li><strong>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</strong></li>
<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
<li><strong>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</strong></li>
<li><strong>TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</strong></li>
<li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li>
<li><strong>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</strong></li>
<li>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</li>
</ol>
<h3 id="_5-3-补充-重要"> 5.3. 补充（重要）</h3>
<p>以下知识点需要重点关注：</p>
<ol>
<li>端口和套接字的意义</li>
<li>UDP 和 TCP 的区别以及两者的应用场景</li>
<li>在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议</li>
<li>TCP 的滑动窗口，流量控制，拥塞控制和连接管理</li>
<li>TCP 的三次握手，四次挥手机制</li>
</ol>
<h2 id="_6-应用层-application-layer"> 6. 应用层（Application Layer）</h2>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3ff57c0632bc7f4017723b1d1b7d3a52.png" alt="应用层" /></p>
<h3 id="_6-1-基本术语"> 6.1. 基本术语</h3>
<ol>
<li><strong>域名系统（DNS）</strong> ：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6af26a3293530061785df50e70d53e07.png" alt="" /></p>
<p style="text-align:right;font-size:12px">https://www.seobility.net/en/wiki/HTTP_headers</p>
<ol start="2">
<li><strong>文件传输协议（FTP）</strong> ：FTP 是 File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念：&quot;下载&quot;（Download）和&quot;上传&quot;（Upload）。 &quot;下载&quot;文件就是从远程主机拷贝文件至自己的计算机上；&quot;上传&quot;文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3f1abf8adba4aa317eca69c489e3db23.png" alt="FTP工作过程" /></p>
<ol start="3">
<li><strong>简单文件传输协议（TFTP）</strong> ：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</li>
<li><strong>远程终端协议（TELNET）</strong> ：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</li>
<li><strong>万维网（WWW）</strong> ：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“'W3'”，英文全称为“World Wide Web”），中文名字为“万维网”，&quot;环球网&quot;等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</li>
<li><strong>万维网的大致工作工程：</strong></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/735f55501e81898aa61b8032f7dbcb73.png" alt="万维网的大致工作工程" /></p>
<ol start="7">
<li><strong>统一资源定位符（URL）</strong> ：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</li>
<li><strong>超文本传输协议（HTTP）</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。</li>
</ol>
<p>HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式。HTTP 的原理如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b273efef5f2388e26414135672b00295.png" alt="" /></p>
<ol start="10">
<li><strong>代理服务器（Proxy Server）</strong> ： 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</li>
<li><strong>简单邮件传输协议(SMTP)</strong> : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b16da4d4fea63de5fce53f54973967d7.png" alt="一个电子邮件被发送的过程" /></p>
<p style="text-align:right;font-size:12px">https://www.campaignmonitor.com/resources/knowledge-base/what-is-the-code-that-makes-bcc-or-cc-operate-in-an-email/<p>
<ol start="11">
<li><strong>搜索引擎</strong> :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/68fe865a9d87de361c45f4a42d624035.png" alt="搜索引擎" /></p>
<ol start="12">
<li><strong>垂直搜索引擎</strong> ：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</li>
<li><strong>全文索引</strong> :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</li>
<li><strong>目录索引</strong> ：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</li>
</ol>
<h3 id="_6-2-重要知识点总结"> 6.2. 重要知识点总结</h3>
<ol>
<li>文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接:控制连接和数据连接。实际用于传输文件的是数据连接。</li>
<li>万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</li>
<li>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</li>
<li>一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</li>
</ol>
<h3 id="_6-3-补充-重要"> 6.3. 补充（重要）</h3>
<p>以下知识点需要重点关注：</p>
<ol>
<li>应用层的常见协议（重点关注 HTTP 协议）</li>
<li>域名系统-从域名解析出 IP 地址</li>
<li>访问一个网站大致的过程</li>
<li>系统调用和应用编程接口概念</li>
</ol>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/img_convert/e7177b00248e30dc49bd6061093a0590.png" type="image/png"/>
    </item>
    <item>
      <title>后端程序员必备的 Linux 基础知识总结</title>
      <link>https://javaguide.cn/cs-basics/operating-system/linux-intro/</link>
      <guid>https://javaguide.cn/cs-basics/operating-system/linux-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">后端程序员必备的 Linux 基础知识总结</source>
      <category>计算机基础</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>简单介绍一下 Java 程序员必知的 Linux 的一些概念以及常见命令。</p>
<p><em>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！笔芯！</em></p>
<h2 id="_1-从认识操作系统开始"> 1. 从认识操作系统开始</h2>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200807161118901.png" alt="" /></p>
<p>正式开始 Linux 之前，简单花一点点篇幅科普一下操作系统相关的内容。</p>
<h3 id="_1-1-操作系统简介"> 1.1. 操作系统简介</h3>
<p>我通过以下四点介绍什么是操作系统：</p>
<ol>
<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>
<li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。</li>
</ol>
<blockquote>
<p>内核（Kernel）在后文中会提到。</p>
</blockquote>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png" alt="Kernel_Layout" /></p>
<h3 id="_1-2-操作系统简单分类"> 1.2. 操作系统简单分类</h3>
<h4 id="_1-2-1-windows"> 1.2.1. Windows</h4>
<p>目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。界面简单易操作，软件生态非常好。</p>
<p><em>玩玩电脑游戏还是必须要有 Windows 的，所以我现在是一台 Windows 用于玩游戏，一台 Mac 用于平时日常开发和学习使用。</em></p>
<p><img src="./images/windows.png" alt="windows" /></p>
<h4 id="_1-2-2-unix"> 1.2.2. Unix</h4>
<p>最早的多用户、多任务操作系统 。后面崛起的 Linux 在很多方面都参考了 Unix。</p>
<p>目前这款操作系统已经逐渐逐渐退出操作系统的舞台。</p>
<p><img src="./images/unix.png" alt="unix" /></p>
<h4 id="_1-2-3-linux"> 1.2.3. Linux</h4>
<p><strong>Linux 是一套免费使用、开源的类 Unix 操作系统。</strong> Linux 存在着许多不同的发行版本，但它们都使用了 <strong>Linux 内核</strong> 。</p>
<blockquote>
<p>严格来讲，Linux 这个词本身只表示 Linux 内核，在 GNU/Linux 系统中，Linux 实际就是 Linux 内核，而该系统的其余部分主要是由 GNU 工程编写和提供的程序组成。单独的 Linux 内核并不能成为一个可以正常工作的操作系统。</p>
<p><strong>很多人更倾向使用 “GNU/Linux” 一词来表达人们通常所说的 “Linux”。</strong></p>
</blockquote>
<p><img src="./images/linux.png" alt="linux" /></p>
<h4 id="_1-2-4-mac-os"> 1.2.4. Mac OS</h4>
<p>苹果自家的操作系统，编程体验和 Linux 相当，但是界面、软件生态以及用户体验各方面都要比 Linux 操作系统更好。</p>
<p><img src="./images/macos.png" alt="macos" /></p>
<h3 id="_1-3-操作系统的内核-kernel"> 1.3. 操作系统的内核（Kernel）</h3>
<p>我们先来看看维基百科对于内核的解释，我觉得总结的非常好！</p>
<blockquote>
<p><strong>内核</strong>（英语：Kernel，又称核心）在计算机科学中是一个用来管理软件发出的数据 I/O（输入与输出）要求的电脑程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。 <strong>直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。有了这个，通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源（特别是处理器及 IO 设备）。</strong></p>
<p>早期计算机系统的设计中，还没有操作系统的内核这个概念。随着计算机系统的发展，操作系统内核的概念才渐渐明晰起来了!</p>
</blockquote>
<p>简单概括两点：</p>
<ol>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</strong></li>
<li><strong>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</strong></li>
</ol>
<h3 id="_1-4-中央处理器-cpu-central-processing-unit"> 1.4. 中央处理器（CPU，Central Processing Unit）</h3>
<p>关于 CPU 简单概括三点：</p>
<ol>
<li><strong>CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑。</strong></li>
<li><strong>CPU 主要包括两个部分：控制器+运算器。</strong></li>
<li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li>
</ol>
<h3 id="_1-5-cpu-vs-kernel-内核"> 1.5. CPU vs Kernel(内核)</h3>
<p>很多人容易无法区分操作系统的内核（Kernel）和中央处理器（CPU），你可以简单从下面两点来区别：</p>
<ol>
<li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li>
<li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。</li>
</ol>
<p>下图清晰说明了应用程序、内核、CPU 这三者的关系。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png" alt="Kernel_Layout" /></p>
<h3 id="_1-6-系统调用"> 1.6. 系统调用</h3>
<p>介绍系统调用之前，我们先来了解一下用户态和系统态。</p>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li><strong>用户态(user mode)</strong> : 用户态运行的进程或可以直接读取用户程序的数据。</li>
<li><strong>系统态(kernel mode)</strong>: 可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p><strong>说了用户态和系统态之后，那么什么是系统调用呢？</strong></p>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li><strong>设备管理</strong> ：完成设备的请求或释放，以及设备启动等功能。</li>
<li><strong>文件管理</strong> ：完成文件的读、写、创建及删除等功能。</li>
<li><strong>进程控制</strong> ：完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li><strong>进程通信</strong> ：完成进程之间的消息传递或信号传递等功能。</li>
<li><strong>内存管理</strong> ：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<p>我在网上找了一个图，通过这个图可以很清晰的说明用户程序、系统调用、内核和硬件之间的关系。（<em>太难了~木有自己画</em>）</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/L181kk2Eou-compress.jpg" alt="" /></p>
<h2 id="_2-初探-linux"> 2. 初探 Linux</h2>
<h3 id="_2-1-linux-简介"> 2.1. Linux 简介</h3>
<p>我们上面已经简单了 Linux，这里只强调三点。</p>
<ul>
<li><strong>类 Unix 系统</strong> ： Linux 是一种自由、开放源码的类似 Unix 的操作系统</li>
<li><strong>Linux 本质是指 Linux 内核</strong> ： 严格来讲，Linux 这个词本身只表示 Linux 内核，单独的 Linux 内核并不能成为一个可以正常工作的操作系统。所以，就有了各种 Linux 发行版。</li>
<li><strong>Linux 之父(林纳斯·本纳第克特·托瓦兹 Linus Benedict Torvalds)</strong> ： 一个编程领域的传奇式人物，真大佬！我辈崇拜敬仰之楷模。他是 <strong>Linux 内核</strong> 的最早作者，随后发起了这个开源项目，担任 Linux 内核的首要架构师。他还发起了 Git 这个开源项目，并为主要的开发者。</li>
</ul>
<p><img src="./images/Linux之父.png" alt="Linux" /></p>
<h3 id="_2-2-linux-诞生"> 2.2. Linux 诞生</h3>
<p>1989 年，Linus Torvalds 进入芬兰陆军新地区旅，服 11 个月的国家义务兵役，军衔为少尉，主要服务于计算机部门，任务是弹道计算。服役期间，购买了安德鲁·斯图尔特·塔能鲍姆所著的教科书及 minix 源代码，开始研究操作系统。1990 年，他退伍后回到大学，开始接触 Unix。</p>
<blockquote>
<p><strong>Minix</strong> 是一个迷你版本的类 Unix 操作系统，由塔能鲍姆教授为了教学之用而创作，采用微核心设计。它启发了 Linux 内核的创作。</p>
</blockquote>
<p>1991 年，Linus Torvalds 开源了 Linux 内核。Linux 以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。</p>
<p><img src="./images/Linux-Logo.png" alt="OPINION: Make the switch to a Linux operating system | Opinion ..." /></p>
<h3 id="_2-3-常见-linux-发行版本有哪些"> 2.3. 常见 Linux 发行版本有哪些？</h3>
<p>Linus Torvalds 开源的只是 Linux 内核，我们上面也提到了操作系统内核的作用。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。</p>
<blockquote>
<p>内核主要负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</p>
</blockquote>
<p>Linux 的发行版本可以大体分为两类：</p>
<ul>
<li>商业公司维护的发行版本，以著名的 Red Hat 为代表，比较典型的有 CentOS 。</li>
<li>社区组织维护的发行版本，以 Debian 为代表，比较典型的有 Ubuntu、Debian。</li>
</ul>
<p>对于初学者学习 Linux ,推荐选择 CentOS 。</p>
<h2 id="_3-linux-文件系统概览"> 3. Linux 文件系统概览</h2>
<h3 id="_3-1-linux-文件系统简介"> 3.1. Linux 文件系统简介</h3>
<p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong> 也就是说在 Linux 系统中有一个重要的概念：<strong>一切都是文件</strong>。</p>
<p>其实这是 UNIX 哲学的一个体现，在 UNIX 系统中，把一切资源都看作是文件，Linux 的文件系统也是借鉴 UNIX 文件系统而来。</p>
<h3 id="_3-2-inode-介绍"> 3.2. inode 介绍</h3>
<p><strong>inode 是 linux/unix 文件系统的基础。那么，inode 是什么?有什么作用呢?</strong></p>
<p>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。</p>
<p>虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 <strong>元信息 metadata</strong> ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 <strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 每个文件都有一个 inode，存储文件的元信息。</p>
<p>可以使用 <code>stat</code> 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux/Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p>
<p>简单来说：inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p>
<p>简单总结一下：</p>
<ul>
<li><strong>inode</strong> ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li>
<li><strong>block</strong> ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li>
</ul>
<p><img src="./images/文件inode信息.png" alt="文件inode信息" /></p>
<h3 id="_3-3-linux-文件类型"> 3.3. Linux 文件类型</h3>
<p>Linux 支持很多文件类型，其中非常重要的文件类型有: <strong>普通文件</strong>，<strong>目录文件</strong>，<strong>链接文件</strong>，<strong>设备文件</strong>，<strong>管道文件</strong>，<strong>Socket 套接字文件</strong>等。</p>
<ul>
<li><strong>普通文件（-）</strong> ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li>
<li><strong>目录文件（d，directory file）</strong> ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li>
<li><strong>符号链接文件（l，symbolic link）</strong> ：保留了指向文件的地址而不是文件本身。</li>
<li><strong>字符设备（c，char）</strong> ：用来访问字符设备比如键盘。</li>
<li><strong>设备文件（b，block）</strong> ： 用来访问块设备比如硬盘、软盘。</li>
<li><strong>管道文件(p,pipe)</strong> : 一种特殊类型的文件，用于进程之间的通信。</li>
<li><strong>套接字(s,socket)</strong> ：用于进程间的网络通信，也可以用于本机之间的非网络通信。</li>
</ul>
<h3 id="_3-4-linux-目录树"> 3.4. Linux 目录树</h3>
<p>所有可操作的计算机资源都存在于目录树这个结构中，对计算资源的访问，可以看做是对这棵目录树的访问。</p>
<p><strong>Linux 的目录结构如下：</strong></p>
<p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：
<img src="./images/Linux目录树.png" alt="Linux的目录结构" /></p>
<p><strong>常见目录说明：</strong></p>
<ul>
<li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；</li>
<li><strong>/etc：</strong> 存放系统管理和配置文件；</li>
<li><strong>/home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示；</li>
<li><strong>/usr ：</strong> 用于存放系统应用程序；</li>
<li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li>
<li><strong>/proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>
<li><strong>/root：</strong> 超级用户（系统管理员）的主目录（特权阶级^o^）；</li>
<li><strong>/sbin:</strong> 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li>
<li><strong>/dev：</strong> 用于存放设备文件；</li>
<li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>
<li><strong>/boot：</strong> 存放用于系统引导时使用的各种文件；</li>
<li><strong>/lib ：</strong> 存放着和系统运行相关的库文件 ；</li>
<li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li>
<li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>
<li><strong>/lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li>
</ul>
<h2 id="_4-linux-基本命令"> 4. Linux 基本命令</h2>
<p>下面只是给出了一些比较常用的命令。推荐一个 Linux 命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。</p>
<p>Linux 命令大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener noreferrer">http://man.linuxde.net/</a></p>
<h3 id="_4-1-目录切换命令"> 4.1. 目录切换命令</h3>
<ul>
<li><strong><code>cd usr</code>：</strong> 切换到该目录下 usr 目录</li>
<li><strong><code>cd ..（或cd../）</code>：</strong> 切换到上一层目录</li>
<li><strong><code>cd /</code>：</strong> 切换到系统根目录</li>
<li><strong><code>cd ~</code>：</strong> 切换到用户主目录</li>
<li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li>
</ul>
<h3 id="_4-2-目录的操作命令-增删改查"> 4.2. 目录的操作命令(增删改查)</h3>
<ul>
<li><strong><code>mkdir 目录名称</code>：</strong> 增加目录。</li>
<li><strong><code>ls/ll</code></strong>（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息。</li>
<li><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）。示例：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；② 在<code>/home</code>目录下查找以.txt 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code> ；③ 当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</li>
<li><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）。注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。</li>
<li><strong><code>mv 目录名称 目录的新位置</code>：</strong> 移动目录的位置---剪切（改）。注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。</li>
<li><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r 代表递归拷贝 。注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r 递归。</li>
<li><strong><code>rm [-rf] 目录</code> :</strong> 删除目录（删）。注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录/文件/压缩包。</li>
</ul>
<h3 id="_4-3-文件的操作命令-增删改查"> 4.3. 文件的操作命令(增删改查)</h3>
<ul>
<li><strong><code>touch 文件名称</code>:</strong> 文件的创建（增）。</li>
<li><strong><code>cat/more/less/tail 文件名称</code></strong> ：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 。</li>
<li><strong><code>vim 文件</code>：</strong> 修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤： <code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</li>
<li><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）。</li>
</ul>
<h3 id="_4-4-压缩文件的操作命令"> 4.4. 压缩文件的操作命令</h3>
<p><strong>1）打包并压缩文件：</strong></p>
<p>Linux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。
命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> ，其中：</p>
<ul>
<li>z：调用 gzip 压缩命令进行压缩</li>
<li>c：打包文件</li>
<li>v：显示运行过程</li>
<li>f：指定文件名</li>
</ul>
<p>比如：假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：<strong><code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code></strong></p>
<p><strong>2）解压压缩包：</strong></p>
<p>命令：<code>tar [-xvf] 压缩文件</code></p>
<p>其中：x：代表解压</p>
<p>示例：</p>
<ul>
<li>将 /test 下的 test.tar.gz 解压到当前目录下可以使用命令：<strong><code>tar -xvf test.tar.gz</code></strong></li>
<li>将 /test 下的 test.tar.gz 解压到根目录/usr 下:<strong><code>tar -xvf test.tar.gz -C /usr</code></strong>（- C 代表指定解压的位置）</li>
</ul>
<h3 id="_4-5-linux-的权限命令"> 4.5. Linux 的权限命令</h3>
<p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。</p>
<p>通过 <strong><code>ls -l</code></strong> 命令我们可以 查看某个目录下的文件或目录的权限</p>
<p>示例：在随意某个目录下<code>ls -l</code></p>
<p><img src="./images/Linux权限命令.png" alt="" /></p>
<p>第一列的内容的信息解释如下：</p>
<p><img src="./images/Linux权限解读.png" alt="" /></p>
<blockquote>
<p>下面将详细讲解文件的类型、Linux 中权限以及文件有所有者、所在组、其它组具体是什么？</p>
</blockquote>
<p><strong>文件的类型：</strong></p>
<ul>
<li>d： 代表目录</li>
<li>-： 代表文件</li>
<li>l： 代表软链接（可以认为是 window 中的快捷方式）</li>
</ul>
<p><strong>Linux 中权限分为以下几种：</strong></p>
<ul>
<li>r：代表权限是可读，r 也可以用数字 4 表示</li>
<li>w：代表权限是可写，w 也可以用数字 2 表示</li>
<li>x：代表权限是可执行，x 也可以用数字 1 表示</li>
</ul>
<p><strong>文件和目录权限的区别：</strong></p>
<p>对文件和目录而言，读写执行表示不同的意义。</p>
<p>对于文件：</p>
<table>
<thead>
<tr>
<th style="text-align:left">权限名称</th>
<th style="text-align:right">可执行操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:right">可以使用 cat 查看文件的内容</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:right">可以修改文件的内容</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:right">可以将其运行为二进制文件</td>
</tr>
</tbody>
</table>
<p>对于目录：</p>
<table>
<thead>
<tr>
<th style="text-align:left">权限名称</th>
<th style="text-align:right">可执行操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:right">可以查看目录下列表</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:right">可以创建和删除目录下文件</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:right">可以使用 cd 进入目录</td>
</tr>
</tbody>
</table>
<p>需要注意的是： <strong>超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。</strong></p>
<p><strong>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</strong></p>
<ul>
<li><strong>所有者(u)</strong> ：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 <code>ls ‐ahl</code> 命令可以看到文件的所有者 也可以使用 chown 用户名 文件名来修改文件的所有者 。</li>
<li><strong>文件所在组(g)</strong> ：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。</li>
<li><strong>其它组(o)</strong> ：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li>
</ul>
<blockquote>
<p>我们再来看看如何修改文件/目录的权限。</p>
</blockquote>
<p><strong>修改文件/目录的权限的命令：<code>chmod</code></strong></p>
<p>示例：修改/test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。</p>
<p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong> 或者 <strong><code>chmod 764 aaa.txt</code></strong></p>
<p><img src="./images/修改文件权限.png" alt="" /></p>
<p><strong>补充一个比较常用的东西:</strong></p>
<p>假如我们装了一个 zookeeper，我们每次开机到要求其自动启动该怎么办？</p>
<ol>
<li>新建一个脚本 zookeeper</li>
<li>为新建的脚本 zookeeper 添加可执行权限，命令是:<code>chmod +x zookeeper</code></li>
<li>把 zookeeper 这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add zookeeper</code></li>
<li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li>
</ol>
<h3 id="_4-6-linux-用户管理"> 4.6. Linux 用户管理</h3>
<p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p><strong>Linux 用户管理相关命令:</strong></p>
<ul>
<li><code>useradd 选项 用户名</code>:添加用户账号</li>
<li><code>userdel 选项 用户名</code>:删除用户帐号</li>
<li><code>usermod 选项 用户名</code>:修改帐号</li>
<li><code>passwd 用户名</code>:更改或创建用户的密码</li>
<li><code>passwd -S 用户名</code> :显示用户账号密码信息</li>
<li><code>passwd -d 用户名</code>: 清除用户密码</li>
</ul>
<p><code>useradd</code> 命令用于 Linux 中创建的新的系统用户。<code>useradd</code>可用来建立用户帐号。帐号建好之后，再用<code>passwd</code>设定帐号的密码．而可用<code>userdel</code>删除帐号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</p>
<p><code>passwd</code>命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p>
<h3 id="_4-7-linux-系统用户组的管理"> 4.7. Linux 系统用户组的管理</h3>
<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p>
<p><strong>Linux 系统用户组的管理相关命令:</strong></p>
<ul>
<li><code>groupadd 选项 用户组</code> :增加一个新的用户组</li>
<li><code>groupdel 用户组</code>:要删除一个已有的用户组</li>
<li><code>groupmod 选项 用户组</code> : 修改用户组的属性</li>
</ul>
<h3 id="_4-8-其他常用命令"> 4.8. 其他常用命令</h3>
<ul>
<li>
<p><strong><code>pwd</code>：</strong> 显示当前所在位置</p>
</li>
<li>
<p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>
</li>
<li>
<p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，--color 代表高亮显示</p>
</li>
<li>
<p><strong><code>ps -ef</code>/<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong><code>ps aux|grep redis</code></strong> （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</p>
<p>注意：如果直接用 ps（（Process Status））命令，会显示所有进程的状态，通常结合 grep 命令查看某进程的状态。</p>
</li>
<li>
<p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p>
<p>先用 ps 查找进程，然后用 kill 杀掉</p>
</li>
<li>
<p><strong>网络通信命令：</strong></p>
<ul>
<li>查看当前系统的网卡信息：ifconfig</li>
<li>查看与某台机器的连接情况：ping</li>
<li>查看当前系统的端口使用：netstat -an</li>
</ul>
</li>
<li>
<p><strong>net-tools 和 iproute2 ：</strong>
<code>net-tools</code>起源于 BSD 的 TCP/IP 工具箱，后来成为老版本 LinuxLinux 中配置网络功能的工具。但自 2001 年起，Linux 社区已经对其停止维护。同时，一些 Linux 发行版比如 Arch Linux 和 CentOS/RHEL 7 则已经完全抛弃了 net-tools，只支持<code>iproute2</code>。linux ip 命令类似于 ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a href="https://linoxide.com/linux-command/use-ip-command-linux" target="_blank" rel="noopener noreferrer">如何在 Linux 中使用 IP 命令和示例</a></p>
</li>
<li>
<p><strong><code>shutdown</code>：</strong> <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定 5 分钟后关机，同时送出警告信息给登入用户。</p>
</li>
<li>
<p><strong><code>reboot</code>：</strong> <strong><code>reboot</code>：</strong> 重开机。<strong><code>reboot -w</code>：</strong> 做个重开机的模拟（只有纪录并不会真的重开机）。</p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200807161118901.png" type="image/png"/>
    </item>
    <item>
      <title>操作系统常见面试题总结</title>
      <link>https://javaguide.cn/cs-basics/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98&amp;%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/cs-basics/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98&amp;%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">操作系统常见面试题总结</source>
      <category>计算机基础</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>大家好，我是 Guide 哥！</p>
<p>很多读者抱怨计算操作系统的知识点比较繁杂，自己也没有多少耐心去看，但是面试的时候又经常会遇到。所以，我带着我整理好的操作系统的常见问题来啦！这篇文章总结了一些我觉得比较重要的操作系统相关的问题比如<strong>进程管理</strong>、<strong>内存管理</strong>、<strong>虚拟内存</strong>等等。</p>
<p>文章形式通过大部分比较喜欢的面试官和求职者之间的对话形式展开。另外，Guide哥 也只是在大学的时候学习过操作系统，不过基本都忘了，为了写这篇文章这段时间看了很多相关的书籍和博客。如果文中有任何需要补充和完善的地方，你都可以在 issue 中指出！</p>
<p>这篇文章只是对一些操作系统比较重要概念的一个概览，深入学习的话，建议大家还是老老实实地去看书。另外， 这篇文章的很多内容参考了《现代操作系统》第三版这本书，非常感谢。</p>
<p>开始本文的内容之前，我们先聊聊为什么要学习操作系统。</p>
<ul>
<li><strong>从对个人能力方面提升来说</strong>  ：操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。比如说我们开发的系统使用的缓存（比如 Redis）和操作系统的高速缓存就很像。CPU 中的高速缓存有很多种，不过大部分都是为了解决 CPU 处理速度和内存处理速度不对等的问题。我们还可以把内存看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。同样地，我们使用的 Redis 缓存就是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。高速缓存一般会按照局部性原理（2-8 原则）根据相应的淘汰算法保证缓存中的数据是经常会被访问的。我们平常使用的 Redis 缓存很多时候也会按照 2-8 原则去做，很多淘汰算法都和操作系统中的类似。既说了 2-8 原则，那就不得不提命中率了，这是所有缓存概念都通用的。简单来说也就是你要访问的数据有多少能直接在缓存中直接找到。命中率高的话，一般表明你的缓存设计比较合理，系统处理速度也相对较快。</li>
<li><strong>从面试角度来说</strong> ：尤其是校招，对于操作系统方面知识的考察是非常非常多的。</li>
</ul>
<p><strong>简单来说，学习操作系统能够提高自己思考的深度以及对技术的理解力，并且，操作系统方面的知识也是面试必备。</strong></p>
<p>关于如何学习操作系统，可以看这篇回答：<a href="https://www.zhihu.com/question/270998611/answer/1640198217" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/270998611/answer/1640198217</a>。</p>
<h2 id="一-操作系统基础"> 一 操作系统基础</h2>
<p>面试官顶着蓬松的假发向我走来，只见他一手拿着厚重的 Thinkpad ，一手提着他那淡黄的长裙。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/ceeb653ely1gd8wj5evc4j20i00n0dh0.jpg" height="300"></img></p>
<h3 id="_1-1-什么是操作系统"> 1.1 什么是操作系统？</h3>
<p>👨‍💻<strong>面试官</strong> ： 先来个简单问题吧！<strong>什么是操作系统？</strong></p>
<p>🙋 <strong>我</strong> ：我通过以下四点向您介绍一下什么是操作系统吧！</p>
<ol>
<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>
<li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong>  举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ol>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png" alt="Kernel_Layout" /></p>
<h3 id="_1-2-系统调用"> 1.2 系统调用</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>什么是系统调用呢？</strong> 能不能详细介绍一下。</p>
<p>🙋 <strong>我</strong> ：介绍系统调用之前，我们先来了解一下用户态和系统态。</p>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li>
<li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>说了用户态和系统态之后，那么什么是系统调用呢？</p>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h2 id="二-进程和线程"> 二 进程和线程</h2>
<h3 id="_2-1-进程和线程的区别"> 2.1 进程和线程的区别</h3>
<p>👨‍💻<strong>面试官</strong>: 好的！我明白了！那你再说一下： <strong>进程和线程的区别</strong>。</p>
<p>🙋 <strong>我：</strong> 好的！ 下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！</p>
<blockquote>
<p>如果你对 Java 内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F" target="_blank" rel="noopener noreferrer">《可能是把 Java 内存区域讲的最清楚的一篇文章》</a></p>
</blockquote>
<p><img src="https://oscimg.oschina.net/oscnet/up-cd8ac705f6f004c01e0a1312f1599430ba5.png" alt="" /></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的</strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h3 id="_2-2-进程有哪几种状态"> 2.2 进程有哪几种状态?</h3>
<p>👨‍💻<strong>面试官</strong> ： 那你再说说<strong>进程有哪几种状态?</strong></p>
<p>🙋 <strong>我</strong> ：我们一般把进程大致分为 5 种状态，这一点和<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md#6-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81" target="_blank" rel="noopener noreferrer">线程</a>很像！</p>
<ul>
<li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li>
<li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li>
<li><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
<li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<blockquote>
<p>订正：下图中 running 状态被 interrupt 向 ready 状态转换的箭头方向反了。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/d38202593012b457debbcd74994c6292.png" alt="process-state" /></p>
<h3 id="_2-3-进程间的通信方式"> 2.3 进程间的通信方式</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>进程间的通信常见的的有哪几种方式呢?</strong></p>
<p>🙋 <strong>我</strong> ：大概有 7 种常见的进程间的通信方式。</p>
<blockquote>
<p>下面这部分总结参考了:<a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener noreferrer">《进程间通信 IPC (InterProcess Communication)》</a> 这篇文章，推荐阅读，总结的非常不错。</p>
</blockquote>
<ol>
<li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循<strong>先进先出(first in first out)</strong>。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</strong></li>
<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h3 id="_2-4-线程间的同步的方式"> 2.4 线程间的同步的方式</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>那线程间的同步的方式有哪些呢?</strong></p>
<p>🙋 <strong>我</strong> ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p>
<ol>
<li><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li>
<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操</li>
</ol>
<h3 id="_2-5-进程的调度算法"> 2.5 进程的调度算法</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>你知道操作系统中进程的调度算法有哪些吗?</strong></p>
<p>🙋 <strong>我</strong> ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！</p>
<p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p>
<ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h3 id="_2-6-什么是死锁"> 2.6 什么是死锁</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>你知道什么是死锁吗?</strong></p>
<p>🙋 <strong>我</strong> ：多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况成为<strong>死锁</strong>。</p>
<h3 id="_2-7-死锁的四个条件"> 2.7 死锁的四个条件</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>产生死锁的四个必要条件是什么?</strong></p>
<p>🙋 <strong>我</strong> ：如果系统中以下四个条件同时成立，那么就能引起死锁：</p>
<ul>
<li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li>
<li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li>
<li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>
<li><strong>循环等待</strong>：有一组等待进程 <code>{P0, P1,..., Pn}</code>，  <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，......，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li>
</ul>
<p>注意，只有四个条件同时成立时，死锁才会出现。</p>
<h2 id="三-操作系统内存管理基础"> 三 操作系统内存管理基础</h2>
<h3 id="_3-1-内存管理介绍"> 3.1 内存管理介绍</h3>
<p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理主要是做什么？</strong></p>
<p>🙋 <strong>我：</strong> 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</p>
<h3 id="_3-2-常见的几种内存管理机制"> 3.2 常见的几种内存管理机制</h3>
<p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理机制了解吗？内存管理有哪几种方式?</strong></p>
<p>🙋 <strong>我：</strong> 这个在学习操作系统的时候有了解过。</p>
<p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p>
<ol>
<li><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li>
<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>
<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
</ol>
<p>👨‍💻<strong>面试官</strong> ： 回答的还不错！不过漏掉了一个很重要的 <strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p>
<p>🙋 <strong>我</strong> ：谢谢面试官！刚刚把这个给忘记了～</p>
<h3 id="_3-3-快表和多级页表"> 3.3 快表和多级页表</h3>
<p>👨‍💻<strong>面试官</strong> ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！</p>
<p>🙋 <strong>我</strong> ：在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题。</li>
</ol>
<h4 id="快表"> 快表</h4>
<p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<p>看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p>
<h4 id="多级页表"> 多级页表</h4>
<p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章</p>
<ul>
<li>多级页表如何节约内存：<a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html" target="_blank" rel="noopener noreferrer">https://www.polarxiong.com/archives/多级页表如何节约内存.html</a></li>
</ul>
<h4 id="总结"> 总结</h4>
<p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。</p>
<h3 id="_3-4-分页机制和分段机制的共同点和区别"> 3.4 分页机制和分段机制的共同点和区别</h3>
<p>👨‍💻<strong>面试官</strong> ： <strong>分页机制和分段机制有哪些共同点和区别呢？</strong></p>
<p>🙋 <strong>我</strong> ：</p>
<ol>
<li><strong>共同点</strong> ：
<ul>
<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li><strong>区别</strong> ：
<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</li>
</ol>
<h3 id="_3-5-逻辑-虚拟-地址和物理地址"> 3.5 逻辑(虚拟)地址和物理地址</h3>
<p>👨‍💻<strong>面试官</strong> ：你刚刚还提到了<strong>逻辑地址和物理地址</strong>这两个概念，我不太清楚，你能为我解释一下不？</p>
<p>🙋 <strong>我：</strong> em...好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<h3 id="_3-6-cpu-寻址了解吗-为什么需要虚拟地址空间"> 3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>CPU 寻址了解吗?为什么需要虚拟地址空间?</strong></p>
<p>🙋 <strong>我</strong> ：这部分我真不清楚！</p>
<p>于是面试完之后我默默去查阅了相关文档！留下了没有技术的泪水。。。</p>
<blockquote>
<p>这部分内容参考了 Microsoft 官网的介绍，地址：<a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=MSDN" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=MSDN</a></p>
</blockquote>
<p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。如下图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/2b27dac8cc647f8aac989da2d1166db2.png" alt="MMU_principle_updated" /></p>
<p><strong>为什么要有虚拟地址空间呢？</strong></p>
<p>先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li>
<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>
</ol>
<p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p>
<p>通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
<h2 id="四-虚拟内存"> 四 虚拟内存</h2>
<h3 id="_4-1-什么是虚拟内存-virtual-memory"> 4.1 什么是虚拟内存(Virtual Memory)?</h3>
<p>👨‍💻<strong>面试官</strong> ：再问你一个常识性的问题！<strong>什么是虚拟内存(Virtual Memory)?</strong></p>
<p>🙋 <strong>我</strong> ：这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。<strong>为什么可以这样呢？</strong> 正是因为 <strong>虚拟内存</strong> 的存在，通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p>
<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong>。推荐阅读：<a href="https://juejin.im/post/59f8691b51882534af254317" target="_blank" rel="noopener noreferrer">《虚拟内存的那点事儿》</a></p>
<p>维基百科中有几句话是这样介绍虚拟内存的。</p>
<blockquote>
<p><strong>虚拟内存</strong> 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/虚拟内存</a></p>
</blockquote>
<h3 id="_4-2-局部性原理"> 4.2 局部性原理</h3>
<p>👨‍💻<strong>面试官</strong> ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的<strong>局部性原理</strong>。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。</p>
<p>🙋 <strong>我</strong> ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p>
<blockquote>
<p>以下内容摘自《计算机操作系统教程》 第 4 章存储器管理。</p>
</blockquote>
<p>早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。</p>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h3 id="_4-3-虚拟存储器"> 4.3 虚拟存储器</h3>
<blockquote>
<p><strong>勘误：虚拟存储器又叫做虚拟内存，都是 Virtual Memory 的翻译，属于同一个概念。</strong></p>
</blockquote>
<p>👨‍💻<strong>面试官</strong> ：<s>都说了虚拟内存了。你再讲讲<strong>虚拟存储器</strong>把！</s></p>
<p>🙋 <strong>我</strong> ：</p>
<blockquote>
<p>这部分内容来自：<a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html" target="_blank" rel="noopener noreferrer">王道考研操作系统知识点整理</a>。</p>
</blockquote>
<p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。</p>
<p>实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。</p>
<h3 id="_4-4-虚拟内存的技术实现"> 4.4 虚拟内存的技术实现</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>虚拟内存技术的实现呢？</strong></p>
<p>🙋 <strong>我</strong> ：<strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<p><strong>这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？</strong></p>
<p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p>
<p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>
<p>不管是上面那种实现方式，我们一般都需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>
</ol>
<h3 id="_4-5-页面置换算法"> 4.5 页面置换算法</h3>
<p>👨‍💻<strong>面试官</strong> ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 <strong>页面置换算法的作用?常见的页面置换算法有哪些?</strong></p>
<p>🙋 <strong>我</strong> ：</p>
<blockquote>
<p>这个题目经常作为笔试题出现，网上已经给出了很不错的回答，我这里只是总结整理了一下。</p>
</blockquote>
<p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p>
<blockquote>
<p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
</blockquote>
<p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>
<ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> :  该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>
<h2 id="reference"> Reference</h2>
<ul>
<li>《计算机操作系统—汤小丹》第四版</li>
<li><a href="https://book.douban.com/subject/1230413/" target="_blank" rel="noopener noreferrer">《深入理解计算机系统》</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/输入输出内存管理单元</a></li>
<li><a href="https://baike.baidu.com/item/%E5%BF%AB%E8%A1%A8/19781679" target="_blank" rel="noopener noreferrer">https://baike.baidu.com/item/快表/19781679</a></li>
<li>https://www.jianshu.com/p/1d47ed0b46d5</li>
<li><a href="https://www.studytonight.com/operating-system" target="_blank" rel="noopener noreferrer">https://www.studytonight.com/operating-system</a></li>
<li><a href="https://www.geeksforgeeks.org/interprocess-communication-methods/" target="_blank" rel="noopener noreferrer">https://www.geeksforgeeks.org/interprocess-communication-methods/</a></li>
<li><a href="https://juejin.im/post/59f8691b51882534af254317" target="_blank" rel="noopener noreferrer">https://juejin.im/post/59f8691b51882534af254317</a></li>
<li>王道考研操作系统知识点整理： https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png" type="image/png"/>
    </item>
    <item>
      <title>Shell 编程入门</title>
      <link>https://javaguide.cn/cs-basics/operating-system/shell-intro/</link>
      <guid>https://javaguide.cn/cs-basics/operating-system/shell-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">Shell 编程入门</source>
      <category>计算机基础</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="shell-编程入门"> Shell 编程入门</h1>
<h2 id="走进-shell-编程的大门"> 走进 Shell 编程的大门</h2>
<h3 id="为什么要学shell"> 为什么要学Shell？</h3>
<p>学一个东西，我们大部分情况都是往实用性方向着想。从工作角度来讲，学习 Shell 是为了提高我们自己工作效率，提高产出，让我们在更少的时间完成更多的事情。</p>
<p>很多人会说 Shell 编程属于运维方面的知识了，应该是运维人员来做，我们做后端开发的没必要学。我觉得这种说法大错特错，相比于专门做Linux运维的人员来说，我们对 Shell 编程掌握程度的要求要比他们低，但是shell编程也是我们必须要掌握的！</p>
<p>目前Linux系统下最流行的运维自动化语言就是Shell和Python了。</p>
<p>两者之间，Shell几乎是IT企业必须使用的运维自动化编程语言，特别是在运维工作中的服务监控、业务快速部署、服务启动停止、数据备份及处理、日志分析等环节里，shell是不可缺的。Python 更适合处理复杂的业务逻辑，以及开发复杂的运维软件工具，实现通过web访问等。Shell是一个命令解释器，解释执行用户所输入的命令和程序。一输入命令，就立即回应的交互的对话方式。</p>
<p>另外，了解 shell 编程也是大部分互联网公司招聘后端开发人员的要求。下图是我截取的一些知名互联网公司对于 Shell 编程的要求。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-16/60190220.jpg" alt="大型互联网公司对于shell编程技能的要求" /></p>
<h3 id="什么是-shell"> 什么是 Shell？</h3>
<p>简单来说“Shell编程就是对一堆Linux命令的逻辑化处理”。</p>
<p>W3Cschool 上的一篇文章是这样介绍 Shell的，如下图所示。
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-26/19456505.jpg" alt="什么是 Shell？" /></p>
<h3 id="shell-编程的-hello-world"> Shell 编程的 Hello World</h3>
<p>学习任何一门编程语言第一件事就是输出HelloWorld了！下面我会从新建文件到shell代码编写来说下Shell 编程如何输出Hello World。</p>
<p>(1)新建一个文件 helloworld.sh :<code>touch helloworld.sh</code>，扩展名为 sh（sh代表Shell）（扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了）</p>
<p>(2) 使脚本具有执行权限：<code>chmod +x helloworld.sh</code></p>
<p>(3) 使用 vim 命令修改helloworld.sh文件：<code>vim helloworld.sh</code>(vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入:wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）)</p>
<p>helloworld.sh 内容如下：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>#第一个shell小程序,echo 是linux中的输出命令。</span>
<span>echo</span>  <span>"helloworld!"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>shell中 # 符号表示注释。<strong>shell 的第一行比较特殊，一般都会以#!开始来指定使用的 shell 类型。在linux中，除了bash shell以外，还有很多版本的shell， 例如zsh、dash等等...不过bash shell还是我们使用最多的。</strong></p>
<p>(4) 运行脚本:<code>./helloworld.sh</code> 。（注意，一定要写成 <code>./helloworld.sh</code> ，而不是 <code>helloworld.sh</code> ，运行其它二进制的程序也一样，直接写 <code>helloworld.sh</code> ，linux 系统会去 PATH 里寻找有没有叫 helloworld.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <code>helloworld.sh</code> 是会找不到命令的，要用<code>./helloworld.sh</code> 告诉系统说，就在当前目录找。）</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-16/55296212.jpg" alt="shell 编程Hello World" /></p>
<h2 id="shell-变量"> Shell 变量</h2>
<h3 id="shell-编程中的变量介绍"> Shell 编程中的变量介绍</h3>
<p><strong>Shell编程中一般分为三种变量：</strong></p>
<ol>
<li><strong>我们自己定义的变量（自定义变量）:</strong> 仅在当前 Shell 实例中有效，其他 Shell 启动的程序不能访问局部变量。</li>
<li><strong>Linux已定义的环境变量</strong>（环境变量， 例如：<code>PATH</code>, ​<code>HOME</code> 等..., 这类变量我们可以直接使用），使用 <code>env</code> 命令可以查看所有的环境变量，而set命令既可以查看环境变量也可以查看自定义变量。</li>
<li><strong>Shell变量</strong> ：Shell变量是由 Shell 程序设置的特殊变量。Shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 Shell 的正常运行</li>
</ol>
<p><strong>常用的环境变量:</strong></p>
<blockquote>
<p>PATH 决定了shell将到哪些目录中寻找命令或程序<br>
HOME 当前用户主目录<br>
HISTSIZE　历史记录数<br>
LOGNAME 当前用户的登录名<br>
HOSTNAME　指主机的名称<br>
SHELL 当前用户Shell类型<br>
LANGUAGE 　语言相关的环境变量，多语言可以修改此环境变量<br>
MAIL　当前用户的邮件存放目录<br>
PS1　基本提示符，对于root用户是#，对于普通用户是$</p>
</blockquote>
<p><strong>使用 Linux 已定义的环境变量：</strong></p>
<p>比如我们要看当前用户目录可以使用：<code>echo $HOME</code>命令；如果我们要看当前用户Shell类型 可以使用<code>echo $SHELL</code>命令。可以看出，使用方法非常简单。</p>
<p><strong>使用自己定义的变量：</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span>#自定义变量hello</span>
<span>hello</span><span>=</span><span>"hello world"</span>
<span>echo</span> <span>$hello</span>
<span>echo</span>  <span>"helloworld!"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-17/19835037.jpg" alt="使用自己定义的变量" /></p>
<p><strong>Shell 编程中的变量名的命名的注意事项：</strong></p>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头，但是可以使用下划线（_）开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul>
<h3 id="shell-字符串入门"> Shell 字符串入门</h3>
<p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号。这点和Java中有所不同。</p>
<p><strong>单引号字符串：</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span>name</span><span>=</span><span>'SnailClimb'</span>
<span>hello</span><span>=</span><span>'Hello, I  am '</span><span>$name</span><span>'!'</span>
<span>echo</span> <span>$hello</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>输出内容：</p>
<div><pre><code>Hello, I am SnailClimb!
</code></pre>
<div><span>1</span><br></div></div><p><strong>双引号字符串：</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span>name</span><span>=</span><span>'SnailClimb'</span>
<span>hello</span><span>=</span><span>"Hello, I  am "</span><span>$name</span><span>"!"</span>
<span>echo</span> <span>$hello</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>输出内容：</p>
<div><pre><code>Hello, I am SnailClimb!
</code></pre>
<div><span>1</span><br></div></div><h3 id="shell-字符串常见操作"> Shell 字符串常见操作</h3>
<p><strong>拼接字符串：</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span>name</span><span>=</span><span>"SnailClimb"</span>
<span># 使用双引号拼接</span>
<span>greeting</span><span>=</span><span>"hello, "</span><span>$name</span><span>" !"</span>
<span>greeting_1</span><span>=</span><span>"hello, <span>${name}</span> !"</span>
<span>echo</span> <span>$greeting</span>  <span>$greeting_1</span>
<span># 使用单引号拼接</span>
<span>greeting_2</span><span>=</span><span>'hello, '</span><span>$name</span><span>' !'</span>
<span>greeting_3</span><span>=</span><span>'hello, ${name} !'</span>
<span>echo</span> <span>$greeting_2</span>  <span>$greeting_3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>输出结果：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-17/51148933.jpg" alt="输出结果" /></p>
<p><strong>获取字符串长度：</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span>#获取字符串长度</span>
<span>name</span><span>=</span><span>"SnailClimb"</span>
<span># 第一种方式</span>
<span>echo</span> <span>${<span>#</span>name}</span> <span>#输出 10</span>
<span># 第二种方式</span>
<span>expr</span> length <span>"<span>$name</span>"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>输出结果:</p>
<div><pre><code>10
10
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>使用 expr 命令时，表达式中的运算符左右必须包含空格，如果不包含空格，将会输出表达式本身:</p>
<div><pre><code><span>expr</span> <span>5</span>+6    // 直接输出 <span>5</span>+6
<span>expr</span> <span>5</span> + <span>6</span>       // 输出 <span>11</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>对于某些运算符，还需要我们使用符号<code>\</code>进行转义，否则就会提示语法错误。</p>
<div><pre><code><span>expr</span> <span>5</span> * <span>6</span>       // 输出错误
<span>expr</span> <span>5</span> <span>\</span>* <span>6</span>      // 输出30
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>截取子字符串:</strong></p>
<p>简单的字符串截取：</p>
<div><pre><code><span>#从字符串第 1 个字符开始往后截取 10 个字符</span>
<span>str</span><span>=</span><span>"SnailClimb is a great man"</span>
<span>echo</span> <span>${str<span>:</span>0<span>:</span>10}</span> <span>#输出:SnailClimb</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>根据表达式截取：</p>
<div><pre><code><span>#!bin/bash</span>
<span>#author:amau</span>

<span>var</span><span>=</span><span>"https://www.runoob.com/linux/linux-shell-variable.html"</span>
<span># %表示删除从后匹配, 最短结果</span>
<span># %%表示删除从后匹配, 最长匹配结果</span>
<span># #表示删除从头匹配, 最短结果</span>
<span># ##表示删除从头匹配, 最长匹配结果</span>
<span># 注: *为通配符, 意为匹配任意数量的任意字符</span>
<span>s1</span><span>=</span><span>${var<span>%%</span>t*}</span> <span>#h</span>
<span>s2</span><span>=</span><span>${var<span>%</span>t*}</span>  <span>#https://www.runoob.com/linux/linux-shell-variable.h</span>
<span>s3</span><span>=</span><span>${var<span>%%</span>.*}</span> <span>#http://www</span>
<span>s4</span><span>=</span><span>${var<span>#</span>*<span>/</span>}</span>  <span>#/www.runoob.com/linux/linux-shell-variable.html</span>
<span>s5</span><span>=</span><span>${var<span>##</span>*<span>/</span>}</span> <span>#linux-shell-variable.html</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="shell-数组"> Shell 数组</h3>
<p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。我下面给了大家一个关于数组操作的 Shell 代码示例，通过该示例大家可以知道如何创建数组、获取数组长度、获取/删除特定位置的数组元素、删除整个数组以及遍历数组。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>array</span><span>=</span><span>(</span><span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span><span>)</span><span>;</span>
<span># 获取数组长度</span>
<span>length</span><span>=</span><span>${<span>#</span>array<span>[</span>@<span>]</span>}</span>
<span># 或者</span>
<span>length2</span><span>=</span><span>${<span>#</span>array<span>[</span>*<span>]</span>}</span>
<span>#输出数组长度</span>
<span>echo</span> <span>$length</span> <span>#输出：5</span>
<span>echo</span> <span>$length2</span> <span>#输出：5</span>
<span># 输出数组第三个元素</span>
<span>echo</span> <span>${array<span>[</span>2<span>]</span>}</span> <span>#输出：3</span>
<span>unset</span> array<span>[</span><span>1</span><span>]</span><span># 删除下标为1的元素也就是删除第二个元素</span>
<span>for</span> <span>i</span> <span>in</span> <span>${array<span>[</span>@<span>]</span>}</span><span>;</span><span>do</span> <span>echo</span> <span>$i</span> <span>;</span><span>done</span> <span># 遍历数组，输出： 1 3 4 5 </span>
<span>unset</span> array<span>;</span> <span># 删除数组中的所有元素</span>
<span>for</span> <span>i</span> <span>in</span> <span>${array<span>[</span>@<span>]</span>}</span><span>;</span><span>do</span> <span>echo</span> <span>$i</span> <span>;</span><span>done</span> <span># 遍历数组，数组元素为空，没有任何输出内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="shell-基本运算符"> Shell 基本运算符</h2>
<blockquote>
<p>说明：图片来自《菜鸟教程》</p>
</blockquote>
<p>Shell 编程支持下面几种运算符</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<h3 id="算数运算符"> 算数运算符</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/4937342.jpg" alt="算数运算符" /></p>
<p>我以加法运算符做一个简单的示例（注意：不是单引号，是反引号）：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>a</span><span>=</span><span>3</span><span>;</span><span>b</span><span>=</span><span>3</span><span>;</span>
<span>val</span><span>=</span><span><span>`</span><span>expr</span> $a + $b<span>`</span></span>
<span>#输出：Total value : 6</span>
<span>echo</span> <span>"Total value : <span>$val</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="关系运算符"> 关系运算符</h3>
<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/64391380.jpg" alt="shell关系运算符" /></p>
<p>通过一个简单的示例演示关系运算符的使用，下面shell程序的作用是当score=100的时候输出A否则输出B。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>score</span><span>=</span><span>90</span><span>;</span>
<span>maxscore</span><span>=</span><span>100</span><span>;</span>
<span>if</span> <span>[</span> <span>$score</span> -eq <span>$maxscore</span> <span>]</span>
<span>then</span>
   <span>echo</span> <span>"A"</span>
<span>else</span>
   <span>echo</span> <span>"B"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>输出结果：</p>
<div><pre><code>B
</code></pre>
<div><span>1</span><br></div></div><h3 id="逻辑运算符"> 逻辑运算符</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/60545848.jpg" alt="逻辑运算符" /></p>
<p>示例：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>a</span><span>=</span><span><span>$((</span> <span>1</span> <span>&amp;&amp;</span> <span>0</span><span>))</span></span>
<span># 输出：0；逻辑与运算只有相与的两边都是1，与的结果才是1；否则与的结果是0</span>
<span>echo</span> <span>$a</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="布尔运算符"> 布尔运算符</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/93961425.jpg" alt="布尔运算符" /></p>
<p>这里就不做演示了，应该挺简单的。</p>
<h3 id="字符串运算符"> 字符串运算符</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/309094.jpg" alt=" 字符串运算符" /></p>
<p>简单示例：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>a</span><span>=</span><span>"abc"</span><span>;</span>
<span>b</span><span>=</span><span>"efg"</span><span>;</span>
<span>if</span> <span>[</span> <span>$a</span> <span>=</span> <span>$b</span> <span>]</span>
<span>then</span>
   <span>echo</span> <span>"a 等于 b"</span>
<span>else</span>
   <span>echo</span> <span>"a 不等于 b"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>输出：</p>
<div><pre><code>a 不等于 b
</code></pre>
<div><span>1</span><br></div></div><h3 id="文件相关运算符"> 文件相关运算符</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/60359774.jpg" alt="文件相关运算符" /></p>
<p>使用方式很简单，比如我们定义好了一个文件路径<code>file=&quot;/usr/learnshell/test.sh&quot;</code> 如果我们想判断这个文件是否可读，可以这样<code>if [ -r $file ]</code> 如果想判断这个文件是否可写，可以这样<code>-w $file</code>，是不是很简单。</p>
<h2 id="shell流程控制"> shell流程控制</h2>
<h3 id="if-条件语句"> if 条件语句</h3>
<p>简单的 if else-if else 的条件语句示例</p>
<div><pre><code><span>#!/bin/bash</span>
<span>a</span><span>=</span><span>3</span><span>;</span>
<span>b</span><span>=</span><span>9</span><span>;</span>
<span>if</span> <span>[</span> <span>$a</span> -eq <span>$b</span> <span>]</span>
<span>then</span>
   <span>echo</span> <span>"a 等于 b"</span>
<span>elif</span> <span>[</span> <span>$a</span> -gt <span>$b</span> <span>]</span>
<span>then</span>
   <span>echo</span> <span>"a 大于 b"</span>
<span>else</span>
   <span>echo</span> <span>"a 小于 b"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>输出结果：</p>
<div><pre><code>a 小于 b
</code></pre>
<div><span>1</span><br></div></div><p>相信大家通过上面的示例就已经掌握了 shell 编程中的 if 条件语句。不过，还要提到的一点是，不同于我们常见的 Java 以及 PHP 中的 if 条件语句，shell  if 条件语句中不能包含空语句也就是什么都不做的语句。</p>
<h3 id="for-循环语句"> for 循环语句</h3>
<p>通过下面三个简单的示例认识 for 循环语句最基本的使用，实际上 for 循环语句的功能比下面你看到的示例展现的要大得多。</p>
<p><strong>输出当前列表中的数据：</strong></p>
<div><pre><code><span>for</span> <span>loop</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>
<span>do</span>
    <span>echo</span> <span>"The value is: <span>$loop</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>产生 10 个随机数：</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span>for</span> <span>i</span> <span>in</span> <span>{</span><span>0</span><span>..</span><span>9</span><span>}</span><span>;</span>
<span>do</span> 
   <span>echo</span> <span>$RANDOM</span><span>;</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>输出1到5:</strong></p>
<p>通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要,下面来看一个例子：</p>
<div><pre><code><span>#!/bin/bash</span>
<span>for</span><span><span>((</span>i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span><span>5</span><span>;</span>i<span>++</span><span>))</span></span><span>;</span><span>do</span>
    <span>echo</span> <span>$i</span><span>;</span>
<span>done</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="while-语句"> while 语句</h3>
<p><strong>基本的 while 循环语句：</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span>int</span><span>=</span><span>1</span>
<span>while</span><span><span>((</span> $int<span>&lt;=</span><span>5</span> <span>))</span></span>
<span>do</span>
    <span>echo</span> <span>$int</span>
    <span>let</span> <span>"int++"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>while循环可用于读取键盘信息：</strong></p>
<div><pre><code><span>echo</span> <span>'按下 &lt;CTRL-D> 退出'</span>
<span>echo</span> -n <span>'输入你最喜欢的电影: '</span>
<span>while</span> <span>read</span> FILM
<span>do</span>
    <span>echo</span> <span>"是的！<span>$FILM</span> 是一个好电影"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>输出内容:</p>
<div><pre><code>按下 &lt;CTRL-D&gt; 退出
输入你最喜欢的电影: 变形金刚
是的！变形金刚 是一个好电影
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>无限循环：</strong></p>
<div><pre><code><span>while</span> <span>true</span>
<span>do</span>
    <span>command</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="shell-函数"> shell 函数</h2>
<h3 id="不带参数没有返回值的函数"> 不带参数没有返回值的函数</h3>
<div><pre><code><span>#!/bin/bash</span>
<span>hello</span><span>(</span><span>)</span><span>{</span>
    <span>echo</span> <span>"这是我的第一个 shell 函数!"</span>
<span>}</span>
<span>echo</span> <span>"-----函数开始执行-----"</span>
hello
<span>echo</span> <span>"-----函数执行完毕-----"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>输出结果：</p>
<div><pre><code>-----函数开始执行-----
这是我的第一个 shell 函数!
-----函数执行完毕-----
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="有返回值的函数"> 有返回值的函数</h3>
<p><strong>输入两个数字之后相加并返回结果：</strong></p>
<div><pre><code><span>#!/bin/bash</span>
<span>funWithReturn</span><span>(</span><span>)</span><span>{</span>
    <span>echo</span> <span>"输入第一个数字: "</span>
    <span>read</span> aNum
    <span>echo</span> <span>"输入第二个数字: "</span>
    <span>read</span> anotherNum
    <span>echo</span> <span>"两个数字分别为 <span>$aNum</span> 和 <span>$anotherNum</span> !"</span>
    <span>return</span> <span><span>$((</span>$aNum<span>+</span>$anotherNum<span>))</span></span>
<span>}</span>
funWithReturn
<span>echo</span> <span>"输入的两个数字之和为 <span>$?</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>输出结果：</p>
<div><pre><code>输入第一个数字: 
1
输入第二个数字: 
2
两个数字分别为 1 和 2 !
输入的两个数字之和为 3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="带参数的函数"> 带参数的函数</h3>
<div><pre><code><span>#!/bin/bash</span>
<span>funWithParam</span><span>(</span><span>)</span><span>{</span>
    <span>echo</span> <span>"第一个参数为 <span>$1</span> !"</span>
    <span>echo</span> <span>"第二个参数为 <span>$2</span> !"</span>
    <span>echo</span> <span>"第十个参数为 <span>$10</span> !"</span>
    <span>echo</span> <span>"第十个参数为 <span>${10}</span> !"</span>
    <span>echo</span> <span>"第十一个参数为 <span>${11}</span> !"</span>
    <span>echo</span> <span>"参数总数有 <span>$#</span> 个!"</span>
    <span>echo</span> <span>"作为一个字符串输出所有参数 <span>$*</span> !"</span>
<span>}</span>
funWithParam <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span> <span>8</span> <span>9</span> <span>34</span> <span>73</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>输出结果：</p>
<div><pre><code>第一个参数为 1 !
第二个参数为 2 !
第十个参数为 10 !
第十个参数为 34 !
第十一个参数为 73 !
参数总数有 11 个!
作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-16/60190220.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3种常用的缓存读写策略</title>
      <link>https://javaguide.cn/database/Redis/3-commonly-used-cache-read-and-write-strategies/</link>
      <guid>https://javaguide.cn/database/Redis/3-commonly-used-cache-read-and-write-strategies/</guid>
      <source url="https://javaguide.cn/rss.xml">3种常用的缓存读写策略</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>看到很多小伙伴简历上写了“<strong>熟练使用缓存</strong>”，但是被我问到“<strong>缓存常用的3种读写策略</strong>”的时候却一脸懵逼。</p>
<p>在我看来，造成这个问题的原因是我们在学习 Redis 的时候，可能只是简单了写一些 Demo，并没有去关注缓存的读写策略，或者说压根不知道这回事。</p>
<p>但是，搞懂3种常见的缓存读写策略对于实际工作中使用缓存以及面试中被问到缓存都是非常有帮助的！</p>
<p>下面我会简单介绍一下自己对于这 3 种缓存读写策略的理解。</p>
<p>另外，<strong>这3 种缓存读写策略各有优劣，不存在最佳，需要我们根据具体的业务场景选择更适合的。</strong></p>
<p><em>个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！——爱你们的 Guide 哥</em></p>
<h3 id="cache-aside-pattern-旁路缓存模式"> Cache Aside Pattern（旁路缓存模式）</h3>
<p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>
<p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。</p>
<p>下面我们来看一下这个策略模式下的缓存读写步骤。</p>
<p><strong>写</strong> ：</p>
<ul>
<li>先更新 DB</li>
<li>然后直接删除 cache 。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5687fe759a1dac9ed9554d27e3a23b6d.png" alt="" /></p>
<p><strong>读</strong> :</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache中读取不到的话，就从 DB 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a8c18b5f5b1aed03234bcbbd8c173a87.png" alt="" /></p>
<p>你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。</p>
<p>比如说面试官很可能会追问：“<strong>在写数据的过程中，可以先删除 cache ，后更新 DB 么？</strong>”</p>
<p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成<strong>数据库（DB）和缓存（Cache）数据不一致</strong>的问题。为什么呢？比如说请求1 先写数据A，请求2随后读数据A的话就很有可能产生数据不一致性的问题。这个过程可以简单描述为：</p>
<blockquote>
<p>请求1先把cache中的A数据删除 -&gt; 请求2从DB中读取数据-&gt;请求1再把DB中的A数据更新。</p>
</blockquote>
<p>当你这样回答之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新DB，后删除cache就没有问题了么？</strong>”</p>
<p><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多！</p>
<p>比如请求1先读数据 A，请求2随后写数据A，并且数据A不在缓存中的话也有可能产生数据不一致性的问题。这个过程可以简单描述为：</p>
<blockquote>
<p>请求1从DB读数据A-&gt;请求2写更新数据 A 到数据库并把删除cache中的A数据-&gt;请求1将数据A写入cache。</p>
</blockquote>
<p>现在我们再来分析一下 <strong>Cache Aside Pattern 的缺陷</strong>。</p>
<p><strong>缺陷1：首次请求数据一定不在 cache 的问题</strong></p>
<p>解决办法：可以将热点数据可以提前放入cache 中。</p>
<p><strong>缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
<h3 id="read-write-through-pattern-读写穿透"> Read/Write Through Pattern（读写穿透）</h3>
<p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入DB的功能。</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 DB。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/20210201100340808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="" /></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9ada757c78614934aca11306f334638d.png" alt="" /></p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>
<h3 id="write-behind-pattern-异步缓存写入"> Write Behind Pattern（异步缓存写入）</h3>
<p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/img_convert/5687fe759a1dac9ed9554d27e3a23b6d.png" type="image/png"/>
    </item>
    <item>
      <title>Redis 内存碎片</title>
      <link>https://javaguide.cn/database/Redis/redis-memory-fragmentation/</link>
      <guid>https://javaguide.cn/database/Redis/redis-memory-fragmentation/</guid>
      <source url="https://javaguide.cn/rss.xml">Redis 内存碎片</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="什么是内存碎片"> 什么是内存碎片?</h2>
<p>你可以将内存碎片简单地理解为那些不可用的空闲内存。</p>
<p>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/memory-fragmentation.png" alt="内存碎片" /></p>
<p>Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。</p>
<h2 id="为什么会有-redis-内存碎片"> 为什么会有 Redis 内存碎片?</h2>
<p>Redis 内存碎片产生比较常见的 2 个原因：</p>
<p><strong>1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</strong></p>
<p>以下是这段 Redis 官方的原话：</p>
<blockquote>
<p>To store user keys, Redis allocates at most as much memory as the <code>maxmemory</code> setting enables (however there are small extra allocations possible).</p>
</blockquote>
<p>Redis 使用 <code>zmalloc</code> 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 <code>size</code> 大小的内存之外，还会多分配 <code>PREFIX_SIZE</code> 大小的内存。</p>
<p><code>zmalloc</code> 方法源码如下（源码地址：https://github.com/antirez/redis-tools/blob/master/zmalloc.c）：</p>
<div><pre><code><span>void</span> <span>*</span><span>zmalloc</span><span>(</span>size_t size<span>)</span> <span>{</span>
   <span>// 分配指定大小的内存</span>
   <span>void</span> <span>*</span>ptr <span>=</span> <span>malloc</span><span>(</span>size<span>+</span>PREFIX_SIZE<span>)</span><span>;</span>
   <span>if</span> <span>(</span><span>!</span>ptr<span>)</span> <span>zmalloc_oom_handler</span><span>(</span>size<span>)</span><span>;</span>
#ifdef <span>HAVE_MALLOC_SIZE</span>
   <span>update_zmalloc_stat_alloc</span><span>(</span><span>zmalloc_size</span><span>(</span>ptr<span>)</span><span>)</span><span>;</span>
   <span>return</span> ptr<span>;</span>
#<span>else</span>
   <span>*</span><span>(</span><span>(</span>size_t<span>*</span><span>)</span>ptr<span>)</span> <span>=</span> size<span>;</span>
   <span>update_zmalloc_stat_alloc</span><span>(</span>size<span>+</span>PREFIX_SIZE<span>)</span><span>;</span>
   <span>return</span> <span>(</span><span>char</span><span>*</span><span>)</span>ptr<span>+</span>PREFIX_SIZE<span>;</span>
#endif
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>另外，Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 <a href="https://github.com/jemalloc/jemalloc" target="_blank" rel="noopener noreferrer">jemalloc</a>，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节......）来分配内存的。jemalloc 划分的内存单元如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/6803d3929e3e46c1b1c9d0bb9ee8e717.png" alt="jemalloc 内存单元示意图" /></p>
<p>当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间，就比如说程序需要申请 17 字节的内存，jemalloc 会直接给它分配 32 字节的内存，这样会导致有 15 字节内存的浪费。不过，jemalloc 专门针对内存碎片问题做了优化，一般不会存在过度碎片化的问题。</p>
<p><strong>2、频繁修改 Redis 中的数据也会产生内存碎片。</strong></p>
<p>当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。</p>
<p>这个在 Redis 官方文档中也有对应的原话:</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/redis-docs-memory-optimization.png" alt="" /></p>
<p>文档地址：https://redis.io/topics/memory-optimization 。</p>
<h2 id="如何查看-redis-内存碎片的信息"> 如何查看 Redis 内存碎片的信息？</h2>
<p>使用 <code>info memory</code> 命令即可查看 Redis 内存相关的信息。下图中每个参数具体的含义，Redis 官方文档有详细的介绍：https://redis.io/commands/INFO 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/redis-info-memory.png" alt="" /></p>
<p>Redis 内存碎片率的计算公式：<code>mem_fragmentation_ratio</code> （内存碎片率）= <code>used_memory_rss</code> (操作系统实际分配给 Redis 的物理内存空间大小)/ <code>used_memory</code>(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p>
<p>也就是说，<code>mem_fragmentation_ratio</code> （内存碎片率）的值越大代表内存碎片率越严重。</p>
<p>一定不要误认为<code>used_memory_rss</code> 减去 <code>used_memory</code>值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。</p>
<p>很多小伙伴可能要问了：“多大的内存碎片率才是需要清理呢？”。</p>
<p>通常情况下，我们认为 <code>mem_fragmentation_ratio &gt; 1.5</code> 的话才需要清理内存碎片。 <code>mem_fragmentation_ratio &gt; 1.5</code> 意味着你使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存。</p>
<p>如果想要快速查看内存碎片率的话，你还可以通过下面这个命令：</p>
<div><pre><code><span>></span> redis-cli -p <span>6379</span> info <span>|</span> <span>grep</span> mem_fragmentation_ratio
</code></pre>
<div><span>1</span><br></div></div><p>另外，内存碎片率可能存在小于 1 的情况。这种情况我在日常使用中还没有遇到过，感兴趣的小伙伴可以看看这篇文章 <a href="https://mp.weixin.qq.com/s/drlDvp7bfq5jt2M5pTqJCw" target="_blank" rel="noopener noreferrer">故障分析 | Redis 内存碎片率太低该怎么办？- 爱可生开源社区</a> 。</p>
<h2 id="如何清理-redis-内存碎片"> 如何清理 Redis 内存碎片？</h2>
<p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p>
<p>直接通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p>
<div><pre><code>config <span>set</span> activedefrag <span>yes</span>
</code></pre>
<div><span>1</span><br></div></div><p>具体什么时候清理需要通过下面两个参数控制：</p>
<div><pre><code><span># 内存碎片占用空间达到 500mb 的时候开始清理</span>
config <span>set</span> active-defrag-ignore-bytes 500mb
<span># 内存碎片率大于 1.5 的时候开始清理</span>
config <span>set</span> active-defrag-threshold-lower <span>50</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：</p>
<div><pre><code><span># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span>
config <span>set</span> active-defrag-cycle-min <span>20</span>
<span># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span>
config <span>set</span> active-defrag-cycle-max <span>50</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>另外，重启节点可以做到内存碎片重新整理。如果你采用的是高可用架构的 Redis 集群的话，你可以将碎片率过高的主节点转换为从节点，以便进行安全重启。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li>Redis 官方文档：https://redis.io/topics/memory-optimization</li>
<li>Redis 核心技术与实战 - 极客时间 - 删除数据后，为什么内存占用率还是很高？：https://time.geekbang.org/column/article/289140</li>
<li>Redis 源码解析——内存分配：https://shinerio.cc/2020/05/17/redis/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/memory-fragmentation.png" type="image/png"/>
    </item>
    <item>
      <title>Redis知识点&amp;面试题总结</title>
      <link>https://javaguide.cn/database/Redis/redis%E7%9F%A5%E8%AF%86%E7%82%B9&amp;%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/database/Redis/redis%E7%9F%A5%E8%AF%86%E7%82%B9&amp;%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">Redis知识点&amp;面试题总结</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="简单介绍一下-redis-呗"> 简单介绍一下 Redis 呗!</h3>
<p>简单来说 <strong>Redis 就是一个使用 C 语言开发的数据库</strong>，不过与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p>
<p>另外，<strong>Redis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。</strong></p>
<p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p>
<h3 id="分布式缓存常见的技术选型方案有哪些"> 分布式缓存常见的技术选型方案有哪些？</h3>
<p>分布式缓存的话，使用的比较多的主要是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p>
<p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p>
<p>分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用信息的问题。因为，本地缓存只在当前服务里有效，比如如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共同的。</p>
<h3 id="说一下-redis-和-memcached-的区别和共同点"> 说一下 Redis 和 Memcached 的区别和共同点</h3>
<p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！</p>
<p><strong>共同点</strong> ：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p><strong>区别</strong> ：</p>
<ol>
<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>
<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</strong></li>
<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>
<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>
<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>
<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>
<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>
<li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li>
</ol>
<p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p>
<h3 id="缓存数据的处理流程是怎样的"> 缓存数据的处理流程是怎样的？</h3>
<p>作为暖男一号，我给大家画了一个草图。</p>
<p><img src="./images/redis-all/缓存的处理流程.png" alt="正常缓存处理流程" /></p>
<p>简单来说就是:</p>
<ol>
<li>如果用户请求的数据在缓存中就直接返回。</li>
<li>缓存中不存在的话就看数据库中是否存在。</li>
<li>数据库中存在的话就更新缓存中的数据。</li>
<li>数据库中不存在的话就返回空数据。</li>
</ol>
<h3 id="为什么要用-redis-为什么要用缓存"> 为什么要用 Redis/为什么要用缓存？</h3>
<p><em>简单，来说使用缓存主要是为了提升用户体验以及应对更多的用户。</em></p>
<p>下面我们主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<p><img src="./images/redis-all/使用缓存之后.png" alt="" /></p>
<p><strong>高性能</strong> ：</p>
<p>对照上面 👆 我画的图。我们设想这样的场景：</p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>
<p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>
<p>不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><strong>高并发：</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
</blockquote>
<p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>
<h3 id="redis-除了做缓存-还能做什么"> Redis 除了做缓存，还能做什么？</h3>
<ul>
<li><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。相关阅读：<a href="https://mp.weixin.qq.com/s/CbnPRfvq4m1sqo2uKI6qQw" target="_blank" rel="noopener noreferrer">《分布式锁中的王者方案 - Redisson》</a>。</li>
<li><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA" target="_blank" rel="noopener noreferrer">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》</a>。</li>
<li><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>
<li>......</li>
</ul>
<h3 id="redis-常见数据结构以及使用场景分析"> Redis 常见数据结构以及使用场景分析</h3>
<p>你可以自己本机安装 redis 或者通过 redis 官网提供的<a href="https://try.redis.io/" target="_blank" rel="noopener noreferrer">在线 redis 环境</a>。</p>
<p><img src="./images/redis-all/try-redis.png" alt="try-redis" /></p>
<h4 id="string"> string</h4>
<ol>
<li><strong>介绍</strong> ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</li>
<li><strong>常用命令：</strong> <code>set,get,strlen,exists,decr,incr,setex</code> 等等。</li>
<li><strong>应用场景：</strong> 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li>
</ol>
<p>下面我们简单看看它的使用！</p>
<p><strong>普通字符串的基本操作：</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> key value <span>#设置 key-value 类型的值</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> get key <span># 根据 key 获得对应的 value</span>
<span>"value"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> exists key  <span># 判断某个 key 是否存在</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> strlen key <span># 返回 key 所储存的字符串值的长度。</span>
<span>(</span>integer<span>)</span> <span>5</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> del key <span># 删除某个 key 对应的值</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> get key
<span>(</span>nil<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>批量设置</strong> :</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> mset key1 value1 key2 value2 <span># 批量设置 key-value 类型的值</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> mget key1 key2 <span># 批量获取多个 key 对应的 value</span>
<span>1</span><span>)</span> <span>"value1"</span>
<span>2</span><span>)</span> <span>"value2"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> number <span>1</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> incr number <span># 将 key 中储存的数字值增一</span>
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> get number
<span>"2"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> decr number <span># 将 key 中储存的数字值减一</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> get number
<span>"1"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>过期（默认为永不过期）</strong>：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> expire key  <span>60</span> <span># 数据在 60s 后过期</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setex key <span>60</span> value <span># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> ttl key <span># 查看数据还有多久过期</span>
<span>(</span>integer<span>)</span> <span>56</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="list"> list</h4>
<ol>
<li><strong>介绍</strong> ：<strong>list</strong> 即是 <strong>链表</strong>。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 <strong>LinkedList</strong>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li>
<li><strong>常用命令:</strong> <code>rpush,lpop,lpush,rpop,lrange,llen</code> 等。</li>
<li><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</li>
</ol>
<p>下面我们简单看看它的使用！</p>
<p><strong>通过 <code>rpush/lpop</code> 实现队列：</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> rpush myList value1 <span># 向 list 的头部（右边）添加元素</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> rpush myList value2 value3 <span># 向list的头部（最右边）添加多个元素</span>
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lpop myList <span># 将 list的尾部(最左边)元素取出</span>
<span>"value1"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange myList <span>0</span> <span>1</span> <span># 查看对应下标的list列表， 0 为 start,1为 end</span>
<span>1</span><span>)</span> <span>"value2"</span>
<span>2</span><span>)</span> <span>"value3"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange myList <span>0</span> -1 <span># 查看列表中的所有元素，-1表示倒数第一</span>
<span>1</span><span>)</span> <span>"value2"</span>
<span>2</span><span>)</span> <span>"value3"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>通过 <code>rpush/rpop</code> 实现栈：</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> rpush myList2 value1 value2 value3
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> rpop myList2 <span># 将 list的头部(最右边)元素取出</span>
<span>"value3"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>我专门画了一个图方便小伙伴们来理解：</p>
<p><img src="./images/redis-all/redis-list.png" alt="redis list" /></p>
<p><strong>通过 <code>lrange</code> 查看对应下标范围的列表元素：</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> rpush myList value1 value2 value3
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange myList <span>0</span> <span>1</span> <span># 查看对应下标的list列表， 0 为 start,1为 end</span>
<span>1</span><span>)</span> <span>"value1"</span>
<span>2</span><span>)</span> <span>"value2"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange myList <span>0</span> -1 <span># 查看列表中的所有元素，-1表示倒数第一</span>
<span>1</span><span>)</span> <span>"value1"</span>
<span>2</span><span>)</span> <span>"value2"</span>
<span>3</span><span>)</span> <span>"value3"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>通过 <code>lrange</code> 命令，你可以基于 list 实现分页查询，性能非常高！</p>
<p><strong>通过 <code>llen</code> 查看链表长度：</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> llen myList
<span>(</span>integer<span>)</span> <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="hash"> hash</h4>
<ol>
<li><strong>介绍</strong> ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li>
<li><strong>常用命令：</strong> <code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code> 等。</li>
<li><strong>应用场景:</strong> 系统中对象数据的存储。</li>
</ol>
<p>下面我们简单看看它的使用！</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> hmset userInfoKey name <span>"guide"</span> description <span>"dev"</span> age <span>"24"</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> hexists userInfoKey name <span># 查看 key 对应的 value中指定的字段是否存在。</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hget userInfoKey name <span># 获取存储在哈希表中指定字段的值。</span>
<span>"guide"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hget userInfoKey age
<span>"24"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hgetall userInfoKey <span># 获取在哈希表中指定 key 的所有字段和值</span>
<span>1</span><span>)</span> <span>"name"</span>
<span>2</span><span>)</span> <span>"guide"</span>
<span>3</span><span>)</span> <span>"description"</span>
<span>4</span><span>)</span> <span>"dev"</span>
<span>5</span><span>)</span> <span>"age"</span>
<span>6</span><span>)</span> <span>"24"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hkeys userInfoKey <span># 获取 key 列表</span>
<span>1</span><span>)</span> <span>"name"</span>
<span>2</span><span>)</span> <span>"description"</span>
<span>3</span><span>)</span> <span>"age"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hvals userInfoKey <span># 获取 value 列表</span>
<span>1</span><span>)</span> <span>"guide"</span>
<span>2</span><span>)</span> <span>"dev"</span>
<span>3</span><span>)</span> <span>"24"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hset userInfoKey name <span>"GuideGeGe"</span> <span># 修改某个字段对应的值</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> hget userInfoKey name
<span>"GuideGeGe"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h4 id="set"> set</h4>
<ol>
<li><strong>介绍 ：</strong> set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</li>
<li><strong>常用命令：</strong> <code>sadd,spop,smembers,sismember,scard,sinterstore,sunion</code> 等。</li>
<li><strong>应用场景:</strong> 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</li>
</ol>
<p>下面我们简单看看它的使用！</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> sadd mySet value1 value2 <span># 添加元素进去</span>
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sadd mySet value1 <span># 不允许有重复元素</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> smembers mySet <span># 查看 set 中所有的元素</span>
<span>1</span><span>)</span> <span>"value1"</span>
<span>2</span><span>)</span> <span>"value2"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> scard mySet <span># 查看 set 的长度</span>
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sismember mySet value1 <span># 检查某个元素是否存在set 中，只能接收单个元素</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sadd mySet2 value2 value3
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sinterstore mySet3 mySet mySet2 <span># 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> smembers mySet3
<span>1</span><span>)</span> <span>"value2"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id="sorted-set"> sorted set</h4>
<ol>
<li><strong>介绍：</strong> 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</li>
<li><strong>常用命令：</strong> <code>zadd,zcard,zscore,zrange,zrevrange,zrem</code> 等。</li>
<li><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li>
</ol>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> zadd myZset <span>3.0</span> value1 <span># 添加元素到 sorted set 中 3.0 为权重</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zadd myZset <span>2.0</span> value2 <span>1.0</span> value3 <span># 一次添加多个元素</span>
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zcard myZset <span># 查看 sorted set 中的元素数量</span>
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zscore myZset value1 <span># 查看某个 value 的权重</span>
<span>"3"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zrange  myZset <span>0</span> -1 <span># 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span>
<span>1</span><span>)</span> <span>"value3"</span>
<span>2</span><span>)</span> <span>"value2"</span>
<span>3</span><span>)</span> <span>"value1"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zrange  myZset <span>0</span> <span>1</span> <span># 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span>
<span>1</span><span>)</span> <span>"value3"</span>
<span>2</span><span>)</span> <span>"value2"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zrevrange  myZset <span>0</span> <span>1</span> <span># 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span>
<span>1</span><span>)</span> <span>"value1"</span>
<span>2</span><span>)</span> <span>"value2"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id="bitmap"> bitmap</h4>
<ol>
<li><strong>介绍：</strong> bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。</li>
<li><strong>常用命令：</strong> <code>setbit</code> 、<code>getbit</code> 、<code>bitcount</code>、<code>bitop</code></li>
<li><strong>应用场景：</strong> 适合需要保存状态信息（比如是否签到、是否登录...）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>
</ol>
<div><pre><code><span># SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit mykey <span>7</span> <span>1</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit mykey <span>7</span> <span>0</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> getbit mykey <span>7</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit mykey <span>6</span> <span>1</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit mykey <span>8</span> <span>1</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span># 通过 bitcount 统计被被设置为 1 的位的数量。</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> bitcount mykey
<span>(</span>integer<span>)</span> <span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>针对上面提到的一些场景，这里进行进一步说明。</p>
<p><strong>使用场景一：用户行为分析</strong>
很多网站为了分析你的喜好，需要研究你点赞过的内容。</p>
<div><pre><code><span># 记录你喜欢过 001 号小姐姐</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit beauty_girl_001 uid <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>使用场景二：统计活跃用户</strong></p>
<p>使用时间作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1</p>
<p>那么我该如何计算某几天/月/年的活跃用户呢(暂且约定，统计时间内只要有一天在线就称为活跃)，有请下一个 redis 的命令</p>
<div><pre><code><span># 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</span>
<span># BITOP 命令支持 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种参数</span>
BITOP operation destkey key <span>[</span>key <span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>初始化数据：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> setbit <span>20210308</span> <span>1</span> <span>1</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit <span>20210308</span> <span>2</span> <span>1</span>
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit <span>20210309</span> <span>1</span> <span>1</span>
<span>(</span>integer<span>)</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>统计 20210308~20210309 总活跃用户数: 1</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> bitop and desk1 <span>20210308</span> <span>20210309</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> bitcount desk1
<span>(</span>integer<span>)</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>统计 20210308~20210309 在线活跃用户数: 2</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> bitop or desk2 <span>20210308</span> <span>20210309</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> bitcount desk2
<span>(</span>integer<span>)</span> <span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>使用场景三：用户在线状态</strong></p>
<p>对于获取或者统计用户在线状态，使用 bitmap 是一个节约空间且效率又高的一种方法。</p>
<p>只需要一个 key，然后用户 ID 为 offset，如果在线就设置为 1，不在线就设置为 0。</p>
<h3 id="redis-单线程模型详解"> Redis 单线程模型详解</h3>
<p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>
<p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：1. 文件事件; 2. 时间事件。</p>
<p>时间事件不需要多花时间了解，我们接触最多的还是 <strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p>可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><img src="./images/redis-all/redis事件处理器.png" alt="" /></p>
<p style="text-align:right; font-size:14px; color:gray">《Redis设计与实现：12章》</p>
<h3 id="redis-没有使用多线程-为什么不使用多线程"> Redis 没有使用多线程？为什么不使用多线程？</h3>
<p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p>
<p><img src="./images/redis-all/redis4.0-more-thread.png" alt="redis4.0 more thread" /></p>
<p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</p>
<p>大体上来说，<strong>Redis 6.0 之前主要还是单线程处理。</strong></p>
<p><strong>那，Redis6.0 之前 为什么不使用多线程？</strong></p>
<p>我觉得主要原因有下面 3 个：</p>
<ol>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
<h3 id="redis6-0-之后为何引入了多线程"> Redis6.0 之后为何引入了多线程？</h3>
<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> ：</p>
<div><pre><code>io-threads-do-reads <span>yes</span>
</code></pre>
<div><span>1</span><br></div></div><p>开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 <code>redis.conf</code> :</p>
<div><pre><code>io-threads <span>4</span> <span>#官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span>
</code></pre>
<div><span>1</span><br></div></div><p>推荐阅读：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw" target="_blank" rel="noopener noreferrer">Redis 6.0 新特性-多线程连环 13 问！</a></li>
<li><a href="https://draveness.me/whys-the-design-redis-single-thread/" target="_blank" rel="noopener noreferrer">为什么 Redis 选择单线程模型</a></li>
</ol>
<h3 id="redis-给缓存数据设置过期时间有啥用"> Redis 给缓存数据设置过期时间有啥用？</h3>
<p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p>
<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> exp key <span>60</span> <span># 数据在 60s 后过期</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> setex key <span>60</span> value <span># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> ttl key <span># 查看数据还有多久过期</span>
<span>(</span>integer<span>)</span> <span>56</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注意：**Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。 **</p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h3 id="redis-是如何判断数据是否过期的呢"> Redis 是如何判断数据是否过期的呢？</h3>
<p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<p><img src="./images/redis-all/redis过期时间.png" alt="redis过期字典" /></p>
<p>过期字典是存储在 redisDb 这个结构里的：</p>
<div><pre><code><span>typedef</span> <span>struct</span> <span>redisDb</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>

    dict <span>*</span>dict<span>;</span>     <span>//数据库键空间,保存着数据库中所有键值对</span>
    dict <span>*</span>expires   <span>// 过期字典,保存着键的过期时间</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span> redisDb<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="过期的数据的删除策略了解么"> 过期的数据的删除策略了解么？</h3>
<p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>
<p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol>
<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p>
<h3 id="redis-内存淘汰机制了解么"> Redis 内存淘汰机制了解么？</h3>
<blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol start="7">
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<h3 id="redis-持久化机制-怎么保证-redis-挂掉之后再重启数据可以进行恢复"> Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</h3>
<p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p>
<p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p>
<div><pre><code>save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>AOF（append-only file）持久化</strong></p>
<p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>
<div><pre><code>appendonly yes
</code></pre>
<div><span>1</span><br></div></div><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<div><pre><code>appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>相关 issue</strong> ：</p>
<ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/783" target="_blank" rel="noopener noreferrer">Redis 的 AOF 方式 #783</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/1439" target="_blank" rel="noopener noreferrer">Redis AOF 重写描述不准确 #1439</a></li>
</ul>
<p><strong>拓展：Redis 4.0 对于持久化机制的优化</strong></p>
<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<p>官方文档地址：https://redis.io/topics/persistence</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/image-host-github-stars-01@main/webfunny_monitor/image-20210807145107290.png" alt="" /></p>
<p><strong>补充内容：AOF 重写</strong></p>
<p>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>
<p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>
<p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<h3 id="bigkey"> bigkey</h3>
<h4 id="什么是-bigkey"> 什么是 bigkey？</h4>
<p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>
<h4 id="bigkey-有什么危害"> bigkey 有什么危害？</h4>
<p>除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。</p>
<p>因此，我们应该尽量避免写入 bigkey！</p>
<h4 id="如何发现-bigkey"> 如何发现 bigkey？</h4>
<p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p>
<div><pre><code><span># redis-cli -p 6379 --bigkeys</span>

<span># Scanning the entire keyspace to find biggest keys as well as</span>
<span># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span>
<span># per 100 SCAN commands (not usually needed).</span>

<span>[</span>00.00%<span>]</span> Biggest string found so far <span>'"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20"'</span> with <span>4437</span> bytes
<span>[</span>00.00%<span>]</span> Biggest list   found so far <span>'"my-list"'</span> with <span>17</span> items

-------- summary -------

Sampled <span>5</span> keys <span>in</span> the keyspace<span>!</span>
Total key length <span>in</span> bytes is <span>264</span> <span>(</span>avg len <span>52.80</span><span>)</span>

Biggest   list found <span>'"my-list"'</span> has <span>17</span> items
Biggest string found <span>'"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20"'</span> has <span>4437</span> bytes

<span>1</span> lists with <span>17</span> items <span>(</span><span>20.00</span>% of keys, avg size <span>17.00</span><span>)</span>
<span>0</span> hashs with <span>0</span> fields <span>(</span>00.00% of keys, avg size <span>0.00</span><span>)</span>
<span>4</span> strings with <span>4831</span> bytes <span>(</span><span>80.00</span>% of keys, avg size <span>1207.75</span><span>)</span>
<span>0</span> streams with <span>0</span> entries <span>(</span>00.00% of keys, avg size <span>0.00</span><span>)</span>
<span>0</span> sets with <span>0</span> members <span>(</span>00.00% of keys, avg size <span>0.00</span><span>)</span>
<span>0</span> zsets with <span>0</span> members <span>(</span>00.00% of keys, avg size <span>0.00</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。</p>
<p><strong>2、分析 RDB 文件</strong></p>
<p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p>
<p>网上有现成的代码/工具可以直接拿来使用：</p>
<ul>
<li><a href="https://github.com/sripathikrishnan/redis-rdb-tools" target="_blank" rel="noopener noreferrer">redis-rdb-tools</a> ：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>
<li><a href="https://github.com/weiyanwei412/rdb_bigkeys" target="_blank" rel="noopener noreferrer">rdb_bigkeys</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>
</ul>
<h3 id="redis-事务"> Redis 事务</h3>
<p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p>
<div><pre><code><span>></span> MULTI
OK
<span>></span> SET <span>USER</span> <span>"Guide哥"</span>
QUEUED
<span>></span> GET <span>USER</span>
QUEUED
<span>></span> EXEC
<span>1</span><span>)</span> OK
<span>2</span><span>)</span> <span>"Guide哥"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>使用 <a href="https://redis.io/commands/multi" target="_blank" rel="noopener noreferrer"><code>MULTI</code></a> 命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href="https://redis.io/commands/exec" target="_blank" rel="noopener noreferrer"><code>EXEC</code></a> 命令将执行所有命令。</p>
<p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code>MULTI</code>）。</li>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li>
<li>执行事务(<code>EXEC</code>)。</li>
</ol>
<p>你也可以通过 <a href="https://redis.io/commands/discard" target="_blank" rel="noopener noreferrer"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<div><pre><code><span>></span> MULTI
OK
<span>></span> SET <span>USER</span> <span>"Guide哥"</span>
QUEUED
<span>></span> GET <span>USER</span>
QUEUED
<span>></span> DISCARD
OK
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><a href="https://redis.io/commands/watch" target="_blank" rel="noopener noreferrer"><code>WATCH</code></a> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p>
<div><pre><code><span>></span> WATCH <span>USER</span>
OK
<span>></span> MULTI
<span>></span> SET <span>USER</span> <span>"Guide哥"</span>
OK
<span>></span> GET <span>USER</span>
Guide哥
<span>></span> EXEC
ERR EXEC without MULTI
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Redis 官网相关介绍 <a href="https://redis.io/topics/transactions" target="_blank" rel="noopener noreferrer">https://redis.io/topics/transactions</a> 如下：</p>
<p><img src="./images/redis-all/redis事务.png" alt="redis事务" /></p>
<p>但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： <strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>
<ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
</ol>
<p><strong>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</strong></p>
<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<p><img src="./images/redis-all/redis-rollBack.png" alt="redis roll back" /></p>
<p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<p><strong>相关 issue</strong> :</p>
<ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/452" target="_blank" rel="noopener noreferrer">issue452: 关于 Redis 事务不满足原子性的问题</a> 。</li>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/491" target="_blank" rel="noopener noreferrer">Issue491:关于 redis 没有事务回滚？</a></li>
</ul>
<h3 id="缓存穿透"> 缓存穿透</h3>
<h4 id="什么是缓存穿透"> 什么是缓存穿透？</h4>
<p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<h4 id="缓存穿透情况的处理流程是怎样的"> 缓存穿透情况的处理流程是怎样的？</h4>
<p>如下图所示，用户的请求最终都要跑到数据库中查询一遍。</p>
<p><img src="./images/redis-all/缓存穿透情况.png" alt="缓存穿透情况" /></p>
<h4 id="有哪些解决办法"> 有哪些解决办法？</h4>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p><strong>1）缓存无效 key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<div><pre><code><span>public</span> <span>Object</span> <span>getObjectInclNullById</span><span>(</span><span>Integer</span> id<span>)</span> <span>{</span>
    <span>// 从缓存中获取数据</span>
    <span>Object</span> cacheValue <span>=</span> cache<span>.</span><span>get</span><span>(</span>id<span>)</span><span>;</span>
    <span>// 缓存为空</span>
    <span>if</span> <span>(</span>cacheValue <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 从数据库中获取</span>
        <span>Object</span> storageValue <span>=</span> storage<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>
        <span>// 缓存空对象</span>
        cache<span>.</span><span>set</span><span>(</span>key<span>,</span> storageValue<span>)</span><span>;</span>
        <span>// 如果存储数据为空，需要设置一个过期时间(300秒)</span>
        <span>if</span> <span>(</span>storageValue <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 必须设置过期时间，否则有被攻击的风险</span>
            cache<span>.</span><span>expire</span><span>(</span>key<span>,</span> <span>60</span> <span>*</span> <span>5</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> storageValue<span>;</span>
    <span>}</span>
    <span>return</span> cacheValue<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>2）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<p><img src="./images/redis-all/加入布隆过滤器后的缓存处理流程.png" alt="image" /></p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/cs-basics/data-structure/bloom-filter.md" target="_blank" rel="noopener noreferrer">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p>
<h3 id="缓存雪崩"> 缓存雪崩</h3>
<h4 id="什么是缓存雪崩"> 什么是缓存雪崩？</h4>
<p>我发现缓存雪崩这名字起的有点意思，哈哈。</p>
<p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p>
<p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p>
<p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>
<h4 id="有哪些解决办法-2"> 有哪些解决办法？</h4>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ol>
<h3 id="如何保证缓存和数据库数据的一致性"> 如何保证缓存和数据库数据的一致性？</h3>
<p>细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>
<p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>
<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<h3 id="参考"> 参考</h3>
<ul>
<li>《Redis 开发与运维》</li>
<li>《Redis 设计与实现》</li>
<li>Redis 命令总结：http://Redisdoc.com/string/set.html</li>
<li>通俗易懂的 Redis 数据结构基础教程：<a href="https://juejin.im/post/5b53ee7e5188251aaa2d2e16" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5b53ee7e5188251aaa2d2e16</a></li>
<li>WHY Redis choose single thread (vs multi threads): <a href="https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153" target="_blank" rel="noopener noreferrer">https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>一千行 MySQL 学习笔记</title>
      <link>https://javaguide.cn/database/mysql/a-thousand-lines-of-mysql-study-notes/</link>
      <guid>https://javaguide.cn/database/mysql/a-thousand-lines-of-mysql-study-notes/</guid>
      <source url="https://javaguide.cn/rss.xml">一千行 MySQL 学习笔记</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>原文地址：https://shockerli.net/post/1000-line-mysql-note/ ，JavaGuide 对本文进行了简答排版，新增了目录。
作者：格物</p>
</blockquote>
<p>非常不错的总结，强烈建议保存下来，需要的时候看一看。</p>
<h3 id="基本操作"> 基本操作</h3>
<div><pre><code>/* Windows服务 */
-- 启动MySQL
    net start mysql
-- 创建Windows服务
    sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)
/* 连接与断开服务器 */
mysql -h 地址 -P 端口 -u 用户名 -p 密码
SHOW PROCESSLIST -- 显示哪些线程正在运行
SHOW VARIABLES -- 显示系统变量信息
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="数据库操作"> 数据库操作</h3>
<div><pre><code>/* 数据库操作 */ ------------------
-- 查看当前数据库
    SELECT DATABASE();
-- 显示当前时间、用户名、数据库版本
    SELECT now(), user(), version();
-- 创建库
    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项
    数据库选项：
        CHARACTER SET charset_name
        COLLATE collation_name
-- 查看已有库
    SHOW DATABASES[ LIKE &#39;PATTERN&#39;]
-- 查看当前库信息
    SHOW CREATE DATABASE 数据库名
-- 修改库的选项信息
    ALTER DATABASE 库名 选项信息
-- 删除库
    DROP DATABASE[ IF EXISTS] 数据库名
        同时删除该数据库相关的目录及其目录内容
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="表的操作"> 表的操作</h3>
<div><pre><code>-- 创建表
    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]
        每个字段必须有数据类型
        最后一个字段后不能有逗号
        TEMPORARY 临时表，会话结束时表自动消失
        对于字段的定义：
            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#39;string&#39;]
-- 表选项
    -- 字符集
        CHARSET = charset_name
        如果表没有设定，则使用数据库字符集
    -- 存储引擎
        ENGINE = engine_name
        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同
        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive
        不同的引擎在保存表的结构和数据时采用不同的方式
        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引
        InnoDB表文件含义：.frm表定义，表空间数据和日志文件
        SHOW ENGINES -- 显示存储引擎的状态信息
        SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息
    -- 自增起始数
    	AUTO_INCREMENT = 行数
    -- 数据文件目录
        DATA DIRECTORY = &#39;目录&#39;
    -- 索引文件目录
        INDEX DIRECTORY = &#39;目录&#39;
    -- 表注释
        COMMENT = &#39;string&#39;
    -- 分区选项
        PARTITION BY ... (详细见手册)
-- 查看所有表
    SHOW TABLES[ LIKE &#39;pattern&#39;]
    SHOW TABLES FROM  库名
-- 查看表结构
    SHOW CREATE TABLE 表名 （信息更详细）
    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;]
    SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;]
-- 修改表
    -- 修改表本身的选项
        ALTER TABLE 表名 表的选项
        eg: ALTER TABLE 表名 ENGINE=MYISAM;
    -- 对表进行重命名
        RENAME TABLE 原表名 TO 新表名
        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）
        -- RENAME可以交换两个表名
    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）
        ALTER TABLE 表名 操作名
        -- 操作名
            ADD[ COLUMN] 字段定义       -- 增加字段
                AFTER 字段名          -- 表示增加在该字段名后面
                FIRST               -- 表示增加在第一个
            ADD PRIMARY KEY(字段名)   -- 创建主键
            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引
            ADD INDEX [索引名] (字段名) -- 创建普通索引
            DROP[ COLUMN] 字段名      -- 删除字段
            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)
            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改
            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)
            DROP INDEX 索引名 -- 删除索引
            DROP FOREIGN KEY 外键    -- 删除外键
-- 删除表
    DROP TABLE[ IF EXISTS] 表名 ...
-- 清空表数据
    TRUNCATE [TABLE] 表名
-- 复制表结构
    CREATE TABLE 表名 LIKE 要复制的表名
-- 复制表结构和数据
    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名
-- 检查表是否有错误
    CHECK TABLE tbl_name [, tbl_name] ... [option] ...
-- 优化表
    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
-- 修复表
    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]
-- 分析表
    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><h3 id="数据操作"> 数据操作</h3>
<div><pre><code>/* 数据操作 */ ------------------
-- 增
    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]
        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。
        -- 可同时插入多条数据记录！
        REPLACE 与 INSERT 完全一样，可互换。
    INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]
-- 查
    SELECT 字段列表 FROM 表名[ 其他子句]
        -- 可来自多个表的多个字段
        -- 其他子句可以不使用
        -- 字段列表可以用*代替，表示所有字段
-- 删
    DELETE FROM 表名[ 删除条件子句]
        没有条件子句，则会删除全部
-- 改
    UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="字符集编码"> 字符集编码</h3>
<div><pre><code>/* 字符集编码 */ ------------------
-- MySQL、数据库、表、字段均可设置编码
-- 数据编码与客户端编码不需一致
SHOW VARIABLES LIKE &#39;character_set_%&#39;   -- 查看所有字符集编码项
    character_set_client        客户端向服务器发送数据时使用的编码
    character_set_results       服务器端将结果返回给客户端所使用的编码
    character_set_connection    连接层编码
SET 变量名 = 变量值
    SET character_set_client = gbk;
    SET character_set_results = gbk;
    SET character_set_connection = gbk;
SET NAMES GBK;  -- 相当于完成以上三个设置
-- 校对集
    校对集用以排序
    SHOW CHARACTER SET [LIKE &#39;pattern&#39;]/SHOW CHARSET [LIKE &#39;pattern&#39;]   查看所有字符集
    SHOW COLLATION [LIKE &#39;pattern&#39;]     查看所有校对集
    CHARSET 字符集编码     设置字符集编码
    COLLATE 校对集编码     设置校对集编码
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="数据类型-列类型"> 数据类型(列类型)</h3>
<div><pre><code>/* 数据类型（列类型） */ ------------------
1. 数值类型
-- a. 整型 ----------
    类型         字节     范围（有符号位）
    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255
    smallint    2字节    -32768 ~ 32767
    mediumint   3字节    -8388608 ~ 8388607
    int         4字节
    bigint      8字节
    int(M)  M表示总位数
    - 默认存在符号位，unsigned 属性修改
    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改
        例：int(5)   插入一个数&#39;123&#39;，补填后为&#39;00123&#39;
    - 在满足要求的情况下，越小越好。
    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。
-- b. 浮点型 ----------
    类型             字节     范围
    float(单精度)     4字节
    double(双精度)    8字节
    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。
        不同于整型，前后均会补填0.
    定义浮点型时，需指定总位数和小数位数。
        float(M, D)     double(M, D)
        M表示总位数，D表示小数位数。
        M和D的大小会决定浮点数的范围。不同于整型的固定范围。
        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。
        支持科学计数法表示。
        浮点数表示近似值。
-- c. 定点数 ----------
    decimal -- 可变长度
    decimal(M, D)   M也表示总位数，D表示小数位数。
    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。
    将浮点数转换为字符串来保存，每9位数字保存为4个字节。
2. 字符串类型
-- a. char, varchar ----------
    char    定长字符串，速度快，但浪费空间
    varchar 变长字符串，速度慢，但节省空间
    M表示能存储的最大长度，此长度是字符数，非字节数。
    不同的编码，所占用的空间不同。
    char,最多255个字符，与编码无关。
    varchar,最多65535字符，与编码有关。
    一条有效记录最大不能超过65535个字节。
        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符
    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。
    varchar 的最大有效长度由最大行大小和使用的字符集确定。
    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是65535-1-2=65532字节。
    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3
-- b. blob, text ----------
    blob 二进制字符串（字节字符串）
        tinyblob, blob, mediumblob, longblob
    text 非二进制字符串（字符字符串）
        tinytext, text, mediumtext, longtext
    text 在定义时，不需要定义长度，也不会计算总长度。
    text 类型在定义时，不可给default值
-- c. binary, varbinary ----------
    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。
    char, varchar, text 对应 binary, varbinary, blob.
3. 日期时间类型
    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。
    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59
    date        3字节    日期         1000-01-01 到 9999-12-31
    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07
    time        3字节    时间         -838:59:59 到 838:59:59
    year        1字节    年份         1901 - 2155
datetime    YYYY-MM-DD hh:mm:ss
timestamp   YY-MM-DD hh:mm:ss
            YYYYMMDDhhmmss
            YYMMDDhhmmss
            YYYYMMDDhhmmss
            YYMMDDhhmmss
date        YYYY-MM-DD
            YY-MM-DD
            YYYYMMDD
            YYMMDD
            YYYYMMDD
            YYMMDD
time        hh:mm:ss
            hhmmss
            hhmmss
year        YYYY
            YY
            YYYY
            YY
4. 枚举和集合
-- 枚举(enum) ----------
enum(val1, val2, val3...)
    在已知的值中进行单选。最大数量为65535.
    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。
    表现为字符串类型，存储却是整型。
    NULL值的索引是NULL。
    空字符串错误值的索引值是0。
-- 集合（set） ----------
set(val1, val2, val3...)
    create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );
    insert into tab values (&#39;男, 女&#39;);
    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。
    当创建表时，SET成员值的尾部空格将自动被删除。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br></div></div><h3 id="列属性-列约束"> 列属性(列约束)</h3>
<div><pre><code>/* 列属性（列约束） */ ------------------
1. PRIMARY 主键
    - 能唯一标识记录的字段，可以作为主键。
    - 一个表只能有一个主键。
    - 主键具有唯一性。
    - 声明字段时，用 primary key 标识。
        也可以在字段列表之后声明
            例：create table tab ( id int, stu varchar(10), primary key (id));
    - 主键字段的值不能为null。
    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。
        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));
2. UNIQUE 唯一索引（唯一约束）
    使得某字段的值也不能重复。
3. NULL 约束
    null不是数据类型，是列的一个属性。
    表示当前列是否可以为null，表示什么都没有。
    null, 允许为空。默认。
    not null, 不允许为空。
    insert into tab values (null, &#39;val&#39;);
        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null
4. DEFAULT 默认值属性
    当前字段的默认值。
    insert into tab values (default, &#39;val&#39;);    -- 此时表示强制使用默认值。
    create table tab ( add_time timestamp default current_timestamp );
        -- 表示将当前时间的时间戳设为默认值。
        current_date, current_time
5. AUTO_INCREMENT 自动增长约束
    自动增长必须为索引（主键或unique）
    只能存在一个字段为自动增长。
    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;
6. COMMENT 注释
    例：create table tab ( id int ) comment &#39;注释内容&#39;;
7. FOREIGN KEY 外键约束
    用于限制主表与从表数据完整性。
    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);
        -- 将表t1的t1_id外键关联到表t2的id字段。
        -- 每个外键都有一个名字，可以通过 constraint 指定
    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。
    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。
    MySQL中，可以对InnoDB引擎使用外键约束：
    语法：
    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]
    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。
    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。
    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：
    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。
    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。
    3. restrict，拒绝父表删除和更新。
    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h3 id="建表规范"> 建表规范</h3>
<div><pre><code>/* 建表规范 */ ------------------
    -- Normal Format, NF
        - 每个表保存一个实体信息
        - 每个具有一个ID字段作为主键
        - ID主键 + 原子表
    -- 1NF, 第一范式
        字段不能再分，就满足第一范式。
    -- 2NF, 第二范式
        满足第一范式的前提下，不能出现部分依赖。
        消除复合主键就可以避免部分依赖。增加单列关键字。
    -- 3NF, 第三范式
        满足第二范式的前提下，不能出现传递依赖。
        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。
        将一个实体信息的数据放在一个表内实现。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="select"> SELECT</h3>
<div><pre><code>/* SELECT */ ------------------
SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT
a. select_expr
    -- 可以用 * 表示所有字段。
        select * from tb;
    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）
        select stu, 29+25, now() from tb;
    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。
        - 使用 as 关键字，也可省略 as.
        select stu+10 as add10 from tb;
b. FROM 子句
    用于标识查询来源。
    -- 可以为表起别名。使用as关键字。
        SELECT * FROM tb1 AS tt, tb2 AS bb;
    -- from子句后，可以同时出现多个表。
        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。
        SELECT * FROM tb1, tb2;
    -- 向优化符提示如何选择索引
        USE INDEX、IGNORE INDEX、FORCE INDEX
        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;
        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;
c. WHERE 子句
    -- 从from获得的数据源中进行筛选。
    -- 整型1表示真，0表示假。
    -- 表达式由运算符和运算数组成。
        -- 运算数：变量（字段）、值、函数返回值
        -- 运算符：
            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,
            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor
            is/is not 加上ture/false/unknown，检验某个值的真假
            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较
d. GROUP BY 子句, 分组子句
    GROUP BY 字段/别名 [排序方式]
    分组后会进行排序。升序：ASC，降序：DESC
    以下[合计函数]需配合 GROUP BY 使用：
    count 返回不同的非NULL值数目  count(*)、count(字段)
    sum 求和
    max 求最大值
    min 求最小值
    avg 求平均值
    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。
e. HAVING 子句，条件子句
    与 where 功能、用法相同，执行时机不同。
    where 在开始时执行检测数据，对原数据进行过滤。
    having 对筛选出的结果再次进行过滤。
    having 字段必须是查询出来的，where 字段必须是数据表存在的。
    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。
    where 不可以使用合计函数。一般需用合计函数才会用 having
    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。
f. ORDER BY 子句，排序子句
    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...
    升序：ASC，降序：DESC
    支持多个字段的排序。
g. LIMIT 子句，限制结果数量子句
    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。
    limit 起始位置, 获取条数
    省略第一个参数，表示从索引0开始。limit 获取条数
h. DISTINCT, ALL 选项
    distinct 去除重复记录
    默认为 all, 全部记录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><h3 id="union"> UNION</h3>
<div><pre><code>/* UNION */ ------------------
    将多个select查询的结果组合成一个结果集合。
    SELECT ... UNION [ALL|DISTINCT] SELECT ...
    默认 DISTINCT 方式，即所有返回的行都是唯一的
    建议，对每个SELECT查询加上小括号包裹。
    ORDER BY 排序时，需加上 LIMIT 进行结合。
    需要各select查询的字段数量一样。
    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="子查询"> 子查询</h3>
<div><pre><code>/* 子查询 */ ------------------
    - 子查询需用括号包裹。
-- from型
    from后要求是一个表，必须给子查询结果取个别名。
    - 简化每个查询内的条件。
    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。
    - 子查询返回一个表，表型子查询。
    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;
-- where型
    - 子查询返回一个值，标量子查询。
    - 不需要给子查询取别名。
    - where子查询内的表，不能直接用以更新。
    select * from tb where money = (select max(money) from tb);
    -- 列子查询
        如果子查询结果返回的是一列。
        使用 in 或 not in 完成查询
        exists 和 not exists 条件
            如果子查询返回数据，则返回1或0。常用于判断条件。
            select column1 from t1 where exists (select * from t2);
    -- 行子查询
        查询条件是一个行。
        select * from t1 where (id, gender) in (select id, gender from t2);
        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)
        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。
    -- 特殊运算符
    != all()    相当于 not in
    = some()    相当于 in。any 是 some 的别名
    != some()   不等同于 not in，不等于其中某一个。
    all, some 可以配合其他运算符一起使用。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id="连接查询-join"> 连接查询(join)</h3>
<div><pre><code>/* 连接查询(join) */ ------------------
    将多个表的字段进行连接，可以指定连接条件。
-- 内连接(inner join)
    - 默认就是内连接，可省略inner。
    - 只有数据存在时才能发送连接。即连接结果不能出现空行。
    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）
    也可用where表示连接条件。
    还有 using, 但需字段名相同。 using(字段名)
    -- 交叉连接 cross join
        即，没有条件的内连接。
        select * from tb1 cross join tb2;
-- 外连接(outer join)
    - 如果数据不存在，也会出现在连接结果中。
    -- 左外连接 left join
        如果数据不存在，左表记录会出现，而右表为null填充
    -- 右外连接 right join
        如果数据不存在，右表记录会出现，而左表为null填充
-- 自然连接(natural join)
    自动判断连接条件完成连接。
    相当于省略了using，会自动查找相同字段名。
    natural join
    natural left join
    natural right join
select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="truncate"> TRUNCATE</h3>
<div><pre><code>/* TRUNCATE */ ------------------
TRUNCATE [TABLE] tbl_name
清空数据
删除重建表
区别：
1，truncate 是删除表再创建，delete 是逐条删除
2，truncate 重置auto_increment的值。而delete不会
3，truncate 不知道删除了几条，而delete知道。
4，当被用于带分区的表时，truncate 会保留分区
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="备份与还原"> 备份与还原</h3>
<div><pre><code>/* 备份与还原 */ ------------------
备份，将数据的结构与表内数据保存起来。
利用 mysqldump 指令完成。
-- 导出
mysqldump [options] db_name [tables]
mysqldump [options] ---database DB1 [DB2 DB3...]
mysqldump [options] --all--database
1. 导出一张表
　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)
2. 导出多张表
　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)
3. 导出所有表
　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)
4. 导出一个库
　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)
可以-w携带WHERE条件
-- 导入
1. 在登录mysql的情况下：
　　source  备份文件
2. 在不登录的情况下
　　mysql -u用户名 -p密码 库名 &lt; 备份文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="视图"> 视图</h3>
<div><pre><code>什么是视图：
    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。
    视图具有表结构文件，但不存在数据文件。
    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。
    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。
-- 创建视图
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement
    - 视图名必须唯一，同时不能与表重名。
    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。
    - 可以指定视图执行的算法，通过ALGORITHM指定。
    - column_list如果存在，则数目必须等于SELECT语句检索的列数
-- 查看结构
    SHOW CREATE VIEW view_name
-- 删除视图
    - 删除视图后，数据依然存在。
    - 可同时删除多个视图。
    DROP VIEW [IF EXISTS] view_name ...
-- 修改视图结构
    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。
    ALTER VIEW view_name [(column_list)] AS select_statement
-- 视图作用
    1. 简化业务逻辑
    2. 对客户端隐藏真实的表结构
-- 视图算法(ALGORITHM)
    MERGE       合并
        将视图的查询语句，与外部查询需要先合并再执行！
    TEMPTABLE   临时表
        将视图执行完毕后，形成临时表，再做外层查询！
    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id="事务-transaction"> 事务(transaction)</h3>
<div><pre><code>事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。
    - 支持连续SQL的集体成功或集体撤销。
    - 事务是数据库在数据完整性方面的一个功能。
    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。
    - InnoDB被称为事务安全型引擎。
-- 事务开启
    START TRANSACTION; 或者 BEGIN;
    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。
-- 事务提交
    COMMIT;
-- 事务回滚
    ROLLBACK;
    如果部分操作发生问题，映射到事务开启前。
-- 事务的特性
    1. 原子性（Atomicity）
        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
    2. 一致性（Consistency）
        事务前后数据的完整性必须保持一致。
        - 事务开始和结束时，外部数据一致
        - 在整个事务过程中，操作是连续的
    3. 隔离性（Isolation）
        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间的数据要相互隔离。
    4. 持久性（Durability）
        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。
-- 事务的实现
    1. 要求是事务支持的表类型
    2. 执行一组相关的操作前开启事务
    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。
-- 事务的原理
    利用InnoDB的自动提交(autocommit)特性完成。
    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。
    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。
-- 注意
    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。
    2. 事务不能被嵌套
-- 保存点
    SAVEPOINT 保存点名称 -- 设置一个事务保存点
    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点
    RELEASE SAVEPOINT 保存点名称 -- 删除保存点
-- InnoDB自动提交特性设置
    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。
    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。
    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，
        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)
        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h3 id="锁表"> 锁表</h3>
<div><pre><code>/* 锁表 */
表锁定只用于防止其它客户端进行不正当地读取和写入
MyISAM 支持表锁，InnoDB 支持行锁
-- 锁定
    LOCK TABLES tbl_name [AS alias]
-- 解锁
    UNLOCK TABLES
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="触发器"> 触发器</h3>
<div><pre><code>/* 触发器 */ ------------------
    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象
    监听：记录的增加、修改、删除。
-- 创建触发器
CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt
    参数：
    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。
    trigger_event指明了激活触发程序的语句的类型
        INSERT：将新行插入表时激活触发程序
        UPDATE：更改某一行时激活触发程序
        DELETE：从表中删除某一行时激活触发程序
    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。
    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构
-- 删除
DROP TRIGGER [schema_name.]trigger_name
可以使用old和new代替旧的和新的数据
    更新操作，更新前是old，更新后是new.
    删除操作，只有old.
    增加操作，只有new.
-- 注意
    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。
-- 字符连接函数
concat(str1,str2,...])
concat_ws(separator,str1,str2,...)
-- 分支语句
if 条件 then
    执行语句
elseif 条件 then
    执行语句
else
    执行语句
end if;
-- 修改最外层语句结束符
delimiter 自定义结束符号
    SQL语句
自定义结束符号
delimiter ;     -- 修改回原来的分号
-- 语句块包裹
begin
    语句块
end
-- 特殊的执行
1. 只要添加记录，就会触发程序。
2. Insert into on duplicate key update 语法会触发：
    如果没有重复记录，会触发 before insert, after insert;
    如果有重复记录并更新，会触发 before insert, before update, after update;
    如果有重复记录但是没有发生更新，则触发 before insert, before update
3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h3 id="sql编程"> SQL编程</h3>
<div><pre><code>/* SQL编程 */ ------------------
--// 局部变量 ----------
-- 变量声明
    declare var_name[,...] type [default value]
    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。
-- 赋值
    使用 set 和 select into 语句为变量赋值。
    - 注意：在函数内是可以使用全局变量（用户自定义的变量）
--// 全局变量 ----------
-- 定义、赋值
set 语句可以定义并为变量赋值。
set @var = value;
也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。
还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。
select @var:=20;
select @v1:=id, @v2=name from t1 limit 1;
select * from tbl_name where @var:=30;
select into 可以将表中查询获得的数据赋给变量。
    -| select max(height) into @max_height from tb;
-- 自定义变量名
为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。
@var=10;
    - 变量被定义后，在整个会话周期都有效（登录到退出）
--// 控制结构 ----------
-- if语句
if search_condition then
    statement_list   
[elseif search_condition then
    statement_list]
...
[else
    statement_list]
end if;
-- case语句
CASE value WHEN [compare-value] THEN result
[WHEN [compare-value] THEN result ...]
[ELSE result]
END
-- while循环
[begin_label:] while search_condition do
    statement_list
end while [end_label];
- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。
    -- 退出循环
        退出整个循环 leave
        退出当前循环 iterate
        通过退出的标签决定退出哪个循环
--// 内置函数 ----------
-- 数值函数
abs(x)          -- 绝对值 abs(-10.9) = 10
format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46
ceil(x)         -- 向上取整 ceil(10.1) = 11
floor(x)        -- 向下取整 floor (10.1) = 10
round(x)        -- 四舍五入去整
mod(m, n)       -- m%n m mod n 求余 10%3=1
pi()            -- 获得圆周率
pow(m, n)       -- m^n
sqrt(x)         -- 算术平方根
rand()          -- 随机数
truncate(x, d)  -- 截取d位小数
-- 时间日期函数
now(), current_timestamp();     -- 当前日期时间
current_date();                 -- 当前日期
current_time();                 -- 当前时间
date(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取日期部分
time(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取时间部分
date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间
unix_timestamp();               -- 获得unix时间戳
from_unixtime();                -- 从时间戳获得时间
-- 字符串函数
length(string)          -- string长度，字节
char_length(string)     -- string的字符个数
substring(str, position [,length])      -- 从str的position开始,取length个字符
replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str
instr(string ,substring)    -- 返回substring首次在string中出现的位置
concat(string [,...])   -- 连接字串
charset(str)            -- 返回字串字符集
lcase(string)           -- 转换成小写
left(string, length)    -- 从string2中的左边起取length个字符
load_file(file_name)    -- 从文件读取内容
locate(substring, string [,start_position]) -- 同instr,但可指定开始位置
lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length
ltrim(string)           -- 去除前端空格
repeat(string, count)   -- 重复count次
rpad(string, length, pad)   --在str后用pad补充,直到长度为length
rtrim(string)           -- 去除后端空格
strcmp(string1 ,string2)    -- 逐字符比较两字串大小
-- 流程函数
case when [condition] then result [when [condition] then result ...] [else result] end   多分支
if(expr1,expr2,expr3)  双分支。
-- 聚合函数
count()
sum();
max();
min();
avg();
group_concat()
-- 其他常用函数
md5();
default();
--// 存储函数，自定义函数 ----------
-- 新建
    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型
        函数体
    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。
    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。
    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。
    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。
    - 多条语句应该使用 begin...end 语句块包含。
    - 一定要有 return 返回值语句。
-- 删除
    DROP FUNCTION [IF EXISTS] function_name;
-- 查看
    SHOW FUNCTION STATUS LIKE &#39;partten&#39;
    SHOW CREATE FUNCTION function_name;
-- 修改
    ALTER FUNCTION function_name 函数选项
--// 存储过程，自定义功能 ----------
-- 定义
存储存储过程 是一段代码（过程），存储在数据库中的sql组成。
一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。
而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。
-- 创建
CREATE PROCEDURE sp_name (参数列表)
    过程体
参数列表：不同于函数的参数列表，需要指明参数类型
IN，表示输入型
OUT，表示输出型
INOUT，表示混合型
注意，没有返回值。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br></div></div><h3 id="存储过程"> 存储过程</h3>
<div><pre><code>/* 存储过程 */ ------------------
存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。
调用：CALL 过程名
-- 注意
- 没有返回值。
- 只能单独调用，不可夹杂在其他语句中
-- 参数
IN|OUT|INOUT 参数名 数据类型
IN      输入：在调用过程中，将数据输入到过程体内部的参数
OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端
INOUT   输入输出：既可输入，也可输出
-- 语法
CREATE PROCEDURE 过程名 (参数列表)
BEGIN
    过程体
END
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="用户和权限管理"> 用户和权限管理</h3>
<div><pre><code>/* 用户和权限管理 */ ------------------
-- root密码重置
1. 停止MySQL服务
2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp;
    [Windows] mysqld --skip-grant-tables
3. use mysql;
4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;
5. FLUSH PRIVILEGES;
用户信息表：mysql.user
-- 刷新权限
FLUSH PRIVILEGES;
-- 增加用户
CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)
    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。
    - 只能创建用户，不能赋予权限。
    - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39;
    - 密码也需引号，纯数字密码也要加引号
    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD
-- 重命名用户
RENAME USER old_user TO new_user
-- 设置密码
SET PASSWORD = PASSWORD(&#39;密码&#39;)  -- 为当前用户设置密码
SET PASSWORD FOR 用户名 = PASSWORD(&#39;密码&#39;) -- 为指定用户设置密码
-- 删除用户
DROP USER 用户名
-- 分配权限/添加用户
GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#39;password&#39;]
    - all privileges 表示所有权限
    - *.* 表示所有库的所有表
    - 库名.表名 表示某库下面的某表
    GRANT ALL PRIVILEGES ON `pms`.* TO &#39;pms&#39;@&#39;%&#39; IDENTIFIED BY &#39;pms0817&#39;;
-- 查看权限
SHOW GRANTS FOR 用户名
    -- 查看当前用户权限
    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();
-- 撤消权限
REVOKE 权限列表 ON 表名 FROM 用户名
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限
-- 权限层级
-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。
全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user
    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。
数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host
    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。
表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv
    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。
列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv
    当使用REVOKE时，您必须指定与被授权列相同的列。
-- 权限列表
ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限
ALTER   -- 允许使用ALTER TABLE
ALTER ROUTINE   -- 更改或取消已存储的子程序
CREATE  -- 允许使用CREATE TABLE
CREATE ROUTINE  -- 创建已存储的子程序
CREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE
CREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。
CREATE VIEW     -- 允许使用CREATE VIEW
DELETE  -- 允许使用DELETE
DROP    -- 允许使用DROP TABLE
EXECUTE     -- 允许用户运行已存储的子程序
FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE
INDEX   -- 允许使用CREATE INDEX和DROP INDEX
INSERT  -- 允许使用INSERT
LOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES
PROCESS     -- 允许使用SHOW FULL PROCESSLIST
REFERENCES  -- 未被实施
RELOAD  -- 允许使用FLUSH
REPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址
REPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）
SELECT  -- 允许使用SELECT
SHOW DATABASES  -- 显示所有数据库
SHOW VIEW   -- 允许使用SHOW CREATE VIEW
SHUTDOWN    -- 允许使用mysqladmin shutdown
SUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。
UPDATE  -- 允许使用UPDATE
USAGE   -- “无权限”的同义词
GRANT OPTION    -- 允许授予权限
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div><h3 id="表维护"> 表维护</h3>
<div><pre><code>/* 表维护 */
-- 分析和存储表的关键字分布
ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...
-- 检查一个或多个表是否有错误
CHECK TABLE tbl_name [, tbl_name] ... [option] ...
option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
-- 整理数据文件的碎片
OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="杂项"> 杂项</h3>
<div><pre><code>/* 杂项 */ ------------------
1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！
2. 每个库目录存在一个保存当前数据库的选项文件db.opt。
3. 注释：
    单行注释 # 注释内容
    多行注释 /* 注释内容 */
    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)
4. 模式通配符：
    _   任意单个字符
    %   任意多个字符，甚至包括零字符
    单引号需要进行转义 \&#39;
5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。
6. SQL对大小写不敏感
7. 清除已有语句：\c
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>一条 SQL 语句在 MySQL 中如何被执行的?</title>
      <link>https://javaguide.cn/database/mysql/how-sql-executed-in-mysql/</link>
      <guid>https://javaguide.cn/database/mysql/how-sql-executed-in-mysql/</guid>
      <source url="https://javaguide.cn/rss.xml">一条 SQL 语句在 MySQL 中如何被执行的?</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文来自<a href="https://github.com/kinglaw1204" target="_blank" rel="noopener noreferrer">木木匠</a>投稿。</p>
<p>本篇文章会分析下一个 sql 语句在 MySQL 中的执行流程，包括 sql 的查询在 MySQL 内部会怎么流转，sql 语句的更新是怎么完成的。</p>
<p>在分析之前我会先带着你看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。</p>
<h2 id="一-mysql-基础架构分析"> 一 MySQL 基础架构分析</h2>
<h3 id="_1-1-mysql-基本架构概览"> 1.1 MySQL 基本架构概览</h3>
<p>下图是 MySQL  的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p>
<p>先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。</p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。
</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png" alt="" /></p>
<p>简单来说 MySQL  主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
<h3 id="_1-2-server-层基本组件介绍"> 1.2 Server 层基本组件介绍</h3>
<h4 id="_1-连接器"> 1) 连接器</h4>
<p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。</p>
<h4 id="_2-查询缓存-mysql-8-0-版本后移除"> 2) 查询缓存(MySQL 8.0 版本后移除)</h4>
<p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
<h4 id="_3-分析器"> 3) 分析器</h4>
<p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>
<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>
<h4 id="_4-优化器"> 4) 优化器</h4>
<p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
<h4 id="_5-执行器"> 5) 执行器</h4>
<p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
<h2 id="二-语句分析"> 二 语句分析</h2>
<h3 id="_2-1-查询语句"> 2.1 查询语句</h3>
<p>说了以上这么多，那么究竟一条 sql 语句是如何执行的呢？其实我们的 sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：</p>
<div><pre><code><span>select</span> <span>*</span> <span>from</span> tb_student  A <span>where</span> A<span>.</span>age<span>=</span><span>'18'</span> <span>and</span> A<span>.</span>name<span>=</span><span>' 张三 '</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<ul>
<li>
<p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>
</li>
<li>
<p>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>
</li>
<li>
<p>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</p>
<div><pre><code>  a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。
  b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。
</code></pre>
</div><p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li>
<p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>
</li>
</ul>
<h3 id="_2-2-更新语句"> 2.2 更新语句</h3>
<p>以上就是一条查询 sql 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：</p>
<div><pre><code>update tb_student A set A.age=&#39;19&#39; where A.name=&#39; 张三 &#39;;
</code></pre>
<div><span>1</span><br></div></div><p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<ul>
<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
<p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>
<p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p>
<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<ul>
<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul>
<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？
这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>
<ul>
<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>
</ul>
<p>这样就解决了数据一致性的问题。</p>
<h2 id="三-总结"> 三 总结</h2>
<ul>
<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li>
<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）---&gt;查询缓存---&gt;分析器---&gt;优化器---&gt;权限校验---&gt;执行器---&gt;引擎</li>
<li>更新语句执行流程如下：分析器----&gt;权限校验----&gt;执行器---&gt;引擎---redo log(prepare 状态)---&gt;binlog---&gt;redo log(commit状态)</li>
</ul>
<h2 id="四-参考"> 四 参考</h2>
<ul>
<li>《MySQL 实战45讲》</li>
<li>MySQL 5.6参考手册:<a href="https://dev.MySQL.com/doc/refman/5.6/en/" target="_blank" rel="noopener noreferrer">https://dev.MySQL.com/doc/refman/5.6/en/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png" type="image/png"/>
    </item>
    <item>
      <title>InnoDB存储引擎对MVCC的实现</title>
      <link>https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc/</link>
      <guid>https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc/</guid>
      <source url="https://javaguide.cn/rss.xml">InnoDB存储引擎对MVCC的实现</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="一致性非锁定读和锁定读"> 一致性非锁定读和锁定读</h2>
<h3 id="一致性非锁定读"> 一致性非锁定读</h3>
<p>对于 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener noreferrer"><strong>一致性非锁定读（Consistent Nonlocking Reads）</strong> </a>的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</p>
<p>在 <code>InnoDB</code> 存储引擎中，<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html" target="_blank" rel="noopener noreferrer">多版本控制 (multi versioning)</a> 就是对非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会去等待行上锁的释放。相反地，<code>InnoDB</code> 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)</p>
<p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>select</code> 语句（不包括 <code>select ... lock in share mode</code> ,<code>select ... for update</code>）则会使用 <code>一致性非锁定读（MVCC）</code>。并且在 <code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和防止部分幻读</p>
<h3 id="锁定读"> 锁定读</h3>
<p>如果执行的是下列语句，就是 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener noreferrer"><strong>锁定读（Locking Reads）</strong></a></p>
<ul>
<li><code>select ... lock in share mode</code></li>
<li><code>select ... for update</code></li>
<li><code>insert</code>、<code>update</code>、<code>delete</code> 操作</li>
</ul>
<p>在锁定读下，读取的是数据的最新版本，这种读也被称为 <code>当前读（current read）</code>。锁定读会对读取到的记录加锁：</p>
<ul>
<li>
<p><code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</p>
</li>
<li>
<p><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</p>
</li>
</ul>
<p>在一致性非锁定读下，即使读取的记录已被其它事务加上 <code>X</code> 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 <code>Repeatable Read</code> 下 <code>MVCC</code> 防止了部分幻读，这边的 “部分” 是指在 <code>一致性非锁定读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， <strong><code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据</strong></p>
<h2 id="innodb-对-mvcc-的实现"> InnoDB 对 MVCC 的实现</h2>
<p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>
<h3 id="隐藏字段"> 隐藏字段</h3>
<p>在内部，<code>InnoDB</code> 存储引擎为每行数据添加了三个 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html" target="_blank" rel="noopener noreferrer">隐藏字段</a>：</p>
<ul>
<li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li>
<li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li>
<li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li>
</ul>
<h3 id="readview"> ReadView</h3>
<div><pre><code>class ReadView <span>{</span>
  <span>/* ... */</span>
private<span>:</span>
  <span>trx_id_t</span> m_low_limit_id<span>;</span>      <span>/* 大于等于这个 ID 的事务均不可见 */</span>

  <span>trx_id_t</span> m_up_limit_id<span>;</span>       <span>/* 小于这个 ID 的事务均可见 */</span>

  <span>trx_id_t</span> m_creator_trx_id<span>;</span>    <span>/* 创建该 Read View 的事务ID */</span>

  <span>trx_id_t</span> m_low_limit_no<span>;</span>      <span>/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span>

  <span>ids_t</span> m_ids<span>;</span>                  <span>/* 创建 Read View 时的活跃事务列表 */</span>

  m_closed<span>;</span>                     <span>/* 标记 Read View 是否 close */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><a href="https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L298" target="_blank" rel="noopener noreferrer"><code>Read View</code></a> 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”</p>
<p>主要有以下字段：</p>
<ul>
<li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>
<li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>
<li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li>
<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>
</ul>
<p><strong>事务可见性示意图</strong>（<a href="https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/#MVCC-1" target="_blank" rel="noopener noreferrer">图源</a>）：</p>
<p><img src="https://leviathan.vip/2019/03/20/InnoDB的事务分析-MVCC/trans_visible.jpg" alt="trans_visible" /></p>
<h3 id="undo-log"> undo-log</h3>
<p><code>undo log</code> 主要有两个作用：</p>
<ul>
<li>当事务回滚时用于将数据恢复到修改前的样子</li>
<li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li>
</ul>
<p><strong>在 <code>InnoDB</code> 存储引擎中 <code>undo log</code> 分为两种： <code>insert undo log</code> 和 <code>update undo log</code>：</strong></p>
<ol>
<li><strong><code>insert undo log</code></strong> ：指在 <code>insert</code> 操作中产生的 <code>undo log</code>。因为 <code>insert</code> 操作的记录只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后直接删除。不需要进行 <code>purge</code> 操作</li>
</ol>
<p><strong><code>insert</code> 时的数据初始状态：</strong></p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/317e91e1-1ee1-42ad-9412-9098d5c6a9ad.png" alt="" /></p>
<ol start="2">
<li><strong><code>update undo log</code></strong> ：<code>update</code> 或 <code>delete</code> 操作中产生的 <code>undo log</code>。该 <code>undo log</code>可能需要提供 <code>MVCC</code> 机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge线程</code> 进行最后的删除</li>
</ol>
<p><strong>数据第一次被修改时：</strong></p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/c52ff79f-10e6-46cb-b5d4-3c9cbcc1934a.png" alt="" /></p>
<p><strong>数据第二次被修改时：</strong></p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/6a276e7a-b0da-4c7b-bdf7-c0c7b7b3b31c.png" alt="" /></p>
<p>不同事务或者相同事务的对同一记录行的修改，会使该记录行的 <code>undo log</code> 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录。</p>
<h3 id="数据可见性算法"> 数据可见性算法</h3>
<p>在 <code>InnoDB</code> 存储引擎中，创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</p>
<p><a href="https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L161" target="_blank" rel="noopener noreferrer">具体的比较算法</a>如下：<a href="https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/#MVCC-1" target="_blank" rel="noopener noreferrer">图源</a></p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/8778836b-34a8-480b-b8c7-654fe207a8c2.png" alt="" /></p>
<ol>
<li>
<p>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</p>
</li>
<li>
<p>如果 DB_TRX_ID &gt;= m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</p>
</li>
<li>
<p>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</p>
</li>
<li>
<p>如果 m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）</p>
<ul>
<li>
<p>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</p>
</li>
<li>
<p>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</p>
</li>
</ul>
</li>
<li>
<p>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</p>
</li>
</ol>
<h2 id="rc-和-rr-隔离级别下-mvcc-的差异"> RC 和 RR 隔离级别下 MVCC 的差异</h2>
<p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p>
<ul>
<li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li>
<li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li>
</ul>
<h2 id="mvcc-解决不可重复读问题"> MVCC 解决不可重复读问题</h2>
<p>虽然 RC 和 RR 都通过 <code>MVCC</code> 来读取快照数据，但由于 <strong>生成 Read View 时机不同</strong>，从而在 RR 级别下实现可重复读</p>
<p>举个例子：</p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/6fb2b9a1-5f14-4dec-a797-e4cf388ed413.png" alt="" /></p>
<h3 id="在-rc-下-readview-生成情况"> 在 RC 下 ReadView 生成情况</h3>
<ol>
<li>
<p><strong><code>假设时间线来到 T4 ，那么此时数据行 id = 1 的版本链为</code>：</strong></p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/a3fd1ec6-8f37-42fa-b090-7446d488fd04.png" alt="" /></p>
</li>
</ol>
<p>由于 RC 级别下每次查询都会生成<code>Read View</code> ，并且事务 101、102 并未提交，此时 <code>103</code> 事务生成的 <code>Read View</code> 中活跃的事务 <strong><code>m_ids</code> 为：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</p>
<ul>
<li>此时最新记录的 <code>DB_TRX_ID</code> 为 101，m_up_limit_id &lt;= 101 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</li>
<li>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</li>
<li>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></li>
</ul>
<ol start="2">
<li>
<p><strong><code>时间线来到 T6 ，数据的版本链为</code>：</strong></p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/528559e9-dae8-4d14-b78d-a5b657c88391.png" alt="markdown" /></p>
</li>
</ol>
<p>因为在 RC 级别下，重新生成 <code>Read View</code>，这时事务 101 已经提交，102 并未提交，所以此时 <code>Read View</code> 中活跃的事务 <strong><code>m_ids</code>：[102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：102，<code>m_creator_trx_id</code>为：103</p>
<ul>
<li>
<p>此时最新记录的 <code>DB_TRX_ID</code> 为 102，m_up_limit_id &lt;= 102 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</p>
</li>
<li>
<p>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 为 101，满足 101 &lt; m_up_limit_id，记录可见，所以在 <code>T6</code> 时间点查询到数据为 <code>name = 李四</code>，与时间 T4 查询到的结果不一致，不可重复读！</p>
</li>
</ul>
<ol start="3">
<li><strong><code>时间线来到 T9 ，数据的版本链为</code>：</strong></li>
</ol>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/6f82703c-36a1-4458-90fe-d7f4edbac71a.png" alt="markdown" /></p>
<p>重新生成 <code>Read View</code>， 这时事务 101 和 102 都已经提交，所以 <strong>m_ids</strong> 为空，则 m_up_limit_id = m_low_limit_id = 104，最新版本事务 ID 为 102，满足 102 &lt; m_low_limit_id，可见，查询结果为 <code>name = 赵六</code></p>
<blockquote>
<p><strong>总结：</strong> <strong>在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</strong></p>
</blockquote>
<h3 id="在-rr-下-readview-生成情况"> 在 RR 下 ReadView 生成情况</h3>
<p><strong>在可重复读级别下，只会在事务开始后第一次读取数据时生成一个 Read View（m_ids 列表）</strong></p>
<ol>
<li><strong><code>在 T4 情况下的版本链为</code>：</strong></li>
</ol>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/0e906b95-c916-4f30-beda-9cb3e49746bf.png" alt="markdown" /></p>
<p>在当前执行 <code>select</code> 语句时生成一个 <code>Read View</code>，此时 <strong><code>m_ids</code>：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</p>
<p>此时和 RC 级别下一样：</p>
<ul>
<li>最新记录的 <code>DB_TRX_ID</code> 为 101，m_up_limit_id &lt;= 101 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</li>
<li>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</li>
<li>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></li>
</ul>
<ol start="2">
<li>
<p><strong><code>时间点 T6 情况下</code>：</strong></p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/79ed6142-7664-4e0b-9023-cf546586aa39.png" alt="markdown" /></p>
<p>在 RR 级别下只会生成一次<code>Read View</code>，所以此时依然沿用 <strong><code>m_ids</code> ：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</p>
</li>
</ol>
<ul>
<li>
<p>最新记录的 <code>DB_TRX_ID</code> 为 102，m_up_limit_id &lt;= 102 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</p>
</li>
<li>
<p>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 为 101，不可见</p>
</li>
<li>
<p>继续根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</p>
</li>
<li>
<p>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></p>
</li>
</ul>
<ol start="3">
<li><strong>时间点 T9 情况下：</strong></li>
</ol>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/cbbedbc5-0e3c-4711-aafd-7f3d68a4ed4e.png" alt="markdown" /></p>
<p>此时情况跟 T6 完全一样，由于已经生成了 <code>Read View</code>，此时依然沿用 <strong><code>m_ids</code> ：[101,102]</strong> ，所以查询结果依然是 <code>name = 菜花</code></p>
<h2 id="mvcc➕next-key-lock-防止幻读"> MVCC➕Next-key-Lock 防止幻读</h2>
<p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p>
<p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p>
<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p>
<p><strong>2、执行 select...for update/lock in share mode、insert、update、delete 等当前读</strong></p>
<p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks" target="_blank" rel="noopener noreferrer">Next-key Lock</a> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p>
<h2 id="参考"> 参考</h2>
<ul>
<li><strong>《MySQL 技术内幕 InnoDB 存储引擎第 2 版》</strong></li>
<li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener noreferrer">Innodb 中的事务隔离级别和锁的关系</a></li>
<li><a href="https://blog.csdn.net/qq_35190492/article/details/109044141" target="_blank" rel="noopener noreferrer">MySQL 事务与 MVCC 如何实现的隔离级别</a></li>
<li><a href="https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/" target="_blank" rel="noopener noreferrer">InnoDB 事务分析-MVCC</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/trans_visible.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>MySQL 高性能优化规范建议</title>
      <link>https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations/</link>
      <guid>https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations/</guid>
      <source url="https://javaguide.cn/rss.xml">MySQL 高性能优化规范建议</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>作者: 听风，原文地址: <a href="https://www.cnblogs.com/huchong/p/10219318.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/huchong/p/10219318.html</a>。JavaGuide 已获得作者授权。</p>
</blockquote>
<h2 id="数据库命令规范"> 数据库命令规范</h2>
<ul>
<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>
<li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>
<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>
<li>临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀</li>
<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>
</ul>
<hr>
<h2 id="数据库基本设计规范"> 数据库基本设计规范</h2>
<h3 id="_1-所有表必须使用-innodb-存储引擎"> 1. 所有表必须使用 Innodb 存储引擎</h3>
<p>没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。</p>
<p>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>
<h3 id="_2-数据库和表的字符集统一使用-utf8"> 2. 数据库和表的字符集统一使用 UTF8</h3>
<p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p>
<p>参考文章：<a href="https://blog.csdn.net/horses/article/details/107243447" target="_blank" rel="noopener noreferrer">MySQL 字符集不一致导致索引失效的一个真实案例</a></p>
<h3 id="_3-所有表和字段都需要添加注释"> 3. 所有表和字段都需要添加注释</h3>
<p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p>
<h3 id="_4-尽量控制单表数据量的大小-建议控制在-500-万以内。"> 4. 尽量控制单表数据量的大小,建议控制在 500 万以内。</h3>
<p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>
<p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
<h3 id="_5-谨慎使用-mysql-分区表"> 5. 谨慎使用 MySQL 分区表</h3>
<p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>
<p>谨慎选择分区键，跨分区查询效率可能更低；</p>
<p>建议采用物理分表的方式管理大数据。</p>
<h3 id="_6-尽量做到冷热数据分离-减小表的宽度"> 6.尽量做到冷热数据分离,减小表的宽度</h3>
<blockquote>
<p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。</p>
</blockquote>
<p>减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；</p>
<p>更有效的利用缓存，避免读入无用的冷数据；</p>
<p>经常一起使用的列放到一个表中（避免更多的关联操作）。</p>
<h3 id="_7-禁止在表中建立预留字段"> 7. 禁止在表中建立预留字段</h3>
<p>预留字段的命名很难做到见名识义。</p>
<p>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</p>
<p>对预留字段类型的修改，会对表进行锁定。</p>
<h3 id="_8-禁止在数据库中存储图片-文件等大的二进制数据"> 8. 禁止在数据库中存储图片,文件等大的二进制数据</h3>
<p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。</p>
<p>通常存储于文件服务器，数据库只存储文件地址信息</p>
<h3 id="_9-禁止在线上做数据库压力测试"> 9. 禁止在线上做数据库压力测试</h3>
<h3 id="_10-禁止从开发环境-测试环境直接连接生产环境数据库"> 10. 禁止从开发环境,测试环境直接连接生产环境数据库</h3>
<hr>
<h2 id="数据库字段设计规范"> 数据库字段设计规范</h2>
<h3 id="_1-优先选择符合存储需要的最小的数据类型"> 1. 优先选择符合存储需要的最小的数据类型</h3>
<p><strong>原因：</strong></p>
<p>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。</p>
<p><strong>方法：</strong></p>
<p><strong>a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</strong></p>
<p>MySQL 提供了两个方法来处理 ip 地址</p>
<ul>
<li>inet_aton 把 ip 转为无符号整型 (4-8 位)</li>
<li>inet_ntoa 把整型的 ip 转为地址</li>
</ul>
<p>插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。</p>
<p><strong>b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储</strong></p>
<p><strong>原因：</strong></p>
<p>无符号相对于有符号可以多出一倍的存储空间</p>
<div><pre><code>SIGNED INT -2147483648~2147483647
UNSIGNED INT 0~4294967295
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>VARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。<strong>过大的长度会消耗更多的内存。</strong></p>
<h3 id="_2-避免使用-text-blob-数据类型-最常见的-text-类型可以存储-64k-的数据"> 2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h3>
<p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</strong></p>
<p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>
<p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>
<p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p>
<p>因为<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247487885&amp;idx=1&amp;sn=65b1bf5f7d4505502620179669a9c2df&amp;chksm=ebd62ea1dca1a7b7bf884bcd9d538d78ba064ee03c09436ca8e57873b1d98a55afd6d7884cfc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">MySQL</a> 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p>
<h3 id="_3-避免使用-enum-类型"> 3. 避免使用 ENUM 类型</h3>
<p>修改 ENUM 值需要使用 ALTER 语句</p>
<p>ENUM 类型的 ORDER BY 操作效率低，需要额外操作</p>
<p>禁止使用数值作为 ENUM 的枚举值</p>
<h3 id="_4-尽可能把所有列定义为-not-null"> 4. 尽可能把所有列定义为 NOT NULL</h3>
<p><strong>原因：</strong></p>
<p>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间</p>
<p>进行比较和计算时要对 NULL 值做特别的处理</p>
<h3 id="_5-使用-timestamp-4-个字节-或-datetime-类型-8-个字节-存储时间"> 5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h3>
<p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p>
<p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p>
<p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p>
<p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p>
<ul>
<li>缺点 1：无法用日期函数进行计算和比较</li>
<li>缺点 2：用字符串存储日期要占用更多的空间</li>
</ul>
<h3 id="_6-同财务相关的金额类数据必须使用-decimal-类型"> 6. 同财务相关的金额类数据必须使用 decimal 类型</h3>
<ul>
<li>非精准浮点：float,double</li>
<li>精准浮点：decimal</li>
</ul>
<p>Decimal 类型为精准浮点数，在计算时不会丢失精度</p>
<p>占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节</p>
<p>可用于存储比 bigint 更大的整型数据</p>
<hr>
<h2 id="索引设计规范"> 索引设计规范</h2>
<h3 id="_1-限制每张表上的索引数量-建议单张表索引不超过-5-个"> 1. 限制每张表上的索引数量,建议单张表索引不超过 5 个</h3>
<p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>
<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>
<h3 id="_2-禁止给表中的每一列都建立单独的索引"> 2. 禁止给表中的每一列都建立单独的索引</h3>
<p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p>
<h3 id="_3-每个-innodb-表必须有个主键"> 3. 每个 Innodb 表必须有个主键</h3>
<p>Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>
<p>Innodb 是按照主键索引的顺序来组织表的</p>
<ul>
<li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li>
<li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li>
<li>主键建议使用自增 ID 值</li>
</ul>
<hr>
<h3 id="_4-常见索引列建议"> 4. 常见索引列建议</h3>
<ul>
<li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li>
<li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li>
<li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li>
<li>多表 join 的关联列</li>
</ul>
<hr>
<h3 id="_5-如何选择索引列的顺序"> 5.如何选择索引列的顺序</h3>
<p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>
<ul>
<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li>
<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>
</ul>
<hr>
<h3 id="_6-避免建立冗余索引和重复索引-增加了查询优化器生成执行计划的时间"> 6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h3>
<ul>
<li>重复索引示例：primary key(id)、index(id)、unique index(id)</li>
<li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li>
</ul>
<hr>
<h3 id="_7-对于频繁的查询优先考虑使用覆盖索引"> 7. 对于频繁的查询优先考虑使用覆盖索引</h3>
<blockquote>
<p>覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p>
</blockquote>
<p><strong>覆盖索引的好处：</strong></p>
<ul>
<li><strong>避免 Innodb 表进行索引的二次查询:</strong> Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>
<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li>
</ul>
<hr>
<h3 id="_8-索引-set-规范"> 8.索引 SET 规范</h3>
<p><strong>尽量避免使用外键约束</strong></p>
<ul>
<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li>
<li>外键可用于保证数据的参照完整性，但建议在业务端实现</li>
<li>外键会影响父表和子表的写操作从而降低性能</li>
</ul>
<hr>
<h2 id="数据库-sql-开发规范"> 数据库 SQL 开发规范</h2>
<h3 id="_1-建议使用预编译语句进行数据库操作"> 1. 建议使用预编译语句进行数据库操作</h3>
<p>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</p>
<p>只传参数，比传递 SQL 语句更高效。</p>
<p>相同语句可以一次解析，多次使用，提高处理效率。</p>
<h3 id="_2-避免数据类型的隐式转换"> 2. 避免数据类型的隐式转换</h3>
<p>隐式转换会导致索引失效如:</p>
<div><pre><code>select name,phone from customer where id = &#39;111&#39;;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_3-充分利用表上已经存在的索引"> 3. 充分利用表上已经存在的索引</h3>
<p>避免使用双%号的查询条件。如：<code>a like '%123%'</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p>
<p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p>
<p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p>
<h3 id="_4-数据库设计时-应该要对以后扩展进行考虑"> 4. 数据库设计时，应该要对以后扩展进行考虑</h3>
<h3 id="_5-程序连接不同的数据库使用不同的账号-禁止跨库查询"> 5. 程序连接不同的数据库使用不同的账号，禁止跨库查询</h3>
<ul>
<li>为数据库迁移和分库分表留出余地</li>
<li>降低业务耦合度</li>
<li>避免权限过大而产生的安全风险</li>
</ul>
<h3 id="_6-禁止使用-select-必须使用-select-字段列表-查询"> 6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h3>
<p><strong>原因：</strong></p>
<ul>
<li>消耗更多的 CPU 和 IO 以网络带宽资源</li>
<li>无法使用覆盖索引</li>
<li>可减少表结构变更带来的影响</li>
</ul>
<h3 id="_7-禁止使用不含字段列表的-insert-语句"> 7. 禁止使用不含字段列表的 INSERT 语句</h3>
<p>如：</p>
<div><pre><code>insert into values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);
</code></pre>
<div><span>1</span><br></div></div><p>应使用：</p>
<div><pre><code>insert into t(c1,c2,c3) values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);
</code></pre>
<div><span>1</span><br></div></div><h3 id="_8-避免使用子查询-可以把子查询优化为-join-操作"> 8. 避免使用子查询，可以把子查询优化为 join 操作</h3>
<p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p>
<p><strong>子查询性能差的原因：</strong></p>
<p>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
<p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p>
<h3 id="_9-避免使用-join-关联太多的表"> 9. 避免使用 JOIN 关联太多的表</h3>
<p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p>
<p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p>
<p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p>
<p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p>
<h3 id="_10-减少同数据库的交互次数"> 10. 减少同数据库的交互次数</h3>
<p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p>
<h3 id="_11-对应同一列进行-or-判断时-使用-in-代替-or"> 11. 对应同一列进行 or 判断时，使用 in 代替 or</h3>
<p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>
<h3 id="_12-禁止使用-order-by-rand-进行随机排序"> 12. 禁止使用 order by rand() 进行随机排序</h3>
<p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>
<p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p>
<h3 id="_13-where-从句中禁止对列进行函数转换和计算"> 13. WHERE 从句中禁止对列进行函数转换和计算</h3>
<p>对列进行函数转换或计算时会导致无法使用索引</p>
<p><strong>不推荐：</strong></p>
<div><pre><code>where date(create_time)=&#39;20190101&#39;
</code></pre>
<div><span>1</span><br></div></div><p><strong>推荐：</strong></p>
<div><pre><code>where create_time &gt;= &#39;20190101&#39; and create_time &lt; &#39;20190102&#39;
</code></pre>
<div><span>1</span><br></div></div><h3 id="_14-在明显不会有重复值时使用-union-all-而不是-union"> 14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION</h3>
<ul>
<li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li>
<li>UNION ALL 不会再对结果集进行去重操作</li>
</ul>
<h3 id="_15-拆分复杂的大-sql-为多个小-sql"> 15. 拆分复杂的大 SQL 为多个小 SQL</h3>
<ul>
<li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li>
<li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li>
<li>SQL 拆分后可以通过并行执行来提高处理效率</li>
</ul>
<hr>
<h2 id="数据库操作行为规范"> 数据库操作行为规范</h2>
<h3 id="_1-超-100-万行的批量写-update-delete-insert-操作-要分批多次进行操作"> 1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h3>
<p><strong>大批量操作可能会造成严重的主从延迟</strong></p>
<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，
而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>
<p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p>
<p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>
<p><strong>避免产生大事务操作</strong></p>
<p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>
<p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>
<h3 id="_2-对于大表使用-pt-online-schema-change-修改表结构"> 2. 对于大表使用 pt-online-schema-change 修改表结构</h3>
<ul>
<li>避免大表修改产生的主从延迟</li>
<li>避免在对表字段进行修改时进行锁表</li>
</ul>
<p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p>
<p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p>
<h3 id="_3-禁止为程序使用的账号赋予-super-权限"> 3. 禁止为程序使用的账号赋予 super 权限</h3>
<ul>
<li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li>
<li>super 权限只能留给 DBA 处理问题的账号使用</li>
</ul>
<h3 id="_4-对于程序连接数据库账号-遵循权限最小原则"> 4. 对于程序连接数据库账号,遵循权限最小原则</h3>
<ul>
<li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li>
<li>程序使用的账号原则上不准有 drop 权限</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>MySQL三大日志(binlog、redo log和undo log)详解</title>
      <link>https://javaguide.cn/database/mysql/mysql-logs/</link>
      <guid>https://javaguide.cn/database/mysql/mysql-logs/</guid>
      <source url="https://javaguide.cn/rss.xml">MySQL三大日志(binlog、redo log和undo log)详解</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文来自公号程序猿阿星投稿，JavaGuide 对其做了补充完善。</p>
</blockquote>
<h2 id="前言"> 前言</h2>
<p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/01.png" alt="" /></p>
<p>今天就来聊聊 <code>redo log</code>（重做日志）、<code>binlog</code>（归档日志）、两阶段提交、<code>undo log</code> （回滚日志）。</p>
<h2 id="redo-log"> redo log</h2>
<p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p>
<p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/02.png" alt="" /></p>
<p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>
<p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p>
<p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p>
<p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/03.png" alt="" /></p>
<blockquote>
<p>图片笔误提示：第4步 “清空 redo log buffe 刷盘到 redo 日志中”这句话中的 buffe 应该是 buffer。</p>
</blockquote>
<p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p>
<blockquote>
<p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>
</blockquote>
<h3 id="刷盘时机"> 刷盘时机</h3>
<p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>
<ul>
<li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li>
<li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>
<li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>
</ul>
<p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p>
<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/04.png" alt="" /></p>
<p>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘。</p>
<p><strong>为什么呢？</strong></p>
<p>因为在事务执行过程 <code>redo log</code> 记录是会写入<code>redo log buffer</code> 中，这些 <code>redo log</code> 记录会被后台线程刷盘。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/05.png" alt="" /></p>
<p>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘。</p>
<p>下面是不同刷盘策略的流程图。</p>
<h4 id="innodb-flush-log-at-trx-commit-0"> innodb_flush_log_at_trx_commit=0</h4>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/06.png" alt="" /></p>
<p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p>
<h4 id="innodb-flush-log-at-trx-commit-1"> innodb_flush_log_at_trx_commit=1</h4>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/07.png" alt="" /></p>
<p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p>
<h4 id="innodb-flush-log-at-trx-commit-2"> innodb_flush_log_at_trx_commit=2</h4>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/09.png" alt="" /></p>
<p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p>
<p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p>
<h3 id="日志文件组"> 日志文件组</h3>
<p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p>
<p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p>
<p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/10.png" alt="" /></p>
<p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p>
<ul>
<li><strong>write pos</strong> 是当前记录的位置，一边写一边后移</li>
<li><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</li>
</ul>
<p>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</p>
<p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p>
<p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/11.png" alt="" /></p>
<p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/12.png" alt="" /></p>
<h3 id="redo-log-小结"> redo log 小结</h3>
<p>相信大家都知道 <code>redo log</code> 的作用和它的刷盘时机、存储形式。</p>
<p>现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p>
<p>它们不都是刷盘么？差别在哪里？</p>
<div><pre><code><span>1</span> <span>Byte</span> <span>=</span> <span>8</span>bit
<span>1</span> KB <span>=</span> <span>1024</span> <span>Byte</span>
<span>1</span> MB <span>=</span> <span>1024</span> KB
<span>1</span> GB <span>=</span> <span>1024</span> MB
<span>1</span> TB <span>=</span> <span>1024</span> GB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p>
<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>
<p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移
量、更新值，再加上是顺序写，所以刷盘速度很快。</p>
<p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p>
<blockquote>
<p>其实内存的数据页在一定时机也会刷盘，我们把这称为页合并，讲 <code>Buffer Pool</code>的时候会对这块细说</p>
</blockquote>
<h2 id="binlog"> binlog</h2>
<p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p>
<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>
<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p>
<p>那 <code>binlog</code> 到底是用来干嘛的？</p>
<p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/04/01.png" alt="" /></p>
<p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>
<h3 id="记录格式"> 记录格式</h3>
<p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ul>
<li><strong>statement</strong></li>
<li><strong>row</strong></li>
<li><strong>mixed</strong></li>
</ul>
<p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/04/02.png" alt="" /></p>
<p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>
<p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/04/03.png" alt="" /></p>
<p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p>
<p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p>
<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p>
<p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>
<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>
<p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>
<h3 id="写入机制"> 写入机制</h3>
<p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p>
<p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>
<p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p>
<p><code>binlog</code>日志刷盘流程如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/04/04.png" alt="" /></p>
<ul>
<li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>
<li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li>
</ul>
<p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p>
<p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/04/05.png" alt="" /></p>
<p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binglog 会丢失。</p>
<p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同<strong>binlog 日志刷盘流程</strong>一样。</p>
<p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/04/06.png" alt="" /></p>
<p>在出现<code>IO</code>瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。</p>
<p>同样的，如果机器宕机，会丢失最近<code>N</code>个事务的<code>binlog</code>日志。</p>
<h2 id="两阶段提交"> 两阶段提交</h2>
<p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p>
<p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>
<p>虽然它们都属于持久化的保证，但是侧重点不同。</p>
<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/05/01.png" alt="" /></p>
<p>回到正题，<code>redo log</code>与<code>binlog</code>两份日志之间的逻辑不一致，会出现什么问题？</p>
<p>我们以<code>update</code>语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段<code>c</code>值更新成<code>1</code>，<code>SQL</code>语句为<code>update T set c=1 where id=2</code>。</p>
<p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，会出现什么情况呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/05/02.png" alt="" /></p>
<p>由于<code>binlog</code>没写完就异常，这时候<code>binlog</code>里面没有对应的修改记录。因此，之后用<code>binlog</code>日志恢复数据时，就会少这一次更新，恢复出来的这一行<code>c</code>值是<code>0</code>，而原库因为<code>redo log</code>日志恢复，这一行<code>c</code>值是<code>1</code>，最终数据不一致。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/05/03.png" alt="" /></p>
<p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p>
<p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/05/04.png" alt="" /></p>
<p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/05/05.png" alt="" /></p>
<p>再看一个场景，<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/05/06.png" alt="" /></p>
<p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p>
<h2 id="undo-log"> undo log</h2>
<blockquote>
<p>这部分内容为 JavaGuide 的补充：</p>
</blockquote>
<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>
<h2 id="总结"> 总结</h2>
<blockquote>
<p>这部分内容为 JavaGuide 的补充：</p>
</blockquote>
<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<h2 id="站在巨人的肩膀上"> 站在巨人的肩膀上</h2>
<ul>
<li>《MySQL 实战 45 讲》</li>
<li>《从零开始带你成为 MySQL 实战优化高手》</li>
<li>《MySQL 是怎样运行的：从根儿上理解 MySQL》</li>
<li>《MySQL 技术 Innodb 存储引擎》</li>
</ul>
<h2 id="mysql-好文推荐"> MySQL 好文推荐</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/R-1km7r0z3oWfwYQV8iiqA" target="_blank" rel="noopener noreferrer">CURD 这么多年，你有了解过 MySQL 的架构设计吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/7Kab4IQsNcU_bZdbv_MuOg" target="_blank" rel="noopener noreferrer">浅谈 MySQL InnoDB 的内存组件</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/01.png" type="image/png"/>
    </item>
    <item>
      <title>MySQL 索引详解</title>
      <link>https://javaguide.cn/database/mysql/mysql-index/</link>
      <guid>https://javaguide.cn/database/mysql/mysql-index/</guid>
      <source url="https://javaguide.cn/rss.xml">MySQL 索引详解</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="何为索引-有什么作用"> 何为索引？有什么作用？</h2>
<p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p>
<p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<h2 id="索引的优缺点"> 索引的优缺点</h2>
<p><strong>优点</strong> ：</p>
<ul>
<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h2 id="索引的底层数据结构"> 索引的底层数据结构</h2>
<h3 id="hash表-b-树"> Hash表 &amp; B+树</h3>
<p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
<p><strong>为何能够通过 key 快速取出 value呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 value 对应的 index，找到了 index 也就找到了对应的 value。</p>
<div><pre><code>hash <span>=</span> <span>hashfunc</span><span>(</span>key<span>)</span>
index <span>=</span> hash <span>%</span> array_size
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><img src="https://img-blog.csdnimg.cn/20210513092328171.png" alt="" /></p>
<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的  key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p>
<p><img src="https://img-blog.csdnimg.cn/20210513092224836.png" alt="" /></p>
<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p>
<p>既然哈希表这么快，<strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong></p>
<p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p>
<p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p>
<p>试想一种情况:</p>
<div><pre><code>SELECT <span>*</span> FROM tb1 WHERE id <span>&lt;</span> <span>500</span><span>;</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>
</code></pre>
<div><span>1</span><br></div></div><p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p>
<h3 id="b-树-b-树"> B 树&amp; B+树</h3>
<p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p>
<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p>
<p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210420165409106.png" alt="" /></p>
<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p>
<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h2 id="索引类型"> 索引类型</h2>
<h3 id="主键索引-primary-key"> 主键索引(Primary Key)</h3>
<p>数据表的主键列使用的就是主键索引。</p>
<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>
<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>
<h3 id="二级索引-辅助索引"> 二级索引(辅助索引)</h3>
<p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<p><strong>PS:不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</strong></p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，
因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ol>
<p>二级索引:
<img src="https://img-blog.csdnimg.cn/20210420165254215.png" alt="" /></p>
<h2 id="聚集索引与非聚集索引"> 聚集索引与非聚集索引</h2>
<h3 id="聚集索引"> 聚集索引</h3>
<p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<h4 id="聚集索引的优点"> 聚集索引的优点</h4>
<p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<h4 id="聚集索引的缺点"> 聚集索引的缺点</h4>
<ol>
<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，
而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，
所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
<h3 id="非聚集索引"> 非聚集索引</h3>
<p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p>
<p><strong>二级索引属于非聚集索引。</strong></p>
<blockquote>
<p>MYISAM 引擎的表的.MYI 文件包含了表的索引，
该表的索引(B+树)的每个叶子非叶子节点存储索引，
叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p>
<p><strong>非聚集索引的叶子节点并不一定存放数据的指针，
因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p>
</blockquote>
<h4 id="非聚集索引的优点"> 非聚集索引的优点</h4>
<p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<h4 id="非聚集索引的缺点"> 非聚集索引的缺点</h4>
<ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ol>
<p>这是 MySQL 的表的文件截图:</p>
<p><img src="https://img-blog.csdnimg.cn/20210420165311654.png" alt="" /></p>
<p>聚集索引和非聚集索引:</p>
<p><img src="https://img-blog.csdnimg.cn/20210420165326946.png" alt="" /></p>
<h3 id="非聚集索引一定回表查询吗-覆盖索引"> 非聚集索引一定回表查询吗(覆盖索引)?</h3>
<p><strong>非聚集索引不一定回表查询。</strong></p>
<blockquote>
<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>
</blockquote>
<div><pre><code> SELECT name FROM table WHERE name=&#39;guang19&#39;;
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>
</blockquote>
<p><strong>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，
因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢?</strong></p>
<div><pre><code>SELECT id FROM table WHERE id=1;
</code></pre>
<div><span>1</span><br></div></div><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>
<h2 id="覆盖索引"> 覆盖索引</h2>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，
而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，
那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<p>覆盖索引:
<img src="https://img-blog.csdnimg.cn/20210420165341868.png" alt="" /></p>
<h2 id="创建索引的注意事项"> 创建索引的注意事项</h2>
<p><strong>1.选择合适的字段创建索引：</strong></p>
<ul>
<li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
<p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。
如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p><strong>4.注意避免冗余索引</strong> 。</p>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h2 id="使用索引的一些建议"> 使用索引的一些建议</h2>
<ul>
<li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li>
<li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li>
<li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li>
<li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li>
</ul>
<h2 id="mysql-如何为表字段添加索引"> MySQL 如何为表字段添加索引？</h2>
<p>1.添加 PRIMARY KEY（主键索引）</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> <span>`</span>table_name<span>`</span> <span>ADD</span> <span>PRIMARY</span> <span>KEY</span> <span>(</span> <span>`</span><span>column</span><span>`</span> <span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>2.添加 UNIQUE(唯一索引)</p>
<div><pre><code>ALTER TABLE `table_name` ADD UNIQUE ( `column` )
</code></pre>
<div><span>1</span><br></div></div><p>3.添加 INDEX(普通索引)</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> <span>`</span>table_name<span>`</span> <span>ADD</span> <span>INDEX</span> index_name <span>(</span> <span>`</span><span>column</span><span>`</span> <span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>4.添加 FULLTEXT(全文索引)</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> <span>`</span>table_name<span>`</span> <span>ADD</span> FULLTEXT <span>(</span> <span>`</span><span>column</span><span>`</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>5.添加多列索引</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> <span>`</span>table_name<span>`</span> <span>ADD</span> <span>INDEX</span> index_name <span>(</span> <span>`</span>column1<span>`</span><span>,</span> <span>`</span>column2<span>`</span><span>,</span> <span>`</span>column3<span>`</span> <span>)</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/20210513092328171.png" type="image/png"/>
    </item>
    <item>
      <title>关于数据库中如何存储时间的一点思考</title>
      <link>https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time/</link>
      <guid>https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time/</guid>
      <source url="https://javaguide.cn/rss.xml">关于数据库中如何存储时间的一点思考</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>我们平时开发中不可避免的就是要存储时间，比如我们要记录操作表中这条记录的时间、记录转账的交易时间、记录出发时间等等。你会发现时间这个东西与我们开发的联系还是非常紧密的，用的好与不好会给我们的业务甚至功能带来很大的影响。所以，我们有必要重新出发，好好认识一下这个东西。</p>
<p>这是一篇短小精悍的文章，仔细阅读一定能学到不少东西！</p>
<h3 id="_1-切记不要用字符串存储日期"> 1.切记不要用字符串存储日期</h3>
<p>我记得我在大学的时候就这样干过，而且现在很多对数据库不太了解的新手也会这样干，可见，这种存储日期的方式的优点还是有的，就是简单直白，容易上手。</p>
<p>但是，这是不正确的做法，主要会有下面两个问题：</p>
<ol>
<li>字符串占用的空间更大！</li>
<li>字符串存储的日期效率比较低（逐个字符进行比对），无法用日期相关的 API 进行计算和比较。</li>
</ol>
<h3 id="_2-datetime-和-timestamp-之间抉择"> 2.Datetime 和 Timestamp 之间抉择</h3>
<p>Datetime 和 Timestamp 是 MySQL 提供的两种比较相似的保存时间的数据类型。他们两者究竟该如何选择呢？</p>
<p><strong>通常我们都会首选 Timestamp。</strong> 下面说一下为什么这样做!</p>
<h4 id="_2-1-datetime-类型没有时区信息"> 2.1 DateTime 类型没有时区信息</h4>
<p><strong>DateTime 类型是没有时区信息的（时区无关）</strong> ，DateTime 类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。不要小看这个问题，很多系统就是因为这个问题闹出了很多笑话。</p>
<p><strong>Timestamp 和时区有关</strong>。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。</p>
<p>下面实际演示一下！</p>
<p>建表 SQL 语句：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> <span>`</span>time_zone_test<span>`</span> <span>(</span>
  <span>`</span>id<span>`</span> <span>bigint</span><span>(</span><span>20</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>AUTO_INCREMENT</span><span>,</span>
  <span>`</span>date_time<span>`</span> <span>datetime</span> <span>DEFAULT</span> <span>NULL</span><span>,</span>
  <span>`</span>time_stamp<span>`</span> <span>timestamp</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>CURRENT_TIMESTAMP</span> <span>ON</span> <span>UPDATE</span> <span>CURRENT_TIMESTAMP</span><span>,</span>
  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>`</span>id<span>`</span><span>)</span>
<span>)</span> <span>ENGINE</span><span>=</span><span>InnoDB</span> <span>DEFAULT</span> <span>CHARSET</span><span>=</span>utf8<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>插入数据：</p>
<div><pre><code><span>INSERT</span> <span>INTO</span> time_zone_test<span>(</span>date_time<span>,</span>time_stamp<span>)</span> <span>VALUES</span><span>(</span><span>NOW</span><span>(</span><span>)</span><span>,</span><span>NOW</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>查看数据：</p>
<div><pre><code><span>select</span> date_time<span>,</span>time_stamp <span>from</span> time_zone_test<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>结果：</p>
<div><pre><code>+---------------------+---------------------+
| date_time           | time_stamp          |
+---------------------+---------------------+
| 2020-01-11 09:53:32 | 2020-01-11 09:53:32 |
+---------------------+---------------------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>现在我们运行</p>
<p>修改当前会话的时区:</p>
<div><pre><code><span>set</span> time_zone<span>=</span><span>'+8:00'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>再次查看数据：</p>
<div><pre><code>+---------------------+---------------------+
| date_time           | time_stamp          |
+---------------------+---------------------+
| 2020-01-11 09:53:32 | 2020-01-11 17:53:32 |
+---------------------+---------------------+
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>扩展：一些关于 MySQL 时区设置的一个常用 sql 命令</strong></p>
<div><pre><code><span># 查看当前会话时区</span>
<span>SELECT</span> @<span>@session.time_zone</span><span>;</span>
<span># 设置当前会话时区</span>
<span>SET</span> time_zone <span>=</span> <span>'Europe/Helsinki'</span><span>;</span>
<span>SET</span> time_zone <span>=</span> <span>"+00:00"</span><span>;</span>
<span># 数据库全局时区设置</span>
<span>SELECT</span> @<span>@global.time_zone</span><span>;</span>
<span># 设置全局时区</span>
<span>SET</span> <span>GLOBAL</span> time_zone <span>=</span> <span>'+8:00'</span><span>;</span>
<span>SET</span> <span>GLOBAL</span> time_zone <span>=</span> <span>'Europe/Helsinki'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="_2-2-datetime-类型耗费空间更大"> 2.2 DateTime 类型耗费空间更大</h4>
<p>Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p>
<ul>
<li>DateTime ：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>
<li>Timestamp： 1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li>
</ul>
<blockquote>
<p>Timestamp 在不同版本的 MySQL 中有细微差别。</p>
</blockquote>
<h3 id="_3-再看-mysql-日期类型存储空间"> 3 再看 MySQL 日期类型存储空间</h3>
<p>下图是 MySQL 5.6 版本中日期类型所占的存储空间：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/FhRGUVHFK0ujRPNA75f6CuOXQHTE.jpeg" alt="" /></p>
<p>可以看出 5.6.4 之后的 MySQL 多出了一个需要 0 ～ 3 字节的小数位。DateTime 和 Timestamp 会有几种不同的存储空间占用。</p>
<p>为了方便，本文我们还是默认 Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。</p>
<h3 id="_4-数值型时间戳是更好的选择吗"> 4.数值型时间戳是更好的选择吗？</h3>
<p>很多时候，我们也会使用 int 或者 bigint 类型的数值也就是时间戳来表示时间。</p>
<p>这种存储方式的具有 Timestamp 类型的所具有一些优点，并且使用它的进行日期排序以及对比等操作的效率会更高，跨系统也很方便，毕竟只是存放的数值。缺点也很明显，就是数据的可读性太差了，你无法直观的看到具体时间。</p>
<p>时间戳的定义如下：</p>
<blockquote>
<p>时间戳的定义是从一个基准时间开始算起，这个基准时间是「1970-1-1 00:00:00 +0:00」，从这个时间开始，用整数表示，以秒计时，随着时间的流逝这个时间整数不断增加。这样一来，我只需要一个数值，就可以完美地表示时间了，而且这个数值是一个绝对数值，即无论的身处地球的任何角落，这个表示时间的时间戳，都是一样的，生成的数值都是一样的，并且没有时区的概念，所以在系统的中时间的传输中，都不需要进行额外的转换了，只有在显示给用户的时候，才转换为字符串格式的本地时间。</p>
</blockquote>
<p>数据库中实际操作：</p>
<div><pre><code>mysql<span>></span> <span>select</span> UNIX_TIMESTAMP<span>(</span><span>'2020-01-11 09:53:32'</span><span>)</span><span>;</span>
<span>+</span><span>---------------------------------------+</span>
<span>|</span> UNIX_TIMESTAMP<span>(</span><span>'2020-01-11 09:53:32'</span><span>)</span> <span>|</span>
<span>+</span><span>---------------------------------------+</span>
<span>|</span>                            <span>1578707612</span> <span>|</span>
<span>+</span><span>---------------------------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span> <span>select</span> FROM_UNIXTIME<span>(</span><span>1578707612</span><span>)</span><span>;</span>
<span>+</span><span>---------------------------+</span>
<span>|</span> FROM_UNIXTIME<span>(</span><span>1578707612</span><span>)</span> <span>|</span>
<span>+</span><span>---------------------------+</span>
<span>|</span> <span>2020</span><span>-</span><span>01</span><span>-</span><span>11</span> <span>09</span>:<span>53</span>:<span>32</span>       <span>|</span>
<span>+</span><span>---------------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.01</span> sec<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="_5-总结"> 5.总结</h3>
<p>MySQL 中时间到底怎么存储才好？Datetime?Timestamp? 数值保存的时间戳？</p>
<p>好像并没有一个银弹，很多程序员会觉得数值型时间戳是真的好，效率又高还各种兼容，但是很多人又觉得它表现的不够直观。这里插一嘴，《高性能 MySQL 》这本神书的作者就是推荐 Timestamp，原因是数值表示时间不够直观。下面是原文：</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/高性能mysql-不推荐用数值时间戳.jpg" style="zoom:50%;" />
<p>每种方式都有各自的优势，根据实际场景才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/总结-常用日期存储方式.jpg" style="zoom:50%;" />]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/FhRGUVHFK0ujRPNA75f6CuOXQHTE.jpeg" type="image/jpeg"/>
    </item>
    <item>
      <title>MySQL知识点&amp;面试题总结</title>
      <link>https://javaguide.cn/database/mysql/mysql%E7%9F%A5%E8%AF%86%E7%82%B9&amp;%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/database/mysql/mysql%E7%9F%A5%E8%AF%86%E7%82%B9&amp;%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">MySQL知识点&amp;面试题总结</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="mysql-基础"> MySQL 基础</h2>
<h3 id="关系型数据库介绍"> 关系型数据库介绍</h3>
<p>顾名思义，关系型数据库就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p>
<p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" alt="" /></p>
<p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。</p>
<p><strong>有哪些常见的关系型数据库呢？</strong></p>
<p>MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ......。</p>
<h3 id="mysql-介绍"> MySQL 介绍</h3>
<p><img src="https://img-blog.csdnimg.cn/20210327143351823.png" alt="" /></p>
<p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p>
<p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong>3306</strong>。</p>
<h2 id="存储引擎"> 存储引擎</h2>
<h3 id="存储引擎相关的命令"> 存储引擎相关的命令</h3>
<p><strong>查看 MySQL 提供的所有存储引擎</strong></p>
<div><pre><code>mysql<span>></span> <span>show</span> engines<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/mysql-engines.png" alt="查看MySQL提供的所有存储引擎" /></p>
<p>从上图我们可以查看出 MySQL 当前默认的存储引擎是 InnoDB，并且在 5.7 版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p>
<p><strong>查看 MySQL 当前默认的存储引擎</strong></p>
<p>我们也可以通过下面的命令查看默认的存储引擎。</p>
<div><pre><code>mysql<span>></span> <span>show</span> variables <span>like</span> <span>'%storage_engine%'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>查看表的存储引擎</strong></p>
<div><pre><code><span>show</span> <span>table</span> <span>status</span> <span>like</span> <span>"table_name"</span> <span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/查看表的存储引擎.png" alt="查看表的存储引擎" /></p>
<h3 id="myisam-和-innodb-的区别"> MyISAM 和 InnoDB 的区别</h3>
<p><img src="https://img-blog.csdnimg.cn/20210327145248960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="" /></p>
<p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p>
<p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p>
<p>5.5 版本之后，MySQL 引入了 InnoDB（事务性数据库引擎），MySQL 5.5 版本后默认的存储引擎为 InnoDB。小伙子，一定要记好这个 InnoDB ，你每次使用 MySQL 数据库都是用的这个存储引擎吧？</p>
<p>言归正传！咱们下面还是来简单对比一下两者：</p>
<p><strong>1.是否支持行级锁</strong></p>
<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
<p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p>
<p><strong>2.是否支持事务</strong></p>
<p>MyISAM 不提供事务支持。</p>
<p>InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</p>
<p><strong>3.是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>🌈 拓展一下：</p>
<p>一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>
<p>🌈 拓展一下：</p>
<ul>
<li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li>
<li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li>
<li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li>
</ul>
<p><strong>5.是否支持 MVCC</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。</p>
<p>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。</p>
<h3 id="关于-myisam-和-innodb-的选择问题"> 关于 MyISAM 和 InnoDB 的选择问题</h3>
<p>大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）。</p>
<p>《MySQL 高性能》上面有一句话这样写到:</p>
<blockquote>
<p>不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p>
</blockquote>
<p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p>
<p>因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。</p>
<h2 id="锁机制与-innodb-锁算法"> 锁机制与 InnoDB 锁算法</h2>
<p><strong>MyISAM 和 InnoDB 存储引擎使用的锁：</strong></p>
<ul>
<li>MyISAM 采用表级锁(table-level locking)。</li>
<li>InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁</li>
</ul>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<p><strong>InnoDB 存储引擎的锁的算法有三种：</strong></p>
<ul>
<li>Record lock：记录锁，单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身</li>
</ul>
<h2 id="查询缓存"> 查询缓存</h2>
<p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p>
<p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p>
<div><pre><code><span>query_cache_type</span><span>=</span><span>1</span>
<span>query_cache_size</span><span>=</span><span>600000</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>MySQL 执行以下命令也可以开启查询缓存</p>
<div><pre><code><span>set</span> <span>global  query_cache_type=1;</span>
<span>set</span> <span>global  query_cache_size=600000;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。（<strong>查询缓存不命中的情况：（1）</strong>）因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，（<strong>查询缓存不命中的情况：（2）</strong>）如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</p>
<p>（<strong>查询缓存不命中的情况：（3）</strong>）<strong>缓存建立之后</strong>，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p>
<p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，<strong>还可以通过 sql_cache 和 sql_no_cache 来控制某个查询语句是否需要缓存：</strong></p>
<div><pre><code><span>select</span> sql_no_cache <span>count</span><span>(</span><span>*</span><span>)</span> <span>from</span> usr<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="事务"> 事务</h2>
<h3 id="何为事务"> 何为事务？</h3>
<p>一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p><strong>可以简单举一个例子不？</strong></p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：</p>
<ol>
<li>将小明的余额减少 1000 元</li>
<li>将小红的余额增加 1000 元。</li>
</ol>
<p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。</p>
<p>这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p>
<h3 id="何为数据库事务"> 何为数据库事务？</h3>
<p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p>
<p>平时，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p>
<p><strong>那数据库事务有什么作用呢？</strong></p>
<p>简单来说：数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p>
<div><pre><code><span># 开启一个事务</span>
<span>START</span> <span>TRANSACTION</span><span>;</span>
<span># 多条 SQL 语句</span>
SQL1<span>,</span>SQL2<span>.</span><span>.</span><span>.</span>
<span>## 提交事务</span>
<span>COMMIT</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/640-20201207160554677.png" alt="" /></p>
<p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/事务特性.png" alt="事务的特性" /></p>
<h3 id="何为-acid-特性呢"> 何为 ACID 特性呢？</h3>
<ol>
<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<p><strong>数据事务的实现原理呢？</strong></p>
<p>我们这里以 MySQL 的 InnoDB 引擎为例来简单说一下。</p>
<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</p>
<p>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p>
<h3 id="并发事务带来哪些问题"> 并发事务带来哪些问题?</h3>
<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读区别：</strong></p>
<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>
<h3 id="事务隔离级别有哪些"> 事务隔离级别有哪些?</h3>
<p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ-UNCOMMITTED</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">READ-COMMITTED</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">REPEATABLE-READ</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">SERIALIZABLE</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<h3 id="mysql-的默认隔离级别是什么"> MySQL 的默认隔离级别是什么?</h3>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> @<span>@tx_isolation</span><span>;</span>
<span>+</span><span>-----------------+</span>
<span>|</span> @<span>@tx_isolation</span>  <span>|</span>
<span>+</span><span>-----------------+</span>
<span>|</span> <span>REPEATABLE</span><span>-</span><span>READ</span> <span>|</span>
<span>+</span><span>-----------------+</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><s>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</s></p>
<p>🐛 问题更正：<strong>MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 Next-Key Locks。</strong></p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
<p>🌈 拓展一下(以下内容摘自《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章)：</p>
<blockquote>
<p>InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p>
</blockquote>
<h2 id="参考"> 参考</h2>
<ul>
<li>《高性能 MySQL》</li>
<li>https://www.omnisci.com/technical-glossary/relational-database</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" type="image/png"/>
    </item>
    <item>
      <title>事务隔离级别(图文详解)</title>
      <link>https://javaguide.cn/database/mysql/transaction-isolation-level/</link>
      <guid>https://javaguide.cn/database/mysql/transaction-isolation-level/</guid>
      <source url="https://javaguide.cn/rss.xml">事务隔离级别(图文详解)</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文由 <a href="https://github.com/Snailclimb" target="_blank" rel="noopener noreferrer">SnailClimb</a> 和 <a href="https://github.com/guang19" target="_blank" rel="noopener noreferrer">guang19</a> 共同完成。</p>
</blockquote>
<h2 id="事务隔离级别-图文详解"> 事务隔离级别(图文详解)</h2>
<h3 id="什么是事务"> 什么是事务?</h3>
<p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h3 id="事务的特性-acid"> 事务的特性(ACID)</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/事务特性.png" alt="事务的特性" /></p>
<ol>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h3 id="并发事务带来的问题"> 并发事务带来的问题</h3>
<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。	例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复度和幻读区别：</strong></p>
<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为     1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导        致A再读自己的工资时工资变为  2000；这就是不可重复读。</p>
<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p>
<h3 id="事务隔离级别"> 事务隔离级别</h3>
<p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻影读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ-UNCOMMITTED</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">READ-COMMITTED</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">REPEATABLE-READ</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">SERIALIZABLE</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> @<span>@tx_isolation</span><span>;</span>
<span>+</span><span>-----------------+</span>
<span>|</span> @<span>@tx_isolation</span>  <span>|</span>
<span>+</span><span>-----------------+</span>
<span>|</span> <span>REPEATABLE</span><span>-</span><span>READ</span> <span>|</span>
<span>+</span><span>-----------------+</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><s>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</s></p>
<p>🐛 问题更正：<strong>MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 Next-Key Locks。</strong></p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
<p>🌈 拓展一下(以下内容摘自《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章)：</p>
<blockquote>
<p>InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p>
</blockquote>
<h3 id="实际情况演示"> 实际情况演示</h3>
<p>在下面我会使用 2 个命令行mysql ，模拟多线程（多事务）对同一份数据的脏读问题。</p>
<p>MySQL 命令行的默认配置中事务都是自动提交的，即执行SQL语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：<code>START TARNSACTION</code>。</p>
<p>我们可以通过下面的命令来设置隔离级别。</p>
<div><pre><code><span>SET</span> <span>[</span><span>SESSION</span><span>|</span><span>GLOBAL</span><span>]</span> <span>TRANSACTION</span> <span>ISOLATION</span> <span>LEVEL</span> <span>[</span><span>READ</span> <span>UNCOMMITTED</span><span>|</span><span>READ</span> <span>COMMITTED</span><span>|</span><span>REPEATABLE</span> <span>READ</span><span>|</span><span>SERIALIZABLE</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>我们再来看一下我们在下面实际操作中使用到的一些并发控制语句:</p>
<ul>
<li><code>START TARNSACTION</code> |<code>BEGIN</code>：显式地开启一个事务。</li>
<li><code>COMMIT</code>：提交事务，使得对数据库做的所有修改成为永久性。</li>
<li><code>ROLLBACK</code>：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li>
</ul>
<h4 id="脏读-读未提交"> 脏读(读未提交)</h4>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-1脏读(读未提交)实例.jpg" width="800px"/>
</div>
<h4 id="避免脏读-读已提交"> 避免脏读(读已提交)</h4>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-2读已提交实例.jpg" width="800px"/>
</div>
<h4 id="不可重复读"> 不可重复读</h4>
<p>还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。</p>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-32-1不可重复读实例.jpg"/>
</div>
<h4 id="可重复读"> 可重复读</h4>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-33-2可重复读.jpg"/>
</div>
<h4 id="防止幻读-可重复读"> 防止幻读(可重复读)</h4>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-33防止幻读(使用可重复读).jpg"/>
</div>
<p>一个事务对数据库进行操作，这种操作的范围是数据库的全部行，然后第二个事务也在对这个数据库操作，这种操作可以是插入一行记录或删除一行记录，那么第一个是事务就会觉得自己出现了幻觉，怎么还有没有处理的记录呢? 或者 怎么多处理了一行记录呢?</p>
<p>幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<h3 id="参考"> 参考</h3>
<ul>
<li>《MySQL技术内幕：InnoDB存储引擎》</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="noopener noreferrer">https://dev.mysql.com/doc/refman/5.7/en/</a></li>
<li><a href="https://tech.youzan.com/seven-questions-about-the-lock-of-mysql/" target="_blank" rel="noopener noreferrer">Mysql 锁：灵魂七拷问</a></li>
<li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener noreferrer">Innodb 中的事务隔离级别和锁的关系</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/事务特性.png" type="image/png"/>
    </item>
    <item>
      <title>字符集</title>
      <link>https://javaguide.cn/database/%E5%AD%97%E7%AC%A6%E9%9B%86/</link>
      <guid>https://javaguide.cn/database/%E5%AD%97%E7%AC%A6%E9%9B%86/</guid>
      <source url="https://javaguide.cn/rss.xml">字符集</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>MySQL 字符编码集中有两套 UTF-8 编码实现：<strong><code>utf8</code></strong> 和 <strong><code>utf8mb4</code></strong>。</p>
<p>如果使用 <strong><code>utf8</code></strong>  的话，存储emoji 符号和一些比较复杂的汉字、繁体字就会出错。</p>
<p>为什么会这样呢？这篇文章可以从源头给你解答。</p>
<h2 id="何为字符集"> 何为字符集？</h2>
<p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 <strong>字符集</strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。</p>
<p><strong>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</strong></p>
<p>我们要将这些字符和二级制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。我们将字符对应二进制数据的过程称为&quot;<strong>字符编码</strong>&quot;，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</p>
<h2 id="有哪些常见的字符集"> 有哪些常见的字符集？</h2>
<p>常见的字符集有 ASCII、GB2312、GBK、UTF-8......。</p>
<p>不同的字符集的主要区别在于：</p>
<ul>
<li>可以表示的字符范围</li>
<li>编码方式</li>
</ul>
<h3 id="ascii"> ASCII</h3>
<p><strong>ASCII</strong> (<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</p>
<p><strong>为什么 ASCII 字符集没有考虑到中文等其他字符呢？</strong> 因为计算机是美国人发明的，当时，计算机的发展还处于比较雏形的时代，还未在其他国家大规模使用。因此，美国发布 ASCII 字符集的时候没有考虑兼容其他国家的语言。</p>
<p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。</p>
<p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII 码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集可以定义 128（2^7）个字符。</p>
<p>由于，ASCII 码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了 <strong>ASCII 扩展字符集</strong> 。ASCII 扩展字符集使用 8 位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义 256（2^8）个字符。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c1c6375d08ca268690cef2b13591a5b4.png" alt="ASCII字符编码" /></p>
<h3 id="gb2312"> GB2312</h3>
<p>我们上面说了，ASCII 字符集是一种现代美国英语适用的字符集。因此，很多国家都捣鼓了一个适合自己国家语言的字符集。</p>
<p>GB2312 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集不支持绝大部分的生僻字和繁体字。</p>
<p>对于英语字符，GB2312 编码和 ASCII 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。</p>
<h3 id="gbk"> GBK</h3>
<p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。</p>
<p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。</p>
<h3 id="gb18030"> GB18030</h3>
<p>GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。</p>
<h3 id="big5"> BIG5</h3>
<p>BIG5 主要针对的是繁体中文，收录了 13000 多个汉字。</p>
<h3 id="unicode-utf-8编码"> Unicode &amp; UTF-8编码</h3>
<p>为了更加适合本国语言，诞生了很多种字符集。</p>
<p>我们上面也说了不同的字符集可以表示的字符范围以及编码规则存在差异。这就导致了一个非常严重的问题：<strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p>
<p>就比如说你使用 UTF-8 编码方式打开 GB2312 编码格式的文件就会出现乱码。示例：“牛”这个汉字 GB2312 编码后的十六进制数值为 “C5A3”，而 “C5A3” 用 UTF-8 解码之后得到的却是 “ţ”。</p>
<p>你可以通过这个网站在线进行编码和解码：https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan</p>
<p><img src="https://img-blog.csdnimg.cn/836c49b117ee4408871b0020b74c991d.png" alt="" /></p>
<p>这样我们就搞懂了乱码的本质： <strong>编码和解码时用了不同或者不兼容的字符集</strong> 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/a8808cbabeea49caa3af27d314fa3c02-1.jpg" alt="" /></p>
<p>为了解决这个问题，人们就想：“如果我们能够有一种字符集将世界上所有的字符都纳入其中就好了！”。</p>
<p>然后，<strong>Unicode</strong> 带着这个使命诞生了。</p>
<p>Unicode 字符集中包含了世界上几乎所有已知的字符。不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。</p>
<p>然后，就有了 <strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32。</p>
<p>UTF-8 使用 1 到 4 个字节为每个字符编码， UTF-16 使用 2 或 4 个字节为每个字符编码，UTF-32 固定位 4 个字节为每个字符编码。</p>
<p>UTF-8 可以根据不同的符号自动选择编码的长短，像英文字符只需要 1 个字节就够了，这一点 ASCII 字符集一样 。因此，对于英语字符，UTF-8 编码和 ASCII 码是相同的。</p>
<p>UTF-32 的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8 的 4 倍之多。</p>
<p><strong>UTF-8</strong> 是目前使用最广的一种字符编码，。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/1280px-Utf8webgrowth.svg.png" alt="" /></p>
<h2 id="mysql-字符集"> MySQL 字符集</h2>
<p>MySQL 支持很多种字符编码的方式，比如 UTF-8、GB2312、GBK、BIG5。</p>
<p>你可以通过 <code>SHOW CHARSET</code> 命令来查看。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211008164229671.png" alt="" /></p>
<p>通常情况下，我们建议使用 UTF-8 作为默认的字符编码方式。</p>
<p>不过，这里有一个小坑。</p>
<p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p>
<ul>
<li><strong><code>utf8</code></strong> ： <code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li>
<li><strong><code>utf8mb4</code></strong> ： UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li>
</ul>
<p><strong>为什么有两套 UTF-8 编码实现呢？</strong> 原因如下：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211008164542347.png" alt="" /></p>
<p>因此，如果你需要存储<code>emoji</code>类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为<code>utf8mb4</code> 而不是<code>utf8</code> ，要不然存储的时候就会报错了。</p>
<p>演示一下吧！（环境：MySQL 5.7+）</p>
<p>建表语句如下，我们指定数据库 CHARSET 为 <code>utf8</code> 。</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> <span>`</span><span>user</span><span>`</span> <span>(</span>
  <span>`</span>id<span>`</span> <span>varchar</span><span>(</span><span>66</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>NOT</span> <span>NULL</span><span>,</span>
  <span>`</span>name<span>`</span> <span>varchar</span><span>(</span><span>33</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>NOT</span> <span>NULL</span><span>,</span>
  <span>`</span>phone<span>`</span> <span>varchar</span><span>(</span><span>33</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>DEFAULT</span> <span>NULL</span><span>,</span>
  <span>`</span>password<span>`</span> <span>varchar</span><span>(</span><span>100</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>DEFAULT</span> <span>NULL</span>
<span>)</span> <span>ENGINE</span><span>=</span><span>InnoDB</span> <span>DEFAULT</span> <span>CHARSET</span><span>=</span>utf8<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>当我们执行下面的 insert 语句插入数据到数据库时，果然报错！</p>
<div><pre><code><span>INSERT</span> <span>INTO</span> <span>`</span><span>user</span><span>`</span> <span>(</span><span>`</span>id<span>`</span><span>,</span> <span>`</span>name<span>`</span><span>,</span> <span>`</span>phone<span>`</span><span>,</span> <span>`</span>password<span>`</span><span>)</span>
<span>VALUES</span>
	<span>(</span><span>'A00003'</span><span>,</span> <span>'guide哥😘😘😘'</span><span>,</span> <span>'181631312312'</span><span>,</span> <span>'123456'</span><span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>报错信息如下：</p>
<div><pre><code>Incorrect string value: &#39;\xF0\x9F\x98\x98\xF0\x9F...&#39; for column &#39;name&#39; at row 1
</code></pre>
<div><span>1</span><br></div></div><h2 id="参考"> 参考</h2>
<ul>
<li>字符集和字符编码（Charset &amp; Encoding）： https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html</li>
<li>十分钟搞清字符集和字符编码：http://cenalulu.github.io/linux/character-encoding/</li>
<li>Unicode-维基百科：https://zh.wikipedia.org/wiki/Unicode</li>
<li>GB2312-维基百科：https://zh.wikipedia.org/wiki/GB_2312</li>
<li>UTF-8-维基百科：https://zh.wikipedia.org/wiki/UTF-8</li>
<li>GB18030-维基百科: https://zh.wikipedia.org/wiki/GB_18030</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/img_convert/c1c6375d08ca268690cef2b13591a5b4.png" type="image/png"/>
    </item>
    <item>
      <title>数据库基础知识</title>
      <link>https://javaguide.cn/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <guid>https://javaguide.cn/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <source url="https://javaguide.cn/rss.xml">数据库基础知识</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>数据库知识基础，这部分内容一定要理解记忆。虽然这部分内容只是理论知识，但是非常重要，这是后面学习 MySQL 数据库的基础。PS: 这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。</p>
<h2 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员"> 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h2>
<ul>
<li><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li>
<li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>
<li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li>
<li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li>
</ul>
<p>数据库系统基本构成如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e21120184e63406526a4e873cacd23f2.png" alt="数据库系统基本构成" /></p>
<h2 id="什么是元组-码-候选码-主码-外码-主属性-非主属性"> 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h2>
<ul>
<li><strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li>
<li><strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</li>
<li><strong>候选码</strong> ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li>
<li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li>
<li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>
<li><strong>主属性</strong> ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>
<li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>
</ul>
<h2 id="主键和外键有什么区别"> 主键和外键有什么区别?</h2>
<ul>
<li><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li>
<li><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li>
</ul>
<h2 id="为什么不推荐使用外键与级联"> 为什么不推荐使用外键与级联？</h2>
<p>对于外键和级联，阿里巴巴开发手册这样说到：</p>
<blockquote>
<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>
<p>说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度</p>
</blockquote>
<p>为什么不要用外键呢？大部分人可能会这样回答：</p>
<blockquote>
<ol>
<li><strong>增加了复杂性：</strong> a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li>
<li><strong>增加了额外工作</strong>： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li>
<li>外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；</li>
<li><strong>对分库分表不友好</strong> ：因为分库分表下外键是无法生效的。</li>
<li>......</li>
</ol>
</blockquote>
<p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p>
<ol>
<li>保证了数据库数据的一致性和完整性；</li>
<li>级联操作方便，减轻了程序代码量；</li>
<li>......</li>
</ol>
<p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p>
<h2 id="什么是-er-图"> 什么是 ER 图？</h2>
<blockquote>
<p>我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问道的。</p>
</blockquote>
<p><strong>E-R 图</strong> 也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。</p>
<p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种关系是：1 对 1（1:1）、1 对多（1: N）。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4717673e36966e0e4b33fccfd753f6ea.png" alt="ER图示例" /></p>
<p>我们试着将上面的 ER 图转换成数据库实际的关系模型(实际设计中，我们通常会将任课教师也作为一个实体来处理)：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5897753dfb301dfa3a814ab06e718a5e.png" alt="关系模型" /></p>
<h2 id="数据库范式了解吗"> 数据库范式了解吗?</h2>
<p><strong>1NF(第一范式)</strong></p>
<p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p>
<p><strong>2NF(第二范式)</strong></p>
<p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bd1d31be3779342427fc9e462bf7f05c.png" alt="第二范式" /></p>
<p>一些重要的概念：</p>
<ul>
<li><strong>函数依赖（functional dependency）</strong> ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li>
<li><strong>部分函数依赖（partial functional dependency）</strong> ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li>
<li><strong>完全函数依赖(Full functional dependency)</strong> ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li>
<li><strong>传递函数依赖</strong> ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li>
</ul>
<p><strong>3NF(第三范式)</strong></p>
<p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p>
<p><strong>总结</strong></p>
<ul>
<li>1NF：属性不可再分。</li>
<li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>
<li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li>
</ul>
<h2 id="什么是存储过程"> 什么是存储过程?</h2>
<p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p>
<p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p>
<p>阿里巴巴 Java 开发手册里要求禁止使用存储过程。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0fa082bc4d4f919065767476a41b2156.png" alt="阿里巴巴Java开发手册: 禁止存储过程" /></p>
<h2 id="drop、delete-与-truncate-区别"> drop、delete 与 truncate 区别？</h2>
<h3 id="用法不同"> 用法不同</h3>
<ul>
<li>drop(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>
<li>truncate (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>
<li>delete（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一列的数据，如果不加 where 子句和<code>truncate table 表名</code>作用类似。</li>
</ul>
<p>truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 <strong>truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。</strong></p>
<h3 id="属于不同的数据库语言"> 属于不同的数据库语言</h3>
<p>truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。</p>
<p><strong>DML 语句和 DDL 语句区别：</strong></p>
<ul>
<li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。</li>
<li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li>
</ul>
<h3 id="执行速度不同"> 执行速度不同</h3>
<p>一般来说:drop&gt;truncate&gt;delete（这个我没有设计测试过）。</p>
<h2 id="数据库设计通常分为哪几步"> 数据库设计通常分为哪几步?</h2>
<ol>
<li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li>
<li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li>
<li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>
<li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li>
<li><strong>数据库实施</strong> : 包括编程、测试和试运行</li>
<li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li>
</ol>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="https://blog.csdn.net/rl529014/article/details/48391465" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/rl529014/article/details/48391465</a></li>
<li><a href="https://www.zhihu.com/question/24696366/answer/29189700" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/24696366/answer/29189700</a></li>
<li><a href="https://blog.csdn.net/bieleyang/article/details/77149954" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/bieleyang/article/details/77149954</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/img_convert/e21120184e63406526a4e873cacd23f2.png" type="image/png"/>
    </item>
    <item>
      <title>网关</title>
      <link>https://javaguide.cn/distributed-system/api-gateway/</link>
      <guid>https://javaguide.cn/distributed-system/api-gateway/</guid>
      <source url="https://javaguide.cn/rss.xml">网关</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="网关"> 网关</h1>
<h2 id="何为网关-为什么要网关"> 何为网关？为什么要网关？</h2>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/微服务-网关.png" alt="微服务-网关" /></p>
<p>微服务背景下，一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。</p>
<p>综上：<strong>一般情况下，网关都会提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、容灾、日志、监控这些功能。</strong></p>
<p>上面介绍了这么多功能，实际上，网关主要做了一件事情：<strong>请求过滤</strong> 。</p>
<h2 id="有哪些常见的网关系统"> 有哪些常见的网关系统？</h2>
<h3 id="netflix-zuul"> Netflix Zuul</h3>
<p>Zuul 是 Netflix 开发的一款提供动态路由、监控、弹性、安全的网关服务。</p>
<p>Zuul 主要通过过滤器（类似于 AOP）来过滤请求，从而实现网关必备的各种功能。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/865991e34f69f8cb345b4aff918e946e.png" alt="Zuul架构" /></p>
<p>我们可以自定义过滤器来处理请求，并且，Zuul 生态本身就有很多现成的过滤器供我们使用。就比如限流可以直接用国外朋友写的 <a href="https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit" target="_blank" rel="noopener noreferrer">spring-cloud-zuul-ratelimit</a> (这里只是举例说明，一般是配合 hystrix 来做限流)：</p>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-starter-netflix-zuul<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
<span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.marcosbarbero.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-zuul-ratelimit<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>2.2.0.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Zuul 1.x 基于同步 IO，性能较差。Zuul 2.x 基于 Netty 实现了异步 IO，性能得到了大幅改进。</p>
<ul>
<li>Github 地址 ： https://github.com/Netflix/zuul</li>
<li>官方 Wiki ： https://github.com/Netflix/zuul/wiki</li>
</ul>
<h3 id="spring-cloud-gateway"> Spring Cloud Gateway</h3>
<p>SpringCloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 **Zuul **。准确点来说，应该是 Zuul 1.x。SpringCloud Gateway 起步要比 Zuul 2.x 更早。</p>
<p>为了提升网关的性能，SpringCloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现异步 IO。</p>
<p>Spring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。</p>
<p>Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。</p>
<ul>
<li>Github 地址 ： https://github.com/spring-cloud/spring-cloud-gateway</li>
<li>官网 ： https://spring.io/projects/spring-cloud-gateway</li>
</ul>
<h3 id="kong"> Kong</h3>
<p>Kong 是一款基于 <a href="https://github.com/openresty/" target="_blank" rel="noopener noreferrer">OpenResty</a> 的高性能、云原生、可扩展的网关系统。</p>
<blockquote>
<p>OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p>
</blockquote>
<p>Kong 提供了插件机制来扩展其功能。比如、在服务上启用 Zipkin 插件</p>
<div><pre><code>$ <span>curl</span> -X POST http://kong:8001/services/<span>{</span>service<span>}</span>/plugins <span>\</span>
    --data <span>"name=zipkin"</span>  <span>\</span>
    --data <span>"config.http_endpoint=http://your.zipkin.collector:9411/api/v2/spans"</span> <span>\</span>
    --data <span>"config.sample_ratio=0.001"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>Github 地址： https://github.com/Kong/kong</li>
<li>官网地址 ： https://konghq.com/kong</li>
</ul>
<h3 id="apisix"> APISIX</h3>
<p>APISIX 是一款基于 Nginx 和 etcd 的高性能、云原生、可扩展的网关系统。</p>
<blockquote>
<p><em>etcd</em>是使用 Go 语言开发的一个开源的、高可用的分布式 key-value 存储系统，使用 Raft 协议做分布式共识。</p>
</blockquote>
<p>与传统 API 网关相比，APISIX 具有动态路由和插件热加载，特别适合微服务系统下的 API 管理。并且，APISIX 与 SkyWalking（分布式链路追踪系统）、Zipkin（分布式链路追踪系统）、Prometheus（监控系统） 等 DevOps 生态工具对接都十分方便。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/727732fad2e943bdd2c502b83ddb1b89.png" alt="apisix架构图" /></p>
<p>作为 NGINX 和 Kong 的替代项目，APISIX 目前已经是 Apache 顶级开源项目，并且是最快毕业的国产开源项目。国内目前已经有很多知名企业（比如金山、有赞、爱奇艺、腾讯、贝壳）使用 APISIX 处理核心的业务流量。</p>
<p>根据官网介绍：“APISIX 已经生产可用，功能、性能、架构全面优于 Kong”。</p>
<ul>
<li>Github 地址 ：https://github.com/apache/apisix</li>
<li>官网地址： https://apisix.apache.org/zh/</li>
</ul>
<p>相关阅读：</p>
<ul>
<li><a href="https://www.apiseven.com/zh/blog/why-we-need-Apache-APISIX" target="_blank" rel="noopener noreferrer">有了 NGINX 和 Kong，为什么还需要 Apache APISIX</a></li>
<li><a href="https://www.apiseven.com/zh/blog" target="_blank" rel="noopener noreferrer">APISIX 技术博客</a></li>
<li><a href="https://www.apiseven.com/zh/usercases" target="_blank" rel="noopener noreferrer">APISIX 用户案例</a></li>
</ul>
<h3 id="shenyu"> Shenyu</h3>
<p>Shenyu 是一款基于 WebFlux 的可扩展、高性能、响应式网关，Apache 顶级开源项目。</p>
<p><img src="https://img-blog.csdnimg.cn/1104eb413cba468cba4dce119165e84e.png" alt="Shenyu架构" /></p>
<p>Shenyu 通过插件扩展功能，插件是 ShenYu 的灵魂，并且插件也是可扩展和热插拔的。不同的插件实现不同的功能。Shenyu 自带了诸如限流、熔断、转发 、重写、重定向、和路由监控等插件。</p>
<ul>
<li>Github 地址： https://github.com/apache/incubator-shenyu</li>
<li>官网地址 ： https://shenyu.apache.org/</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3.png" type="image/png"/>
    </item>
    <item>
      <title>分布式 ID</title>
      <link>https://javaguide.cn/distributed-system/distributed-id/</link>
      <guid>https://javaguide.cn/distributed-system/distributed-id/</guid>
      <source url="https://javaguide.cn/rss.xml">分布式 ID</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="分布式-id"> 分布式 ID</h1>
<h2 id="分布式-id-介绍"> 分布式 ID 介绍</h2>
<h3 id="何为-id"> 何为 ID？</h3>
<p>日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/up-79beb853b8319f850638c9708f83039dfda.png" alt="" /></p>
<p>我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID 对应且仅对应</p>
<p>简单来说，<strong>ID 就是数据的唯一标识</strong>。</p>
<h3 id="何为分布式-id"> 何为分布式 ID？</h3>
<p>分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。</p>
<p>我简单举一个分库分表的例子。</p>
<p>我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。</p>
<p>单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。</p>
<p>在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。<strong>我们如何为不同的数据节点生成全局唯一主键呢？</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d78d9d5362c71f4713a090baf7ec65d2b6d.png" alt="" /></p>
<p>这个时候就需要生成<strong>分布式 ID</strong>了。</p>
<h3 id="分布式-id-需要满足哪些要求"> 分布式 ID 需要满足哪些要求?</h3>
<p><img src="https://img-blog.csdnimg.cn/20210610082309988.png" alt="" /></p>
<p>分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式 ID。</p>
<p>一个最基本的分布式 ID 需要满足下面这些要求：</p>
<ul>
<li><strong>全局唯一</strong> ：ID 的全局唯一性肯定是首先要满足的！</li>
<li><strong>高性能</strong> ： 分布式 ID 的生成速度要快，对本地资源消耗要小。</li>
<li><strong>高可用</strong> ：生成分布式 ID 的服务要保证可用性无限接近于 100%。</li>
<li><strong>方便易用</strong> ：拿来即用，使用方便，快速接入！</li>
</ul>
<p>除了这些之外，一个比较好的分布式 ID 还应保证：</p>
<ul>
<li><strong>安全</strong> ：ID 中不包含敏感信息。</li>
<li><strong>有序递增</strong> ：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</li>
<li><strong>有具体的业务含义</strong> ：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。</li>
<li><strong>独立部署</strong> ：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。</li>
</ul>
<h2 id="分布式-id-常见解决方案"> 分布式 ID 常见解决方案</h2>
<h3 id="数据库"> 数据库</h3>
<h4 id="数据库主键自增"> 数据库主键自增</h4>
<p>这种方式就比较简单直白了，就是通过关系型数据库的自增主键产生来唯一的 ID。</p>
<p><img src="https://img-blog.csdnimg.cn/20210610081957287.png" alt="" /></p>
<p>以 MySQL 举例，我们通过下面的方式即可。</p>
<p><strong>1.创建一个数据库表。</strong></p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> <span>`</span>sequence_id<span>`</span> <span>(</span>
  <span>`</span>id<span>`</span> <span>bigint</span><span>(</span><span>20</span><span>)</span> <span>unsigned</span> <span>NOT</span> <span>NULL</span> <span>AUTO_INCREMENT</span><span>,</span>
  <span>`</span>stub<span>`</span> <span>char</span><span>(</span><span>10</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>''</span><span>,</span>
  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>`</span>id<span>`</span><span>)</span><span>,</span>
  <span>UNIQUE</span> <span>KEY</span> <span>`</span>stub<span>`</span> <span>(</span><span>`</span>stub<span>`</span><span>)</span>
<span>)</span> <span>ENGINE</span><span>=</span><span>InnoDB</span> <span>DEFAULT</span> <span>CHARSET</span><span>=</span>utf8mb4<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>stub</code> 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给 <code>stub</code> 字段创建了唯一索引，保证其唯一性。</p>
<p><strong>2.通过 <code>replace into</code> 来插入数据。</strong></p>
<div><pre><code>BEGIN<span>;</span>
REPLACE <span>INTO</span> sequence_id <span>(</span>stub<span>)</span> VALUES <span>(</span><span>'stub'</span><span>)</span><span>;</span>
<span>SELECT</span> <span>LAST_INSERT_ID</span><span>(</span><span>)</span><span>;</span>
COMMIT<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>插入数据这里，我们没有使用 <code>insert into</code> 而是使用 <code>replace into</code> 来插入数据，具体步骤是这样的：</p>
<p>1)第一步： 尝试把数据插入到表中。</p>
<p>2)第二步： 如果主键或唯一索引字段出现重复数据错误而插入失败时，先从表中删除含有重复关键字值的冲突行，然后再次尝试把数据插入到表中。</p>
<p>这种方式的优缺点也比较明显：</p>
<ul>
<li><strong>优点</strong> ：实现起来比较简单、ID 有序递增、存储消耗空间小</li>
<li><strong>缺点</strong> ： 支持的并发量不大、存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）、每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）</li>
</ul>
<h4 id="数据库号段模式"> 数据库号段模式</h4>
<p>数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID 需求比较大的时候，肯定是不行的。</p>
<p>如果我们可以批量获取，然后存在在内存里面，需要用到的时候，直接从内存里面拿就舒服了！这也就是我们说的 <strong>基于数据库的号段模式来生成分布式 ID。</strong></p>
<p>数据库的号段模式也是目前比较主流的一种分布式 ID 生成方式。像滴滴开源的<a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener noreferrer">Tinyid</a> 就是基于这种方式来做的。不过，TinyId 使用了双号段缓存、增加多 db 支持等方式来进一步优化。</p>
<p>以 MySQL 举例，我们通过下面的方式即可。</p>
<p><strong>1.创建一个数据库表。</strong></p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> <span>`</span>sequence_id_generator<span>`</span> <span>(</span>
  <span>`</span>id<span>`</span> <span>int</span><span>(</span><span>10</span><span>)</span> <span>NOT</span> <span>NULL</span><span>,</span>
  <span>`</span>current_max_id<span>`</span> <span>bigint</span><span>(</span><span>20</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>COMMENT</span> <span>'当前最大id'</span><span>,</span>
  <span>`</span>step<span>`</span> <span>int</span><span>(</span><span>10</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>COMMENT</span> <span>'号段的长度'</span><span>,</span>
  <span>`</span>version<span>`</span> <span>int</span><span>(</span><span>20</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>COMMENT</span> <span>'版本号'</span><span>,</span>
  <span>`</span>biz_type<span>`</span>    <span>int</span><span>(</span><span>20</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>COMMENT</span> <span>'业务类型'</span><span>,</span>
   <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>`</span>id<span>`</span><span>)</span>
<span>)</span> <span>ENGINE</span><span>=</span><span>InnoDB</span> <span>DEFAULT</span> <span>CHARSET</span><span>=</span>utf8mb4<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>current_max_id</code> 字段和<code>step</code>字段主要用于获取批量 ID，获取的批量 id 为： <code>current_max_id ~ current_max_id+step</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/20210610081149228.png" alt="" /></p>
<p><code>version</code> 字段主要用于解决并发问题（乐观锁）,<code>biz_type</code> 主要用于表示业余类型。</p>
<p><strong>2.先插入一行数据。</strong></p>
<div><pre><code><span>INSERT</span> <span>INTO</span> <span>`</span>sequence_id_generator<span>`</span> <span>(</span><span>`</span>id<span>`</span><span>,</span> <span>`</span>current_max_id<span>`</span><span>,</span> <span>`</span>step<span>`</span><span>,</span> <span>`</span>version<span>`</span><span>,</span> <span>`</span>biz_type<span>`</span><span>)</span>
<span>VALUES</span>
	<span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>100</span><span>,</span> <span>0</span><span>,</span> <span>101</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>3.通过 SELECT 获取指定业务下的批量唯一 ID</strong></p>
<div><pre><code><span>SELECT</span> <span>`</span>current_max_id<span>`</span><span>,</span> <span>`</span>step<span>`</span><span>,</span><span>`</span>version<span>`</span> <span>FROM</span> <span>`</span>sequence_id_generator<span>`</span> <span>where</span> <span>`</span>biz_type<span>`</span> <span>=</span> <span>101</span>
</code></pre>
<div><span>1</span><br></div></div><p>结果：</p>
<div><pre><code>id	current_max_id	step	version	biz_type
1	0	100	1	101
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>4.不够用的话，更新之后重新 SELECT 即可。</strong></p>
<div><pre><code><span>UPDATE</span> sequence_id_generator <span>SET</span> current_max_id <span>=</span> <span>0</span><span>+</span><span>100</span><span>,</span> version<span>=</span>version<span>+</span><span>1</span> <span>WHERE</span> version <span>=</span> <span>0</span>  <span>AND</span> <span>`</span>biz_type<span>`</span> <span>=</span> <span>101</span>
<span>SELECT</span> <span>`</span>current_max_id<span>`</span><span>,</span> <span>`</span>step<span>`</span><span>,</span><span>`</span>version<span>`</span> <span>FROM</span> <span>`</span>sequence_id_generator<span>`</span> <span>where</span> <span>`</span>biz_type<span>`</span> <span>=</span> <span>101</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>结果：</p>
<div><pre><code>id	current_max_id	step	version	biz_type
1	100	100	1	101
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>相比于数据库主键自增的方式，<strong>数据库的号段模式对于数据库的访问次数更少，数据库压力更小。</strong></p>
<p>另外，为了避免单点问题，你可以从使用主从模式来提高可用性。</p>
<p><strong>数据库号段模式的优缺点:</strong></p>
<ul>
<li><strong>优点</strong> ：ID 有序递增、存储消耗空间小</li>
<li><strong>缺点</strong> ：存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）</li>
</ul>
<h4 id="nosql"> NoSQL</h4>
<p><img src="https://img-blog.csdnimg.cn/2021061008245858.png" alt="" /></p>
<p>一般情况下，NoSQL 方案使用 Redis 多一些。我们通过 Redis 的 <code>incr</code> 命令即可实现对 id 原子顺序递增。</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> sequence_id_biz_type <span>1</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> incr sequence_id_biz_type
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> get sequence_id_biz_type
<span>"2"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>为了提高可用性和并发，我们可以使用 Redis Cluser。Redis Cluser 是 Redis 官方提供的 Redis 集群解决方案（3.0+版本）。</p>
<p>除了 Redis Cluser 之外，你也可以使用开源的 Redis 集群方案<a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener noreferrer">Codis</a> （大规模集群比如上百个节点的时候比较推荐）。</p>
<p>除了高可用和并发之外，我们知道 Redis 基于内存，我们需要持久化数据，避免重启机器或者机器故障后数据丢失。Redis 支持两种不同的持久化方式：<strong>快照（snapshotting，RDB）</strong>、<strong>只追加文件（append-only file, AOF）</strong>。 并且，Redis 4.0 开始支持 <strong>RDB 和 AOF 的混合持久化</strong>（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>关于 Redis 持久化，我这里就不过多介绍。不了解这部分内容的小伙伴，可以看看 <a href="https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all" target="_blank" rel="noopener noreferrer">JavaGuide 对于 Redis 知识点的总结</a>。</p>
<p><strong>Redis 方案的优缺点：</strong></p>
<ul>
<li><strong>优点</strong> ： 性能不错并且生成的 ID 是有序递增的</li>
<li><strong>缺点</strong> ： 和数据库主键自增方案的缺点类似</li>
</ul>
<p>除了 Redis 之外，MongoDB ObjectId 经常也会被拿来当做分布式 ID 的解决方案。</p>
<p><img src="https://img-blog.csdnimg.cn/20210207103320582.png" alt="" /></p>
<p>MongoDB ObjectId 一共需要 12 个字节存储：</p>
<ul>
<li>0~3：时间戳</li>
<li>3~6： 代表机器 ID</li>
<li>7~8：机器进程 ID</li>
<li>9~11 ：自增值</li>
</ul>
<p><strong>MongoDB 方案的优缺点：</strong></p>
<ul>
<li><strong>优点</strong> ： 性能不错并且生成的 ID 是有序递增的</li>
<li><strong>缺点</strong> ： 需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID） 、有安全性问题（ID 生成有规律性）</li>
</ul>
<h3 id="算法"> 算法</h3>
<h4 id="uuid"> UUID</h4>
<p>UUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID 包含 32 个 16 进制数字（8-4-4-4-12）。</p>
<p>JDK 就提供了现成的生成 UUID 的方法，一行代码就行了。</p>
<div><pre><code><span>//输出示例：cb4a9ede-fa5e-4585-b9bb-d60bce986eaa</span>
UUID<span>.</span><span>randomUUID</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><a href="https://tools.ietf.org/html/rfc4122" target="_blank" rel="noopener noreferrer">RFC 4122</a> 中关于 UUID 的示例是这样的：</p>
<p><img src="https://img-blog.csdnimg.cn/20210202110824430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="" /></p>
<p>我们这里重点关注一下这个 Version(版本)，不同的版本对应的 UUID 的生成规则是不同的。</p>
<p>5 种不同的 Version(版本)值分别对应的含义（参考<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81" target="_blank" rel="noopener noreferrer">维基百科对于 UUID 的介绍</a>）：</p>
<ul>
<li><strong>版本 1</strong> : UUID 是根据时间和节点 ID（通常是 MAC 地址）生成；</li>
<li><strong>版本 2</strong> : UUID 是根据标识符（通常是组或用户 ID）、时间和节点 ID 生成；</li>
<li><strong>版本 3、版本 5</strong> : 版本 5 - 确定性 UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成；</li>
<li><strong>版本 4</strong> : UUID 使用<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%80%A7" target="_blank" rel="noopener noreferrer">随机性</a>或<a href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%80%A7" target="_blank" rel="noopener noreferrer">伪随机性</a>生成。</li>
</ul>
<p>下面是 Version 1 版本下生成的 UUID 的示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20210202113013477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="" /></p>
<p>JDK 中通过 <code>UUID</code> 的 <code>randomUUID()</code> 方法生成的 UUID 的版本默认为 4。</p>
<div><pre><code><span>UUID</span> uuid <span>=</span> UUID<span>.</span><span>randomUUID</span><span>(</span><span>)</span><span>;</span>
<span>int</span> version <span>=</span> uuid<span>.</span><span>version</span><span>(</span><span>)</span><span>;</span><span>// 4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>另外，Variant(变体)也有 4 种不同的值，这种值分别对应不同的含义。这里就不介绍了，貌似平时也不怎么需要关注。</p>
<p>需要用到的时候，去看看维基百科对于 UUID 的 Variant(变体) 相关的介绍即可。</p>
<p>从上面的介绍中可以看出，UUID 可以保证唯一性，因为其生成规则包括 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，计算机基于这些规则生成的 UUID 是肯定不会重复的。</p>
<p>虽然，UUID 可以做到全局唯一性，但是，我们一般很少会使用它。</p>
<p>比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：</p>
<ul>
<li>数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。</li>
<li>UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。</li>
</ul>
<p>最后，我们再简单分析一下 <strong>UUID 的优缺点</strong> （面试的时候可能会被问到的哦！） :</p>
<ul>
<li><strong>优点</strong> ：生成速度比较快、简单易用</li>
<li><strong>缺点</strong> ： 存储消耗空间大（32 个字符串，128 位） 、 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)、无序（非自增）、没有具体业务含义、需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）</li>
</ul>
<h4 id="snowflake-雪花算法"> Snowflake(雪花算法)</h4>
<p>Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义：</p>
<ul>
<li><strong>第 0 位</strong>： 符号位（标识正负），始终为 0，没有用，不用管。</li>
<li><strong>第 1~41 位</strong> ：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</li>
<li><strong>第 42~52 位</strong> ：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。</li>
<li><strong>第 53~64 位</strong> ：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-a7e54a77b5ab1d9fa16d5ae3a3c50c5aee9.png" alt="" /></p>
<p>如果你想要使用 Snowflake 算法的话，一般不需要你自己再造轮子。有很多基于 Snowflake 算法的开源实现比如美团 的 Leaf、百度的 UidGenerator，并且这些开源实现对原有的 Snowflake 算法进行了优化。</p>
<p>另外，在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。</p>
<p>我们再来看看 Snowflake 算法的优缺点 ：</p>
<ul>
<li><strong>优点</strong> ：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）</li>
<li><strong>缺点</strong> ： 需要解决重复 ID 问题（依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID）。</li>
</ul>
<h3 id="开源框架"> 开源框架</h3>
<h4 id="uidgenerator-百度"> UidGenerator(百度)</h4>
<p><a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener noreferrer">UidGenerator</a> 是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。</p>
<p>不过，UidGenerator 对 Snowflake(雪花算法)进行了改进，生成的唯一 ID 组成如下。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ad5b9dd0077a949db923611b2450277e406.png" alt="" /></p>
<p>可以看出，和原始 Snowflake(雪花算法)生成的唯一 ID 的组成不太一样。并且，上面这些参数我们都可以自定义。</p>
<p>UidGenerator 官方文档中的介绍如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-358b1a4cddb3675018b8595f66ece9cae88.png" alt="" /></p>
<p>自 18 年后，UidGenerator 就基本没有再维护了，我这里也不过多介绍。想要进一步了解的朋友，可以看看 <a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener noreferrer">UidGenerator 的官方介绍</a>。</p>
<h4 id="leaf-美团"> Leaf(美团)</h4>
<p><strong><a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener noreferrer">Leaf</a></strong> 是美团开源的一个分布式 ID 解决方案 。这个项目的名字 Leaf（树叶） 起源于德国哲学家、数学家莱布尼茨的一句话： “There are no two identical leaves in the world”（世界上没有两片相同的树叶） 。这名字起得真心挺不错的，有点文艺青年那味了！</p>
<p><img src="https://img-blog.csdnimg.cn/20210422145229617.png" alt="" /></p>
<p>Leaf 提供了 <strong>号段模式</strong> 和 <strong>Snowflake(雪花算法)</strong> 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper 。</p>
<p>Leaf 的诞生主要是为了解决美团各个业务线生成分布式 ID 的方法多种多样以及不可靠的问题。</p>
<p>Leaf 对原有的号段模式进行改进，比如它这里增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段（图片来自于美团官方文章：<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener noreferrer">《Leaf——美团点评分布式 ID 生成系统》</a>）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210422144846724.png" alt="" /></p>
<p>根据项目 README 介绍，在 4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w/s，TP999 1ms。</p>
<h4 id="tinyid-滴滴"> Tinyid(滴滴)</h4>
<p><a href="https://github.com/didi/tinyid" target="_blank" rel="noopener noreferrer">Tinyid</a> 是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。</p>
<p>数据库号段模式的原理我们在上面已经介绍过了。<strong>Tinyid 有哪些亮点呢？</strong></p>
<p>为了搞清楚这个问题，我们先来看看基于数据库号段模式的简单架构方案。（图片来自于 Tinyid 的官方 wiki:<a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener noreferrer">《Tinyid 原理介绍》</a>）</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4afc0e45c0c86ba5ad645d023dce11e53c2.png" alt="" /></p>
<p>在这种架构模式下，我们通过 HTTP 请求向发号器服务申请唯一 ID。负载均衡 router 会把我们的请求送往其中的一台 tinyid-server。</p>
<p>这种方案有什么问题呢？在我看来（Tinyid 官方 wiki 也有介绍到），主要由下面这 2 个问题：</p>
<ul>
<li>获取新号段的情况下，程序获取唯一 ID 的速度比较慢。</li>
<li>需要保证 DB 高可用，这个是比较麻烦且耗费资源的。</li>
</ul>
<p>除此之外，HTTP 调用也存在网络开销。</p>
<p>Tinyid 的原理比较简单，其架构如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-53f74cd615178046d6c04fe50513fee74ce.png" alt="" /></p>
<p>相比于基于数据库号段模式的简单架构方案，Tinyid 方案主要做了下面这些优化：</p>
<ul>
<li><strong>双号段缓存</strong> ：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。 Tinyid 中的号段在用到一定程度的时候，就会去异步加载下一个号段，保证内存中始终有可用号段。</li>
<li><strong>增加多 db 支持</strong> ：支持多个 DB，并且，每个 DB 都能生成唯一 ID，提高了可用性。</li>
<li><strong>增加 tinyid-client</strong> ：纯本地操作，无 HTTP 请求消耗，性能和可用性都有很大提升。</li>
</ul>
<p>Tinyid 的优缺点这里就不分析了，结合数据库号段模式的优缺点和 Tinyid 的原理就能知道。</p>
<h2 id="分布式-id-生成方案总结"> 分布式 ID 生成方案总结</h2>
<p>这篇文章中，我基本上已经把最常见的分布式 ID 生成方案都总结了一波。</p>
<p>除了上面介绍的方式之外，像 ZooKeeper 这类中间件也可以帮助我们生成唯一 ID。<strong>没有银弹，一定要结合实际项目来选择最适合自己的方案。</strong></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/up-79beb853b8319f850638c9708f83039dfda.png" type="image/png"/>
    </item>
    <item>
      <title>ZooKeeper 实战</title>
      <link>https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-in-action/</link>
      <guid>https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-in-action/</guid>
      <source url="https://javaguide.cn/rss.xml">ZooKeeper 实战</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="zookeeper-实战"> ZooKeeper 实战</h1>
<h2 id="_1-前言"> 1. 前言</h2>
<p>这篇文章简单给演示一下 ZooKeeper 常见命令的使用以及 ZooKeeper Java客户端 Curator 的基本使用。介绍到的内容都是最基本的操作，能满足日常工作的基本需要。</p>
<p>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！</p>
<h2 id="_2-zookeeper-安装和使用"> 2. ZooKeeper 安装和使用</h2>
<h3 id="_2-1-使用docker-安装-zookeeper"> 2.1. 使用Docker 安装 zookeeper</h3>
<p><strong>a.使用 Docker 下载 ZooKeeper</strong></p>
<div><pre><code>docker pull zookeeper:3.5.8
</code></pre>
<div><span>1</span><br></div></div><p><strong>b.运行 ZooKeeper</strong></p>
<div><pre><code>docker run -d --name zookeeper -p <span>2181</span>:2181 zookeeper:3.5.8
</code></pre>
<div><span>1</span><br></div></div><h3 id="_2-2-连接-zookeeper-服务"> 2.2. 连接 ZooKeeper 服务</h3>
<p><strong>a.进入ZooKeeper容器中</strong></p>
<p>先使用 <code>docker ps</code> 查看 ZooKeeper 的 ContainerID，然后使用 <code>docker exec -it ContainerID /bin/bash</code> 命令进入容器中。</p>
<p><strong>b.先进入 bin 目录,然后通过  <code>./zkCli.sh -server 127.0.0.1:2181</code>命令连接ZooKeeper 服务</strong></p>
<div><pre><code>root@eaf70fc620cb:/apache-zookeeper-3.5.8-bin<span># cd bin</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果你看到控制台成功打印出如下信息的话，说明你已经成功连接 ZooKeeper 服务。</p>
<p><img src="./images/连接ZooKeeper服务.png" alt="" /></p>
<h3 id="_2-3-常用命令演示"> 2.3. 常用命令演示</h3>
<h4 id="_2-3-1-查看常用命令-help-命令"> 2.3.1. 查看常用命令(help 命令)</h4>
<p>通过 <code>help</code> 命令查看 ZooKeeper 常用命令</p>
<h4 id="_2-3-2-创建节点-create-命令"> 2.3.2. 创建节点(create 命令)</h4>
<p>通过 <code>create</code> 命令在根目录创建了 node1 节点，与它关联的字符串是&quot;node1&quot;</p>
<div><pre><code><span>[</span>zk: <span>127.0</span>.0.1:2181<span>(</span>CONNECTED<span>)</span> <span>34</span><span>]</span> create /node1 “node1”
</code></pre>
<div><span>1</span><br></div></div><p>通过 <code>create</code> 命令在根目录创建了 node1 节点，与它关联的内容是数字 123</p>
<div><pre><code><span>[</span>zk: <span>127.0</span>.0.1:2181<span>(</span>CONNECTED<span>)</span> <span>1</span><span>]</span> create /node1/node1.1 <span>123</span>
Created /node1/node1.1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="_2-3-3-更新节点数据内容-set-命令"> 2.3.3. 更新节点数据内容(set 命令)</h4>
<div><pre><code><span>[</span>zk: <span>127.0</span>.0.1:2181<span>(</span>CONNECTED<span>)</span> <span>11</span><span>]</span> <span>set</span> /node1 <span>"set node1"</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="_2-3-4-获取节点的数据-get-命令"> 2.3.4. 获取节点的数据(get 命令)</h4>
<p><code>get</code> 命令可以获取指定节点的数据内容和节点的状态,可以看出我们通过 <code>set</code> 命令已经将节点数据内容改为 &quot;set node1&quot;。</p>
<div><pre><code><span>set</span> node1
cZxid <span>=</span> 0x47
ctime <span>=</span> Sun Jan <span>20</span> <span>10</span>:22:59 CST <span>2019</span>
mZxid <span>=</span> 0x4b
mtime <span>=</span> Sun Jan <span>20</span> <span>10</span>:41:10 CST <span>2019</span>
pZxid <span>=</span> 0x4a
cversion <span>=</span> <span>1</span>
dataVersion <span>=</span> <span>1</span>
aclVersion <span>=</span> <span>0</span>
ephemeralOwner <span>=</span> 0x0
dataLength <span>=</span> <span>9</span>
numChildren <span>=</span> <span>1</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="_2-3-5-查看某个目录下的子节点-ls-命令"> 2.3.5. 查看某个目录下的子节点(ls 命令)</h4>
<p>通过 <code>ls</code> 命令查看根目录下的节点</p>
<div><pre><code><span>[</span>zk: <span>127.0</span>.0.1:2181<span>(</span>CONNECTED<span>)</span> <span>37</span><span>]</span> <span>ls</span> /
<span>[</span>dubbo, ZooKeeper, node1<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>通过 <code>ls</code> 命令查看 node1 目录下的节点</p>
<div><pre><code><span>[</span>zk: <span>127.0</span>.0.1:2181<span>(</span>CONNECTED<span>)</span> <span>5</span><span>]</span> <span>ls</span> /node1
<span>[</span>node1.1<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>ZooKeeper 中的 ls 命令和 linux 命令中的 ls 类似， 这个命令将列出绝对路径 path 下的所有子节点信息（列出 1 级，并不递归）</p>
<h4 id="_2-3-6-查看节点状态-stat-命令"> 2.3.6. 查看节点状态(stat 命令)</h4>
<p>通过 <code>stat</code> 命令查看节点状态</p>
<div><pre><code><span>[</span>zk: <span>127.0</span>.0.1:2181<span>(</span>CONNECTED<span>)</span> <span>10</span><span>]</span> <span>stat</span> /node1
cZxid <span>=</span> 0x47
ctime <span>=</span> Sun Jan <span>20</span> <span>10</span>:22:59 CST <span>2019</span>
mZxid <span>=</span> 0x47
mtime <span>=</span> Sun Jan <span>20</span> <span>10</span>:22:59 CST <span>2019</span>
pZxid <span>=</span> 0x4a
cversion <span>=</span> <span>1</span>
dataVersion <span>=</span> <span>0</span>
aclVersion <span>=</span> <span>0</span>
ephemeralOwner <span>=</span> 0x0
dataLength <span>=</span> <span>11</span>
numChildren <span>=</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>上面显示的一些信息比如 cversion、aclVersion、numChildren 等等，我在上面 “znode(数据节点)的结构” 这部分已经介绍到。</p>
<h4 id="_2-3-7-查看节点信息和状态-ls2-命令"> 2.3.7. 查看节点信息和状态(ls2 命令)</h4>
<p><code>ls2</code> 命令更像是  <code>ls</code> 命令和 <code>stat</code> 命令的结合。 <code>ls2</code> 命令返回的信息包括 2 部分：</p>
<ol>
<li>子节点列表</li>
<li>当前节点的 stat 信息。</li>
</ol>
<div><pre><code><span>[</span>zk: <span>127.0</span>.0.1:2181<span>(</span>CONNECTED<span>)</span> <span>7</span><span>]</span> ls2 /node1
<span>[</span>node1.1<span>]</span>
cZxid <span>=</span> 0x47
ctime <span>=</span> Sun Jan <span>20</span> <span>10</span>:22:59 CST <span>2019</span>
mZxid <span>=</span> 0x47
mtime <span>=</span> Sun Jan <span>20</span> <span>10</span>:22:59 CST <span>2019</span>
pZxid <span>=</span> 0x4a
cversion <span>=</span> <span>1</span>
dataVersion <span>=</span> <span>0</span>
aclVersion <span>=</span> <span>0</span>
ephemeralOwner <span>=</span> 0x0
dataLength <span>=</span> <span>11</span>
numChildren <span>=</span> <span>1</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="_2-3-8-删除节点-delete-命令"> 2.3.8. 删除节点(delete 命令)</h4>
<p>这个命令很简单，但是需要注意的一点是如果你要删除某一个节点，那么这个节点必须无子节点才行。</p>
<div><pre><code><span>[</span>zk: <span>127.0</span>.0.1:2181<span>(</span>CONNECTED<span>)</span> <span>3</span><span>]</span> delete /node1/node1.1
</code></pre>
<div><span>1</span><br></div></div><p>在后面我会介绍到 Java 客户端 API 的使用以及开源 ZooKeeper 客户端 ZkClient 和 Curator 的使用。</p>
<h2 id="_3-zookeeper-java客户端-curator简单使用"> 3. ZooKeeper Java客户端 Curator简单使用</h2>
<p>Curator 是Netflix公司开源的一套 ZooKeeper Java客户端框架，相比于 Zookeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p>
<p><img src="./images/curator.png" alt="" /></p>
<p>下面我们就来简单地演示一下 Curator 的使用吧！</p>
<p>Curator4.0+版本对ZooKeeper 3.5.x支持比较好。开始之前，请先将下面的依赖添加进你的项目。</p>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.curator<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>curator-framework<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>4.2.0<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
<span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.curator<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>curator-recipes<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>4.2.0<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="_3-1-连接-zookeeper-客户端"> 3.1. 连接 ZooKeeper 客户端</h3>
<p>通过 <code>CuratorFrameworkFactory</code> 创建 <code>CuratorFramework</code> 对象，然后再调用  <code>CuratorFramework</code> 对象的 <code>start()</code> 方法即可！</p>
<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>int</span> BASE_SLEEP_TIME <span>=</span> <span>1000</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_RETRIES <span>=</span> <span>3</span><span>;</span>

<span>// Retry strategy. Retry 3 times, and will increase the sleep time between retries.</span>
<span>RetryPolicy</span> retryPolicy <span>=</span> <span>new</span> <span>ExponentialBackoffRetry</span><span>(</span>BASE_SLEEP_TIME<span>,</span> MAX_RETRIES<span>)</span><span>;</span>
<span>CuratorFramework</span> zkClient <span>=</span> <span>CuratorFrameworkFactory</span><span>.</span><span>builder</span><span>(</span><span>)</span>
    <span>// the server to connect to (can be a server list)</span>
    <span>.</span><span>connectString</span><span>(</span><span>"127.0.0.1:2181"</span><span>)</span>
    <span>.</span><span>retryPolicy</span><span>(</span>retryPolicy<span>)</span>
    <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
zkClient<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>对于一些基本参数的说明：</p>
<ul>
<li><code>baseSleepTimeMs</code>：重试之间等待的初始时间</li>
<li><code>maxRetries</code> ：最大重试次数</li>
<li><code>connectString</code> ：要连接的服务器列表</li>
<li><code>retryPolicy</code> ：重试策略</li>
</ul>
<h3 id="_3-2-数据节点的增删改查"> 3.2. 数据节点的增删改查</h3>
<h4 id="_3-2-1-创建节点"> 3.2.1. 创建节点</h4>
<p>我们在 <a href="./zookeeper-intro.html">ZooKeeper常见概念解读</a> 中介绍到，我们通常是将 znode 分为 4 大类：</p>
<ul>
<li><strong>持久（PERSISTENT）节点</strong> ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li>
<li><strong>临时（EPHEMERAL）节点</strong> ：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，临时节点 <strong>只能做叶子节点</strong> ，不能创建子节点。</li>
<li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong> ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code> 、<code>/node1/app0000000002</code> 。</li>
<li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong> ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li>
</ul>
<p>你在使用的ZooKeeper 的时候，会发现  <code>CreateMode</code> 类中实际有 7种 znode 类型 ，但是用的最多的还是上面介绍的 4 种。</p>
<p><strong>a.创建持久化节点</strong></p>
<p>你可以通过下面两种方式创建持久化的节点。</p>
<div><pre><code><span>//注意:下面的代码会报错，下文说了具体原因</span>
zkClient<span>.</span><span>create</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1/00001"</span><span>)</span><span>;</span>
zkClient<span>.</span><span>create</span><span>(</span><span>)</span><span>.</span><span>withMode</span><span>(</span><span>CreateMode</span><span>.</span>PERSISTENT<span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1/00002"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>但是，你运行上面的代码会报错，这是因为的父节点<code>node1</code>还未创建。</p>
<p>你可以先创建父节点 <code>node1</code> ，然后再执行上面的代码就不会报错了。</p>
<div><pre><code>zkClient<span>.</span><span>create</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>更推荐的方式是通过下面这行代码， <strong><code>creatingParentsIfNeeded()</code> 可以保证父节点不存在的时候自动创建父节点，这是非常有用的。</strong></p>
<div><pre><code>zkClient<span>.</span><span>create</span><span>(</span><span>)</span><span>.</span><span>creatingParentsIfNeeded</span><span>(</span><span>)</span><span>.</span><span>withMode</span><span>(</span><span>CreateMode</span><span>.</span>PERSISTENT<span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1/00001"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>b.创建临时节点</strong></p>
<div><pre><code>zkClient<span>.</span><span>create</span><span>(</span><span>)</span><span>.</span><span>creatingParentsIfNeeded</span><span>(</span><span>)</span><span>.</span><span>withMode</span><span>(</span><span>CreateMode</span><span>.</span>EPHEMERAL<span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1/00001"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>c.创建节点并指定数据内容</strong></p>
<div><pre><code>zkClient<span>.</span><span>create</span><span>(</span><span>)</span><span>.</span><span>creatingParentsIfNeeded</span><span>(</span><span>)</span><span>.</span><span>withMode</span><span>(</span><span>CreateMode</span><span>.</span>EPHEMERAL<span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1/00001"</span><span>,</span><span>"java"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>
zkClient<span>.</span><span>getData</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1/00001"</span><span>)</span><span>;</span><span>//获取节点的数据内容，获取到的是 byte数组</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>d.检测节点是否创建成功</strong></p>
<div><pre><code>zkClient<span>.</span><span>checkExists</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1/00001"</span><span>)</span><span>;</span><span>//不为null的话，说明节点创建成功</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="_3-2-2-删除节点"> 3.2.2. 删除节点</h4>
<p><strong>a.删除一个子节点</strong></p>
<div><pre><code>zkClient<span>.</span><span>delete</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1/00001"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>b.删除一个节点以及其下的所有子节点</strong></p>
<div><pre><code>zkClient<span>.</span><span>delete</span><span>(</span><span>)</span><span>.</span><span>deletingChildrenIfNeeded</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="_3-2-3-获取-更新节点数据内容"> 3.2.3. 获取/更新节点数据内容</h4>
<div><pre><code>zkClient<span>.</span><span>create</span><span>(</span><span>)</span><span>.</span><span>creatingParentsIfNeeded</span><span>(</span><span>)</span><span>.</span><span>withMode</span><span>(</span><span>CreateMode</span><span>.</span>EPHEMERAL<span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1/00001"</span><span>,</span><span>"java"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>
zkClient<span>.</span><span>getData</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1/00001"</span><span>)</span><span>;</span><span>//获取节点的数据内容</span>
zkClient<span>.</span><span>setData</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1/00001"</span><span>,</span><span>"c++"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//更新节点数据内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="_3-2-4-获取某个节点的所有子节点路径"> 3.2.4. 获取某个节点的所有子节点路径</h4>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> childrenPaths <span>=</span> zkClient<span>.</span><span>getChildren</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span><span>"/node1"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>ZooKeeper 相关概念总结(入门)</title>
      <link>https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro/</link>
      <guid>https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">ZooKeeper 相关概念总结(入门)</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="zookeeper-相关概念总结-入门"> ZooKeeper 相关概念总结(入门)</h1>
<h2 id="_1-前言"> 1. 前言</h2>
<p>相信大家对 ZooKeeper 应该不算陌生。但是你真的了解 ZooKeeper 到底有啥用不？如果别人/面试官让你给他讲讲对于 ZooKeeper 的认识，你能回答到什么地步呢？</p>
<p>拿我自己来说吧！我本人曾经使用 Dubbo 来做分布式项目的时候，使用了 ZooKeeper 作为注册中心。为了保证分布式系统能够同步访问某个资源，我还使用 ZooKeeper 做过分布式锁。另外，我在学习 Kafka 的时候，知道 Kafka 很多功能的实现依赖了 ZooKeeper。</p>
<p>前几天，总结项目经验的时候，我突然问自己 ZooKeeper 到底是个什么东西？想了半天，脑海中只是简单的能浮现出几句话：</p>
<ol>
<li>ZooKeeper 可以被用作注册中心、分布式锁；</li>
<li>ZooKeeper 是 Hadoop 生态系统的一员；</li>
<li>构建 ZooKeeper 集群的时候，使用的服务器最好是奇数台。</li>
</ol>
<p>由此可见，我对于 ZooKeeper 的理解仅仅是停留在了表面。</p>
<p>所以，通过本文，希望带大家稍微详细的了解一下 ZooKeeper 。如果没有学过 ZooKeeper ，那么本文将会是你进入 ZooKeeper 大门的垫脚砖。如果你已经接触过 ZooKeeper ，那么本文将带你回顾一下 ZooKeeper 的一些基础概念。</p>
<p>另外，本文不光会涉及到 ZooKeeper 的一些概念，后面的文章会介绍到 ZooKeeper 常见命令的使用以及使用 Apache Curator 作为 ZooKeeper 的客户端。</p>
<p><em>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！</em></p>
<h2 id="_2-zookeeper-介绍"> 2. ZooKeeper 介绍</h2>
<h3 id="_2-1-zookeeper-由来"> 2.1. ZooKeeper 由来</h3>
<p>正式介绍 ZooKeeper 之前，我们先来看看 ZooKeeper 的由来，还挺有意思的。</p>
<p>下面这段内容摘自《从 Paxos 到 ZooKeeper 》第四章第一节，推荐大家阅读一下：</p>
<blockquote>
<p>ZooKeeper 最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。</p>
<p>关于“ZooKeeper”这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的 Pig 项目),雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 RaghuRamakrishnan 开玩笑地说：“在这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧一一一因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了，而 ZooKeeper 正好要用来进行分布式环境的协调一一于是，ZooKeeper 的名字也就由此诞生了。</p>
</blockquote>
<h3 id="_2-2-zookeeper-概览"> 2.2. ZooKeeper 概览</h3>
<p>ZooKeeper 是一个开源的<strong>分布式协调服务</strong>，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>
<blockquote>
<p><strong>原语：</strong> 操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。</p>
</blockquote>
<p><strong>ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</strong></p>
<p>另外，<strong>ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。</strong></p>
<h3 id="_2-3-zookeeper-特点"> 2.3. ZooKeeper 特点</h3>
<ul>
<li><strong>顺序一致性：</strong> 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>
<li><strong>原子性：</strong> 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>
<li><strong>单一系统映像 ：</strong> 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>
<li><strong>可靠性：</strong> 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>
</ul>
<h3 id="_2-4-zookeeper-典型应用场景"> 2.4. ZooKeeper 典型应用场景</h3>
<p>ZooKeeper 概览中，我们介绍到使用其通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>
<p>下面选 3 个典型的应用场景来专门说说：</p>
<ol>
<li><strong>分布式锁</strong> ： 通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。</li>
<li><strong>命名服务</strong> ：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID</li>
<li><strong>数据发布/订阅</strong> ：通过 <strong>Watcher 机制</strong> 可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。</li>
</ol>
<p>实际上，这些功能的实现基本都得益于 ZooKeeper 可以保存数据的功能，但是 ZooKeeper 不适合保存大量数据，这一点需要注意。</p>
<h3 id="_2-5-有哪些著名的开源项目用到了-zookeeper"> 2.5. 有哪些著名的开源项目用到了 ZooKeeper?</h3>
<ol>
<li><strong>Kafka</strong> : ZooKeeper 主要为 Kafka 提供 Broker 和 Topic 的注册以及多个 Partition 的负载均衡等功能。</li>
<li><strong>Hbase</strong> : ZooKeeper 为 Hbase 提供确保整个集群只有一个 Master 以及保存和提供 regionserver 状态信息（是否在线）等功能。</li>
<li><strong>Hadoop</strong> : ZooKeeper 为 Namenode 提供高可用支持。</li>
</ol>
<h2 id="_3-zookeeper-重要概念解读"> 3. ZooKeeper 重要概念解读</h2>
<p><em>破音：拿出小本本，下面的内容非常重要哦！</em></p>
<h3 id="_3-1-data-model-数据模型"> 3.1. Data model（数据模型）</h3>
<p>ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。并且。每个节点还可以拥有 N 个子节点，最上层是根节点以“/”来代表。每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。并且，每个 znode 都一个唯一的路径标识。</p>
<p>强调一句：<strong>ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上，ZooKeeper 给出的上限是每个结点的数据大小最大是 1M。</strong></p>
<p>从下图可以更直观地看出：ZooKeeper 节点路径标识方式和 Unix 文件系统路径非常相似，都是由一系列使用斜杠&quot;/&quot;进行分割的路径表示，开发人员可以向这个节点中写入数据，也可以在节点下面创建子节点。这些操作我们后面都会介绍到。</p>
<p><img src="./images/znode-structure.png" alt="ZooKeeper 数据模型" /></p>
<h3 id="_3-2-znode-数据节点"> 3.2. znode（数据节点）</h3>
<p>介绍了 ZooKeeper 树形数据模型之后，我们知道每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。你要存放的数据就放在上面，是你使用 ZooKeeper 过程中经常需要接触到的一个概念。</p>
<h4 id="_3-2-1-znode-4-种类型"> 3.2.1. znode 4 种类型</h4>
<p>我们通常是将 znode 分为 4 大类：</p>
<ul>
<li><strong>持久（PERSISTENT）节点</strong> ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li>
<li><strong>临时（EPHEMERAL）节点</strong> ：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，<strong>临时节点只能做叶子节点</strong> ，不能创建子节点。</li>
<li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong> ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code> 、<code>/node1/app0000000002</code> 。</li>
<li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong> ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li>
</ul>
<h4 id="_3-2-2-znode-数据结构"> 3.2.2. znode 数据结构</h4>
<p>每个 znode 由 2 部分组成:</p>
<ul>
<li><strong>stat</strong> ：状态信息</li>
<li><strong>data</strong> ： 节点存放的数据的具体内容</li>
</ul>
<p>如下所示，我通过 get 命令来获取 根目录下的 dubbo 节点的内容。（get 命令在下面会介绍到）。</p>
<div><pre><code><span>[</span>zk: <span>127.0</span>.0.1:2181<span>(</span>CONNECTED<span>)</span> <span>6</span><span>]</span> get /dubbo
<span># 该数据节点关联的数据内容为空</span>
null
<span># 下面是该数据节点的一些状态信息，其实就是 Stat 对象的格式化输出</span>
cZxid <span>=</span> 0x2
ctime <span>=</span> Tue Nov <span>27</span> <span>11</span>:05:34 CST <span>2018</span>
mZxid <span>=</span> 0x2
mtime <span>=</span> Tue Nov <span>27</span> <span>11</span>:05:34 CST <span>2018</span>
pZxid <span>=</span> 0x3
cversion <span>=</span> <span>1</span>
dataVersion <span>=</span> <span>0</span>
aclVersion <span>=</span> <span>0</span>
ephemeralOwner <span>=</span> 0x0
dataLength <span>=</span> <span>0</span>
numChildren <span>=</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>Stat 类中包含了一个数据节点的所有状态信息的字段，包括事务 ID-cZxid、节点创建时间-ctime 和子节点个数-numChildren 等等。</p>
<p>下面我们来看一下每个 znode 状态信息究竟代表的是什么吧！（下面的内容来源于《从 Paxos 到 ZooKeeper 分布式一致性原理与实践》，因为 Guide 确实也不是特别清楚，要学会参考资料的嘛！ ） ：</p>
<table>
<thead>
<tr>
<th>znode 状态信息</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>cZxid</td>
<td>create ZXID，即该数据节点被创建时的事务 id</td>
</tr>
<tr>
<td>ctime</td>
<td>create time，即该节点的创建时间</td>
</tr>
<tr>
<td>mZxid</td>
<td>modified ZXID，即该节点最终一次更新时的事务 id</td>
</tr>
<tr>
<td>mtime</td>
<td>modified time，即该节点最后一次的更新时间</td>
</tr>
<tr>
<td>pZxid</td>
<td>该节点的子节点列表最后一次修改时的事务 id，只有子节点列表变更才会更新 pZxid，子节点内容变更不会更新</td>
</tr>
<tr>
<td>cversion</td>
<td>子节点版本号，当前节点的子节点每次变化时值增加 1</td>
</tr>
<tr>
<td>dataVersion</td>
<td>数据节点内容版本号，节点创建时为 0，每更新一次节点内容(不管内容有无变化)该版本号的值增加 1</td>
</tr>
<tr>
<td>aclVersion</td>
<td>节点的 ACL 版本号，表示该节点 ACL 信息变更次数</td>
</tr>
<tr>
<td>ephemeralOwner</td>
<td>创建该临时节点的会话的 sessionId；如果当前节点为持久节点，则 ephemeralOwner=0</td>
</tr>
<tr>
<td>dataLength</td>
<td>数据节点内容长度</td>
</tr>
<tr>
<td>numChildren</td>
<td>当前节点的子节点个数</td>
</tr>
</tbody>
</table>
<h3 id="_3-3-版本-version"> 3.3. 版本（version）</h3>
<p>在前面我们已经提到，对应于每个 znode，ZooKeeper 都会为其维护一个叫作 <strong>Stat</strong> 的数据结构，Stat 中记录了这个 znode 的三个相关的版本：</p>
<ul>
<li><strong>dataVersion</strong> ：当前 znode 节点的版本号</li>
<li><strong>cversion</strong> ： 当前 znode 子节点的版本</li>
<li><strong>aclVersion</strong> ： 当前 znode 的 ACL 的版本。</li>
</ul>
<h3 id="_3-4-acl-权限控制"> 3.4. ACL（权限控制）</h3>
<p>ZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。</p>
<p>对于 znode 操作的权限，ZooKeeper 提供了以下 5 种：</p>
<ul>
<li><strong>CREATE</strong> : 能创建子节点</li>
<li><strong>READ</strong> ：能获取节点数据和列出其子节点</li>
<li><strong>WRITE</strong> : 能设置/更新节点数据</li>
<li><strong>DELETE</strong> : 能删除子节点</li>
<li><strong>ADMIN</strong> : 能设置节点 ACL 的权限</li>
</ul>
<p>其中尤其需要注意的是，<strong>CREATE</strong> 和 <strong>DELETE</strong> 这两种权限都是针对 <strong>子节点</strong> 的权限控制。</p>
<p>对于身份认证，提供了以下几种方式：</p>
<ul>
<li><strong>world</strong> ： 默认方式，所有用户都可无条件访问。</li>
<li><strong>auth</strong> :不使用任何 id，代表任何已认证的用户。</li>
<li><strong>digest</strong> :用户名:密码认证方式： <em>username:password</em> 。</li>
<li><strong>ip</strong> : 对指定 ip 进行限制。</li>
</ul>
<h3 id="_3-5-watcher-事件监听器"> 3.5. Watcher（事件监听器）</h3>
<p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>
<p><img src="./images/watche机制.png" alt="watcher机制" /></p>
<p><em>破音：非常有用的一个特性，都能出小本本记好了，后面用到 ZooKeeper 基本离不开 Watcher（事件监听器）机制。</em></p>
<h3 id="_3-6-会话-session"> 3.6. 会话（Session）</h3>
<p>Session 可以看作是 ZooKeeper 服务器与客户端的之间的一个 TCP 长连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watcher 事件通知。</p>
<p>Session 有一个属性叫做：<code>sessionTimeout</code> ，<code>sessionTimeout</code> 代表会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在<code>sessionTimeout</code>规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p>
<p>另外，在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 <code>sessionID</code>。由于 <code>sessionID</code>是 ZooKeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 <code>sessionID</code> 的，因此，无论是哪台服务器为客户端分配的 <code>sessionID</code>，都务必保证全局唯一。</p>
<h2 id="_4-zookeeper-集群"> 4. ZooKeeper 集群</h2>
<p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。ZooKeeper 官方提供的架构图就是一个 ZooKeeper 集群整体对外提供服务。</p>
<p><img src="./images/zookeeper集群.png" alt="" /></p>
<p>上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 ZAB 协议（ZooKeeper Atomic Broadcast）来保持数据的一致性。</p>
<p><strong>最典型集群模式： Master/Slave 模式（主备模式）</strong>。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</p>
<h3 id="_4-1-zookeeper-集群角色"> 4.1. ZooKeeper 集群角色</h3>
<p>但是，在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了 Leader、Follower 和 Observer 三种角色。如下图所示</p>
<p><img src="./images/zookeeper集群中的角色.png" alt="" /></p>
<p>ZooKeeper 集群中的所有机器通过一个 <strong>Leader 选举过程</strong> 来选定一台称为 “<strong>Leader</strong>” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，<strong>Follower</strong> 和 <strong>Observer</strong> 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Leader</td>
<td>为客户端提供读和写的服务，负责投票的发起和决议，更新系统状态。</td>
</tr>
<tr>
<td>Follower</td>
<td>为客户端提供读服务，如果是写服务则转发给 Leader。参与选举过程中的投票。</td>
</tr>
<tr>
<td>Observer</td>
<td>为客户端提供读服务，如果是写服务则转发给 Leader。不参与选举过程中的投票，也不参与“过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于 ZooKeeper3.3 系列新增的角色。</td>
</tr>
</tbody>
</table>
<p>当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入 Leader 选举过程，这个过程会选举产生新的 Leader 服务器。</p>
<p>这个过程大致是这样的：</p>
<ol>
<li><strong>Leader election（选举阶段）</strong>：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。</li>
<li><strong>Discovery（发现阶段）</strong> ：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。</li>
<li><strong>Synchronization（同步阶段）</strong> :同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后
准 leader 才会成为真正的 leader。</li>
<li><strong>Broadcast（广播阶段）</strong> :到了这个阶段，ZooKeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li>
</ol>
<h3 id="_4-2-zookeeper-集群中的服务器状态"> 4.2. ZooKeeper 集群中的服务器状态</h3>
<ul>
<li><strong>LOOKING</strong> ：寻找 Leader。</li>
<li><strong>LEADING</strong> ：Leader 状态，对应的节点为 Leader。</li>
<li><strong>FOLLOWING</strong> ：Follower 状态，对应的节点为 Follower。</li>
<li><strong>OBSERVING</strong> ：Observer 状态，对应节点为 Observer，该节点不参与 Leader 选举。</li>
</ul>
<h3 id="_4-3-zookeeper-集群为啥最好奇数台"> 4.3. ZooKeeper 集群为啥最好奇数台？</h3>
<p>ZooKeeper 集群在宕掉几个 ZooKeeper 服务器之后，如果剩下的 ZooKeeper 服务器个数大于宕掉的个数的话整个 ZooKeeper 才依然可用。假如我们的集群中有 n 台 ZooKeeper 服务器，那么也就是剩下的服务数必须大于 n/2。先说一下结论，2n 和 2n-1 的容忍度是一样的，都是 n-1，大家可以先自己仔细想一想，这应该是一个很简单的数学问题了。</p>
<p>比如假如我们有 3 台，那么最大允许宕掉 1 台 ZooKeeper 服务器，如果我们有 4 台的的时候也同样只允许宕掉 1 台。
假如我们有 5 台，那么最大允许宕掉 2 台 ZooKeeper 服务器，如果我们有 6 台的的时候也同样只允许宕掉 2 台。</p>
<p>综上，何必增加那一个不必要的 ZooKeeper 呢？</p>
<h3 id="_4-4-zookeeper-选举的过半机制防止脑裂"> 4.4. ZooKeeper 选举的过半机制防止脑裂</h3>
<p><strong>何为集群脑裂？</strong></p>
<p>对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。保证可用性的同时，会发生一种机房间网络线路故障，导致机房间网络不通，而集群被割裂成几个小集群。这时候子集群各自选主导致“脑裂”的情况。</p>
<p>举例说明：比如现在有一个由 6 台服务器所组成的一个集群，部署在了 2 个机房，每个机房 3 台。正常情况下只有 1 个 leader，但是当两个机房中间网络断开的时候，每个机房的 3 台服务器都会认为另一个机房的 3 台服务器下线，而选出自己的 leader 并对外提供服务。若没有过半机制，当网络恢复的时候会发现有 2 个 leader。仿佛是 1 个大脑（leader）分散成了 2 个大脑，这就发生了脑裂现象。脑裂期间 2 个大脑都可能对外提供了服务，这将会带来数据一致性等问题。</p>
<p><strong>过半机制是如何防止脑裂现象产生的？</strong></p>
<p>ZooKeeper 的过半机制导致不可能产生 2 个 leader，因为少于等于一半是不可能产生 leader 的，这就使得不论机房的机器如何分配都不可能发生脑裂。</p>
<h2 id="_5-zab-协议和-paxos-算法"> 5. ZAB 协议和 Paxos 算法</h2>
<p>Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos 算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在 ZooKeeper 的官方文档中也指出，ZAB 协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 Zookeeper 设计的崩溃可恢复的原子消息广播算法。</p>
<h3 id="_5-1-zab-协议介绍"> 5.1. ZAB 协议介绍</h3>
<p>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p>
<h3 id="_5-2-zab-协议两种基本的模式-崩溃恢复和消息广播"> 5.2. ZAB 协议两种基本的模式：崩溃恢复和消息广播</h3>
<p>ZAB 协议包括两种基本的模式，分别是</p>
<ul>
<li><strong>崩溃恢复</strong> ：当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。其中，<strong>所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致</strong>。</li>
<li><strong>消息广播</strong> ：<strong>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。</strong> 当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</li>
</ul>
<p>关于 <strong>ZAB 协议&amp;Paxos 算法</strong> 需要讲和理解的东西太多了，具体可以看下面这两篇文章：</p>
<ul>
<li><a href="http://codemacro.com/2014/10/15/explain-poxos/" target="_blank" rel="noopener noreferrer">图解 Paxos 一致性协议</a></li>
<li><a href="https://dbaplus.cn/news-141-1875-1.html" target="_blank" rel="noopener noreferrer">Zookeeper ZAB 协议分析</a></li>
</ul>
<h2 id="_6-总结"> 6. 总结</h2>
<ol>
<li>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。</li>
<li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</li>
<li>ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 znode 中存储的数据量较小的进一步原因）。</li>
<li>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地明显，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li>
<li>ZooKeeper 有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个 znode 被创建了，除非主动进行 znode 的移除操作，否则这个 znode 将一直保存在 ZooKeeper 上。</li>
<li>ZooKeeper 底层其实只提供了两个功能：① 管理（存储、读取）用户程序提交的数据；② 为用户程序提供数据节点监听服务。</li>
</ol>
<h2 id="_7-参考"> 7. 参考</h2>
<ol>
<li>《从 Paxos 到 ZooKeeper 分布式一致性原理与实践》</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>ZooKeeper 相关概念总结(进阶)</title>
      <link>https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus/</link>
      <guid>https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus/</guid>
      <source url="https://javaguide.cn/rss.xml">ZooKeeper 相关概念总结(进阶)</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="zookeeper-相关概念总结-进阶"> ZooKeeper 相关概念总结(进阶)</h1>
<blockquote>
<p><a href="https://juejin.im/user/5c33853851882525ea106810" target="_blank" rel="noopener noreferrer">FrancisQ</a> 投稿。</p>
</blockquote>
<h2 id="_1-好久不见"> 1. 好久不见</h2>
<p>离上一篇文章的发布也快一个月了，想想已经快一个月没写东西了，其中可能有期末考试、课程设计和驾照考试，但这都不是借口！</p>
<p>一到冬天就懒的不行，望广大掘友督促我🙄🙄✍️✍️。</p>
<blockquote>
<p>文章很长，先赞后看，养成习惯。❤️ 🧡 💛 💚 💙 💜</p>
</blockquote>
<h2 id="_2-什么是zookeeper"> 2. 什么是ZooKeeper</h2>
<p><code>ZooKeeper</code> 由 <code>Yahoo</code> 开发，后来捐赠给了 <code>Apache</code> ，现已成为 <code>Apache</code> 顶级项目。<code>ZooKeeper</code> 是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于 <code>Paxos</code> 算法的 <code>ZAB</code> 协议完成的。其主要功能包括：配置维护、分布式同步、集群管理、分布式事务等。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7c349891b773671514a68f057b2e14f8.png" alt="zookeeper" /></p>
<p>简单来说， <code>ZooKeeper</code> 是一个 <strong>分布式协调服务框架</strong> 。分布式？协调服务？这啥玩意？🤔🤔</p>
<p>其实解释到分布式这个概念的时候，我发现有些同学并不是能把 **分布式和集群 **这两个概念很好的理解透。前段时间有同学和我探讨起分布式的东西，他说分布式不就是加机器吗？一台机器不够用再加一台抗压呗。当然加机器这种说法也无可厚非，你一个分布式系统必定涉及到多个机器，但是你别忘了，计算机学科中还有一个相似的概念—— <code>Cluster</code> ，集群不也是加机器吗？但是 集群 和 分布式 其实就是两个完全不同的概念。</p>
<p>比如，我现在有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也 <strong>一样</strong> 提供秒杀服务，这个时候就是 <strong><code>Cluster</code> 集群</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ffcb080eb66f242ffcd8d2047a7f46aa.png" alt="cluster" /></p>
<p>但是，我现在换一种方式，我将一个秒杀服务 <strong>拆分成多个子服务</strong> ，比如创建订单服务，增加积分服务，扣优惠券服务等等，<strong>然后我将这些子服务都部署在不同的服务器上</strong> ，这个时候就是  <strong><code>Distributed</code> 分布式</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/07191f38aa947b0075e5c0a6a019a11d.png" alt="distributed" /></p>
<p>而我为什么反驳同学所说的分布式就是加机器呢？因为我认为加机器更加适用于构建集群，因为它真是只有加机器。而对于分布式来说，你首先需要将业务进行拆分，然后再加机器（不仅仅是加机器那么简单），同时你还要去解决分布式带来的一系列问题。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2b2fbc21abfb3f6547a2121f28c6d00f.png" alt="" /></p>
<p>比如各个分布式组件如何协调起来，如何减少各个系统之间的耦合度，分布式事务的处理，如何去配置整个分布式系统等等。<code>ZooKeeper</code> 主要就是解决这些问题的。</p>
<h2 id="_3-一致性问题"> 3. 一致性问题</h2>
<p>设计一个分布式系统必定会遇到一个问题—— <strong>因为分区容忍性（partition tolerance）的存在，就必定要求我们需要在系统可用性（availability）和数据一致性（consistency）中做出权衡</strong> 。这就是著名的 <code>CAP</code> 定理。</p>
<p>理解起来其实很简单，比如说把一个班级作为整个系统，而学生是系统中的一个个独立的子系统。这个时候班里的小红小明偷偷谈恋爱被班里的大嘴巴小花发现了，小花欣喜若狂告诉了周围的人，然后小红小明谈恋爱的消息在班级里传播起来了。当在消息的传播（散布）过程中，你抓到一个同学问他们的情况，如果回答你不知道，那么说明整个班级系统出现了数据不一致的问题（因为小花已经知道这个消息了）。而如果他直接不回答你，因为整个班级有消息在进行传播（为了保证一致性，需要所有人都知道才可提供服务），这个时候就出现了系统的可用性问题。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/34ffff41f6ca4f221ca9d9ad6f0b5470.png" alt="" /></p>
<p>而上述前者就是 <code>Eureka</code> 的处理方式，它保证了AP（可用性），后者就是我们今天所要讲的 <code>ZooKeeper</code> 的处理方式，它保证了CP（数据一致性）。</p>
<h2 id="_4-一致性协议和算法"> 4. 一致性协议和算法</h2>
<p>而为了解决数据一致性问题，在科学家和程序员的不断探索中，就出现了很多的一致性协议和算法。比如 2PC（两阶段提交），3PC（三阶段提交），Paxos算法等等。</p>
<p>这时候请你思考一个问题，同学之间如果采用传纸条的方式去传播消息，那么就会出现一个问题——我咋知道我的小纸条有没有传到我想要传递的那个人手中呢？万一被哪个小家伙给劫持篡改了呢，对吧？</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b0e01fe3213dcc1535c31298ba9bdfbc.png" alt="" /></p>
<p>这个时候就引申出一个概念—— <strong>拜占庭将军问题</strong> 。它意指 <strong>在不可靠信道上试图通过消息传递的方式达到一致性是不可能的</strong>， 所以所有的一致性算法的 <strong>必要前提</strong> 就是安全可靠的消息通道。</p>
<p>而为什么要去解决数据一致性的问题？你想想，如果一个秒杀系统将服务拆分成了下订单和加积分服务，这两个服务部署在不同的机器上了，万一在消息的传播过程中积分系统宕机了，总不能你这边下了订单却没加积分吧？你总得保证两边的数据需要一致吧？</p>
<h3 id="_4-1-2pc-两阶段提交"> 4.1. 2PC（两阶段提交）</h3>
<p>两阶段提交是一种保证分布式系统数据一致性的协议，现在很多数据库都是采用的两阶段提交协议来完成 <strong>分布式事务</strong> 的处理。</p>
<p>在介绍2PC之前，我们先来想想分布式事务到底有什么问题呢？</p>
<p>还拿秒杀系统的下订单和加积分两个系统来举例吧（我想你们可能都吐了🤮🤮🤮），我们此时下完订单会发个消息给积分系统告诉它下面该增加积分了。如果我们仅仅是发送一个消息也不收回复，那么我们的订单系统怎么能知道积分系统的收到消息的情况呢？如果我们增加一个收回复的过程，那么当积分系统收到消息后返回给订单系统一个 <code>Response</code> ，但在中间出现了网络波动，那个回复消息没有发送成功，订单系统是不是以为积分系统消息接收失败了？它是不是会回滚事务？但此时积分系统是成功收到消息的，它就会去处理消息然后给用户增加积分，这个时候就会出现积分加了但是订单没下成功。</p>
<p>所以我们所需要解决的是在分布式系统中，整个调用链中，我们所有服务的数据处理要么都成功要么都失败，即所有服务的 <strong>原子性问题</strong> 。</p>
<p>在两阶段提交中，主要涉及到两个角色，分别是协调者和参与者。</p>
<p>第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 <code>prepare</code> 请求（其中包括事务内容）告诉参与者你们需要执行事务了，如果能执行我发的事务内容那么就先执行但不提交，执行后请给我回复。然后参与者收到 <code>prepare</code> 消息后，他们会开始执行事务（但不提交），并将 <code>Undo</code> 和 <code>Redo</code> 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了。</p>
<p>第二阶段：第二阶段主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作，即提交事务或者回滚事务。</p>
<p>比如这个时候 <strong>所有的参与者</strong> 都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 <strong><code>Commit</code> 请求</strong> ，当参与者收到 <code>Commit</code> 请求的时候会执行前面执行的事务的 <strong>提交操作</strong> ，提交完毕之后将给协调者发送提交成功的响应。</p>
<p>而如果在第一阶段并不是所有参与者都返回了准备好了的消息，那么此时协调者将会给所有参与者发送 <strong>回滚事务的 <code>rollback</code> 请求</strong>，参与者收到之后将会 <strong>回滚它在第一阶段所做的事务处理</strong> ，然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7ce4e40b68d625676bb42c29efce046a.png" alt="2PC流程" /></p>
<p>个人觉得 2PC 实现得还是比较鸡肋的，因为事实上它只解决了各个事务的原子性问题，随之也带来了很多的问题。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9af1ad68517561a8e9f5d3455a32132d.png" alt="" /></p>
<ul>
<li><strong>单点故障问题</strong>，如果协调者挂了那么整个系统都处于不可用的状态了。</li>
<li><strong>阻塞问题</strong>，即当协调者发送 <code>prepare</code> 请求，参与者收到之后如果能处理那么它将会进行事务的处理但并不提交，这个时候会一直占用着资源不释放，如果此时协调者挂了，那么这些资源都不会再释放了，这会极大影响性能。</li>
<li><strong>数据不一致问题</strong>，比如当第二阶段，协调者只发送了一部分的 <code>commit</code> 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。</li>
</ul>
<h3 id="_4-2-3pc-三阶段提交"> 4.2. 3PC（三阶段提交）</h3>
<p>因为2PC存在的一系列问题，比如单点，容错机制缺陷等等，从而产生了 <strong>3PC（三阶段提交）</strong> 。那么这三阶段又分别是什么呢？</p>
<blockquote>
<p>千万不要吧PC理解成个人电脑了，其实他们是 phase-commit 的缩写，即阶段提交。</p>
</blockquote>
<ol>
<li><strong>CanCommit阶段</strong>：协调者向所有参与者发送 <code>CanCommit</code> 请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO 。</li>
<li><strong>PreCommit阶段</strong>：协调者根据参与者返回的响应来决定是否可以进行下面的 <code>PreCommit</code> 操作。如果上面参与者返回的都是 YES，那么协调者将向所有参与者发送 <code>PreCommit</code> 预提交请求，<strong>参与者收到预提交请求后，会进行事务的执行操作，并将 <code>Undo</code> 和 <code>Redo</code> 信息写入事务日志中</strong> ，最后如果参与者顺利执行了事务则给协调者返回成功的响应。如果在第一阶段协调者收到了 <strong>任何一个 NO</strong> 的信息，或者 <strong>在一定时间内</strong> 并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort），参与者收到中断请求之后会立即中断事务，或者在一定时间内没有收到协调者的请求，它也会中断事务。</li>
<li><strong>DoCommit阶段</strong>：这个阶段其实和 <code>2PC</code> 的第二阶段差不多，如果协调者收到了所有参与者在 <code>PreCommit</code> 阶段的 YES 响应，那么协调者将会给所有参与者发送 <code>DoCommit</code> 请求，<strong>参与者收到 <code>DoCommit</code> 请求后则会进行事务的提交工作</strong>，完成后则会给协调者返回响应，协调者收到所有参与者返回的事务提交成功的响应之后则完成事务。若协调者在 <code>PreCommit</code> 阶段 <strong>收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应</strong> ，那么就会进行中断请求的发送，参与者收到中断请求后则会 <strong>通过上面记录的回滚日志</strong> 来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d0b44361c746593f70a6e42c298b413a.png" alt="3PC流程" /></p>
<blockquote>
<p>这里是 <code>3PC</code> 在成功的环境下的流程图，你可以看到 <code>3PC</code> 在很多地方进行了超时中断的处理，比如协调者在指定时间内为收到全部的确认消息则进行事务中断的处理，这样能 <strong>减少同步阻塞的时间</strong> 。还有需要注意的是，<strong><code>3PC</code> 在 <code>DoCommit</code> 阶段参与者如未收到协调者发送的提交事务的请求，它会在一定时间内进行事务的提交</strong>。为什么这么做呢？是因为这个时候我们肯定<strong>保证了在第一阶段所有的协调者全部返回了可以执行事务的响应</strong>，这个时候我们有理由<strong>相信其他系统都能进行事务的执行和提交</strong>，所以<strong>不管</strong>协调者有没有发消息给参与者，进入第三阶段参与者都会进行事务的提交操作。</p>
</blockquote>
<p>总之，<code>3PC</code> 通过一系列的超时机制很好的缓解了阻塞问题，但是最重要的一致性并没有得到根本的解决，比如在 <code>PreCommit</code> 阶段，当一个参与者收到了请求之后其他参与者和协调者挂了或者出现了网络分区，这个时候收到消息的参与者都会进行事务提交，这就会出现数据不一致性问题。</p>
<p>所以，要解决一致性问题还需要靠 <code>Paxos</code> 算法⭐️ ⭐️ ⭐️ 。</p>
<h3 id="_4-3-paxos-算法"> 4.3. <code>Paxos</code> 算法</h3>
<p><code>Paxos</code> 算法是基于<strong>消息传递且具有高度容错特性的一致性算法</strong>，是目前公认的解决分布式一致性问题最有效的算法之一，<strong>其解决的问题就是在分布式系统中如何就某个值（决议）达成一致</strong> 。</p>
<p>在 <code>Paxos</code> 中主要有三个角色，分别为 <code>Proposer提案者</code>、<code>Acceptor表决者</code>、<code>Learner学习者</code>。<code>Paxos</code> 算法和 <code>2PC</code> 一样，也有两个阶段，分别为 <code>Prepare</code> 和 <code>accept</code> 阶段。</p>
<h4 id="_4-3-1-prepare-阶段"> 4.3.1. prepare 阶段</h4>
<ul>
<li><code>Proposer提案者</code>：负责提出 <code>proposal</code>，每个提案者在提出提案时都会首先获取到一个 <strong>具有全局唯一性的、递增的提案编号N</strong>，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案，在<strong>第一阶段是只将提案编号发送给所有的表决者</strong>。</li>
<li><code>Acceptor表决者</code>：每个表决者在 <code>accept</code> 某提案后，会将该提案编号N记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个<strong>编号最大的提案</strong>，其编号假设为 <code>maxN</code>。每个表决者仅会 <code>accept</code> 编号大于自己本地 <code>maxN</code> 的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给 <code>Proposer</code> 。</li>
</ul>
<blockquote>
<p>下面是 <code>prepare</code> 阶段的流程图，你可以对照着参考一下。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/22e8d512d954676bdf0cc92d200af8ef.png" alt="paxos第一阶段" /></p>
<h4 id="_4-3-2-accept-阶段"> 4.3.2. accept 阶段</h4>
<p>当一个提案被 <code>Proposer</code> 提出后，如果 <code>Proposer</code> 收到了超过半数的 <code>Acceptor</code> 的批准（<code>Proposer</code> 本身同意），那么此时 <code>Proposer</code> 会给所有的 <code>Acceptor</code> 发送真正的提案（你可以理解为第一阶段为试探），这个时候 <code>Proposer</code> 就会发送提案的内容和提案编号。</p>
<p>表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号 <strong>大于等于</strong> 已经批准过的最大提案编号，那么就 <code>accept</code> 该提案（此时执行提案内容但不提交），随后将情况返回给 <code>Proposer</code> 。如果不满足则不回应或者返回 NO 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b82536f956f70a584c6a20c10113f225.png" alt="paxos第二阶段1" /></p>
<p>当 <code>Proposer</code> 收到超过半数的 <code>accept</code> ，那么它这个时候会向所有的 <code>acceptor</code> 发送提案的提交请求。需要注意的是，因为上述仅仅是超过半数的 <code>acceptor</code> 批准执行了该提案内容，其他没有批准的并没有执行该提案内容，所以这个时候需要<strong>向未批准的 <code>acceptor</code> 发送提案内容和提案编号并让它无条件执行和提交</strong>，而对于前面已经批准过该提案的 <code>acceptor</code> 来说 <strong>仅仅需要发送该提案的编号</strong> ，让 <code>acceptor</code> 执行提交就行了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/743889b97485fdfe2094e5ef0af6b141.png" alt="paxos第二阶段2" /></p>
<p>而如果 <code>Proposer</code> 如果没有收到超过半数的 <code>accept</code>  那么它将会将 <strong>递增</strong> 该 <code>Proposal</code> 的编号，然后 <strong>重新进入 <code>Prepare</code> 阶段</strong> 。</p>
<blockquote>
<p>对于 <code>Learner</code> 来说如何去学习 <code>Acceptor</code> 批准的提案内容，这有很多方式，读者可以自己去了解一下，这里不做过多解释。</p>
</blockquote>
<h4 id="_4-3-3-paxos-算法的死循环问题"> 4.3.3. <code>paxos</code> 算法的死循环问题</h4>
<p>其实就有点类似于两个人吵架，小明说我是对的，小红说我才是对的，两个人据理力争的谁也不让谁🤬🤬。</p>
<p>比如说，此时提案者 P1 提出一个方案 M1，完成了 <code>Prepare</code> 阶段的工作，这个时候 <code>acceptor</code> 则批准了 M1，但是此时提案者 P2 同时也提出了一个方案 M2，它也完成了 <code>Prepare</code> 阶段的工作。然后 P1 的方案已经不能在第二阶段被批准了（因为 <code>acceptor</code> 已经批准了比 M1 更大的 M2），所以 P1 自增方案变为 M3 重新进入 <code>Prepare</code> 阶段，然后 <code>acceptor</code> ，又批准了新的 M3 方案，它又不能批准 M2 了，这个时候 M2 又自增进入 <code>Prepare</code> 阶段。。。</p>
<p>就这样无休无止的永远提案下去，这就是 <code>paxos</code> 算法的死循环问题。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/72ccf65cdc107346ff2a1a881d296a2b.png" alt="" /></p>
<p>那么如何解决呢？很简单，人多了容易吵架，我现在 <strong>就允许一个能提案</strong> 就行了。</p>
<h2 id="_5-引出-zab"> 5. 引出 <code>ZAB</code></h2>
<h3 id="_5-1-zookeeper-架构"> 5.1. <code>Zookeeper</code> 架构</h3>
<p>作为一个优秀高效且可靠的分布式协调框架，<code>ZooKeeper</code> 在解决分布式数据一致性问题时并没有直接使用 <code>Paxos</code> ，而是专门定制了一致性协议叫做 <code>ZAB(ZooKeeper Atomic Broadcast)</code> 原子广播协议，该协议能够很好地支持 <strong>崩溃恢复</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0c38d08ea026e25bf3849cc7654a4e79.png" alt="Zookeeper架构" /></p>
<h3 id="_5-2-zab-中的三个角色"> 5.2. <code>ZAB</code> 中的三个角色</h3>
<p>和介绍 <code>Paxos</code> 一样，在介绍 <code>ZAB</code> 协议之前，我们首先来了解一下在 <code>ZAB</code> 中三个主要的角色，<code>Leader 领导者</code>、<code>Follower跟随者</code>、<code>Observer观察者</code> 。</p>
<ul>
<li><code>Leader</code> ：集群中 <strong>唯一的写请求处理者</strong> ，能够发起投票（投票也是为了进行写请求）。</li>
<li><code>Follower</code>：能够接收客户端的请求，如果是读请求则可以自己处理，<strong>如果是写请求则要转发给 <code>Leader</code></strong> 。在选举过程中会参与投票，<strong>有选举权和被选举权</strong> 。</li>
<li><code>Observer</code> ：就是没有选举权和被选举权的 <code>Follower</code> 。</li>
</ul>
<p>在 <code>ZAB</code> 协议中对 <code>zkServer</code>(即上面我们说的三个角色的总称) 还有两种模式的定义，分别是 <strong>消息广播</strong> 和 <strong>崩溃恢复</strong> 。</p>
<h3 id="_5-3-消息广播模式"> 5.3. 消息广播模式</h3>
<p>说白了就是 <code>ZAB</code> 协议是如何处理写请求的，上面我们不是说只有 <code>Leader</code> 能处理写请求嘛？那么我们的 <code>Follower</code> 和 <code>Observer</code> 是不是也需要 <strong>同步更新数据</strong> 呢？总不能数据只在 <code>Leader</code> 中更新了，其他角色都没有得到更新吧？</p>
<p>不就是 <strong>在整个集群中保持数据的一致性</strong> 嘛？如果是你，你会怎么做呢？</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e6064aea729dcc2d927d5d81c4797e74.png" alt="" /></p>
<p>废话，第一步肯定需要 <code>Leader</code> 将写请求 <strong>广播</strong> 出去呀，让 <code>Leader</code> 问问 <code>Followers</code> 是否同意更新，如果超过半数以上的同意那么就进行 <code>Follower</code> 和 <code>Observer</code> 的更新（和 <code>Paxos</code> 一样）。当然这么说有点虚，画张图理解一下。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/08ccce48190fe4edcbcbb223d6231876.png" alt="消息广播" /></p>
<p>嗯。。。看起来很简单，貌似懂了🤥🤥🤥。这两个 <code>Queue</code> 哪冒出来的？答案是 <strong><code>ZAB</code> 需要让 <code>Follower</code> 和 <code>Observer</code> 保证顺序性</strong> 。何为顺序性，比如我现在有一个写请求A，此时 <code>Leader</code> 将请求A广播出去，因为只需要半数同意就行，所以可能这个时候有一个 <code>Follower</code> F1因为网络原因没有收到，而 <code>Leader</code> 又广播了一个请求B，因为网络原因，F1竟然先收到了请求B然后才收到了请求A，这个时候请求处理的顺序不同就会导致数据的不同，从而 <strong>产生数据不一致问题</strong> 。</p>
<p>所以在 <code>Leader</code> 这端，它为每个其他的 <code>zkServer</code> 准备了一个 <strong>队列</strong> ，采用先进先出的方式发送消息。由于协议是 **通过 <code>TCP</code> **来进行网络通信的，保证了消息的发送顺序性，接受顺序性也得到了保证。</p>
<p>除此之外，在 <code>ZAB</code> 中还定义了一个 <strong>全局单调递增的事务ID <code>ZXID</code></strong> ，它是一个64位long型，其中高32位表示 <code>epoch</code> 年代，低32位表示事务id。<code>epoch</code> 是会根据 <code>Leader</code> 的变化而变化的，当一个 <code>Leader</code> 挂了，新的 <code>Leader</code> 上位的时候，年代（<code>epoch</code>）就变了。而低32位可以简单理解为递增的事务id。</p>
<p>定义这个的原因也是为了顺序性，每个 <code>proposal</code> 在 <code>Leader</code> 中生成后需要 <strong>通过其 <code>ZXID</code> 来进行排序</strong> ，才能得到处理。</p>
<h3 id="_5-4-崩溃恢复模式"> 5.4. 崩溃恢复模式</h3>
<p>说到崩溃恢复我们首先要提到 <code>ZAB</code> 中的 <code>Leader</code> 选举算法，当系统出现崩溃影响最大应该是 <code>Leader</code> 的崩溃，因为我们只有一个 <code>Leader</code> ，所以当 <code>Leader</code> 出现问题的时候我们势必需要重新选举 <code>Leader</code> 。</p>
<p><code>Leader</code> 选举可以分为两个不同的阶段，第一个是我们提到的 <code>Leader</code> 宕机需要重新选举，第二则是当 <code>Zookeeper</code> 启动时需要进行系统的 <code>Leader</code> 初始化选举。下面我先来介绍一下 <code>ZAB</code> 是如何进行初始化选举的。</p>
<p>假设我们集群中有3台机器，那也就意味着我们需要两台以上同意（超过半数）。比如这个时候我们启动了 <code>server1</code> ，它会首先 <strong>投票给自己</strong> ，投票内容为服务器的 <code>myid</code> 和 <code>ZXID</code> ，因为初始化所以 <code>ZXID</code> 都为0，此时 <code>server1</code> 发出的投票为 (1,0)。但此时 <code>server1</code> 的投票仅为1，所以不能作为 <code>Leader</code> ，此时还在选举阶段所以整个集群处于 <strong><code>Looking</code> 状态</strong>。</p>
<p>接着 <code>server2</code> 启动了，它首先也会将投票选给自己(2,0)，并将投票信息广播出去（<code>server1</code>也会，只是它那时没有其他的服务器了），<code>server1</code> 在收到 <code>server2</code> 的投票信息后会将投票信息与自己的作比较。<strong>首先它会比较 <code>ZXID</code> ，<code>ZXID</code> 大的优先为 <code>Leader</code>，如果相同则比较 <code>myid</code>，<code>myid</code> 大的优先作为 <code>Leader</code></strong>。所以此时<code>server1</code> 发现 <code>server2</code> 更适合做 <code>Leader</code>，它就会将自己的投票信息更改为(2,0)然后再广播出去，之后<code>server2</code>  收到之后发现和自己的一样无需做更改，并且自己的 <strong>投票已经超过半数</strong> ，则 <strong>确定 <code>server2</code> 为 <code>Leader</code></strong>，<code>server1</code> 也会将自己服务器设置为 <code>Following</code> 变为 <code>Follower</code>。整个服务器就从 <code>Looking</code> 变为了正常状态。</p>
<p>当 <code>server3</code> 启动发现集群没有处于 <code>Looking</code> 状态时，它会直接以 <code>Follower</code> 的身份加入集群。</p>
<p>还是前面三个 <code>server</code> 的例子，如果在整个集群运行的过程中 <code>server2</code> 挂了，那么整个集群会如何重新选举 <code>Leader</code> 呢？其实和初始化选举差不多。</p>
<p>首先毫无疑问的是剩下的两个 <code>Follower</code> 会将自己的状态 <strong>从 <code>Following</code> 变为 <code>Looking</code> 状态</strong> ，然后每个 <code>server</code> 会向初始化投票一样首先给自己投票（这不过这里的 <code>zxid</code> 可能不是0了，这里为了方便随便取个数字）。</p>
<p>假设 <code>server1</code> 给自己投票为(1,99)，然后广播给其他 <code>server</code>，<code>server3</code> 首先也会给自己投票(3,95)，然后也广播给其他 <code>server</code>。<code>server1</code> 和 <code>server3</code> 此时会收到彼此的投票信息，和一开始选举一样，他们也会比较自己的投票和收到的投票（<code>zxid</code> 大的优先，如果相同那么就 <code>myid</code> 大的优先）。这个时候 <code>server1</code> 收到了 <code>server3</code> 的投票发现没自己的合适故不变，<code>server3</code> 收到 <code>server1</code> 的投票结果后发现比自己的合适于是更改投票为(1,99)然后广播出去，最后 <code>server1</code> 收到了发现自己的投票已经超过半数就把自己设为 <code>Leader</code>，<code>server3</code> 也随之变为 <code>Follower</code>。</p>
<blockquote>
<p>请注意 <code>ZooKeeper</code> 为什么要设置奇数个结点？比如这里我们是三个，挂了一个我们还能正常工作，挂了两个我们就不能正常工作了（已经没有超过半数的节点数了，所以无法进行投票等操作了）。而假设我们现在有四个，挂了一个也能工作，<strong>但是挂了两个也不能正常工作了</strong>，这是和三个一样的，而三个比四个还少一个，带来的效益是一样的，所以 <code>Zookeeper</code> 推荐奇数个 <code>server</code> 。</p>
</blockquote>
<p>那么说完了 <code>ZAB</code> 中的 <code>Leader</code> 选举方式之后我们再来了解一下 <strong>崩溃恢复</strong> 是什么玩意？</p>
<p>其实主要就是 <strong>当集群中有机器挂了，我们整个集群如何保证数据一致性？</strong></p>
<p>如果只是 <code>Follower</code> 挂了，而且挂的没超过半数的时候，因为我们一开始讲了在 <code>Leader</code> 中会维护队列，所以不用担心后面的数据没接收到导致数据不一致性。</p>
<p>如果 <code>Leader</code> 挂了那就麻烦了，我们肯定需要先暂停服务变为 <code>Looking</code> 状态然后进行 <code>Leader</code> 的重新选举（上面我讲过了），但这个就要分为两种情况了，分别是 <strong>确保已经被Leader提交的提案最终能够被所有的Follower提交</strong> 和 <strong>跳过那些已经被丢弃的提案</strong> 。</p>
<p>确保已经被Leader提交的提案最终能够被所有的Follower提交是什么意思呢？</p>
<p>假设 <code>Leader (server2)</code> 发送 <code>commit</code> 请求（忘了请看上面的消息广播模式），他发送给了 <code>server3</code>，然后要发给 <code>server1</code> 的时候突然挂了。这个时候重新选举的时候我们如果把 <code>server1</code> 作为 <code>Leader</code> 的话，那么肯定会产生数据不一致性，因为 <code>server3</code> 肯定会提交刚刚 <code>server2</code> 发送的 <code>commit</code> 请求的提案，而 <code>server1</code> 根本没收到所以会丢弃。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ffcb12c6fb2bad76ac7105696655e85c.png" alt="崩溃恢复" /></p>
<p>那怎么解决呢？</p>
<p>聪明的同学肯定会质疑，<strong>这个时候 <code>server1</code> 已经不可能成为 <code>Leader</code> 了，因为 <code>server1</code> 和 <code>server3</code> 进行投票选举的时候会比较 <code>ZXID</code> ，而此时 <code>server3</code> 的 <code>ZXID</code> 肯定比 <code>server1</code> 的大了</strong>。(不理解可以看前面的选举算法)</p>
<p>那么跳过那些已经被丢弃的提案又是什么意思呢？</p>
<p>假设 <code>Leader (server2)</code> 此时同意了提案N1，自身提交了这个事务并且要发送给所有 <code>Follower</code> 要 <code>commit</code> 的请求，却在这个时候挂了，此时肯定要重新进行 <code>Leader</code> 的选举，比如说此时选 <code>server1</code> 为 <code>Leader</code> （这无所谓）。但是过了一会，这个 <strong>挂掉的 <code>Leader</code> 又重新恢复了</strong> ，此时它肯定会作为 <code>Follower</code> 的身份进入集群中，需要注意的是刚刚 <code>server2</code> 已经同意提交了提案N1，但其他 <code>server</code> 并没有收到它的 <code>commit</code> 信息，所以其他 <code>server</code> 不可能再提交这个提案N1了，这样就会出现数据不一致性问题了，所以 <strong>该提案N1最终需要被抛弃掉</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/abb6efc7d4df9c82b162cbecb129a6e3.png" alt="崩溃恢复" /></p>
<h2 id="_6-zookeeper的几个理论知识"> 6. Zookeeper的几个理论知识</h2>
<p>了解了 <code>ZAB</code> 协议还不够，它仅仅是 <code>Zookeeper</code> 内部实现的一种方式，而我们如何通过 <code>Zookeeper</code> 去做一些典型的应用场景呢？比如说集群管理，分布式锁，<code>Master</code> 选举等等。</p>
<p>这就涉及到如何使用 <code>Zookeeper</code> 了，但在使用之前我们还需要掌握几个概念。比如 <code>Zookeeper</code> 的 <strong>数据模型</strong> 、<strong>会话机制</strong>、<strong>ACL</strong>、<strong>Watcher机制</strong> 等等。</p>
<h3 id="_6-1-数据模型"> 6.1. 数据模型</h3>
<p><code>zookeeper</code> 数据存储结构与标准的 <code>Unix</code> 文件系统非常相似，都是在根节点下挂很多子节点(树型)。但是 <code>zookeeper</code> 中没有文件系统中目录与文件的概念，而是 <strong>使用了 <code>znode</code> 作为数据节点</strong> 。<code>znode</code> 是 <code>zookeeper</code> 中的最小数据单元，每个 <code>znode</code> 上都可以保存数据，同时还可以挂载子节点，形成一个树形化命名空间。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8f35dba8c44c4a10d81e3395df971ce7.png" alt="zk数据模型" /></p>
<p>每个 <code>znode</code> 都有自己所属的 <strong>节点类型</strong> 和 <strong>节点状态</strong>。</p>
<p>其中节点类型可以分为 <strong>持久节点</strong>、<strong>持久顺序节点</strong>、<strong>临时节点</strong> 和 <strong>临时顺序节点</strong>。</p>
<ul>
<li>持久节点：一旦创建就一直存在，直到将其删除。</li>
<li>持久顺序节点：一个父节点可以为其子节点 <strong>维护一个创建的先后顺序</strong> ，这个顺序体现在 <strong>节点名称</strong> 上，是节点名称后自动添加一个由 10 位数字组成的数字串，从 0 开始计数。</li>
<li>临时节点：临时节点的生命周期是与 <strong>客户端会话</strong> 绑定的，<strong>会话消失则节点消失</strong> 。临时节点 <strong>只能做叶子节点</strong> ，不能创建子节点。</li>
<li>临时顺序节点：父节点可以创建一个维持了顺序的临时节点(和前面的持久顺序性节点一样)。</li>
</ul>
<p>节点状态中包含了很多节点的属性比如 <code>czxid</code> 、<code>mzxid</code> 等等，在 <code>zookeeper</code> 中是使用 <code>Stat</code> 这个类来维护的。下面我列举一些属性解释。</p>
<ul>
<li><code>czxid</code>：<code>Created ZXID</code>，该数据节点被 <strong>创建</strong> 时的事务ID。</li>
<li><code>mzxid</code>：<code>Modified ZXID</code>，节点 <strong>最后一次被更新时</strong> 的事务ID。</li>
<li><code>ctime</code>：<code>Created Time</code>，该节点被创建的时间。</li>
<li><code>mtime</code>： <code>Modified Time</code>，该节点最后一次被修改的时间。</li>
<li><code>version</code>：节点的版本号。</li>
<li><code>cversion</code>：<strong>子节点</strong> 的版本号。</li>
<li><code>aversion</code>：节点的 <code>ACL</code> 版本号。</li>
<li><code>ephemeralOwner</code>：创建该节点的会话的 <code>sessionID</code> ，如果该节点为持久节点，该值为0。</li>
<li><code>dataLength</code>：节点数据内容的长度。</li>
<li><code>numChildre</code>：该节点的子节点个数，如果为临时节点为0。</li>
<li><code>pzxid</code>：该节点子节点列表最后一次被修改时的事务ID，注意是子节点的 <strong>列表</strong> ，不是内容。</li>
</ul>
<h3 id="_6-2-会话"> 6.2. 会话</h3>
<p>我想这个对于后端开发的朋友肯定不陌生，不就是 <code>session</code> 吗？只不过 <code>zk</code> 客户端和服务端是通过 <strong><code>TCP</code> 长连接</strong> 维持的会话机制，其实对于会话来说你可以理解为 <strong>保持连接状态</strong> 。</p>
<p>在 <code>zookeeper</code> 中，会话还有对应的事件，比如 <code>CONNECTION_LOSS 连接丢失事件</code> 、<code>SESSION_MOVED 会话转移事件</code> 、<code>SESSION_EXPIRED 会话超时失效事件</code> 。</p>
<h3 id="_6-3-acl"> 6.3. ACL</h3>
<p><code>ACL</code> 为 <code>Access Control Lists</code> ，它是一种权限控制。在 <code>zookeeper</code> 中定义了5种权限，它们分别为：</p>
<ul>
<li><code>CREATE</code> ：创建子节点的权限。</li>
<li><code>READ</code>：获取节点数据和子节点列表的权限。</li>
<li><code>WRITE</code>：更新节点数据的权限。</li>
<li><code>DELETE</code>：删除子节点的权限。</li>
<li><code>ADMIN</code>：设置节点 ACL 的权限。</li>
</ul>
<h3 id="_6-4-watcher机制"> 6.4. Watcher机制</h3>
<p><code>Watcher</code> 为事件监听器，是 <code>zk</code> 非常重要的一个特性，很多功能都依赖于它，它有点类似于订阅的方式，即客户端向服务端 <strong>注册</strong> 指定的 <code>watcher</code> ，当服务端符合了 <code>watcher</code> 的某些事件或要求则会 <strong>向客户端发送事件通知</strong> ，客户端收到通知后找到自己定义的 <code>Watcher</code> 然后 <strong>执行相应的回调方法</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/241ab8cc37571034fa984322b753c7ba.png" alt="watcher机制" /></p>
<h2 id="_7-zookeeper的几个典型应用场景"> 7. Zookeeper的几个典型应用场景</h2>
<p>前面说了这么多的理论知识，你可能听得一头雾水，这些玩意有啥用？能干啥事？别急，听我慢慢道来。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9c9bd2a892e23e0b7582370c50117d8c.png" alt="" /></p>
<h3 id="_7-1-选主"> 7.1. 选主</h3>
<p>还记得上面我们的所说的临时节点吗？因为 <code>Zookeeper</code> 的强一致性，能够很好地在保证 <strong>在高并发的情况下保证节点创建的全局唯一性</strong> (即无法重复创建同样的节点)。</p>
<p>利用这个特性，我们可以 <strong>让多个客户端创建一个指定的节点</strong> ，创建成功的就是 <code>master</code>。</p>
<p>但是，如果这个 <code>master</code> 挂了怎么办？？？</p>
<p>你想想为什么我们要创建临时节点？还记得临时节点的生命周期吗？<code>master</code> 挂了是不是代表会话断了？会话断了是不是意味着这个节点没了？还记得 <code>watcher</code> 吗？我们是不是可以 <strong>让其他不是 <code>master</code> 的节点监听节点的状态</strong> ，比如说我们监听这个临时节点的父节点，如果子节点个数变了就代表 <code>master</code> 挂了，这个时候我们 <strong>触发回调函数进行重新选举</strong> ，或者我们直接监听节点的状态，我们可以通过节点是否已经失去连接来判断 <code>master</code> 是否挂了等等。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a94707028c5581c815f72fba0f50f43a.png" alt="选主" /></p>
<p>总的来说，我们可以完全 <strong>利用 临时节点、节点状态 和 <code>watcher</code> 来实现选主的功能</strong>，临时节点主要用来选举，节点状态和<code>watcher</code> 可以用来判断 <code>master</code> 的活性和进行重新选举。</p>
<h3 id="_7-2-分布式锁"> 7.2. 分布式锁</h3>
<p>分布式锁的实现方式有很多种，比如 <code>Redis</code> 、数据库 、<code>zookeeper</code> 等。个人认为 <code>zookeeper</code> 在实现分布式锁这方面是非常非常简单的。</p>
<p>上面我们已经提到过了 <strong>zk在高并发的情况下保证节点创建的全局唯一性</strong>，这玩意一看就知道能干啥了。实现互斥锁呗，又因为能在分布式的情况下，所以能实现分布式锁呗。</p>
<p>如何实现呢？这玩意其实跟选主基本一样，我们也可以利用临时节点的创建来实现。</p>
<p>首先肯定是如何获取锁，因为创建节点的唯一性，我们可以让多个客户端同时创建一个临时节点，<strong>创建成功的就说明获取到了锁</strong> 。然后没有获取到锁的客户端也像上面选主的非主节点创建一个 <code>watcher</code> 进行节点状态的监听，如果这个互斥锁被释放了（可能获取锁的客户端宕机了，或者那个客户端主动释放了锁）可以调用回调函数重新获得锁。</p>
<blockquote>
<p><code>zk</code> 中不需要向 <code>redis</code> 那样考虑锁得不到释放的问题了，因为当客户端挂了，节点也挂了，锁也释放了。是不是很简答？</p>
</blockquote>
<p>那能不能使用 <code>zookeeper</code> 同时实现 <strong>共享锁和独占锁</strong> 呢？答案是可以的，不过稍微有点复杂而已。</p>
<p>还记得 <strong>有序的节点</strong> 吗？</p>
<p>这个时候我规定所有创建节点必须有序，当你是读请求（要获取共享锁）的话，如果 <strong>没有比自己更小的节点，或比自己小的节点都是读请求</strong> ，则可以获取到读锁，然后就可以开始读了。<strong>若比自己小的节点中有写请求</strong> ，则当前客户端无法获取到读锁，只能等待前面的写请求完成。</p>
<p>如果你是写请求（获取独占锁），若 <strong>没有比自己更小的节点</strong> ，则表示当前客户端可以直接获取到写锁，对数据进行修改。若发现 <strong>有比自己更小的节点，无论是读操作还是写操作，当前客户端都无法获取到写锁</strong> ，等待所有前面的操作完成。</p>
<p>这就很好地同时实现了共享锁和独占锁，当然还有优化的地方，比如当一个锁得到释放它会通知所有等待的客户端从而造成 <strong>羊群效应</strong> 。此时你可以通过让等待的节点只监听他们前面的节点。</p>
<p>具体怎么做呢？其实也很简单，你可以让 <strong>读请求监听比自己小的最后一个写请求节点，写请求只监听比自己小的最后一个节点</strong> ，感兴趣的小伙伴可以自己去研究一下。</p>
<h3 id="_7-3-命名服务"> 7.3. 命名服务</h3>
<p>如何给一个对象设置ID，大家可能都会想到 <code>UUID</code>，但是 <code>UUID</code> 最大的问题就在于它太长了。。。(太长不一定是好事，嘿嘿嘿)。那么在条件允许的情况下，我们能不能使用 <code>zookeeper</code> 来实现呢？</p>
<p>我们之前提到过 <code>zookeeper</code> 是通过 <strong>树形结构</strong> 来存储数据节点的，那也就是说，对于每个节点的 <strong>全路径</strong>，它必定是唯一的，我们可以使用节点的全路径作为命名方式了。而且更重要的是，路径是我们可以自己定义的，这对于我们对有些有语意的对象的ID设置可以更加便于理解。</p>
<h3 id="_7-4-集群管理和注册中心"> 7.4. 集群管理和注册中心</h3>
<p>看到这里是不是觉得 <code>zookeeper</code> 实在是太强大了，它怎么能这么能干！</p>
<p>别急，它能干的事情还很多呢。可能我们会有这样的需求，我们需要了解整个集群中有多少机器在工作，我们想对集群中的每台机器的运行时状态进行数据采集，对集群中机器进行上下线操作等等。</p>
<p>而 <code>zookeeper</code> 天然支持的 <code>watcher</code> 和 临时节点能很好的实现这些需求。我们可以为每条机器创建临时节点，并监控其父节点，如果子节点列表有变动（我们可能创建删除了临时节点），那么我们可以使用在其父节点绑定的 <code>watcher</code> 进行状态监控和回调。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6115820219c35c68bcb2c9a855ebace3.png" alt="集群管理" /></p>
<p>至于注册中心也很简单，我们同样也是让 <strong>服务提供者</strong> 在 <code>zookeeper</code> 中创建一个临时节点并且将自己的 <code>ip、port、调用方式</code> 写入节点，当 <strong>服务消费者</strong> 需要进行调用的时候会 <strong>通过注册中心找到相应的服务的地址列表(IP端口什么的)</strong> ，并缓存到本地(方便以后调用)，当消费者调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从地址列表中取一个服务提供者的服务器调用服务。</p>
<p>当服务提供者的某台服务器宕机或下线时，相应的地址会从服务提供者地址列表中移除。同时，注册中心会将新的服务地址列表发送给服务消费者的机器并缓存在消费者本机（当然你可以让消费者进行节点监听，我记得 <code>Eureka</code> 会先试错，然后再更新）。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0b5b3911a7c2dae23391d17c91416b29.png" alt="注册中心" /></p>
<h2 id="_8-总结"> 8. 总结</h2>
<p>看到这里的同学实在是太有耐心了👍👍👍，如果觉得我写得不错的话点个赞哈。</p>
<p>不知道大家是否还记得我讲了什么😒。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b0bde9f3979b8f19187e6c374ad98993.png" alt="" /></p>
<p>这篇文章中我带大家入门了 <code>zookeeper</code> 这个强大的分布式协调框架。现在我们来简单梳理一下整篇文章的内容。</p>
<ul>
<li>
<p>分布式与集群的区别</p>
</li>
<li>
<p><code>2PC</code> 、<code>3PC</code> 以及 <code>paxos</code> 算法这些一致性框架的原理和实现。</p>
</li>
<li>
<p><code>zookeeper</code> 专门的一致性算法 <code>ZAB</code> 原子广播协议的内容（<code>Leader</code> 选举、崩溃恢复、消息广播）。</p>
</li>
<li>
<p><code>zookeeper</code> 中的一些基本概念，比如 <code>ACL</code>，数据节点，会话，<code>watcher</code>机制等等。</p>
</li>
<li>
<p><code>zookeeper</code> 的典型应用场景，比如选主，注册中心等等。</p>
<p>如果忘了可以回去看看再次理解一下，如果有疑问和建议欢迎提出🤝🤝🤝。</p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/img_convert/7c349891b773671514a68f057b2e14f8.png" type="image/png"/>
    </item>
    <item>
      <title>分布式事务</title>
      <link>https://javaguide.cn/distributed-system/distributed-transaction/</link>
      <guid>https://javaguide.cn/distributed-system/distributed-transaction/</guid>
      <source url="https://javaguide.cn/rss.xml">分布式事务</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="分布式事务"> 分布式事务</h1>
<p>这部分内容为我的星球专属，已经整理到了<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7?#" target="_blank" rel="noopener noreferrer">《Java面试进阶指北  打造个人的技术竞争力》</a>中。</p>
<p>欢迎加入我的星球，<a href="https://sourl.cn/v9dbdC" target="_blank" rel="noopener noreferrer">一个纯 Java 面试交流圈子 ！Ready！</a> （点击链接了解星球详细信息，还有专属优惠款可以领取）。</p>
<p><img src="https://img-blog.csdnimg.cn/57cedfa4d3d1425a8e4c6a6807d8f732.png" alt="" /></p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/57cedfa4d3d1425a8e4c6a6807d8f732.png" type="image/png"/>
    </item>
    <item>
      <title>服务之间的调用为啥不直接用 HTTP 而用 RPC？</title>
      <link>https://javaguide.cn/distributed-system/rpc/why-use-rpc/</link>
      <guid>https://javaguide.cn/distributed-system/rpc/why-use-rpc/</guid>
      <source url="https://javaguide.cn/rss.xml">服务之间的调用为啥不直接用 HTTP 而用 RPC？</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="服务之间的调用为啥不直接用-http-而用-rpc"> 服务之间的调用为啥不直接用 HTTP 而用 RPC？</h1>
<h2 id="什么是-rpc-rpc原理是什么"> 什么是 RPC?RPC原理是什么?</h2>
<h3 id="什么是-rpc"> <strong>什么是 RPC？</strong></h3>
<p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p>
<h3 id="rpc原理是什么"> <strong>RPC原理是什么？</strong></h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg" alt="RPC原理图" /></p>
<ol>
<li>服务消费端（client）以本地调用的方式调用远程服务；</li>
<li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li>
<li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li>
<li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: <code>RpcRequest</code>；</li>
<li>服务端 Stub（桩）根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li>
<li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li>
<li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:<code>RpcResponse</code> ，这样也就得到了最终结果。</li>
</ol>
<p>下面再贴一个网上的时序图，辅助理解：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/32527396.jpg" alt="RPC原理时序图" /></p>
<h3 id="rpc-解决了什么问题"> RPC 解决了什么问题？</h3>
<p>从上面对 RPC 介绍的内容中，概括来讲RPC 主要解决了：<strong>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。</strong></p>
<h3 id="常见的-rpc-框架总结"> 常见的 RPC 框架总结?</h3>
<ul>
<li><strong>RMI（JDK自带）：</strong> JDK自带的RPC，有很多局限性，不推荐使用。</li>
<li><strong>Dubbo:</strong> Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。</li>
<li><strong>gRPC</strong> ：gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。</li>
<li><strong>Hessian：</strong> Hessian是一个轻量级的remoting on http工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。</li>
<li><strong>Thrift：</strong>  Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</li>
</ul>
<h3 id="rpc学习材料"> RPC学习材料</h3>
<ul>
<li><a href="https://github.com/Snailclimb/guide-rpc-framework" target="_blank" rel="noopener noreferrer">跟着 Guide 哥造轮子</a></li>
</ul>
<h2 id="既有-http-为啥用-rpc-进行服务调用"> 既有 HTTP ,为啥用 RPC 进行服务调用?</h2>
<h3 id="rpc-只是一种设计而已"> RPC 只是一种设计而已</h3>
<p>RPC 只是一种概念、一种设计，就是为了解决 <strong>不同服务之间的调用问题</strong>, 它一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p>
<p>但是，HTTP  是一种协议，RPC框架可以使用 HTTP协议作为传输协议或者直接使用TCP作为传输协议，使用不同的协议一般也是为了适应不同的场景。</p>
<h3 id="http-和-tcp"> HTTP 和 TCP</h3>
<p><strong>可能现在很多对计算机网络不太熟悉的朋友已经被搞蒙了，要想真正搞懂，还需要来简单复习一下计算机网络基础知识：</strong></p>
<blockquote>
<p>我们通常谈计算机网络的五层协议的体系结构是指：应用层、传输层、网络层、数据链路层、物理层。</p>
<p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong> HTTP 属于应用层协议，它会基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过 URL 向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。HTTP协议建立在 TCP 协议之上。</p>
<p><strong>传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。TCP是传输层协议，主要解决数据如何在网络中传输。相比于UDP,<strong>TCP</strong> 提供的是<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</p>
</blockquote>
<h3 id="rpc框架功能更齐全"> RPC框架功能更齐全</h3>
<p>成熟的 RPC框架还提供好了“服务自动注册与发现”、&quot;智能负载均衡&quot;、“可视化的服务治理和运维”、“运行期流量调度”等等功能，这些也算是选择
RPC 进行服务注册和发现的一方面原因吧！</p>
<p><strong>相关阅读：</strong></p>
<ul>
<li>http://www.ruanyifeng.com/blog/2016/08/http.html （HTTP 协议入门- 阮一峰）</li>
</ul>
<h3 id="一个常见的错误观点"> 一个常见的错误观点</h3>
<p>很多文章中还会提到说 HTTP 协议相较于自定义 TCP 报文协议，增加的开销在于连接的建立与断开，但是这个观点已经被否认，下面截取自知乎中一个回答，原回答地址：https://www.zhihu.com/question/41609070/answer/191965937 。</p>
<blockquote>
<p>首先要否认一点 HTTP 协议相较于自定义 TCP 报文协议，增加的开销在于连接的建立与断开。HTTP 协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。二一要说的是 HTTP 也可以使用 Protobuf 这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Dubbo知识点&amp;面试题总结</title>
      <link>https://javaguide.cn/distributed-system/rpc/dubbo/</link>
      <guid>https://javaguide.cn/distributed-system/rpc/dubbo/</guid>
      <source url="https://javaguide.cn/rss.xml">Dubbo知识点&amp;面试题总结</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="dubbo知识点-面试题总结"> Dubbo知识点&amp;面试题总结</h1>
<p>这篇文章是我根据官方文档以及自己平时的使用情况，对 Dubbo 所做的一个总结。欢迎补充！</p>
<h2 id="rpc基础"> RPC基础</h2>
<h3 id="何为-rpc"> 何为 RPC?</h3>
<p><strong>RPC（Remote Procedure Call）</strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p>
<p><strong>为什么要 RPC  ？</strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面。</p>
<p><strong>RPC 能帮助我们做什么呢？</strong> 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。</p>
<p>举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。</p>
<p>一言蔽之：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</strong></p>
<h3 id="rpc-的原理是什么"> RPC 的原理是什么?</h3>
<p>为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC的 核心功能看作是下面👇 6 个部分实现的：</p>
<ol>
<li><strong>客户端（服务消费端）</strong> ：调用远程方法的一端。</li>
<li><strong>客户端 Stub（桩）</strong> ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li>
<li><strong>网络传输</strong> ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。</li>
<li><strong>服务端 Stub（桩）</strong> ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</li>
<li><strong>服务端（服务提供端）</strong> ：提供远程方法的一端。</li>
</ol>
<p>具体原理图如下，后面我会串起来将整个RPC的过程给大家说一下。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg" alt="RPC原理图" /></p>
<ol>
<li>服务消费端（client）以本地调用的方式调用远程服务；</li>
<li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li>
<li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li>
<li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: <code>RpcRequest</code>；</li>
<li>服务端 Stub（桩）根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li>
<li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li>
<li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:<code>RpcResponse</code> ，这样也就得到了最终结果。over!</li>
</ol>
<p>相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。</p>
<p>虽然篇幅不多，但是基本把 RPC 框架的核心原理讲清楚了！另外，对于上面的技术细节，我会在后面的章节介绍到。</p>
<p><strong>最后，对于 RPC 的原理，希望小伙伴不单单要理解，还要能够自己画出来并且能够给别人讲出来。因为，在面试中这个问题在面试官问到 RPC 相关内容的时候基本都会碰到。</strong></p>
<h2 id="dubbo基础"> Dubbo基础</h2>
<h3 id="什么是-dubbo"> 什么是 Dubbo?</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/427f2168-1930-4c14-8760-415fac8db1d0-20200802184737978.png" alt="" /></p>
<p><a href="https://github.com/apache/dubbo" target="_blank" rel="noopener noreferrer">Apache Dubbo</a> |ˈdʌbəʊ|  是一款高性能、轻量级的开源 Java RPC 框架。</p>
<p>根据 <a href="https://dubbo.apache.org/zh/" target="_blank" rel="noopener noreferrer">Dubbo 官方文档</a>的介绍，Dubbo 提供了六大核心能力</p>
<ol>
<li>面向接口代理的高性能RPC调用。</li>
<li>智能容错和负载均衡。</li>
<li>服务自动注册和发现。</li>
<li>高度可扩展能力。</li>
<li>运行期流量调度。</li>
<li>可视化的服务治理与运维。</li>
</ol>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/源码/dubbo/dubbo提供的六大核心能力.png" alt="Dubbo提供的六大核心能力" /></p>
<p>简单来说就是： <strong>Dubbo 不光可以帮助我们调用远程服务，还提供了一些其他开箱即用的功能比如智能负载均衡。</strong></p>
<p>Dubbo 目前已经有接近 34.4 k 的 Star  。</p>
<p>在 <strong>2020 年度 OSC 中国开源项目</strong> 评选活动中，Dubbo 位列开发框架和基础组件类项目的第7名。想比几年前来说，热度和排名有所下降。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/源码/dubbo/image-20210107153159545.png" alt="" /></p>
<p>Dubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p>
<h3 id="为什么要用-dubbo"> 为什么要用 Dubbo?</h3>
<p>随着互联网的发展，网站的规模越来越大，用户数量越来越多。单一应用架构 、垂直应用架构无法满足我们的需求，这个时候分布式服务架构就诞生了。</p>
<p>分布式服务架构下，系统被拆分成不同的服务比如短信服务、安全服务，每个服务独立提供系统的某个核心服务。</p>
<p>我们可以使用 Java RMI（Java Remote Method Invocation）、Hessian这种支持远程调用的框架来简单地暴露和引用远程服务。但是！当服务越来越多之后，服务调用关系越来越复杂。当应用访问压力越来越大后，负载均衡以及服务监控的需求也迫在眉睫。我们可以用 F5 这类硬件来做负载均衡，但这样增加了成本，并且存在单点故障的风险。</p>
<p>不过，Dubbo 的出现让上述问题得到了解决。<strong>Dubbo 帮助我们解决了什么问题呢？</strong></p>
<ol>
<li><strong>负载均衡</strong> ： 同一个服务部署在不同的机器时该调用哪一台机器上的服务。</li>
<li><strong>服务调用链路生成</strong>  ： 随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。</li>
<li><strong>服务访问压力以及时长统计、资源调度和治理</strong> ：基于访问压力实时管理集群容量，提高集群利用率。</li>
<li>......</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-26/43050183.jpg" alt="" /></p>
<p>另外，Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。</p>
<p><strong>我们刚刚提到了分布式这个概念，下面再给大家介绍一下什么是分布式？为什么要分布式？</strong></p>
<h2 id="分布式基础"> 分布式基础</h2>
<h3 id="什么是分布式"> 什么是分布式?</h3>
<p>分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/分布式事务示意图.png" alt="分布式事务示意图" /></p>
<h3 id="为什么要分布式"> 为什么要分布式?</h3>
<p>从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。</p>
<p>另外，我觉得将系统拆分成分布式之后不光便于系统扩展和维护，更能提高整个系统的性能。你想一想嘛？把整个系统拆分成不同的服务/系统，然后每个服务/系统 单独部署在一台服务器上，是不是很大程度上提高了系统性能呢？</p>
<h2 id="dubbo-架构"> Dubbo 架构</h2>
<h3 id="dubbo-架构中的核心角色有哪些"> Dubbo 架构中的核心角色有哪些？</h3>
<p><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/design/" target="_blank" rel="noopener noreferrer">官方文档中的框架设计章节</a> 已经介绍的非常详细了，我这里把一些比较重要的点再提一下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/源码/dubbo/dubbo-relation.jpg" alt="dubbo-relation" /></p>
<p>上述节点简单介绍以及他们之间的关系：</p>
<ul>
<li><strong>Container：</strong> 服务运行容器，负责加载、运行服务提供者。必须。</li>
<li><strong>Provider：</strong> 暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。</li>
<li><strong>Consumer：</strong> 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。</li>
<li><strong>Registry：</strong> 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。</li>
<li><strong>Monitor：</strong> 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须。</li>
</ul>
<h3 id="dubbo-中的-invoker-概念了解么"> Dubbo 中的 Invoker 概念了解么？</h3>
<p><code>Invoker</code> 是 Dubbo 领域模型中非常重要的一个概念，你如果阅读过 Dubbo 源码的话，你会无数次看到这玩意。就比如下面我要说的负载均衡这块的源码中就有大量 <code>Invoker</code> 的身影。</p>
<p>简单来说，<code>Invoker</code> 就是 Dubbo 对远程调用的抽象。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/dubbo_rpc_invoke.jpg" alt="dubbo_rpc_invoke.jpg" /></p>
<p>按照 Dubbo 官方的话来说，<code>Invoker</code>  分为</p>
<ul>
<li>服务提供 <code>Invoker</code></li>
<li>服务消费 <code>Invoker</code></li>
</ul>
<p>假如我们需要调用一个远程方法，我们需要动态代理来屏蔽远程调用的细节吧！我们屏蔽掉的这些细节就依赖对应的 <code>Invoker</code>  实现， <code>Invoker</code> 实现了真正的远程服务调用。</p>
<h3 id="dubbo-的工作原理了解么"> Dubbo 的工作原理了解么？</h3>
<p>下图是 Dubbo 的整体设计，从下至上分为十层，各层均为单向依赖。</p>
<blockquote>
<p>左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</p>
</blockquote>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/source-code/dubbo/dubbo-framework.jpg" alt="dubbo-framework" /></p>
<ul>
<li><strong>config 配置层</strong>：Dubbo相关的配置。支持代码配置，同时也支持基于 Spring  来做配置，以 <code>ServiceConfig</code>, <code>ReferenceConfig</code> 为中心</li>
<li><strong>proxy 服务代理层</strong>：调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以 <code>ServiceProxy</code> 为中心。</li>
<li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现。</li>
<li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code> 为中心。</li>
<li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 <code>Statistics</code> 为中心。</li>
<li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 <code>Invocation</code>, <code>Result</code> 为中心。</li>
<li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 <code>Request</code>, <code>Response</code> 为中心。</li>
<li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 <code>Message</code> 为中心。</li>
<li><strong>serialize 数据序列化层</strong> ：对需要在网络传输的数据进行序列化。</li>
</ul>
<h3 id="dubbo-的-spi-机制了解么-如何扩展-dubbo-中的默认实现"> Dubbo 的 SPI 机制了解么？ 如何扩展 Dubbo 中的默认实现？</h3>
<p>SPI（Service Provider Interface） 机制被大量用在开源项目中，它可以帮助我们动态寻找服务/功能（比如负载均衡策略）的实现。</p>
<p>SPI 的具体原理是这样的：我们将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类。和 IoC 的解耦思想是类似的。</p>
<p>Java 本身就提供了 SPI 机制的实现。不过，Dubbo 没有直接用，而是对 Java原生的 SPI机制进行了增强，以便更好满足自己的需求。</p>
<p><strong>那我们如何扩展 Dubbo 中的默认实现呢？</strong></p>
<p>比如说我们想要实现自己的负载均衡策略，我们创建对应的实现类 <code>XxxLoadBalance</code> 实现 <code>LoadBalance</code> 接口或者 <code>AbstractLoadBalance</code> 类。</p>
<div><pre><code><span>package</span> <span>com<span>.</span>xxx</span><span>;</span>
 
<span>import</span> <span>org<span>.</span>apache<span>.</span>dubbo<span>.</span>rpc<span>.</span>cluster<span>.</span></span><span>LoadBalance</span><span>;</span>
<span>import</span> <span>org<span>.</span>apache<span>.</span>dubbo<span>.</span>rpc<span>.</span></span><span>Invoker</span><span>;</span>
<span>import</span> <span>org<span>.</span>apache<span>.</span>dubbo<span>.</span>rpc<span>.</span></span><span>Invocation</span><span>;</span>
<span>import</span> <span>org<span>.</span>apache<span>.</span>dubbo<span>.</span>rpc<span>.</span></span><span>RpcException</span><span>;</span> 
 
<span>public</span> <span>class</span> <span>XxxLoadBalance</span> <span>implements</span> <span>LoadBalance</span> <span>{</span>
    <span>public</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Invoker</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>select</span><span>(</span><span>List</span><span><span>&lt;</span><span>Invoker</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> invokers<span>,</span> <span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>RpcException</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>我们将这个实现类的路径写入到<code>resources</code> 目录下的 <code>META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance</code>文件中即可。</p>
<div><pre><code>src
 <span>|</span><span>-</span>main
    <span>|</span><span>-</span>java
        <span>|</span><span>-</span>com
            <span>|</span><span>-</span>xxx
                <span>|</span><span>-</span><span>XxxLoadBalance</span><span>.</span>java <span>(</span>实现<span>LoadBalance</span>接口<span>)</span>
    <span>|</span><span>-</span>resources
        <span>|</span><span>-</span>META<span>-</span>INF
            <span>|</span><span>-</span>dubbo
                <span>|</span><span>-</span><span><span>org<span>.</span>apache<span>.</span>dubbo<span>.</span>rpc<span>.</span>cluster<span>.</span></span>LoadBalance</span> <span>(</span>纯文本文件，内容为：xxx<span>=</span><span><span>com<span>.</span>xxx<span>.</span></span>XxxLoadBalance</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>org.apache.dubbo.rpc.cluster.LoadBalance</code></p>
<div><pre><code>xxx=com.xxx.XxxLoadBalance
</code></pre>
<div><span>1</span><br></div></div><p>其他还有很多可供扩展的选择，你可以在<a href="https://dubbo.apache.org/zh/docs/v2.7/dev/impls/" target="_blank" rel="noopener noreferrer">官方文档@SPI扩展实现</a>这里找到。</p>
<p><img src="https://img-blog.csdnimg.cn/20210328091015555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="" /></p>
<h3 id="dubbo-的微内核架构了解吗"> Dubbo 的微内核架构了解吗？</h3>
<p>Dubbo 采用 微内核（Microkernel） + 插件（Plugin） 模式，简单来说就是微内核架构。微内核只负责组装插件。</p>
<p><strong>何为微内核架构呢？</strong> 《软件架构模式》 这本书是这样介绍的：</p>
<blockquote>
<p>微内核架构模式（有时被称为插件架构模式）是实现基于产品应用程序的一种自然模式。基于产品的应用程序是已经打包好并且拥有不同版本，可作为第三方插件下载的。然后，很多公司也在开发、发布自己内部商业应用像有版本号、说明及可加载插件式的应用软件（这也是这种模式的特征）。微内核系统可让用户添加额外的应用如插件，到核心应用，继而提供了可扩展性和功能分离的用法。</p>
</blockquote>
<p>微内核架构包含两类组件：<strong>核心系统（core system）</strong> 和 <strong>插件模块（plug-in modules）</strong>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/source-code/dubbo/微内核架构示意图.png" alt="" /></p>
<p>核心系统提供系统所需核心能力，插件模块可以扩展系统的功能。因此， 基于微内核架构的系统，非常易于扩展功能。</p>
<p>我们常见的一些IDE，都可以看作是基于微内核架构设计的。绝大多数 IDE比如IDEA、VSCode都提供了插件来丰富自己的功能。</p>
<p>正是因为Dubbo基于微内核架构，才使得我们可以随心所欲替换Dubbo的功能点。比如你觉得Dubbo 的序列化模块实现的不满足自己要求，没关系啊！你自己实现一个序列化模块就好了啊！</p>
<p>通常情况下，微核心都会采用 Factory、IoC、OSGi 等方式管理插件生命周期。Dubbo 不想依赖 Spring 等 IoC 容器，也不想自己造一个小的 IoC 容器（过度设计），因此采用了一种最简单的 Factory 方式管理插件 ：<strong>JDK 标准的 SPI 扩展机制</strong> （<code>java.util.ServiceLoader</code>）。</p>
<h3 id="关于dubbo架构的一些自测小问题"> 关于Dubbo架构的一些自测小问题</h3>
<h4 id="注册中心的作用了解么"> 注册中心的作用了解么？</h4>
<p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互。</p>
<h4 id="服务提供者宕机后-注册中心会做什么"> 服务提供者宕机后，注册中心会做什么？</h4>
<p>注册中心会立即推送事件通知消费者。</p>
<h4 id="监控中心的作用呢"> 监控中心的作用呢？</h4>
<p>监控中心负责统计各服务调用次数，调用时间等。</p>
<h4 id="注册中心和监控中心都宕机的话-服务都会挂掉吗"> 注册中心和监控中心都宕机的话，服务都会挂掉吗？</h4>
<p>不会。两者都宕机也不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。</p>
<h2 id="dubbo-的负载均衡策略"> Dubbo 的负载均衡策略</h2>
<h3 id="什么是负载均衡"> 什么是负载均衡？</h3>
<p>先来看一下稍微官方点的解释。下面这段话摘自维基百科对负载均衡的定义：</p>
<blockquote>
<p>负载均衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动）的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件。</p>
</blockquote>
<p><strong>上面讲的大家可能不太好理解，再用通俗的话给大家说一下。</strong></p>
<p>我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。</p>
<h3 id="dubbo-提供的负载均衡策略有哪些"> Dubbo 提供的负载均衡策略有哪些？</h3>
<p>在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 <code>random</code> 随机调用。我们还可以自行扩展负载均衡策略（参考Dubbo SPI机制）。</p>
<p>在 Dubbo 中，所有负载均衡实现类均继承自 <code>AbstractLoadBalance</code>，该类实现了 <code>LoadBalance</code> 接口，并封装了一些公共的逻辑。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractLoadBalance</span> <span>implements</span> <span>LoadBalance</span> <span>{</span>

    <span>static</span> <span>int</span> <span>calculateWarmupWeight</span><span>(</span><span>int</span> uptime<span>,</span> <span>int</span> warmup<span>,</span> <span>int</span> weight<span>)</span> <span>{</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Invoker</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>select</span><span>(</span><span>List</span><span><span>&lt;</span><span>Invoker</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> invokers<span>,</span> <span>URL</span> url<span>,</span> <span>Invocation</span> invocation<span>)</span> <span>{</span>
    <span>}</span>

    <span>protected</span> <span>abstract</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Invoker</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>doSelect</span><span>(</span><span>List</span><span><span>&lt;</span><span>Invoker</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> invokers<span>,</span> <span>URL</span> url<span>,</span> <span>Invocation</span> invocation<span>)</span><span>;</span>


    <span>int</span> <span>getWeight</span><span>(</span><span>Invoker</span><span><span>&lt;</span><span>?</span><span>></span></span> invoker<span>,</span> <span>Invocation</span> invocation<span>)</span> <span>{</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><code>AbstractLoadBalance</code> 的实现类有下面这些：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210326105257812.png" alt="" /></p>
<p>官方文档对负载均衡这部分的介绍非常详细，推荐小伙伴们看看，地址：<a href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#m-zhdocsv27devsourceloadbalance" target="_blank" rel="noopener noreferrer">https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#m-zhdocsv27devsourceloadbalance</a> 。</p>
<h4 id="randomloadbalance"> RandomLoadBalance</h4>
<p>根据权重随机选择（对加权随机算法的实现）。这是Dubbo默认采用的一种负载均衡策略。</p>
<p><code>RandomLoadBalance</code> 具体的实现原理非常简单，假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。</p>
<p>我们把这些权重值分布在坐标区间会得到：S1-&gt;[0, 7) ，S2-&gt;[7, 10)。我们生成[0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/ RandomLoadBalance.png" alt="RandomLoadBalance" /></p>
<p><code>RandomLoadBalance</code> 的源码非常简单，简单花几分钟时间看一下。</p>
<blockquote>
<p>以下源码来自 Dubbo master 分支上的最新的版本 2.7.9。</p>
</blockquote>
<div><pre><code><span>public</span> <span>class</span> <span>RandomLoadBalance</span> <span>extends</span> <span>AbstractLoadBalance</span> <span>{</span>

    <span>public</span> <span>static</span> <span>final</span> <span>String</span> NAME <span>=</span> <span>"random"</span><span>;</span>

    <span>@Override</span>
    <span>protected</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Invoker</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>doSelect</span><span>(</span><span>List</span><span><span>&lt;</span><span>Invoker</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> invokers<span>,</span> <span>URL</span> url<span>,</span> <span>Invocation</span> invocation<span>)</span> <span>{</span>

        <span>int</span> length <span>=</span> invokers<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
        <span>boolean</span> sameWeight <span>=</span> <span>true</span><span>;</span>
        <span>int</span><span>[</span><span>]</span> weights <span>=</span> <span>new</span> <span>int</span><span>[</span>length<span>]</span><span>;</span> 
        <span>int</span> totalWeight <span>=</span> <span>0</span><span>;</span>
        <span>// 下面这个for循环的主要作用就是计算所有该服务的提供者的权重之和 totalWeight（），</span>
        <span>// 除此之外，还会检测每个服务提供者的权重是否相同</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>int</span> weight <span>=</span> <span>getWeight</span><span>(</span>invokers<span>.</span><span>get</span><span>(</span>i<span>)</span><span>,</span> invocation<span>)</span><span>;</span>
            totalWeight <span>+=</span> weight<span>;</span>
            weights<span>[</span>i<span>]</span> <span>=</span> totalWeight<span>;</span>
            <span>if</span> <span>(</span>sameWeight <span>&amp;&amp;</span> totalWeight <span>!=</span> weight <span>*</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span> <span>{</span>
                sameWeight <span>=</span> <span>false</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>if</span> <span>(</span>totalWeight <span>></span> <span>0</span> <span>&amp;&amp;</span> <span>!</span>sameWeight<span>)</span> <span>{</span>
            <span>// 随机生成一个 [0, totalWeight) 区间内的数字</span>
            <span>int</span> offset <span>=</span> <span>ThreadLocalRandom</span><span>.</span><span>current</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span>totalWeight<span>)</span><span>;</span>
            <span>// 判断会落在哪个服务提供者的区间</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>offset <span>&lt;</span> weights<span>[</span>i<span>]</span><span>)</span> <span>{</span>
                    <span>return</span> invokers<span>.</span><span>get</span><span>(</span>i<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
  
        <span>return</span> invokers<span>.</span><span>get</span><span>(</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span>length<span>)</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h4 id="leastactiveloadbalance"> LeastActiveLoadBalance</h4>
<p><code>LeastActiveLoadBalance</code> 直译过来就是<strong>最小活跃数负载均衡</strong>。</p>
<p>这个名字起得有点不直观，不仔细看官方对活跃数的定义，你压根不知道这玩意是干嘛的。</p>
<p>我这么说吧！初始状态下所有服务提供者的活跃数均为 0（每个服务提供者的中特定方法都对应一个活跃数，我在后面的源码中会提到），每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。</p>
<p>因此，<strong>Dubbo 就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。</strong></p>
<p><strong>如果有多个服务提供者的活跃数相等怎么办？</strong></p>
<p>很简单，那就再走一遍  <code>RandomLoadBalance</code> 。</p>
<div><pre><code><span>public</span> <span>class</span> <span>LeastActiveLoadBalance</span> <span>extends</span> <span>AbstractLoadBalance</span> <span>{</span>

    <span>public</span> <span>static</span> <span>final</span> <span>String</span> NAME <span>=</span> <span>"leastactive"</span><span>;</span>

    <span>@Override</span>
    <span>protected</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Invoker</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>doSelect</span><span>(</span><span>List</span><span><span>&lt;</span><span>Invoker</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> invokers<span>,</span> <span>URL</span> url<span>,</span> <span>Invocation</span> invocation<span>)</span> <span>{</span>
        <span>int</span> length <span>=</span> invokers<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> leastActive <span>=</span> <span>-</span><span>1</span><span>;</span>
        <span>int</span> leastCount <span>=</span> <span>0</span><span>;</span>
        <span>int</span><span>[</span><span>]</span> leastIndexes <span>=</span> <span>new</span> <span>int</span><span>[</span>length<span>]</span><span>;</span>
        <span>int</span><span>[</span><span>]</span> weights <span>=</span> <span>new</span> <span>int</span><span>[</span>length<span>]</span><span>;</span>
        <span>int</span> totalWeight <span>=</span> <span>0</span><span>;</span>
        <span>int</span> firstWeight <span>=</span> <span>0</span><span>;</span>
        <span>boolean</span> sameWeight <span>=</span> <span>true</span><span>;</span>
        <span>// 这个 for 循环的主要作用是遍历 invokers 列表，找出活跃数最小的 Invoker</span>
        <span>// 如果有多个 Invoker 具有相同的最小活跃数，还会记录下这些 Invoker 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>Invoker</span><span><span>&lt;</span><span>T</span><span>></span></span> invoker <span>=</span> invokers<span>.</span><span>get</span><span>(</span>i<span>)</span><span>;</span>
            <span>// 获取 invoker 对应的活跃(active)数</span>
            <span>int</span> active <span>=</span> <span>RpcStatus</span><span>.</span><span>getStatus</span><span>(</span>invoker<span>.</span><span>getUrl</span><span>(</span><span>)</span><span>,</span> invocation<span>.</span><span>getMethodName</span><span>(</span><span>)</span><span>)</span><span>.</span><span>getActive</span><span>(</span><span>)</span><span>;</span>
            <span>int</span> afterWarmup <span>=</span> <span>getWeight</span><span>(</span>invoker<span>,</span> invocation<span>)</span><span>;</span>
            weights<span>[</span>i<span>]</span> <span>=</span> afterWarmup<span>;</span>
            <span>if</span> <span>(</span>leastActive <span>==</span> <span>-</span><span>1</span> <span>||</span> active <span>&lt;</span> leastActive<span>)</span> <span>{</span>
                leastActive <span>=</span> active<span>;</span>
                leastCount <span>=</span> <span>1</span><span>;</span>
                leastIndexes<span>[</span><span>0</span><span>]</span> <span>=</span> i<span>;</span>
                totalWeight <span>=</span> afterWarmup<span>;</span>
                firstWeight <span>=</span> afterWarmup<span>;</span>
                sameWeight <span>=</span> <span>true</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>active <span>==</span> leastActive<span>)</span> <span>{</span>
                leastIndexes<span>[</span>leastCount<span>++</span><span>]</span> <span>=</span> i<span>;</span>
                totalWeight <span>+=</span> afterWarmup<span>;</span>
                <span>if</span> <span>(</span>sameWeight <span>&amp;&amp;</span> afterWarmup <span>!=</span> firstWeight<span>)</span> <span>{</span>
                    sameWeight <span>=</span> <span>false</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
       <span>// 如果只有一个 Invoker 具有最小的活跃数，此时直接返回该 Invoker 即可</span>
        <span>if</span> <span>(</span>leastCount <span>==</span> <span>1</span><span>)</span> <span>{</span>
            <span>return</span> invokers<span>.</span><span>get</span><span>(</span>leastIndexes<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
        <span>}</span>
        <span>// 如果有多个 Invoker 具有相同的最小活跃数，但它们之间的权重不同</span>
        <span>// 这里的处理方式就和  RandomLoadBalance 一致了</span>
        <span>if</span> <span>(</span><span>!</span>sameWeight <span>&amp;&amp;</span> totalWeight <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>int</span> offsetWeight <span>=</span> <span>ThreadLocalRandom</span><span>.</span><span>current</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span>totalWeight<span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> leastCount<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>int</span> leastIndex <span>=</span> leastIndexes<span>[</span>i<span>]</span><span>;</span>
                offsetWeight <span>-=</span> weights<span>[</span>leastIndex<span>]</span><span>;</span>
                <span>if</span> <span>(</span>offsetWeight <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
                    <span>return</span> invokers<span>.</span><span>get</span><span>(</span>leastIndex<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> invokers<span>.</span><span>get</span><span>(</span>leastIndexes<span>[</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span>leastCount<span>)</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><p>活跃数是通过 <code>RpcStatus</code> 中的一个 <code>ConcurrentMap</code> 保存的，根据 URL 以及服务提供者被调用的方法的名称，我们便可以获取到对应的活跃数。也就是说服务提供者中的每一个方法的活跃数都是互相独立的。</p>
<div><pre><code><span>public</span> <span>class</span> <span>RpcStatus</span> <span>{</span>
    
    <span>private</span> <span>static</span> <span>final</span> <span>ConcurrentMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>ConcurrentMap</span><span>&lt;</span><span>String</span><span>,</span> <span>RpcStatus</span><span>></span><span>></span></span> METHOD_STATISTICS <span>=</span>
            <span>new</span> <span>ConcurrentHashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>ConcurrentMap</span><span>&lt;</span><span>String</span><span>,</span> <span>RpcStatus</span><span>></span><span>></span></span><span>(</span><span>)</span><span>;</span>

   <span>public</span> <span>static</span> <span>RpcStatus</span> <span>getStatus</span><span>(</span><span>URL</span> url<span>,</span> <span>String</span> methodName<span>)</span> <span>{</span>
        <span>String</span> uri <span>=</span> url<span>.</span><span>toIdentityString</span><span>(</span><span>)</span><span>;</span>
        <span>ConcurrentMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>RpcStatus</span><span>></span></span> map <span>=</span> METHOD_STATISTICS<span>.</span><span>computeIfAbsent</span><span>(</span>uri<span>,</span> k <span>-></span> <span>new</span> <span>ConcurrentHashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> map<span>.</span><span>computeIfAbsent</span><span>(</span>methodName<span>,</span> k <span>-></span> <span>new</span> <span>RpcStatus</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>int</span> <span>getActive</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> active<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="consistenthashloadbalance"> ConsistentHashLoadBalance</h4>
<p><code>ConsistentHashLoadBalance</code>  小伙伴们应该也不会陌生，在分库分表、各种集群中就经常使用这个负载均衡策略。</p>
<p><code>ConsistentHashLoadBalance</code> 即<strong>一致性Hash负载均衡策略</strong>。 <code>ConsistentHashLoadBalance</code> 中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/consistent-hash-data-incline.jpg" alt="" /></p>
<p>另外，Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/consistent-hash-invoker.jpg" alt="" /></p>
<p>官方有详细的源码分析：<a href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#23-consistenthashloadbalance" target="_blank" rel="noopener noreferrer">https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#23-consistenthashloadbalance</a> 。这里还有一个相关的 <a href="https://github.com/apache/dubbo/pull/5440" target="_blank" rel="noopener noreferrer">PR#5440</a> 来修复老版本中 ConsistentHashLoadBalance 存在的一些Bug。感兴趣的小伙伴，可以多花点时间研究一下。我这里不多分析了，这个作业留给你们！</p>
<h4 id="roundrobinloadbalance"> RoundRobinLoadBalance</h4>
<p>加权轮询负载均衡。</p>
<p>轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。比如假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。</p>
<p>如果我们有 10 次请求，那么  7 次会被 S1处理，3次被 S2处理。</p>
<p>但是，如果是 <code>RandomLoadBalance</code> 的话，很可能存在10次请求有9次都被 S1 处理的情况（概率性问题）。</p>
<p>Dubbo 中的 <code>RoundRobinLoadBalance</code> 的代码实现被修改重建了好几次，Dubbo-2.6.5 版本的 <code>RoundRobinLoadBalance</code> 为平滑加权轮询算法。</p>
<h2 id="dubbo序列化协议"> Dubbo序列化协议</h2>
<h3 id="dubbo-支持哪些序列化方式呢"> Dubbo 支持哪些序列化方式呢？</h3>
<p><img src="https://img-blog.csdnimg.cn/20210328092219640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="" /></p>
<p>Dubbo 支持多种序列化方式：JDK自带的序列化、hessian2、JSON、Kryo、FST、Protostuff，ProtoBuf等等。</p>
<p>Dubbo 默认使用的序列化方式是 hession2。</p>
<h3 id="谈谈你对这些序列化协议了解"> 谈谈你对这些序列化协议了解？</h3>
<p>一般我们不会直接使用 JDK 自带的序列化方式。主要原因有两个：</p>
<ol>
<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
</ol>
<p>JSON 序列化由于性能问题，我们一般也不会考虑使用。</p>
<p>像 Protostuff，ProtoBuf、hessian2这些都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p>
<p>Kryo和FST这两种序列化方式是 Dubbo 后来才引入的，性能非常好。不过，这两者都是专门针对 Java 语言的。Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：<a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/" target="_blank" rel="noopener noreferrer">https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/</a>)</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/569e541a-22b2-4846-aa07-0ad479f07440.png" alt="" /></p>
<p>Dubbo 官方文档中还有一个关于这些<a href="https://dubbo.apache.org/zh/docs/v2.7/user/serialization/#m-zhdocsv27userserialization" target="_blank" rel="noopener noreferrer">序列化协议的性能对比图</a>可供参考。</p>
<p><img src="https://img-blog.csdnimg.cn/20210328093219609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" alt="" /></p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>CAP &amp; BASE理论</title>
      <link>https://javaguide.cn/distributed-system/%E7%90%86%E8%AE%BA&amp;%E7%AE%97%E6%B3%95/cap&amp;base%E7%90%86%E8%AE%BA/</link>
      <guid>https://javaguide.cn/distributed-system/%E7%90%86%E8%AE%BA&amp;%E7%AE%97%E6%B3%95/cap&amp;base%E7%90%86%E8%AE%BA/</guid>
      <source url="https://javaguide.cn/rss.xml">CAP &amp; BASE理论</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="cap-base理论"> CAP &amp; BASE理论</h1>
<p>经历过技术面试的小伙伴想必对这个两个概念已经再熟悉不过了！</p>
<p>Guide哥当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。</p>
<p>并且，这两个理论也可以说是小伙伴们学习分布式相关内容的基础了！</p>
<p>因此，小伙伴们非常非常有必要将这理论搞懂，并且能够用自己的理解给别人讲出来。</p>
<p>这篇文章我会站在自己的角度对这两个概念进行解读！</p>
<p><em>个人能力有限。如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！——爱你们的Guide哥</em></p>
<h2 id="cap理论"> CAP理论</h2>
<p><a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="noopener noreferrer">CAP 理论/定理</a>起源于 2000年，由加州大学伯克利分校的Eric Brewer教授在分布式计算原理研讨会（PODC）上提出，因此 CAP定理又被称作 <strong>布鲁尔定理（Brewer’s theorem）</strong></p>
<p>2年后，麻省理工学院的Seth Gilbert和Nancy Lynch 发表了布鲁尔猜想的证明，CAP理论正式成为分布式领域的定理。</p>
<h3 id="简介"> 简介</h3>
<p><strong>CAP</strong> 也就是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong> 这三个单词首字母组合。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/cap.png" alt="" /></p>
<p>CAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 <strong>Consistency</strong>、<strong>Availability</strong>、<strong>Partition Tolerance</strong> 三个单词的明确定义。</p>
<p>因此，对于 CAP 的民间解读有很多，一般比较被大家推荐的是下面 👇 这种版本的解读。</p>
<p>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p>
<ul>
<li><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本</li>
<li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>
<li><strong>分区容错性（Partition tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>
</ul>
<p><strong>什么是网络分区？</strong></p>
<blockquote>
<p>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。</p>
</blockquote>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/partition-tolerance.png" alt="partition-tolerance" /></p>
<h3 id="不是所谓的-3-选-2"> 不是所谓的“3 选 2”</h3>
<p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。</p>
<blockquote>
<p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p>
<p>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p>
</blockquote>
<p>因此，<strong>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</strong> 比如  ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>
<p><strong>为啥不可能选择 CA 架构呢？</strong> 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p>
<p><strong>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</strong></p>
<p>另外，需要补充说明的一点是： <strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</strong></p>
<h3 id="cap-实际应用案例"> CAP 实际应用案例</h3>
<p>我这里以注册中心来探讨一下 CAP 的实际应用。考虑到很多小伙伴不知道注册中心是干嘛的，这里简单以 Dubbo 为例说一说。</p>
<p>下图是 Dubbo 的架构图。<strong>注册中心 Registry 在其中扮演了什么角色呢？提供了什么服务呢？</strong></p>
<p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/dubbo-architecture.png" alt="" /></p>
<p>常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos...。</p>
<ol>
<li><strong>ZooKeeper 保证的是 CP。</strong> 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</li>
<li><strong>Eureka 保证的则是 AP。</strong> Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。</li>
<li><strong>Nacos 不仅支持 CP 也支持 AP。</strong></li>
</ol>
<h3 id="总结"> 总结</h3>
<p>在进行分布式系统设计和开发时，我们不应该仅仅局限在 CAP 问题上，还要关注系统的扩展性、可用性等等</p>
<p>在系统发生“分区”的情况下，CAP 理论只能满足 CP 或者 AP。要注意的是，这里的前提是系统发生了“分区”</p>
<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。</p>
<p>总结：<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>
<h3 id="推荐阅读"> 推荐阅读</h3>
<ol>
<li><a href="https://medium.com/@ravindraprasad/cap-theorem-simplified-28499a67eab4" target="_blank" rel="noopener noreferrer">CAP 定理简化</a> （英文，有趣的案例）</li>
<li><a href="https://juejin.im/post/6844903936718012430" target="_blank" rel="noopener noreferrer">神一样的 CAP 理论被应用在何方</a> （中文，列举了很多实际的例子）</li>
<li><a href="https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html" target="_blank" rel="noopener noreferrer">请停止呼叫数据库 CP 或 AP </a> （英文，带给你不一样的思考）</li>
</ol>
<h2 id="base-理论"> BASE 理论</h2>
<p><a href="https://dl.acm.org/doi/10.1145/1394127.1394128" target="_blank" rel="noopener noreferrer">BASE 理论</a>起源于 2008 年， 由eBay的架构师Dan Pritchett在ACM上发表。</p>
<h3 id="简介-2"> 简介</h3>
<p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>
<h3 id="base-理论的核心思想"> BASE 理论的核心思想</h3>
<p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<blockquote>
<p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>
</blockquote>
<p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</strong></p>
<p><strong>为什么这样说呢？</strong></p>
<p>CAP 理论这节我们也说过了：</p>
<blockquote>
<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>
</blockquote>
<p>因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p>
<h3 id="base-理论三要素"> BASE 理论三要素</h3>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzI0LzE2MzkxNDgwNmQ5ZTE1YzY?x-oss-process=image/format,png" alt="BASE理论三要素" /></p>
<h4 id="_1-基本可用"> 1. 基本可用</h4>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>
<p><strong>什么叫允许损失部分可用性呢？</strong></p>
<ul>
<li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li>
<li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>
</ul>
<h4 id="_2-软状态"> 2. 软状态</h4>
<p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h4 id="_3-最终一致性"> 3. 最终一致性</h4>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<blockquote>
<p>分布式一致性的 3 种级别：</p>
<ol>
<li>
<p><strong>强一致性</strong> ：系统写入了什么，读出来的就是什么。</p>
</li>
<li>
<p><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</p>
</li>
<li>
<p><strong>最终一致性</strong> ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</p>
</li>
</ol>
<p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p>
</blockquote>
<p>那实现最终一致性的具体方式是什么呢? <a href="http://gk.link/a/10rZM" target="_blank" rel="noopener noreferrer">《分布式协议与算法实战》</a> 中是这样介绍：</p>
<blockquote>
<ul>
<li><strong>读时修复</strong> : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点 的副本数据不一致，系统就自动修复数据。</li>
<li><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。</li>
<li><strong>异步修复</strong> : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li>
</ul>
</blockquote>
<p>比较推荐 <strong>写时修复</strong>，这种方式对性能消耗比较低。</p>
<h3 id="总结-2"> 总结</h3>
<p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/cap.png" type="image/png"/>
    </item>
    <item>
      <title>Paxos 算法和 Raft 算法</title>
      <link>https://javaguide.cn/distributed-system/%E7%90%86%E8%AE%BA&amp;%E7%AE%97%E6%B3%95/paxos&amp;raft%E7%AE%97%E6%B3%95/</link>
      <guid>https://javaguide.cn/distributed-system/%E7%90%86%E8%AE%BA&amp;%E7%AE%97%E6%B3%95/paxos&amp;raft%E7%AE%97%E6%B3%95/</guid>
      <source url="https://javaguide.cn/rss.xml">Paxos 算法和 Raft 算法</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="paxos-算法和-raft-算法"> Paxos 算法和 Raft 算法</h1>
<p>Paxos 算法诞生于 1990 年，这是一种解决分布式系统一致性的经典算法 。但是，由于 Paxos 算法非常难以理解和实现，不断有人尝试简化这一算法。到了2013 年才诞生了一个比 Paxos 算法更易理解和实现的分布式一致性算法—Raft 算法。</p>
]]></content:encoded>
    </item>
    <item>
      <title>限流</title>
      <link>https://javaguide.cn/high-availability/limit-request/</link>
      <guid>https://javaguide.cn/high-availability/limit-request/</guid>
      <source url="https://javaguide.cn/rss.xml">限流</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="限流"> 限流</h1>
<h2 id="何为限流-为什么要限流"> 何为限流？为什么要限流？</h2>
<p>针对软件系统来说，限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。毕竟，软件系统的处理能力是有限的。如果说超过了其处理能力的范围，软件系统可能直接就挂掉了。</p>
<p>限流可能会导致用户的请求无法被正确处理，不过，这往往也是权衡了软件系统的稳定性之后得到的最优解。</p>
<p>现实生活中，处处都有限流的实际应用，就比如排队买票是为了避免大量用户涌入购票而导致售票员无法处理。</p>
<p><img src="https://img-blog.csdnimg.cn/f9f17071fc4d489d85d2a234fb298df1.png" alt="排队示意图" /></p>
<h2 id="常见限流算法"> 常见限流算法</h2>
<p>简单介绍 4 种非常好理解并且容易实现的限流算法！</p>
<blockquote>
<p>图片来源于 InfoQ 的一篇文章<a href="https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673" target="_blank" rel="noopener noreferrer">《分布式服务限流实战，已经为你排好坑了》</a>。</p>
</blockquote>
<h3 id="固定窗口计数器算法"> 固定窗口计数器算法</h3>
<p>固定窗口其实就是时间窗口。<strong>固定窗口计数器算法</strong> 规定了我们单位时间处理的请求数量。</p>
<p>假如我们规定系统中某个接口 1 分钟只能访问 33 次的话，使用固定窗口计数器算法的实现思路如下：</p>
<ul>
<li>给定一个变量 <code>counter</code> 来记录当前接口处理的请求数量，初始值为 0（代表接口当前 1 分钟内还未处理请求）。</li>
<li>1 分钟之内每处理一个请求之后就将 <code>counter+1</code> ，当 <code>counter=33</code> 之后（也就是说在这 1 分钟内接口已经被访问 33 次的话），后续的请求就会被全部拒绝。</li>
<li>等到 1 分钟结束后，将 <code>counter</code> 重置 0，重新开始计数。</li>
</ul>
<p><strong>这种限流算法无法保证限流速率，因而无法保证突然激增的流量。</strong></p>
<p>就比如说我们限制某个接口 1 分钟只能访问 1000 次，该接口的 QPS 为 500，前 55s 这个接口 1 个请求没有接收，后 1s 突然接收了 1000 个请求。然后，在当前场景下，这 1000 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了。</p>
<p><img src="https://static001.infoq.cn/resource/image/8d/15/8ded7a2b90e1482093f92fff555b3615.png" alt="固定窗口计数器算法" /></p>
<h3 id="滑动窗口计数器算法"> 滑动窗口计数器算法</h3>
<p><strong>滑动窗口计数器算法</strong> 算的上是固定窗口计数器算法的升级版。</p>
<p>滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：<strong>它把时间以一定比例分片</strong> 。</p>
<p>例如我们的借口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理 不大于 <code>60(请求数)/60（窗口数）</code> 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。</p>
<p>很显然， <strong>当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</strong></p>
<p><img src="https://static001.infoq.cn/resource/image/ae/15/ae4d3cd14efb8dc7046d691c90264715.png" alt="滑动窗口计数器算法" /></p>
<h3 id="漏桶算法"> 漏桶算法</h3>
<p>我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。</p>
<p>如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了（和消息队列削峰/限流的思想是一样的）。</p>
<p><img src="https://static001.infoq.cn/resource/image/75/03/75938d1010138ce66e38c6ed0392f103.png" alt="漏桶算法" /></p>
<h3 id="令牌桶算法"> 令牌桶算法</h3>
<p>令牌桶算法也比较简单。和漏桶算法算法一样，我们的主角还是桶（这限流算法和桶过不去啊）。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。</p>
<p><img src="https://static001.infoq.cn/resource/image/ec/93/eca0e5eaa35dac938c673fecf2ec9a93.png" alt="令牌桶算法" /></p>
<h2 id="单机限流"> 单机限流</h2>
<p>单机限流可以直接使用 Google Guava 自带的限流工具类 <code>RateLimiter</code> 。 <code>RateLimiter</code> 基于令牌桶算法，可以应对突发流量。</p>
<blockquote>
<p>Guava 地址：https://github.com/google/guava</p>
</blockquote>
<p>除了最基本的令牌桶算法(平滑突发限流)实现之外，Guava 的<code>RateLimiter</code>还提供了 <strong>平滑预热限流</strong> 的算法实现。</p>
<p>平滑突发限流就是按照指定的速率放令牌到桶里，而平滑预热限流会有一段预热时间，预热时间之内，速率会逐渐提升到配置的速率。</p>
<p>我们下面通过两个简单的小例子来详细了解吧！</p>
<p>我们直接在项目中引入 Guava 相关的依赖即可使用。</p>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.google.guava<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>guava<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>31.0.1-jre<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是一个简单的 Guava 平滑突发限流的 Demo。</p>
<div><pre><code><span>import</span> <span>com<span>.</span>google<span>.</span>common<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>RateLimiter</span><span>;</span>

<span>/**
 * 微信搜 JavaGuide 回复"面试突击"即可免费领取个人原创的 Java 面试手册
 *
 * @author Guide哥
 * @date 2021/10/08 19:12
 **/</span>
<span>public</span> <span>class</span> <span>RateLimiterDemo</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里</span>
        <span>RateLimiter</span> rateLimiter <span>=</span> <span>RateLimiter</span><span>.</span><span>create</span><span>(</span><span>5</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>double</span> sleepingTime <span>=</span> rateLimiter<span>.</span><span>acquire</span><span>(</span><span>1</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>"get 1 tokens: %ss%n"</span><span>,</span> sleepingTime<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>输出：</p>
<div><pre><code>get <span>1</span> tokens: <span>0</span>.0s
get <span>1</span> tokens: <span>0</span>.188413s
get <span>1</span> tokens: <span>0</span>.197811s
get <span>1</span> tokens: <span>0</span>.198316s
get <span>1</span> tokens: <span>0</span>.19864s
get <span>1</span> tokens: <span>0</span>.199363s
get <span>1</span> tokens: <span>0</span>.193997s
get <span>1</span> tokens: <span>0</span>.199623s
get <span>1</span> tokens: <span>0</span>.199357s
get <span>1</span> tokens: <span>0</span>.195676s
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>下面是一个简单的 Guava 平滑预热限流的 Demo。</p>
<div><pre><code><span>import</span> <span>com<span>.</span>google<span>.</span>common<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>RateLimiter</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>TimeUnit</span><span>;</span>

<span>/**
 * 微信搜 JavaGuide 回复"面试突击"即可免费领取个人原创的 Java 面试手册
 *
 * @author Guide哥
 * @date 2021/10/08 19:12
 **/</span>
<span>public</span> <span>class</span> <span>RateLimiterDemo</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里</span>
        <span>// 预热时间为3s,也就说刚开始的 3s 内发牌速率会逐渐提升到 0.2s 放 1 个令牌到桶里</span>
        <span>RateLimiter</span> rateLimiter <span>=</span> <span>RateLimiter</span><span>.</span><span>create</span><span>(</span><span>5</span><span>,</span> <span>3</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>20</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>double</span> sleepingTime <span>=</span> rateLimiter<span>.</span><span>acquire</span><span>(</span><span>1</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>"get 1 tokens: %sds%n"</span><span>,</span> sleepingTime<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>输出：</p>
<div><pre><code>get <span>1</span> tokens: <span>0</span>.0s
get <span>1</span> tokens: <span>0</span>.561919s
get <span>1</span> tokens: <span>0</span>.516931s
get <span>1</span> tokens: <span>0</span>.463798s
get <span>1</span> tokens: <span>0</span>.41286s
get <span>1</span> tokens: <span>0</span>.356172s
get <span>1</span> tokens: <span>0</span>.300489s
get <span>1</span> tokens: <span>0</span>.252545s
get <span>1</span> tokens: <span>0</span>.203996s
get <span>1</span> tokens: <span>0</span>.198359s
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>另外，<strong>Bucket4j</strong> 是一个非常不错的基于令牌/漏桶算法的限流库。</p>
<blockquote>
<p>Bucket4j 地址：https://github.com/vladimir-bukhtoyarov/bucket4j</p>
</blockquote>
<p>相对于，Guava 的限流工具类来说，Bucket4j 提供的限流功能更加全面。不仅支持单机限流和分布式限流，还可以集成监控，搭配 Prometheus 和 Grafana 使用。</p>
<p>不过，毕竟 Guava 也只是一个功能全面的工具类库，其提供的开箱即用的限流功能在很多单机场景下还是比较实用的。</p>
<p>Spring Cloud Gateway 中自带的单机限流的早期版本就是基于 Bucket4j 实现的。后来，替换成了 <strong>Resilience4j</strong>。</p>
<p>Resilience4j 是一个轻量级的容错组件，其灵感来自于 Hystrix。自<a href="https://github.com/Netflix/Hystrix/commit/a7df971cbaddd8c5e976b3cc5f14013fe6ad00e6" target="_blank" rel="noopener noreferrer">Netflix 宣布不再积极开发 Hystrix</a> 之后，Spring 官方和 Netflix 都更推荐使用 Resilience4j 来做限流熔断。</p>
<blockquote>
<p>Resilience4j 地址: https://github.com/resilience4j/resilience4j</p>
</blockquote>
<p>一般情况下，为了保证系统的高可用，项目的限流和熔断都是要一起做的。</p>
<p>Resilience4j 不仅提供限流，还提供了熔断、负载保护、自动重试等保障系统高可用开箱即用的功能。并且，Resilience4j 的生态也更好，很多网关都使用 Resilience4j 来做限流熔断的。</p>
<p>因此，在绝大部分场景下 Resilience4j 或许会是更好的选择。如果是一些比较简单的限流场景的话，Guava 或者 Bucket4j 也是不错的选择。</p>
<h2 id="分布式限流"> 分布式限流</h2>
<p>分布式限流常见的方案：</p>
<ul>
<li><strong>借助中间件架限流</strong> ：可以借助 Sentinel 或者使用 Redis 来自己实现对应的限流逻辑。</li>
<li><strong>网关层限流</strong> ：比较常用的一种方案，直接在网关层把限流给安排上了。不过，通常网关层限流通常也需要借助到中间件/框架。就比如 Spring Cloud Gateway 的分布式限流实现<code>RedisRateLimiter</code>就是基于 Redis+Lua 来实现的，再比如 Spring Cloud Gateway 还可以整合 Sentinel 来做限流。</li>
</ul>
<p>如果你要基于 Redis 来手动实现限流逻辑的话，建议配合 Lua 脚本来做。</p>
<p>网上也有很多现成的脚本供你参考，就比如 Apache 网关项目 ShenYu 的 RateLimiter 限流插件就基于 Redis + Lua 实现了令牌桶算法/并发令牌桶算法、漏桶算法、滑动窗口算法。</p>
<blockquote>
<p>ShenYu 地址: https://github.com/apache/incubator-shenyu</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/e1e2a75f489e4854990dabe3b6cec522.png" alt="" /></p>
<h2 id="相关阅读"> 相关阅读</h2>
<ul>
<li>服务治理之轻量级熔断框架 Resilience4j ：https://xie.infoq.cn/article/14786e571c1a4143ad1ef8f19</li>
<li>超详细的 Guava RateLimiter 限流原理解析：https://cloud.tencent.com/developer/article/1408819</li>
<li>实战 Spring Cloud Gateway 之限流篇 👍：https://www.aneasystone.com/archives/2020/08/spring-cloud-gateway-current-limiting.html</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/f9f17071fc4d489d85d2a234fb298df1.png" type="image/png"/>
    </item>
    <item>
      <title>性能测试入门</title>
      <link>https://javaguide.cn/high-availability/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link>
      <guid>https://javaguide.cn/high-availability/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</guid>
      <source url="https://javaguide.cn/rss.xml">性能测试入门</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="性能测试入门"> 性能测试入门</h1>
<p>性能测试一般情况下都是由测试这个职位去做的，那还需要我们开发学这个干嘛呢？了解性能测试的指标、分类以及工具等知识有助于我们更好地去写出性能更好的程序，另外作为开发这个角色，如果你会性能测试的话，相信也会为你的履历加分不少。</p>
<p>这篇文章是我会结合自己的实际经历以及在测试这里取的经所得，除此之外，我还借鉴了一些优秀书籍，希望对你有帮助。</p>
<p>本文思维导图：</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/网站性能测试.png" style="zoom:50%;" />
<h2 id="一-不同角色看网站性能"> 一 不同角色看网站性能</h2>
<h3 id="_1-1-用户"> 1.1 用户</h3>
<p>当用户打开一个网站的时候，最关注的是什么？当然是网站响应速度的快慢。比如我们点击了淘宝的主页，淘宝需要多久将首页的内容呈现在我的面前，我点击了提交订单按钮需要多久返回结果等等。</p>
<p>所以，用户在体验我们系统的时候往往根据你的响应速度的快慢来评判你的网站的性能。</p>
<h3 id="_1-2-开发人员"> 1.2 开发人员</h3>
<p>用户与开发人员都关注速度，这个速度实际上就是我们的系统<strong>处理用户请求的速度</strong>。</p>
<p>开发人员一般情况下很难直观的去评判自己网站的性能，我们往往会根据网站当前的架构以及基础设施情况给一个大概的值,比如：</p>
<ol>
<li>项目架构是分布式的吗？</li>
<li>用到了缓存和消息队列没有？</li>
<li>高并发的业务有没有特殊处理？</li>
<li>数据库设计是否合理？</li>
<li>系统用到的算法是否还需要优化？</li>
<li>系统是否存在内存泄露的问题？</li>
<li>项目使用的 Redis 缓存多大？服务器性能如何？用的是机械硬盘还是固态硬盘？</li>
<li>......</li>
</ol>
<h3 id="_1-3-测试人员"> 1.3 测试人员</h3>
<p>测试人员一般会根据性能测试工具来测试，然后一般会做出一个表格。这个表格可能会涵盖下面这些重要的内容：</p>
<ol>
<li>相应时间；</li>
<li>请求成功率；</li>
<li>吞吐量；</li>
<li>......</li>
</ol>
<h3 id="_1-4-运维人员"> 1.4 运维人员</h3>
<p>运维人员会倾向于根据基础设施和资源的利用率来判断网站的性能，比如我们的服务器资源使用是否合理、数据库资源是否存在滥用的情况、当然，这是传统的运维人员，现在 Devpos 火起来后，单纯干运维的很少了。我们这里暂且还保留有这个角色。</p>
<h2 id="二-性能测试需要注意的点"> 二 性能测试需要注意的点</h2>
<p>几乎没有文章在讲性能测试的时候提到这个问题，大家都会讲如何去性能测试，有哪些性能测试指标这些东西。</p>
<h3 id="_2-1-了解系统的业务场景"> 2.1 了解系统的业务场景</h3>
<p><strong>性能测试之前更需要你了解当前的系统的业务场景。</strong> 对系统业务了解的不够深刻，我们很容易犯测试方向偏执的错误，从而导致我们忽略了对系统某些更需要性能测试的地方进行测试。比如我们的系统可以为用户提供发送邮件的功能，用户配置成功邮箱后只需输入相应的邮箱之后就能发送，系统每天大概能处理上万次发邮件的请求。很多人看到这个可能就直接开始使用相关工具测试邮箱发送接口，但是，发送邮件这个场景可能不是当前系统的性能瓶颈，这么多人用我们的系统发邮件， 还可能有很多人一起发邮件，单单这个场景就这么人用，那用户管理可能才是性能瓶颈吧！</p>
<h3 id="_2-2-历史数据非常有用"> 2.2 历史数据非常有用</h3>
<p>当前系统所留下的历史数据非常重要，一般情况下，我们可以通过相应的些历史数据初步判定这个系统哪些接口调用的比较多、哪些 service 承受的压力最大，这样的话，我们就可以针对这些地方进行更细致的性能测试与分析。</p>
<p>另外，这些地方也就像这个系统的一个短板一样，优化好了这些地方会为我们的系统带来质的提升。</p>
<h3 id="三-性能测试的指标"> 三 性能测试的指标</h3>
<h3 id="_3-1-响应时间"> 3.1 响应时间</h3>
<p><strong>响应时间就是用户发出请求到用户收到系统处理结果所需要的时间。</strong> 重要吗？实在太重要！</p>
<p>比较出名的 2-5-8 原则是这样描述的：通常来说，2到5秒，页面体验会比较好，5到8秒还可以接受，8秒以上基本就很难接受了。另外，据统计当网站慢一秒就会流失十分之一的客户。</p>
<p>但是，在某些场景下我们也并不需要太看重 2-5-8 原则 ，比如我觉得系统导出导入大数据量这种就不需要，系统生成系统报告这种也不需要。</p>
<h3 id="_3-2-并发数"> 3.2 并发数</h3>
<p><strong>并发数是系统能同时处理请求的数目即同时提交请求的用户数目。</strong></p>
<p>不得不说，高并发是现在后端架构中非常非常火热的一个词了，这个与当前的互联网环境以及中国整体的互联网用户量都有很大关系。一般情况下，你的系统并发量越大，说明你的产品做的就越大。但是，并不是每个系统都需要达到像淘宝、12306 这种亿级并发量的。</p>
<h3 id="_3-3-吞吐量"> 3.3 吞吐量</h3>
<p>吞吐量指的是系统单位时间内系统处理的请求数量。衡量吞吐量有几个重要的参数：QPS（TPS）、并发数、响应时间。</p>
<ol>
<li>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</li>
<li>TPS（Transaction Per Second）：服务器每秒处理的事务数（这里的一个事务可以理解为客户发出请求到收到服务器的过程）；</li>
<li>并发数；系统能同时处理请求的数目即同时提交请求的用户数目。</li>
<li>响应时间： 一般取多次请求的平均响应时间</li>
</ol>
<p>理清他们的概念，就很容易搞清楚他们之间的关系了。</p>
<ul>
<li><strong>QPS（TPS）</strong> = 并发数/平均响应时间</li>
<li><strong>并发数</strong> = QPS\平均响应时间</li>
</ul>
<p>书中是这样描述 QPS 和 TPS 的区别的。</p>
<blockquote>
<p>QPS vs TPS：QPS 基本类似于 TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器2次，一次访问，产生一个“T”，产生2个“Q”。</p>
</blockquote>
<h3 id="_3-4-性能计数器"> 3.4 性能计数器</h3>
<p><strong>性能计数器是描述服务器或者操作系统的一些数据指标如内存使用、CPU使用、磁盘与网络I/O等情况。</strong></p>
<h3 id="四-几种常见的性能测试"> 四 几种常见的性能测试</h3>
<h3 id="性能测试"> 性能测试</h3>
<p>性能测试方法是通过测试工具模拟用户请求系统，目的主要是为了测试系统的性能是否满足要求。通俗地说，这种方法就是要在特定的运行条件下验证系统的能力状态。</p>
<p>性能测试是你在对系统性能已经有了解的前提之后进行的，并且有明确的性能指标。</p>
<h3 id="负载测试"> 负载测试</h3>
<p>对被测试的系统继续加大请求压力，直到服务器的某个资源已经达到饱和了，比如系统的缓存已经不够用了或者系统的响应时间已经不满足要求了。</p>
<p>负载测试说白点就是测试系统的上线。</p>
<h3 id="压力测试"> 压力测试</h3>
<p>不去管系统资源的使用情况，对系统继续加大请求压力，直到服务器崩溃无法再继续提供服务。</p>
<h3 id="稳定性测试"> 稳定性测试</h3>
<p>模拟真实场景，给系统一定压力，看看业务是否能稳定运行。</p>
<h2 id="五-常用性能测试工具"> 五 常用性能测试工具</h2>
<p>这里就不多扩展了，有时间的话会单独拎一个熟悉的说一下。</p>
<h3 id="_5-1-后端常用"> 5.1 后端常用</h3>
<p>没记错的话，除了 LoadRunner 其他几款性能测试工具都是开源免费的。</p>
<ol>
<li>Jmeter ：Apache JMeter 是 JAVA 开发的性能测试工具。</li>
<li>LoadRunner：一款商业的性能测试工具。</li>
<li>Galtling ：一款基于Scala 开发的高性能服务器性能测试工具。</li>
<li>ab ：全称为 Apache Bench 。Apache 旗下的一款测试工具，非常实用。</li>
</ol>
<h3 id="_5-2-前端常用"> 5.2 前端常用</h3>
<ol>
<li>Fiddler：抓包工具，它可以修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是Web 调试的利器。</li>
<li>HttpWatch: 可用于录制HTTP请求信息的工具。</li>
</ol>
<h2 id="六-常见的性能优化策略"> 六 常见的性能优化策略</h2>
<p>性能优化之前我们需要对请求经历的各个环节进行分析，排查出可能出现性能瓶颈的地方，定位问题。</p>
<p>下面是一些性能优化时，我经常拿来自问的一些问题：</p>
<ol>
<li>系统是否需要缓存？</li>
<li>系统架构本身是不是就有问题？</li>
<li>系统是否存在死锁的地方？</li>
<li>系统是否存在内存泄漏？（Java 的自动回收内存虽然很方便，但是，有时候代码写的不好真的会造成内存泄漏）</li>
<li>数据库索引使用是否合理？</li>
<li>......</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>灾备设计&amp;异地多活</title>
      <link>https://javaguide.cn/high-availability/%E7%81%BE%E5%A4%87%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/</link>
      <guid>https://javaguide.cn/high-availability/%E7%81%BE%E5%A4%87%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/</guid>
      <source url="https://javaguide.cn/rss.xml">灾备设计&amp;异地多活</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="灾备设计-异地多活"> 灾备设计&amp;异地多活</h1>
<p><strong>灾备</strong> = 容灾+备份。</p>
<ul>
<li><strong>备份</strong> ： 将系统所产生的的所有重要数据多备份几份。</li>
<li><strong>容灾</strong> ： 在异地建立两个完全相同的系统。当某个地方的系统突然挂掉，整个应用系统可以切换到另一个，这样系统就可以正常提供服务了。</li>
</ul>
<p><strong>异地多活</strong> 描述的是将服务部署在异地并且服务同时对外提供服务。和传统的灾备设计的最主要区别在于“多活”，即所有站点都是同时在对外提供服务的。异地多活是为了应对突发状况比如火灾、地震等自然或者认为灾害。</p>
<p>相关阅读：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/T6mMDdtTfBuIiEowCpqu6Q" target="_blank" rel="noopener noreferrer">搞懂异地多活，看这篇就够了</a></li>
<li><a href="https://mp.weixin.qq.com/s/hMD-IS__4JE5_nQhYPYSTg" target="_blank" rel="noopener noreferrer">四步构建异地多活</a></li>
<li><a href="http://gk.link/a/10pKZ" target="_blank" rel="noopener noreferrer">《从零开始学架构》— 28 | 业务高可用的保障：异地多活架构</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>超时&amp;重试机制</title>
      <link>https://javaguide.cn/high-availability/%E8%B6%85%E6%97%B6%E5%92%8C%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</link>
      <guid>https://javaguide.cn/high-availability/%E8%B6%85%E6%97%B6%E5%92%8C%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</guid>
      <source url="https://javaguide.cn/rss.xml">超时&amp;重试机制</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="超时-重试机制"> 超时&amp;重试机制</h1>
<p><strong>一旦用户的请求超过某个时间得不到响应就结束此次请求并抛出异常。</strong> 如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。</p>
<p>另外，重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p>
]]></content:encoded>
    </item>
    <item>
      <title>降级&amp;熔断</title>
      <link>https://javaguide.cn/high-availability/%E9%99%8D%E7%BA%A7&amp;%E7%86%94%E6%96%AD/</link>
      <guid>https://javaguide.cn/high-availability/%E9%99%8D%E7%BA%A7&amp;%E7%86%94%E6%96%AD/</guid>
      <source url="https://javaguide.cn/rss.xml">降级&amp;熔断</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="降级-熔断"> 降级&amp;熔断</h1>
<p>降级是从系统功能优先级的角度考虑如何应对系统故障。</p>
<p>服务降级指的是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</p>
<p>熔断和降级是两个比较容易混淆的概念，两者的含义并不相同。</p>
<p>降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。</p>
]]></content:encoded>
    </item>
    <item>
      <title>集群</title>
      <link>https://javaguide.cn/high-availability/%E9%9B%86%E7%BE%A4/</link>
      <guid>https://javaguide.cn/high-availability/%E9%9B%86%E7%BE%A4/</guid>
      <source url="https://javaguide.cn/rss.xml">集群</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="集群"> 集群</h1>
<p>相同的服务部署多份，避免单点故障。</p>
]]></content:encoded>
    </item>
    <item>
      <title>高可用系统设计</title>
      <link>https://javaguide.cn/high-availability/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</link>
      <guid>https://javaguide.cn/high-availability/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</guid>
      <source url="https://javaguide.cn/rss.xml">高可用系统设计</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="高可用系统设计"> 高可用系统设计</h1>
<p>一篇短小的文章，面试经常遇到的这个问题。本文主要包括下面这些内容：</p>
<ol>
<li>高可用的定义</li>
<li>哪些情况可能会导致系统不可用？</li>
<li>有哪些提高系统可用性的方法？只是简单的提一嘴，更具体内容在后续的文章中介绍，就拿限流来说，你需要搞懂：何为限流？如何限流？为什么要限流？如何做呢？说一下原理？。</li>
</ol>
<h2 id="什么是高可用-可用性的判断标准是啥"> 什么是高可用？可用性的判断标准是啥？</h2>
<p><strong>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</strong></p>
<p><strong>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。</strong></p>
<p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</p>
<h2 id="哪些情况会导致系统不可用"> 哪些情况会导致系统不可用？</h2>
<ol>
<li>黑客攻击；</li>
<li>硬件故障，比如服务器坏掉。</li>
<li>并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。</li>
<li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。</li>
<li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。</li>
<li>自然灾害或者人为破坏。</li>
<li>......</li>
</ol>
<h2 id="有哪些提高系统可用性的方法"> 有哪些提高系统可用性的方法？</h2>
<h3 id="_1-注重代码质量-测试严格把关"> 1. 注重代码质量，测试严格把关</h3>
<p>我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！</p>
<p>另外，安利这个对提高代码质量有实际效果的宝贝：</p>
<ol>
<li>sonarqube ：保证你写出更安全更干净的代码！（ps: 目前所在的项目基本都会用到这个插件）。</li>
<li>Alibaba 开源的 Java 诊断工具 Arthas 也是很不错的选择。</li>
<li>IDEA 自带的代码分析等工具进行代码扫描也是非常非常棒的。</li>
</ol>
<h3 id="_2-使用集群-减少单点故障"> 2.使用集群，减少单点故障</h3>
<p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例挂了，不到一秒就会有另外一台 Redis 实例顶上。</p>
<h3 id="_3-限流"> 3.限流</h3>
<p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。——来自 alibaba-<a href="https://github.com/alibaba/Sentinel" title="Sentinel" target="_blank" rel="noopener noreferrer">Sentinel</a> 的 wiki。</p>
<h3 id="_4-超时和重试机制设置"> 4.超时和重试机制设置</h3>
<p>一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法再处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p>
<h3 id="_5-熔断机制"> 5.熔断机制</h3>
<p>超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。</p>
<h3 id="_6-异步调用"> 6.异步调用</h3>
<p>异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 <strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。</p>
<h3 id="_7-使用缓存"> 7.使用缓存</h3>
<p>如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！</p>
<h3 id="_8-其他"> 8.其他</h3>
<ol>
<li><strong>核心应用和服务优先使用更好的硬件</strong></li>
<li><strong>监控系统资源使用情况增加报警设置。</strong></li>
<li><strong>注意备份，必要时候回滚。</strong></li>
<li><strong>灰度发布：</strong> 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可</li>
<li><strong>定期检查/更换硬件：</strong> 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。</li>
<li>.....(想起来再补充！也欢迎各位欢迎补充！)</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Kafka知识点&amp;面试题总结</title>
      <link>https://javaguide.cn/high-performance/message-queue/kafka%E7%9F%A5%E8%AF%86%E7%82%B9&amp;%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/high-performance/message-queue/kafka%E7%9F%A5%E8%AF%86%E7%82%B9&amp;%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">Kafka知识点&amp;面试题总结</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="kafka知识点-面试题总结"> Kafka知识点&amp;面试题总结</h1>
<h3 id="kafka-是什么-主要应用场景有哪些"> Kafka 是什么？主要应用场景有哪些？</h3>
<p>Kafka 是一个分布式流式处理平台。这到底是什么意思呢？</p>
<p>流平台具有三个关键功能：</p>
<ol>
<li><strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li>
<li><strong>容错的持久方式存储记录消息流</strong>： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li>
<li><strong>流式处理平台：</strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li>
</ol>
<p>Kafka 主要有两大应用场景：</p>
<ol>
<li><strong>消息队列</strong> ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li>
<li><strong>数据处理：</strong> 构建实时的流数据处理程序来转换或处理数据流。</li>
</ol>
<h3 id="和其他消息队列相比-kafka的优势在哪里"> 和其他消息队列相比,Kafka的优势在哪里？</h3>
<p>我们现在经常提到 Kafka 的时候就已经默认它是一个非常优秀的消息队列了，我们也会经常拿它跟 RocketMQ、RabbitMQ 对比。我觉得 Kafka 相比其他消息队列主要的优势如下：</p>
<ol>
<li><strong>极致的性能</strong> ：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。</li>
<li><strong>生态系统兼容性无可匹敌</strong> ：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。</li>
</ol>
<p>实际上在早期的时候 Kafka 并不是一个合格的消息队列，早期的 Kafka 在消息队列领域就像是一个衣衫褴褛的孩子一样，功能不完备并且有一些小问题比如丢失消息、不保证消息可靠性等等。当然，这也和 LinkedIn 最早开发 Kafka 用于处理海量的日志有很大关系，哈哈哈，人家本来最开始就不是为了作为消息队列滴，谁知道后面误打误撞在消息队列领域占据了一席之地。</p>
<p>随着后续的发展，这些短板都被 Kafka 逐步修复完善。所以，<strong>Kafka 作为消息队列不可靠这个说法已经过时！</strong></p>
<h3 id="队列模型了解吗-kafka-的消息模型知道吗"> 队列模型了解吗？Kafka 的消息模型知道吗？</h3>
<blockquote>
<p>题外话：早期的 JMS 和 AMQP 属于消息服务领域权威组织所做的相关的标准，我在 <a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener noreferrer">JavaGuide</a>的 <a href="https://github.com/Snailclimb/JavaGuide#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E4%B8%AD%E9%97%B4%E4%BB%B6" target="_blank" rel="noopener noreferrer">《消息队列其实很简单》</a>这篇文章中介绍过。但是，这些标准的进化跟不上消息队列的演进速度，这些标准实际上已经属于废弃状态。所以，可能存在的情况是：不同的消息队列都有自己的一套消息模型。</p>
</blockquote>
<h4 id="队列模型-早期的消息模型"> 队列模型：早期的消息模型</h4>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/队列模型23.png" alt="队列模型" /></p>
<p><strong>使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</strong> 比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<p><strong>队列模型存在的问题：</strong></p>
<p>假如我们存在这样一种情况：我们需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容。</p>
<p>这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。</p>
<h4 id="发布-订阅模型-kafka-消息模型"> 发布-订阅模型:Kafka 消息模型</h4>
<p>发布-订阅模型主要是为了解决队列模型存在的问题。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/发布订阅模型.png" alt="发布订阅模型" /></p>
<p>发布订阅模型（Pub-Sub） 使用<strong>主题（Topic）</strong> 作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
<p><strong>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</strong></p>
<p><strong>Kafka 采用的就是发布 - 订阅模型。</strong></p>
<blockquote>
<p><strong>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。</strong></p>
</blockquote>
<h3 id="什么是producer、consumer、broker、topic、partition"> 什么是Producer、Consumer、Broker、Topic、Partition？</h3>
<p>Kafka 将生产者发布的消息发送到 <strong>Topic（主题）</strong> 中，需要这些消息的消费者可以订阅这些 <strong>Topic（主题）</strong>，如下图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/KafkaTopicPartitioning.png" alt="Kafka Topic Partition" /></p>
<p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p>
<ol>
<li><strong>Producer（生产者）</strong> : 产生消息的一方。</li>
<li><strong>Consumer（消费者）</strong> : 消费消息的一方。</li>
<li><strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</li>
</ol>
<p>同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p>
<ul>
<li><strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</li>
<li><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样。</li>
</ul>
<blockquote>
<p>划重点：<strong>Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。这样是不是更好理解一点？</strong></p>
</blockquote>
<h3 id="kafka-的多副本机制了解吗-带来了什么好处"> Kafka 的多副本机制了解吗？带来了什么好处？</h3>
<p>还有一点我觉得比较重要的是 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p>
<blockquote>
<p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p>
</blockquote>
<p><strong>Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</strong></p>
<ol>
<li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li>
<li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li>
</ol>
<h3 id="zookeeper-在-kafka-中的作用知道吗"> Zookeeper 在 Kafka 中的作用知道吗？</h3>
<blockquote>
<p><strong>要想搞懂 zookeeper 在 Kafka 中的作用 一定要自己搭建一个 Kafka 环境然后自己进 zookeeper 去看一下有哪些文件夹和 Kafka 有关，每个节点又保存了什么信息。</strong> 一定不要光看不实践，这样学来的也终会忘记！这部分内容参考和借鉴了这篇文章：https://www.jianshu.com/p/a036405f989c 。</p>
</blockquote>
<p>下图就是我的本地 Zookeeper ，它成功和我本地的 Kafka 关联上（以下文件夹结构借助 idea 插件 Zookeeper tool 实现）。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zookeeper-kafka.jpg" style="zoom:50%;" />
<p>ZooKeeper 主要为 Kafka 提供元数据的管理的功能。</p>
<p>从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：</p>
<ol>
<li><strong>Broker 注册</strong> ：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 <code>/brokers/ids</code> 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li>
<li><strong>Topic 注册</strong> ： 在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li>
<li><strong>负载均衡</strong> ：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li>
<li>......</li>
</ol>
<h3 id="kafka-如何保证消息的消费顺序"> Kafka 如何保证消息的消费顺序？</h3>
<p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p>
<ol>
<li>更改用户会员等级。</li>
<li>根据会员等级计算订单价格。</li>
</ol>
<p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p>
<p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/KafkaTopicPartionsLayout.png" alt="" /></p>
<p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 <strong>Kafka 只能为我们保证 Partition(分区) 中的消息有序。</strong></p>
<blockquote>
<p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p>
</blockquote>
<p>所以，我们就有一种很简单的保证消息消费顺序的方法：<strong>1 个 Topic 只对应一个 Partition</strong>。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p>
<p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。</p>
<p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p>
<ol>
<li>1 个 Topic 只对应一个 Partition。</li>
<li>（推荐）发送消息的时候指定 key/Partition。</li>
</ol>
<p>当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的，</p>
<h3 id="kafka-如何保证消息不丢失"> Kafka 如何保证消息不丢失</h3>
<h4 id="生产者丢失消息的情况"> 生产者丢失消息的情况</h4>
<p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p>
<p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是  Kafka 生产者(Producer) 使用  <code>send</code> 方法发送消息实际上是异步的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p>
<blockquote>
<p><strong>详细代码见我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486269&amp;idx=2&amp;sn=ec00417ad641dd8c3d145d74cafa09ce&amp;chksm=cea244f6f9d5cde0c8eb233fcc4cf82e11acd06446719a7af55230649863a3ddd95f78d111de&amp;token=1633957262&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">Kafka系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列?</a></strong></p>
</blockquote>
<div><pre><code><span>SendResult</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> sendResult <span>=</span> kafkaTemplate<span>.</span><span>send</span><span>(</span>topic<span>,</span> o<span>)</span><span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
<span>if</span> <span>(</span>sendResult<span>.</span><span>getRecordMetadata</span><span>(</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
  logger<span>.</span><span>info</span><span>(</span><span>"生产者成功发送消息到"</span> <span>+</span> sendResult<span>.</span><span>getProducerRecord</span><span>(</span><span>)</span><span>.</span><span>topic</span><span>(</span><span>)</span> <span>+</span> <span>"-> "</span> <span>+</span> sendRe
              sult<span>.</span><span>getProducerRecord</span><span>(</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p>
<div><pre><code>        <span>ListenableFuture</span><span><span>&lt;</span><span>SendResult</span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span><span>></span></span> future <span>=</span> kafkaTemplate<span>.</span><span>send</span><span>(</span>topic<span>,</span> o<span>)</span><span>;</span>
        future<span>.</span><span>addCallback</span><span>(</span>result <span>-></span> logger<span>.</span><span>info</span><span>(</span><span>"生产者成功发送消息到topic:{} partition:{}的消息"</span><span>,</span> result<span>.</span><span>getRecordMetadata</span><span>(</span><span>)</span><span>.</span><span>topic</span><span>(</span><span>)</span><span>,</span> result<span>.</span><span>getRecordMetadata</span><span>(</span><span>)</span><span>.</span><span>partition</span><span>(</span><span>)</span><span>)</span><span>,</span>
                ex <span>-></span> logger<span>.</span><span>error</span><span>(</span><span>"生产者发送消失败，原因：{}"</span><span>,</span> ex<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p>
<p><strong>另外这里推荐为 Producer 的<code>retries</code>（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你3次一下子就重试完了</strong></p>
<h4 id="消费者丢失消息的情况"> 消费者丢失消息的情况</h4>
<p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/kafka-offset.jpg" alt="kafka offset" /></p>
<p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p>
<p><strong>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>
<h4 id="kafka-弄丢了消息"> Kafka 弄丢了消息</h4>
<p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p>
<p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p>
<p><strong>设置 acks = all</strong></p>
<p>解决办法就是我们设置  <strong>acks = all</strong>。acks 是 Kafka 生产者(Producer)  很重要的一个参数。</p>
<p>acks 的默认值即为1，代表我们的消息被leader副本接收之后就算被成功发送。当我们配置 <strong>acks = all</strong> 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。</p>
<p><strong>设置 replication.factor &gt;= 3</strong></p>
<p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;= 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p>
<p><strong>设置 min.insync.replicas &gt; 1</strong></p>
<p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p>
<p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor = min.insync.replicas + 1</strong>。</p>
<p><strong>设置 unclean.leader.election.enable = false</strong></p>
<blockquote>
<p><strong>Kafka 0.11.0.0版本开始 unclean.leader.election.enable 参数的默认值由原来的true 改为false</strong></p>
</blockquote>
<p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable = false</strong>  的话，当 leader 副本发生故障时就不会从  follower 副本中和 leader 同步程度达不到要求的副本中选择出  leader ，这样降低了消息丢失的可能性。</p>
<h3 id="kafka-如何保证消息不重复消费"> Kafka 如何保证消息不重复消费</h3>
<p><strong>kafka出现消息重复消费的原因：</strong></p>
<ul>
<li>服务端侧已经消费的数据没有成功提交 offset（根本原因）。</li>
<li>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>消费消息服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。这种方法最有效。</li>
<li>将 <strong><code>enable.auto.commit</code></strong> 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：<strong>什么时候提交offset合适？</strong>
<ul>
<li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li>
<li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li>
</ul>
</li>
</ul>
<h3 id="reference"> Reference</h3>
<ul>
<li>Kafka 官方文档： https://kafka.apache.org/documentation/</li>
<li>极客时间—《Kafka核心技术与实战》第11节：无消息丢失配置怎么实现？</li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/队列模型23.png" type="image/png"/>
    </item>
    <item>
      <title>消息队列知识点&amp;面试题总结</title>
      <link>https://javaguide.cn/high-performance/message-queue/message-queue/</link>
      <guid>https://javaguide.cn/high-performance/message-queue/message-queue/</guid>
      <source url="https://javaguide.cn/rss.xml">消息队列知识点&amp;面试题总结</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="消息队列知识点-面试题总结"> 消息队列知识点&amp;面试题总结</h1>
<p>“RabbitMQ？”“Kafka？”“RocketMQ？”...在日常学习与开发过程中，我们常常听到消息队列这个关键词。我也在我的多篇文章中提到了这个概念。可能你是熟练使用消息队列的老手，又或者你是不懂消息队列的新手，不论你了不了解消息队列，本文都将带你搞懂消息队列的一些基本理论。如果你是老手，你可能从本文学到你之前不曾注意的一些关于消息队列的重要概念，如果你是新手，相信本文将是你打开消息队列大门的一板砖。</p>
<h2 id="一-什么是消息队列"> 一 什么是消息队列</h2>
<p>我们可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/消息队列/message-queue-small.png" alt="Message queue" /></p>
<p>消息队列是分布式系统中重要的组件之一。使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。</p>
<p>我们知道队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</p>
<h2 id="二-为什么要用消息队列"> 二 为什么要用消息队列</h2>
<p>通常来说，使用消息队列能为我们的系统带来下面三点好处：</p>
<ol>
<li><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></li>
<li><strong>削峰/限流</strong></li>
<li><strong>降低系统耦合性。</strong></li>
</ol>
<p>如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐你结合你自己的项目来回答。</p>
<p>《大型网站技术架构》第四章和第七章均有提到消息队列对应用性能及扩展性的提升。</p>
<h3 id="_2-1-通过异步处理提高系统性能-减少响应所需时间"> 2.1 通过异步处理提高系统性能（减少响应所需时间）</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/Asynchronous-message-queue.png" alt="通过异步处理提高系统性能" /></p>
<p>将用户的请求数据存储到消息队列之后就立即返回结果。随后，系统再对消息进行消费。</p>
<p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，<strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>
<h3 id="_2-2-削峰-限流"> 2.2 削峰/限流</h3>
<p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</strong></p>
<p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/削峰-消息队列.png" alt="削峰" /></p>
<h3 id="_2-3-降低系统耦合性"> 2.3 降低系统耦合性</h3>
<p>使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/消息队列-解耦.png" alt="解耦" /></p>
<p>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</p>
<p><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p>
<p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>
<p>另外，为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p>
<p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。</p>
<h2 id="三-使用消息队列带来的一些问题"> 三 使用消息队列带来的一些问题</h2>
<ul>
<li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li>
<li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li>
<li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li>
</ul>
<h2 id="四-jms-vs-amqp"> 四 JMS VS AMQP</h2>
<h3 id="_4-1-jms"> 4.1 JMS</h3>
<h4 id="_4-1-1-jms-简介"> 4.1.1 JMS 简介</h4>
<p>JMS（JAVA Message Service,java 消息服务）是 java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。<strong>JMS（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<p><strong>ActiveMQ 就是基于 JMS 规范实现的。</strong></p>
<h4 id="_4-1-2-jms-两种消息模型"> 4.1.2 JMS 两种消息模型</h4>
<p><strong>① 点到点（P2P）模型</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/队列模型23.png" alt="队列模型" /></p>
<p>使用<strong>队列（Queue）<strong>作为消息通信载体；满足</strong>生产者与消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<p><strong>② 发布/订阅（Pub/Sub）模型</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/发布订阅模型.png" alt="发布订阅模型" /></p>
<p>发布订阅模型（Pub/Sub） 使用<strong>主题（Topic）<strong>作为消息通信载体，类似于</strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
<h4 id="_4-1-3-jms-五种不同的消息正文格式"> 4.1.3 JMS 五种不同的消息正文格式</h4>
<p>JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>
<ul>
<li>StreamMessage -- Java 原始值的数据流</li>
<li>MapMessage--一套名称-值对</li>
<li>TextMessage--一个字符串对象</li>
<li>ObjectMessage--一个序列化的 Java 对象</li>
<li>BytesMessage--一个字节的数据流</li>
</ul>
<h3 id="_4-2-amqp"> 4.2 AMQP</h3>
<p>AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p>
<p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p>
<h3 id="_4-3-jms-vs-amqp"> 4.3 JMS vs AMQP</h3>
<table>
<thead>
<tr>
<th style="text-align:left">对比方向</th>
<th style="text-align:left">JMS</th>
<th style="text-align:left">AMQP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">定义</td>
<td style="text-align:left">Java API</td>
<td style="text-align:left">协议</td>
</tr>
<tr>
<td style="text-align:left">跨语言</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">跨平台</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">支持消息类型</td>
<td style="text-align:left">提供两种消息模型：①Peer-2-Peer;②Pub/sub</td>
<td style="text-align:left">提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；</td>
</tr>
<tr>
<td style="text-align:left">支持消息类型</td>
<td style="text-align:left">支持多种消息类型 ，我们在上面提到过</td>
<td style="text-align:left">byte[]（二进制）</td>
</tr>
</tbody>
</table>
<p><strong>总结：</strong></p>
<ul>
<li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。</li>
<li>JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。</li>
<li>由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。</li>
</ul>
<h2 id="五-常见的消息队列对比"> 五 常见的消息队列对比</h2>
<table>
<thead>
<tr>
<th>对比方向</th>
<th>概要</th>
</tr>
</thead>
<tbody>
<tr>
<td>吞吐量</td>
<td>万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。</td>
</tr>
<tr>
<td>可用性</td>
<td>都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>时效性</td>
<td>RabbitMQ 基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。</td>
</tr>
<tr>
<td>功能支持</td>
<td>除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
<tr>
<td>消息丢失</td>
<td>ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。</td>
</tr>
</tbody>
</table>
<p><strong>总结：</strong></p>
<ul>
<li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。</li>
<li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的</li>
<li>Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li>
</ul>
<p>参考：《Java 工程师面试突击第 1 季-中华石杉老师》</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/message-queue-small.png" type="image/png"/>
    </item>
    <item>
      <title>RabbitMQ 入门总结</title>
      <link>https://javaguide.cn/high-performance/message-queue/rabbitmq-intro/</link>
      <guid>https://javaguide.cn/high-performance/message-queue/rabbitmq-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">RabbitMQ 入门总结</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="rabbitmq-入门总结"> RabbitMQ 入门总结</h1>
<h2 id="一-rabbitmq-介绍"> 一 RabbitMQ 介绍</h2>
<p>这部分参考了 《RabbitMQ实战指南》这本书的第 1 章和第 2 章。</p>
<h3 id="_1-1-rabbitmq-简介"> 1.1 RabbitMQ 简介</h3>
<p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p>
<p>RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p>
<ul>
<li><strong>可靠性：</strong> RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li>
<li><strong>灵活的路由：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。</li>
<li><strong>扩展性：</strong> 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>
<li><strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li>
<li><strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li>
<li><strong>多语言客户端：</strong> RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript等。</li>
<li><strong>易用的管理界面：</strong> RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li>
<li><strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI机制。</li>
</ul>
<h3 id="_1-2-rabbitmq-核心概念"> 1.2 RabbitMQ 核心概念</h3>
<p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p>
<p>下面再来看看图1—— RabbitMQ 的整体模型架构。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/96388546.jpg" alt="图1-RabbitMQ 的整体模型架构" /></p>
<p>下面我会一一介绍上图中的一些概念。</p>
<h4 id="_1-2-1-producer-生产者-和-consumer-消费者"> 1.2.1 Producer(生产者) 和 Consumer(消费者)</h4>
<ul>
<li><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</li>
<li><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</li>
</ul>
<p>消息一般由 2 部分组成：<strong>消息头</strong>（或者说是标签 Label）和 <strong>消息体</strong>。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</p>
<h4 id="_1-2-2-exchange-交换器"> 1.2.2 Exchange(交换器)</h4>
<p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，<strong>Exchange(交换器)</strong> 会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong> 中。</p>
<p><strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。</p>
<p><strong>RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略</strong>：<strong>direct(默认)</strong>，<strong>fanout</strong>, <strong>topic</strong>, 和 <strong>headers</strong>，不同类型的Exchange转发消息的策略有所区别。这个会在介绍 <strong>Exchange Types(交换器类型)</strong> 的时候介绍到。</p>
<p>Exchange(交换器) 示意图如下：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/24007899.jpg" alt="Exchange(交换器) 示意图" /></p>
<p>生产者将消息发给交换器的时候，一般会指定一个 <strong>RoutingKey(路由键)</strong>，用来指定这个消息的路由规则，而这个 <strong>RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效</strong>。</p>
<p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</p>
<p>Binding(绑定) 示意图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/70553134.jpg" alt="Binding(绑定) 示意图" /></p>
<p>生产者将消息发送给交换器时，需要一个RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p>
<h4 id="_1-2-3-queue-消息队列"> 1.2.3 Queue(消息队列)</h4>
<p><strong>Queue(消息队列)</strong> 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>
<p><strong>RabbitMQ</strong> 中消息只能存储在 <strong>队列</strong> 中，这一点和 <strong>Kafka</strong> 这种消息中间件相反。Kafka 将消息存储在 <strong>topic（主题）</strong> 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。</p>
<p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。</p>
<p><strong>RabbitMQ</strong> 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p>
<h4 id="_1-2-4-broker-消息中间件的服务节点"> 1.2.4 Broker（消息中间件的服务节点）</h4>
<p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p>
<p>下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从Broker中消费数据的整个流程。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/67952922.jpg" alt="消息队列的运转过程" /></p>
<p>这样图1中的一些关于 RabbitMQ 的基本概念我们就介绍完毕了，下面再来介绍一下 <strong>Exchange Types(交换器类型)</strong> 。</p>
<h4 id="_1-2-5-exchange-types-交换器类型"> 1.2.5 Exchange Types(交换器类型)</h4>
<p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种（AMQP规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。</p>
<h5 id="_1-fanout"> ① fanout</h5>
<p>fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</p>
<h5 id="_2-direct"> ② direct</h5>
<p>direct 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/37008021.jpg" alt="direct 类型交换器" /></p>
<p>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为&quot;Info”或者&quot;debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p>
<p>direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p>
<h5 id="_3-topic"> ③ topic</h5>
<p>前面讲到direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p>
<ul>
<li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li>
<li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li>
<li>BindingKey 中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li>
</ul>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/73843.jpg" alt="topic 类型交换器" /></p>
<p>以上图为例：</p>
<ul>
<li>路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queue1 和 Queue2;</li>
<li>路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；</li>
<li>路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；</li>
<li>路由键为 “java.rabbitmq.demo” 的消息只会路由到 Queue1 中；</li>
<li>路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。</li>
</ul>
<h5 id="_4-headers-不推荐"> ④ headers(不推荐)</h5>
<p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p>
<h2 id="二-安装-rabbitmq"> 二 安装 RabbitMQ</h2>
<p>通过 Docker 安装非常方便，只需要几条命令就好了，我这里是只说一下常规安装方法。</p>
<p>前面提到了 RabbitMQ 是由 Erlang语言编写的，也正因如此，在安装RabbitMQ 之前需要安装 Erlang。</p>
<p>注意：在安装 RabbitMQ 的时候需要注意 RabbitMQ 和 Erlang 的版本关系，如果不注意的话会导致出错，两者对应关系如下:</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RabbitMQ-Erlang.png" alt="RabbitMQ 和 Erlang 的版本关系" /></p>
<h3 id="_2-1-安装-erlang"> 2.1 安装 erlang</h3>
<p><strong>1 下载 erlang 安装包</strong></p>
<p>在官网下载然后上传到 Linux 上或者直接使用下面的命令下载对应的版本。</p>
<div><pre><code><span>[</span>root@SnailClimb local<span>]</span><span>#wget https://erlang.org/download/otp_src_19.3.tar.gz</span>
</code></pre>
<div><span>1</span><br></div></div><p>erlang 官网下载：<a href="https://www.erlang.org/downloads" target="_blank" rel="noopener noreferrer">https://www.erlang.org/downloads</a></p>
<p><strong>2 解压 erlang 安装包</strong></p>
<div><pre><code><span>[</span>root@SnailClimb local<span>]</span><span>#tar -xvzf otp_src_19.3.tar.gz</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>3 删除 erlang 安装包</strong></p>
<div><pre><code><span>[</span>root@SnailClimb local<span>]</span><span>#rm -rf otp_src_19.3.tar.gz</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>4 安装 erlang 的依赖工具</strong></p>
<div><pre><code><span>[</span>root@SnailClimb local<span>]</span><span>#yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC-devel</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>5 进入erlang 安装包解压文件对 erlang 进行安装环境的配置</strong></p>
<p>新建一个文件夹</p>
<div><pre><code><span>[</span>root@SnailClimb local<span>]</span><span># mkdir erlang</span>
</code></pre>
<div><span>1</span><br></div></div><p>对 erlang 进行安装环境的配置</p>
<div><pre><code><span>[</span>root@SnailClimb otp_src_19.3<span>]</span><span># </span>
./configure --prefix<span>=</span>/usr/local/erlang --without-javac
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>6 编译安装</strong></p>
<div><pre><code><span>[</span>root@SnailClimb otp_src_19.3<span>]</span><span># </span>
<span>make</span> <span>&amp;&amp;</span> <span>make</span> <span>install</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>7 验证一下 erlang 是否安装成功了</strong></p>
<div><pre><code><span>[</span>root@SnailClimb otp_src_19.3<span>]</span><span># ./bin/erl</span>
</code></pre>
<div><span>1</span><br></div></div><p>运行下面的语句输出“hello world”</p>
<div><pre><code> <span>io</span><span>:</span><span>format</span><span>(</span><span>"hello world~n"</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-12/49570541.jpg" alt="输出“hello world”" /></p>
<p>大功告成，我们的 erlang 已经安装完成。</p>
<p><strong>8 配置  erlang 环境变量</strong></p>
<div><pre><code><span>[</span>root@SnailClimb etc<span>]</span><span># vim profile</span>
</code></pre>
<div><span>1</span><br></div></div><p>追加下列环境变量到文件末尾</p>
<div><pre><code><span>#erlang</span>
<span>ERL_HOME</span><span>=</span>/usr/local/erlang
<span><span>PATH</span></span><span>=</span><span>$ERL_HOME</span>/bin:<span>$PATH</span>
<span>export</span> ERL_HOME <span>PATH</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>运行下列命令使配置文件<code>profile</code>生效</p>
<div><pre><code><span>[</span>root@SnailClimb etc<span>]</span><span># source /etc/profile</span>
</code></pre>
<div><span>1</span><br></div></div><p>输入 erl 查看 erlang 环境变量是否配置正确</p>
<div><pre><code><span>[</span>root@SnailClimb etc<span>]</span><span># erl</span>
</code></pre>
<div><span>1</span><br></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-12/62504246.jpg" alt="输入 erl 查看 erlang 环境变量是否配置正确" /></p>
<h3 id="_2-2-安装-rabbitmq"> 2.2 安装 RabbitMQ</h3>
<p><strong>1. 下载rpm</strong></p>
<div><pre><code><span>wget</span> https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.8/rabbitmq-server-3.6.8-1.el7.noarch.rpm
</code></pre>
<div><span>1</span><br></div></div><p>或者直接在官网下载</p>
<p><a href="https://www.rabbitmq.com/install-rpm.html" target="_blank" rel="noopener noreferrer">https://www.rabbitmq.com/install-rpm.html</a></p>
<p><strong>2. 安装rpm</strong></p>
<div><pre><code><span>rpm</span> --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc
</code></pre>
<div><span>1</span><br></div></div><p>紧接着执行：</p>
<div><pre><code>yum <span>install</span> rabbitmq-server-3.6.8-1.el7.noarch.rpm
</code></pre>
<div><span>1</span><br></div></div><p>中途需要你输入&quot;y&quot;才能继续安装。</p>
<p><strong>3 开启 web 管理插件</strong></p>
<div><pre><code>rabbitmq-plugins <span>enable</span> rabbitmq_management
</code></pre>
<div><span>1</span><br></div></div><p><strong>4 设置开机启动</strong></p>
<div><pre><code><span>chkconfig</span> rabbitmq-server on
</code></pre>
<div><span>1</span><br></div></div><p><strong>5. 启动服务</strong></p>
<div><pre><code><span>service</span> rabbitmq-server start
</code></pre>
<div><span>1</span><br></div></div><p><strong>6. 查看服务状态</strong></p>
<div><pre><code><span>service</span> rabbitmq-server status
</code></pre>
<div><span>1</span><br></div></div><p><strong>7. 访问 RabbitMQ 控制台</strong></p>
<p>浏览器访问：http://你的ip地址:15672/</p>
<p>默认用户名和密码：guest/guest; 但是需要注意的是：guest用户只是被容许从localhost访问。官网文档描述如下：</p>
<div><pre><code>“guest” user can only connect via localhost
</code></pre>
<div><span>1</span><br></div></div><p><strong>解决远程访问 RabbitMQ 远程访问密码错误</strong></p>
<p>新建用户并授权</p>
<div><pre><code><span>[</span>root@SnailClimb rabbitmq<span>]</span><span># rabbitmqctl add_user root root</span>
Creating user <span>"root"</span> <span>..</span>.
<span>[</span>root@SnailClimb rabbitmq<span>]</span><span># rabbitmqctl set_user_tags root administrator</span>

Setting tags <span>for</span> user <span>"root"</span> to <span>[</span>administrator<span>]</span> <span>..</span>.
<span>[</span>root@SnailClimb rabbitmq<span>]</span><span># </span>
<span>[</span>root@SnailClimb rabbitmq<span>]</span><span># rabbitmqctl set_permissions -p / root ".*" ".*" ".*"</span>
Setting permissions <span>for</span> user <span>"root"</span> <span>in</span> vhost <span>"/"</span> <span>..</span>.

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>再次访问:http://你的ip地址:15672/ ,输入用户名和密码：root root</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-12/45835332.jpg" alt="RabbitMQ控制台" /></p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/96388546.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>RocketMQ入门总结</title>
      <link>https://javaguide.cn/high-performance/message-queue/rocketmq-intro/</link>
      <guid>https://javaguide.cn/high-performance/message-queue/rocketmq-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">RocketMQ入门总结</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="rocketmq入门总结"> RocketMQ入门总结</h1>
<blockquote>
<p>文章很长，点赞再看，养成好习惯😋😋😋</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485969&amp;idx=1&amp;sn=6bd53abde30d42a778d5a35ec104428c&amp;chksm=cea245daf9d5cccce631f93115f0c2c4a7634e55f5bef9009fd03f5a0ffa55b745b5ef4f0530&amp;token=294077121&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">本文由 FrancisQ 老哥投稿！</a></p>
</blockquote>
<h2 id="消息队列扫盲"> 消息队列扫盲</h2>
<p>消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道是啥吧？</p>
<p>所以问题并不是消息队列是什么，而是 <strong>消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？</strong></p>
<h3 id="消息队列为什么会出现"> 消息队列为什么会出现？</h3>
<p>消息队列算是作为后端程序员的一个必备技能吧，因为<strong>分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。</p>
<h3 id="消息队列能用来干什么"> 消息队列能用来干什么？</h3>
<h4 id="异步"> 异步</h4>
<p>你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？</p>
<p>很好👍，你又提出了一个概念，<strong>同步通信</strong>。就比如现在业界使用比较多的 <code>Dubbo</code> 就是一个适用于各个系统之间同步通信的 <code>RPC</code> 框架。</p>
<p>我来举个🌰吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef37fee7e09230.jpg" alt="" /></p>
<p>我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。</p>
<p>当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短信系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 <strong>头重脚轻</strong> 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef380429cf373e.jpg" alt="" /></p>
<p>这样整个系统的调用链又变长了，整个时间就变成了550ms。</p>
<p>当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。</p>
<p>我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦😋😋😋”  咦~~~ 为了多吃点，真恶心。</p>
<p>然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。</p>
<p>最终我们从大妈手中接过饭菜然后去寻找座位了...</p>
<p>回想一下，我们在给大妈发送需要的信息之后我们是 <strong>同步等待大妈给我配好饭菜</strong> 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/006APoFYly1fvd9cwjlfrj30as0b03ym.jpg" alt="" /></p>
<p>那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 <strong>(传达一个消息)</strong> ，然后我们就可以在饭桌上安心的玩手机了 <strong>(干自己其他事情)</strong> ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以干其他事情了，这是一个 <strong>异步</strong> 的概念。</p>
<p>所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38124f55eaea.jpg" alt="" /></p>
<p>这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 150ms + 10ms = 160ms。</p>
<blockquote>
<p>但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。</p>
</blockquote>
<h4 id="解耦"> 解耦</h4>
<p>回到最初同步调用的过程，我们写个伪代码简单概括一下。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef381a505d3e1f.jpg" alt="" /></p>
<p>那么第二步，我们又添加了一个发送邮件，我们就得重新去修改代码，如果我们又加一个需求：用户购买完还需要给他加积分，这个时候我们是不是又得改代码？</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef381c4e1b1ac7.jpg" alt="" /></p>
<p>如果你觉得还行，那么我这个时候不要发邮件这个服务了呢，我是不是又得改代码，又得重启应用？</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef381f273a66bd.jpg" alt="" /></p>
<p>这样改来改去是不是很麻烦，那么 <strong>此时我们就用一个消息队列在中间进行解耦</strong> 。你需要注意的是，我们后面的发送短信、发送邮件、添加积分等一些操作都依赖于上面的 <code>result</code> ，这东西抽象出来就是购票的处理结果呀，比如订单号，用户账号等等，也就是说我们后面的一系列服务都是需要同样的消息来进行处理。既然这样，我们是不是可以通过 <strong>“广播消息”</strong> 来实现。</p>
<p>我上面所讲的“广播”并不是真正的广播，而是接下来的系统作为消费者去 <strong>订阅</strong> 特定的主题。比如我们这里的主题就可以叫做 <code>订票</code> ，我们购买系统作为一个生产者去生产这条消息放入消息队列，然后消费者订阅了这个主题，会从消息队列中拉取消息并消费。就比如我们刚刚画的那张图，你会发现，在生产者这边我们只需要关注 <strong>生产消息到指定主题中</strong> ，而 <strong>消费者只需要关注从指定主题中拉取消息</strong> 就行了。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef382674b66892.jpg" alt="" /></p>
<blockquote>
<p>如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。</p>
</blockquote>
<h4 id="削峰"> 削峰</h4>
<p>我们再次回到一开始我们使用同步调用系统的情况，并且思考一下，如果此时有大量用户请求购票整个系统会变成什么样？</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef382a9756bb1c.jpg" alt="" /></p>
<p>如果，此时有一万的请求进入购票系统，我们知道运行我们主业务的服务器配置一般会比较好，所以这里我们假设购票系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而对于短信系统来说并不是我们的主要业务，所以我们配备的硬件资源并不会太高，那么你觉得现在这个短信系统能承受这一万的峰值么，且不说能不能承受，系统会不会 <strong>直接崩溃</strong> 了？</p>
<p>短信业务又不是我们的主业务，我们能不能 <strong>折中处理</strong> 呢？如果我们把购买完成的信息发送到消息队列中，而短信系统 <strong>尽自己所能地去消息队列中取消息和消费消息</strong> ，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。</p>
<p>留得江山在，还怕没柴烧？你敢说每次发送验证码的时候是一发你就收到了的么？</p>
<h4 id="消息队列能带来什么好处"> 消息队列能带来什么好处？</h4>
<p>其实上面我已经说了。<strong>异步、解耦、削峰。</strong> 哪怕你上面的都没看懂也千万要记住这六个字，因为他不仅是消息队列的精华，更是编程和架构的精华。</p>
<h4 id="消息队列会带来副作用吗"> 消息队列会带来副作用吗？</h4>
<p>没有哪一门技术是“银弹”，消息队列也有它的副作用。</p>
<p>比如，本来好好的两个系统之间的调用，我中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 <strong>降低了系统的可用性</strong> ？</p>
<p>那这样是不是要保证HA(高可用)？是不是要搞集群？那么我 <strong>整个系统的复杂度是不是上升了</strong> ？</p>
<p>抛开上面的问题不讲，万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。</p>
<p>或者我消费端处理失败了，请求重发，这样也会产生重复的消息。</p>
<p>对于一些微服务来说，消费重复消息会带来更大的麻烦，比如增加积分，这个时候我加了多次是不是对其他用户不公平？</p>
<p>那么，又 <strong>如何解决重复消费消息的问题</strong> 呢？</p>
<p>如果我们此时的消息需要保证严格的顺序性怎么办呢？比如生产者生产了一系列的有序消息(对一个id为1的记录进行删除增加修改)，但是我们知道在发布订阅模型中，对于主题是无顺序的，那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费，比如这个时候我们消费的顺序为修改删除增加，如果该记录涉及到金额的话是不是会出大事情？</p>
<p>那么，又 <strong>如何解决消息的顺序消费问题</strong> 呢？</p>
<p>就拿我们上面所讲的分布式系统来说，用户购票完成之后是不是需要增加账户积分？在同一个系统中我们一般会使用事务来进行解决，如果用 <code>Spring</code> 的话我们在上面伪代码中加入 <code>@Transactional</code> 注解就好了。但是在不同系统中如何保证事务呢？总不能这个系统我扣钱成功了你那积分系统积分没加吧？或者说我这扣钱明明失败了，你那积分系统给我加了积分。</p>
<p>那么，又如何 <strong>解决分布式事务问题</strong> 呢？</p>
<p>我们刚刚说了，消息队列可以进行削峰操作，那如果我的消费者如果消费很慢或者生产者生产消息很快，这样是不是会将消息堆积在消息队列中？</p>
<p>那么，又如何 <strong>解决消息堆积的问题</strong> 呢？</p>
<p>可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题，这消息队列还怎么用啊😵？</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef382d709abc9d.png" alt="" /></p>
<p>别急，办法总是有的。</p>
<h2 id="rocketmq是什么"> RocketMQ是什么？</h2>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef383014430799.jpg" alt="" /></p>
<p>哇，你个混蛋！上面给我抛出那么多问题，你现在又讲 <code>RocketMQ</code> ，还让不让人活了？！🤬</p>
<p>别急别急，话说你现在清楚 <code>MQ</code> 的构造吗，我还没讲呢，我们先搞明白 <code>MQ</code> 的内部构造，再来看看如何解决上面的一系列问题吧，不过你最好带着问题去阅读和了解喔。</p>
<p><code>RocketMQ</code> 是一个 <strong>队列模型</strong> 的消息中间件，具有<strong>高性能、高可靠、高实时、分布式</strong> 的特点。它是一个采用 <code>Java</code> 语言开发的分布式的消息系统，由阿里巴巴团队开发，在2016年底贡献给 <code>Apache</code>，成为了 <code>Apache</code> 的一个顶级项目。 在阿里内部，<code>RocketMQ</code> 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 <code>RocketMQ</code> 流转。</p>
<p>废话不多说，想要了解 <code>RocketMQ</code> 历史的同学可以自己去搜寻资料。听完上面的介绍，你只要知道 <code>RocketMQ</code> 很快、很牛、而且经历过双十一的实践就行了！</p>
<h2 id="队列模型和主题模型"> 队列模型和主题模型</h2>
<p>在谈 <code>RocketMQ</code> 的技术架构之前，我们先来了解一下两个名词概念——<strong>队列模型</strong> 和 <strong>主题模型</strong> 。</p>
<p>首先我问一个问题，消息队列为什么要叫消息队列？</p>
<p>你可能觉得很弱智，这玩意不就是存放消息的队列嘛？不叫消息队列叫什么？</p>
<p>的确，早期的消息中间件是通过 <strong>队列</strong> 这一模型来实现的，可能是历史原因，我们都习惯把消息中间件成为消息队列。</p>
<p>但是，如今例如 <code>RocketMQ</code> 、<code>Kafka</code> 这些优秀的消息中间件不仅仅是通过一个 <strong>队列</strong> 来实现消息存储的。</p>
<h3 id="队列模型"> 队列模型</h3>
<p>就像我们理解队列一样，消息中间件的队列模型就真的只是一个队列。。。我画一张图给大家理解。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3834ae653469.jpg" alt="" /></p>
<p>在一开始我跟你提到了一个 <strong>“广播”</strong> 的概念，也就是说如果我们此时我们需要将一个消息发送给多个消费者(比如此时我需要将信息发送给短信系统和邮件系统)，这个时候单个队列即不能满足需求了。</p>
<p>当然你可以让 <code>Producer</code> 生产消息放入多个队列中，然后每个队列去对应每一个消费者。问题是可以解决，创建多个队列并且复制多份消息是会很影响资源和性能的。而且，这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列，这就违背我们消息中间件的 <strong>解耦</strong> 这一原则。</p>
<h3 id="主题模型"> 主题模型</h3>
<p>那么有没有好的方法去解决这一个问题呢？有，那就是 <strong>主题模型</strong> 或者可以称为 <strong>发布订阅模型</strong> 。</p>
<blockquote>
<p>感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下，我相信你会有所收获的。</p>
</blockquote>
<p>在主题模型中，消息的生产者称为 <strong>发布者(Publisher)</strong> ，消息的消费者称为 <strong>订阅者(Subscriber)</strong> ，存放消息的容器称为 <strong>主题(Topic)</strong> 。</p>
<p>其中，发布者将消息发送到指定主题中，订阅者需要 <strong>提前订阅主题</strong> 才能接受特定主题的消息。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3837887d9a54sds.jpg" alt="" /></p>
<h3 id="rocketmq中的消息模型"> RocketMQ中的消息模型</h3>
<p><code>RocketMQ</code> 中的消息模型就是按照 <strong>主题模型</strong> 所实现的。你可能会好奇这个 <strong>主题</strong> 到底是怎么实现的呢？你上面也没有讲到呀！</p>
<p>其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 <code>Kafka</code> 中的 <strong>分区</strong> ，<code>RocketMQ</code> 中的 <strong>队列</strong> ，<code>RabbitMQ</code> 中的 <code>Exchange</code> 。我们可以理解为 <strong>主题模型/发布订阅模型</strong> 就是一个标准，那些中间件只不过照着这个标准去实现而已。</p>
<p>所以，<code>RocketMQ</code> 中的 <strong>主题模型</strong> 到底是如何实现的呢？首先我画一张图，大家尝试着去理解一下。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef383d3e8c9788.jpg" alt="" /></p>
<p>我们可以看到在整个图中有 <code>Producer Group</code> 、<code>Topic</code> 、<code>Consumer Group</code>  三个角色，我来分别介绍一下他们。</p>
<ul>
<li><code>Producer Group</code> 生产者组： 代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 <code>Producer Group</code> 生产者组，它们一般生产相同的消息。</li>
<li><code>Consumer Group</code> 消费者组： 代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 <code>Consumer Group</code> 消费者组，它们一般消费相同的消息。</li>
<li><code>Topic</code> 主题： 代表一类消息，比如订单消息，物流消息等等。</li>
</ul>
<p>你可以看到图中生产者组中的生产者会向主题发送消息，而 <strong>主题中存在多个队列</strong>，生产者每次生产消息之后是指定主题中的某个队列发送消息的。</p>
<p>每个主题中都有多个队列(分布在不同的 <code>Broker</code>中，如果是集群的话，<code>Broker</code>又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 <code>topic</code> 的多个队列，<strong>一个队列只会被一个消费者消费</strong>。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 <code>Consumer1</code> 和 <code>Consumer2</code> 分别对应着两个队列，而 <code>Consumer3</code> 是没有队列对应的，所以一般来讲要控制 <strong>消费者组中的消费者个数和主题中队列个数相同</strong> 。</p>
<p>当然也可以消费者个数小于队列个数，只不过不太建议。如下图。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3850c808d707.jpg" alt="" /></p>
<p><strong>每个消费组在每个队列上维护一个消费位置</strong> ，为什么呢？</p>
<p>因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 <strong>消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3857fefaa079.jpg" alt="" /></p>
<p>可能你还有一个问题，<strong>为什么一个主题中需要维护多个队列</strong> ？</p>
<p>答案是 <strong>提高并发能力</strong> 。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 <strong>发布订阅模式</strong> 。如下图。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38600cdb6d4b.jpg" alt="" /></p>
<p>但是，这样我生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 <code>Consumer</code> 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。</p>
<p>所以总结来说，<code>RocketMQ</code> 通过<strong>使用在一个 <code>Topic</code> 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了 <strong>主题模式/发布订阅模式</strong> 。</p>
<h2 id="rocketmq的架构图"> RocketMQ的架构图</h2>
<p>讲完了消息模型，我们理解起 <code>RocketMQ</code> 的技术架构起来就容易多了。</p>
<p><code>RocketMQ</code> 技术架构中有四大角色 <code>NameServer</code> 、<code>Broker</code> 、<code>Producer</code> 、<code>Consumer</code> 。我来向大家分别解释一下这四个角色是干啥的。</p>
<ul>
<li>
<p><code>Broker</code>： 主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 <code>Broker</code> ，消费者从 <code>Broker</code> 拉取消息并消费。</p>
<p>这里，我还得普及一下关于 <code>Broker</code> 、<code>Topic</code> 和 队列的关系。上面我讲解了 <code>Topic</code> 和队列的关系——一个 <code>Topic</code> 中存在多个队列，那么这个 <code>Topic</code> 和队列存放在哪呢？</p>
<p><strong>一个 <code>Topic</code> 分布在多个 <code>Broker</code>上，一个 <code>Broker</code> 可以配置多个 <code>Topic</code> ，它们是多对多的关系</strong>。</p>
<p>如果某个 <code>Topic</code> 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 <strong>尽量多分布在不同 <code>Broker</code> 上，以减轻某个 <code>Broker</code> 的压力</strong> 。</p>
<p><code>Topic</code> 消息量都比较均匀的情况下，如果某个 <code>broker</code> 上的队列越多，则该 <code>broker</code> 压力越大。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38687488a5a4.jpg" alt="" /></p>
<blockquote>
<p>所以说我们需要配置多个Broker。</p>
</blockquote>
</li>
<li>
<p><code>NameServer</code>： 不知道你们有没有接触过 <code>ZooKeeper</code> 和 <code>Spring Cloud</code> 中的 <code>Eureka</code> ，它其实也是一个 <strong>注册中心</strong> ，主要提供两个功能：<strong>Broker管理</strong> 和 <strong>路由信息管理</strong> 。说白了就是 <code>Broker</code> 会将自己的信息注册到 <code>NameServer</code> 中，此时 <code>NameServer</code> 就存放了很多 <code>Broker</code> 的信息(Broker的路由表)，消费者和生产者就从 <code>NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code>Broker</code> 进行通信(生产者和消费者定期会向 <code>NameServer</code> 去查询相关的 <code>Broker</code> 的信息)。</p>
</li>
<li>
<p><code>Producer</code>： 消息发布的角色，支持分布式集群方式部署。说白了就是生产者。</p>
</li>
<li>
<p><code>Consumer</code>： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。</p>
</li>
</ul>
<p>听完了上面的解释你可能会觉得，这玩意好简单。不就是这样的么？</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef386c6d1e8bdb.jpg" alt="" /></p>
<p>嗯？你可能会发现一个问题，这老家伙 <code>NameServer</code> 干啥用的，这不多余吗？直接 <code>Producer</code> 、<code>Consumer</code> 和 <code>Broker</code> 直接进行生产消息，消费消息不就好了么？</p>
<p>但是，我们上文提到过 <code>Broker</code> 是需要保证高可用的，如果整个系统仅仅靠着一个 <code>Broker</code> 来维持的话，那么这个 <code>Broker</code> 的压力会不会很大？所以我们需要使用多个 <code>Broker</code> 来保证 <strong>负载均衡</strong> 。</p>
<p>如果说，我们的消费者和生产者直接和多个 <code>Broker</code> 相连，那么当 <code>Broker</code> 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 <code>NameServer</code> 注册中心就是用来解决这个问题的。</p>
<blockquote>
<p>如果还不是很理解的话，可以去看我介绍 <code>Spring Cloud</code> 的那篇文章，其中介绍了 <code>Eureka</code> 注册中心。</p>
</blockquote>
<p>当然，<code>RocketMQ</code> 中的技术架构肯定不止前面那么简单，因为上面图中的四个角色都是需要做集群的。我给出一张官网的架构图，大家尝试理解一下。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef386fa3be1e53.jpg" alt="" /></p>
<p>其实和我们最开始画的那张乞丐版的架构图也没什么区别，主要是一些细节上的差别。听我细细道来🤨。</p>
<p>第一、我们的 <code>Broker</code> <strong>做了集群并且还进行了主从部署</strong> ，由于消息分布在各个 <code>Broker</code> 上，一旦某个 <code>Broker</code> 宕机，则该<code>Broker</code> 上的消息读写都会受到影响。所以 <code>Rocketmq</code> 提供了 <code>master/slave</code> 的结构，<code>salve</code> 定时从 <code>master</code> 同步数据(同步刷盘或者异步刷盘)，如果 <code>master</code> 宕机，<strong>则 <code>slave</code> 提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</p>
<p>第二、为了保证 <code>HA</code> ，我们的 <code>NameServer</code> 也做了集群部署，但是请注意它是 <strong>去中心化</strong> 的。也就意味着它没有主节点，你可以很明显地看出 <code>NameServer</code> 的所有节点是没有进行 <code>Info Replicate</code> 的，在 <code>RocketMQ</code> 中是通过 <strong>单个Broker和所有NameServer保持长连接</strong> ，并且在每隔30秒 <code>Broker</code> 会向所有 <code>Nameserver</code> 发送心跳，心跳包含了自身的 <code>Topic</code> 配置信息，这个步骤就对应这上面的 <code>Routing Info</code> 。</p>
<p>第三、在生产者需要向 <code>Broker</code> 发送消息的时候，<strong>需要先从 <code>NameServer</code> 获取关于 <code>Broker</code> 的路由信息</strong>，然后通过 <strong>轮询</strong> 的方法去向每个队列中生产数据以达到 <strong>负载均衡</strong> 的效果。</p>
<p>第四、消费者通过 <code>NameServer</code> 获取所有 <code>Broker</code> 的路由信息后，向 <code>Broker</code> 发送 <code>Pull</code> 请求来获取消息数据。<code>Consumer</code> 可以以两种模式启动—— <strong>广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p>
<h2 id="如何解决-顺序消费、重复消费"> 如何解决 顺序消费、重复消费</h2>
<p>其实，这些东西都是我在介绍消息队列带来的一些副作用的时候提到的，也就是说，这些问题不仅仅挂钩于 <code>RocketMQ</code> ，而是应该每个消息中间件都需要去解决的。</p>
<p>在上面我介绍 <code>RocketMQ</code> 的技术架构的时候我已经向你展示了 <strong>它是如何保证高可用的</strong> ，这里不涉及运维方面的搭建，如果你感兴趣可以自己去官网上照着例子搭建属于你自己的 <code>RocketMQ</code> 集群。</p>
<blockquote>
<p>其实 <code>Kafka</code> 的架构基本和 <code>RocketMQ</code> 类似，只是它注册中心使用了 <code>Zookeeper</code> 、它的 <strong>分区</strong> 就相当于 <code>RocketMQ</code> 中的 <strong>队列</strong> 。还有一些小细节不同会在后面提到。</p>
</blockquote>
<h3 id="顺序消费"> 顺序消费</h3>
<p>在上面的技术架构介绍中，我们已经知道了 <strong><code>RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序</strong> 的。</p>
<p>这又扯到两个概念——<strong>普通顺序</strong> 和 <strong>严格顺序</strong> 。</p>
<p>所谓普通顺序是指 消费者通过 <strong>同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code>Broker</code> <strong>重启情况下不会保证消息顺序性</strong> (短暂时间) 。</p>
<p>所谓严格顺序是指  消费者收到的 <strong>所有消息</strong> 均是有顺序的。严格顺序消息 <strong>即使在异常情况下也会保证消息的顺序性</strong> 。</p>
<p>但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，<code>Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 <code>binlog</code> 同步。</p>
<p>一般而言，我们的 <code>MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p>
<p>那么，我们现在使用了 <strong>普通顺序模式</strong> ，我们从上面学习知道了在 <code>Producer</code> 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 <strong>三个消息会被发送到不同队列</strong> ，因为在不同的队列此时就无法使用 <code>RocketMQ</code> 带来的队列有序特性来保证消息有序性了。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3874585e096e.jpg" alt="" /></p>
<p>那么，怎么解决呢？</p>
<p>其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 <strong>Hash取模法</strong> 来保证同一个订单在同一个队列中就行了。</p>
<h3 id="重复消费"> 重复消费</h3>
<p>emmm，就两个字—— <strong>幂等</strong> 。在编程中一个<em>幂等</em> 操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如说，这个时候我们有一个订单的处理积分的系统，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动(当然还有很多种情况，比如Broker意外重启等等)，这条回应没有发送成功。</p>
<p>那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p>
<p>所以我们需要给我们的消费者实现 <strong>幂等</strong> ，也就是对同一个消息的处理结果，执行多少次都不变。</p>
<p>那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 <strong>写入 <code>Redis</code></strong> 来保证，因为 <code>Redis</code> 的 <code>key</code> 和 <code>value</code> 就是天然支持幂等的。当然还有使用 <strong>数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</p>
<p>不过最主要的还是需要 <strong>根据特定场景使用特定的解决方案</strong> ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p>
<p>而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，<strong>在其他场景中来解决重复请求或者重复调用的问题</strong> 。比如将HTTP服务设计成幂等的，<strong>解决前端或者APP重复提交表单数据的问题</strong> ，也可以将一个微服务设计成幂等的，解决 <code>RPC</code> 框架自动重试导致的 <strong>重复调用问题</strong> 。</p>
<h2 id="分布式事务"> 分布式事务</h2>
<p>如何解释分布式事务呢？事务大家都知道吧？<strong>要么都执行要么都不执行</strong> 。在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现A系统下了订单，但是B系统增加积分失败或者A系统没有下订单，B系统却增加了积分。前者对用户不友好，后者对运营商不利，这是我们都不愿意见到的。</p>
<p>那么，如何去解决这个问题呢？</p>
<p>如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，<strong>都不是完美的解决方案</strong>。</p>
<p>在 <code>RocketMQ</code> 中使用的是 <strong>事务消息加上事务反查机制</strong> 来解决分布式事务问题的。我画了张图，大家可以对照着图进行理解。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38798d7a987f.png" alt="" /></p>
<p>在第一步发送的 half 消息 ，它的意思是 <strong>在事务提交之前，对于消费者来说，这个消息是不可见的</strong> 。</p>
<blockquote>
<p>那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后 <strong>改变主题</strong> 为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，<strong>然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费</strong>，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>
</blockquote>
<p>你可以试想一下，如果没有从第5步开始的 <strong>事务反查机制</strong> ，如果出现网路波动第4步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 <code>RocketMQ</code> 中就是使用的上述的事务反查来解决的，而在 <code>Kafka</code> 中通常是直接抛出一个异常让用户来自行解决。</p>
<p>你还需要注意的是，在 <code>MQ Server</code> 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——<strong>本地事务和存储消息到消息队列才是同一个事务</strong>。这样也就产生了事务的<strong>最终一致性</strong>，因为整个过程是异步的，<strong>每个系统只要保证它自己那一部分的事务就行了</strong>。</p>
<h2 id="消息堆积问题"> 消息堆积问题</h2>
<p>在上面我们提到了消息队列一个很重要的功能——<strong>削峰</strong> 。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p>
<p>其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。</p>
<p>我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 <strong>限流降级</strong> 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 <strong>是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。</p>
<blockquote>
<p>当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 <strong>同时你还需要增加每个主题的队列数量</strong> 。</p>
<p>别忘了在 <code>RocketMQ</code> 中，<strong>一个队列只会被一个消费者消费</strong> ，如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef387d939ab66d.jpg" alt="" /></p>
<h2 id="回溯消费"> 回溯消费</h2>
<p>回溯消费是指 <code>Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费，在<code>RocketMQ</code> 中， <code>Broker</code> 在向<code>Consumer</code> 投递成功消息后，<strong>消息仍然需要保留</strong> 。并且重新消费一般是按照时间维度，例如由于 <code>Consumer</code> 系统故障，恢复后需要重新消费1小时前的数据，那么 <code>Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。<code>RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p>
<p>这是官方文档的解释，我直接照搬过来就当科普了😁😁😁。</p>
<h2 id="rocketmq-的刷盘机制"> RocketMQ 的刷盘机制</h2>
<p>上面我讲了那么多的 <code>RocketMQ</code> 的架构和设计原理，你有没有好奇</p>
<p>在 <code>Topic</code> 中的 <strong>队列是以什么样的形式存在的？</strong></p>
<p><strong>队列中的消息又是如何进行存储持久化的呢？</strong></p>
<p>我在上文中提到的 <strong>同步刷盘</strong> 和 <strong>异步刷盘</strong> 又是什么呢？它们会给持久化带来什么样的影响呢？</p>
<p>下面我将给你们一一解释。</p>
<h3 id="同步刷盘和异步刷盘"> 同步刷盘和异步刷盘</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef387fba311cda.jpg" alt="" /></p>
<p>如上图所示，在同步刷盘中需要等待一个刷盘成功的 <code>ACK</code> ，同步刷盘对 <code>MQ</code> 消息可靠性来说是一种不错的保障，但是 <strong>性能上会有较大影响</strong> ，一般地适用于金融等特定业务场景。</p>
<p>而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， <strong>降低了读写延迟</strong> ，提高了 <code>MQ</code> 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。</p>
<p>一般地，<strong>异步刷盘只有在 <code>Broker</code> 意外宕机的时候会丢失部分数据</strong>，你可以设置 <code>Broker</code> 的参数 <code>FlushDiskType</code> 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。</p>
<h3 id="同步复制和异步复制"> 同步复制和异步复制</h3>
<p>上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 <code>Borker</code> 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。</p>
<ul>
<li>同步复制： 也叫 “同步双写”，也就是说，<strong>只有消息同步双写到主从结点上时才返回写入成功</strong> 。</li>
<li>异步复制： <strong>消息写入主节点之后就直接返回写入成功</strong> 。</li>
</ul>
<p>然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p>
<p>那么，<strong>异步复制会不会也像异步刷盘那样影响消息的可靠性呢？</strong></p>
<p>答案是不会的，因为两者就是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略仅仅是影响到了 <strong>可用性</strong> 。为什么呢？其主要原因<strong>是 <code>RocketMQ</code> 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了</strong>。</p>
<p>比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong>消费者可以自动切换到从节点进行消费</strong>(仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p>
<p>在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong>一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个 <code>Topic</code> 是分布在不同 <code>Broker</code> 中的。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38687488a5a4.jpg" alt="" /></p>
<p>但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong>严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 <code>Topic</code> 下的队列来保证顺序性的。如果此时我们主节点A负责的是订单A的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点A的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p>
<p>而在 <code>RocketMQ</code> 中采用了 <code>Dledger</code> 解决这个问题。他要求在写入消息的时候，要求<strong>至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p>
<blockquote>
<p>也不是说 <code>Dledger</code> 是个完美的方案，至少在 <code>Dledger</code> 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制半数以上节点的效率和直接异步复制还是有一定的差距的。</p>
</blockquote>
<h3 id="存储机制"> 存储机制</h3>
<p>还记得上面我们一开始的三个问题吗？到这里第三个问题已经解决了。</p>
<p>但是，在 <code>Topic</code> 中的 <strong>队列是以什么样的形式存在的？队列中的消息又是如何进行存储持久化的呢？</strong> 还未解决，其实这里涉及到了 <code>RocketMQ</code> 是如何设计它的存储结构了。我首先想大家介绍 <code>RocketMQ</code> 消息存储架构中的三大角色——<code>CommitLog</code> 、<code>ConsumeQueue</code> 和 <code>IndexFile</code> 。</p>
<ul>
<li><code>CommitLog</code>： <strong>消息主体以及元数据的存储主体</strong>，存储 <code>Producer</code> 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是<strong>顺序写入日志文件</strong>，当文件满了，写入下一个文件。</li>
<li><code>ConsumeQueue</code>： 消息消费队列，<strong>引入的目的主要是提高消息消费的性能</strong>(我们再前面也讲了)，由于<code>RocketMQ</code> 是基于主题 <code>Topic</code> 的订阅模式，消息消费是针对主题进行的，如果要遍历 <code>commitlog</code> 文件中根据 <code>Topic</code> 检索消息是非常低效的。<code>Consumer</code> 即可根据 <code>ConsumeQueue</code> 来查找待消费的消息。其中，<code>ConsumeQueue</code>（逻辑消费队列）<strong>作为消费消息的索引</strong>，保存了指定 <code>Topic</code> 下的队列消息在 <code>CommitLog</code> 中的<strong>起始物理偏移量 <code>offset</code> <strong>，消息大小 <code>size</code> 和消息 <code>Tag</code> 的 <code>HashCode</code> 值。</strong><code>consumequeue</code> 文件可以看成是基于 <code>topic</code> 的 <code>commitlog</code> 索引文件</strong>，故 <code>consumequeue</code> 文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 <code>consumequeue</code> 文件采取定长设计，每一个条目共20个字节，分别为8字节的 <code>commitlog</code> 物理偏移量、4字节的消息长度、8字节tag <code>hashcode</code>，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个 <code>ConsumeQueue</code>文件大小约5.72M；</li>
<li><code>IndexFile</code>： <code>IndexFile</code>（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。这里只做科普不做详细介绍。</li>
</ul>
<p>总结来说，整个消息存储的结构，最主要的就是 <code>CommitLoq</code> 和 <code>ConsumeQueue</code> 。而 <code>ConsumeQueue</code> 你可以大概理解为 <code>Topic</code> 中的队列。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3884c02acc72.png" alt="" /></p>
<p><code>RocketMQ</code> 采用的是 <strong>混合型的存储结构</strong> ，即为 <code>Broker</code> 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 <code>Kafka</code> 中会为每个 <code>Topic</code> 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，<code>RockeMQ</code> 是不分书的种类直接成批的塞上去的，而 <code>Kafka</code> 是将书本放入指定的分类区域的。</p>
<p>而 <code>RocketMQ</code> 为什么要这么做呢？原因是 <strong>提高数据的写入效率</strong> ，不分 <code>Topic</code> 意味着我们有更大的几率获取 <strong>成批</strong> 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。</p>
<p>所以，在 <code>RocketMQ</code> 中又使用了 <code>ConsumeQueue</code> 作为每个队列的索引文件来 <strong>提升读取消息的效率</strong>。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。</p>
<p>讲到这里，你可能对 <code>RockeMQ</code> 的存储架构还有些模糊，没事，我们结合着图来理解一下。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef388763c25c62.jpg" alt="" /></p>
<p>emmm，是不是有一点复杂🤣，看英文图片和英文文档的时候就不要怂，硬着头皮往下看就行。</p>
<blockquote>
<p>如果上面没看懂的读者一定要认真看下面的流程分析！</p>
</blockquote>
<p>首先，在最上面的那一块就是我刚刚讲的你现在可以直接 <strong>把 <code>ConsumerQueue</code> 理解为 <code>Queue</code></strong>。</p>
<p>在图中最左边说明了 <font color = red>红色方块 </font> 代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 <code>Topic</code> 、<code>QueueId</code> 和具体消息内容，而在 <code>Broker</code> 中管你是哪门子消息，他直接 <strong>全部顺序存储到了 CommitLog</strong>。而根据生产者指定的 <code>Topic</code> 和 <code>QueueId</code> 将这条消息本身在 <code>CommitLog</code> 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 <code>ConsumeQueue</code> 索引文件中。而在每个队列中都保存了 <code>ConsumeOffset</code> 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 <code>ConsumeOffset</code> 获取下一个未被消费的消息就行了。</p>
<p>上述就是我对于整个消息存储架构的大概理解(这里不涉及到一些细节讨论，比如稀疏索引等等问题)，希望对你有帮助。</p>
<p>因为有一个知识点因为写嗨了忘讲了，想想在哪里加也不好，所以我留给大家去思考🤔🤔一下吧。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/e314ee45gy1g05zgr67bbj20gp0b3aba.jpg" alt="" /></p>
<p>为什么 <code>CommitLog</code> 文件要设计成固定大小的长度呢？提醒：<strong>内存映射机制</strong>。</p>
<h2 id="总结"> 总结</h2>
<p>总算把这篇博客写完了。我讲的你们还记得吗😅？</p>
<p>这篇文章中我主要想大家介绍了</p>
<ol>
<li>消息队列出现的原因</li>
<li>消息队列的作用(异步，解耦，削峰)</li>
<li>消息队列带来的一系列问题(消息堆积、重复消费、顺序消费、分布式事务等等)</li>
<li>消息队列的两种消息模型——队列和主题模式</li>
<li>分析了 <code>RocketMQ</code> 的技术架构(<code>NameServer</code> 、<code>Broker</code> 、<code>Producer</code> 、<code>Comsumer</code>)</li>
<li>结合 <code>RocketMQ</code> 回答了消息队列副作用的解决方案</li>
<li>介绍了 <code>RocketMQ</code> 的存储机制和刷盘策略。</li>
</ol>
<p>等等。。。</p>
<blockquote>
<p>如果喜欢可以点赞哟👍👍👍。</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef37fee7e09230.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>RocketMQ常见问题</title>
      <link>https://javaguide.cn/high-performance/message-queue/rocketmq-questions/</link>
      <guid>https://javaguide.cn/high-performance/message-queue/rocketmq-questions/</guid>
      <source url="https://javaguide.cn/rss.xml">RocketMQ常见问题</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="rocketmq常见问题"> RocketMQ常见问题</h1>
<p>本文来自读者 <a href="https://github.com/Snailclimb/JavaGuide/pull/291" target="_blank" rel="noopener noreferrer">PR</a>。</p>
<h2 id="_1-单机版消息中心"> 1 单机版消息中心</h2>
<p>一个消息中心，最基本的需要支持多生产者、多消费者，例如下：</p>
<div><pre><code><span>class</span> <span>Scratch</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 实际中会有 nameserver 服务来找到 broker 具体位置以及 broker 主从信息</span>
        <span>Broker</span> broker <span>=</span> <span>new</span> <span>Broker</span><span>(</span><span>)</span><span>;</span>
        <span>Producer</span> producer1 <span>=</span> <span>new</span> <span>Producer</span><span>(</span><span>)</span><span>;</span>
        producer1<span>.</span><span>connectBroker</span><span>(</span>broker<span>)</span><span>;</span>
        <span>Producer</span> producer2 <span>=</span> <span>new</span> <span>Producer</span><span>(</span><span>)</span><span>;</span>
        producer2<span>.</span><span>connectBroker</span><span>(</span>broker<span>)</span><span>;</span>

        <span>Consumer</span> consumer1 <span>=</span> <span>new</span> <span>Consumer</span><span>(</span><span>)</span><span>;</span>
        consumer1<span>.</span><span>connectBroker</span><span>(</span>broker<span>)</span><span>;</span>
        <span>Consumer</span> consumer2 <span>=</span> <span>new</span> <span>Consumer</span><span>(</span><span>)</span><span>;</span>
        consumer2<span>.</span><span>connectBroker</span><span>(</span>broker<span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>2</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            producer1<span>.</span><span>asyncSendMsg</span><span>(</span><span>"producer1 send msg"</span> <span>+</span> i<span>)</span><span>;</span>
            producer2<span>.</span><span>asyncSendMsg</span><span>(</span><span>"producer2 send msg"</span> <span>+</span> i<span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"broker has msg:"</span> <span>+</span> broker<span>.</span><span>getAllMagByDisk</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"consumer1 consume msg："</span> <span>+</span> consumer1<span>.</span><span>syncPullMsg</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"consumer2 consume msg："</span> <span>+</span> consumer2<span>.</span><span>syncPullMsg</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

<span>}</span>

<span>class</span> <span>Producer</span> <span>{</span>

    <span>private</span> <span>Broker</span> broker<span>;</span>

    <span>public</span> <span>void</span> <span>connectBroker</span><span>(</span><span>Broker</span> broker<span>)</span> <span>{</span>
        <span>this</span><span>.</span>broker <span>=</span> broker<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>asyncSendMsg</span><span>(</span><span>String</span> msg<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>broker <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>"please connect broker first"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            broker<span>.</span><span>sendMsg</span><span>(</span>msg<span>)</span><span>;</span>
        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>Consumer</span> <span>{</span>
    <span>private</span> <span>Broker</span> broker<span>;</span>

    <span>public</span> <span>void</span> <span>connectBroker</span><span>(</span><span>Broker</span> broker<span>)</span> <span>{</span>
        <span>this</span><span>.</span>broker <span>=</span> broker<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>syncPullMsg</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> broker<span>.</span><span>getMsg</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>

<span>class</span> <span>Broker</span> <span>{</span>

    <span>// 对应 RocketMQ 中 MessageQueue，默认情况下 1 个 Topic 包含 4 个 MessageQueue</span>
    <span>private</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>String</span><span>></span></span> messageQueue <span>=</span> <span>new</span> <span>LinkedBlockingQueue</span><span>(</span><span>Integer</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>

    <span>// 实际发送消息到 broker 服务器使用 Netty 发送</span>
    <span>public</span> <span>void</span> <span>sendMsg</span><span>(</span><span>String</span> msg<span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            messageQueue<span>.</span><span>put</span><span>(</span>msg<span>)</span><span>;</span>
            <span>// 实际会同步或异步落盘，异步落盘使用的定时任务定时扫描落盘</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>

        <span>}</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getMsg</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>return</span> messageQueue<span>.</span><span>take</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>

        <span>}</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getAllMagByDisk</span><span>(</span><span>)</span> <span>{</span>
        <span>StringBuilder</span> sb <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>"\n"</span><span>)</span><span>;</span>
        messageQueue<span>.</span><span>iterator</span><span>(</span><span>)</span><span>.</span><span>forEachRemaining</span><span>(</span><span>(</span>msg<span>)</span> <span>-></span> <span>{</span>
            sb<span>.</span><span>append</span><span>(</span>msg <span>+</span> <span>"\n"</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
        <span>return</span> sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br></div></div><p>问题：</p>
<ol>
<li>没有实现真正执行消息存储落盘</li>
<li>没有实现 NameServer 去作为注册中心，定位服务</li>
<li>使用 LinkedBlockingQueue 作为消息队列，注意，参数是无限大，在真正 RocketMQ 也是如此是无限大，理论上不会出现对进来的数据进行抛弃，但是会有内存泄漏问题（阿里巴巴开发手册也因为这个问题，建议我们使用自制线程池）</li>
<li>没有使用多个队列（即多个 LinkedBlockingQueue），RocketMQ 的顺序消息是通过生产者和消费者同时使用同一个 MessageQueue 来实现，但是如果我们只有一个 MessageQueue，那我们天然就支持顺序消息</li>
<li>没有使用 MappedByteBuffer 来实现文件映射从而使消息数据落盘非常的快（实际 RocketMQ 使用的是 FileChannel+DirectBuffer）</li>
</ol>
<h2 id="_2-分布式消息中心"> 2 分布式消息中心</h2>
<h3 id="_2-1-问题与解决"> 2.1 问题与解决</h3>
<h4 id="_2-1-1-消息丢失的问题"> 2.1.1 消息丢失的问题</h4>
<ol>
<li>当你系统需要保证百分百消息不丢失，你可以使用生产者每发送一个消息，Broker 同步返回一个消息发送成功的反馈消息</li>
<li>即每发送一个消息，同步落盘后才返回生产者消息发送成功，这样只要生产者得到了消息发送生成的返回，事后除了硬盘损坏，都可以保证不会消息丢失</li>
<li>但是这同时引入了一个问题，同步落盘怎么才能快？</li>
</ol>
<h4 id="_2-1-2-同步落盘怎么才能快"> 2.1.2 同步落盘怎么才能快</h4>
<ol>
<li>使用 FileChannel + DirectBuffer 池，使用堆外内存，加快内存拷贝</li>
<li>使用数据和索引分离，当消息需要写入时，使用 commitlog 文件顺序写，当需要定位某个消息时，查询index 文件来定位，从而减少文件IO随机读写的性能损耗</li>
</ol>
<h4 id="_2-1-3-消息堆积的问题"> 2.1.3 消息堆积的问题</h4>
<ol>
<li>后台定时任务每隔72小时，删除旧的没有使用过的消息信息</li>
<li>根据不同的业务实现不同的丢弃任务，具体参考线程池的 AbortPolicy，例如FIFO/LRU等（RocketMQ没有此策略）</li>
<li>消息定时转移，或者对某些重要的 TAG 型（支付型）消息真正落库</li>
</ol>
<h4 id="_2-1-4-定时消息的实现"> 2.1.4 定时消息的实现</h4>
<ol>
<li>实际 RocketMQ 没有实现任意精度的定时消息，它只支持某些特定的时间精度的定时消息</li>
<li>实现定时消息的原理是：创建特定时间精度的 MessageQueue，例如生产者需要定时1s之后被消费者消费，你只需要将此消息发送到特定的 Topic，例如：MessageQueue-1 表示这个 MessageQueue 里面的消息都会延迟一秒被消费，然后 Broker 会在 1s 后发送到消费者消费此消息，使用 newSingleThreadScheduledExecutor 实现</li>
</ol>
<h4 id="_2-1-5-顺序消息的实现"> 2.1.5 顺序消息的实现</h4>
<ol>
<li>与定时消息同原理，生产者生产消息时指定特定的 MessageQueue ，消费者消费消息时，消费特定的 MessageQueue，其实单机版的消息中心在一个 MessageQueue 就天然支持了顺序消息</li>
<li>注意：同一个 MessageQueue 保证里面的消息是顺序消费的前提是：消费者是串行的消费该 MessageQueue，因为就算 MessageQueue 是顺序的，但是当并行消费时，还是会有顺序问题，但是串行消费也同时引入了两个问题：</li>
</ol>
<blockquote>
<ol>
<li>引入锁来实现串行</li>
<li>前一个消费阻塞时后面都会被阻塞</li>
</ol>
</blockquote>
<h4 id="_2-1-6-分布式消息的实现"> 2.1.6 分布式消息的实现</h4>
<ol>
<li>需要前置知识：2PC</li>
<li>RocketMQ4.3 起支持，原理为2PC，即两阶段提交，prepared-&gt;commit/rollback</li>
<li>生产者发送事务消息，假设该事务消息 Topic 为 Topic1-Trans，Broker 得到后首先更改该消息的 Topic 为 Topic1-Prepared，该 Topic1-Prepared 对消费者不可见。然后定时回调生产者的本地事务A执行状态，根据本地事务A执行状态，来是否将该消息修改为 Topic1-Commit 或 Topic1-Rollback，消费者就可以正常找到该事务消息或者不执行等</li>
</ol>
<blockquote>
<p>注意，就算是事务消息最后回滚了也不会物理删除，只会逻辑删除该消息</p>
</blockquote>
<h4 id="_2-1-7-消息的-push-实现"> 2.1.7 消息的 push 实现</h4>
<ol>
<li>注意，RocketMQ 已经说了自己会有低延迟问题，其中就包括这个消息的 push 延迟问题</li>
<li>因为这并不是真正的将消息主动的推送到消费者，而是 Broker 定时任务每5s将消息推送到消费者</li>
<li>pull模式需要我们手动调用consumer拉消息，而push模式则只需要我们提供一个listener即可实现对消息的监听，而实际上，RocketMQ的push模式是基于pull模式实现的，它没有实现真正的push。</li>
<li>push方式里，consumer把轮询过程封装了，并注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉消息是被推送过来的。</li>
</ol>
<h4 id="_2-1-8-消息重复发送的避免"> 2.1.8 消息重复发送的避免</h4>
<ol>
<li>RocketMQ 会出现消息重复发送的问题，因为在网络延迟的情况下，这种问题不可避免的发生，如果非要实现消息不可重复发送，那基本太难，因为网络环境无法预知，还会使程序复杂度加大，因此默认允许消息重复发送</li>
<li>RocketMQ 让使用者在消费者端去解决该问题，即需要消费者端在消费消息时支持幂等性的去消费消息</li>
<li>最简单的解决方案是每条消费记录有个消费状态字段，根据这个消费状态字段来判断是否消费或者使用一个集中式的表，来存储所有消息的消费状态，从而避免重复消费</li>
<li>具体实现可以查询关于消息幂等消费的解决方案</li>
</ol>
<h4 id="_2-1-9-广播消费与集群消费"> 2.1.9 广播消费与集群消费</h4>
<ol>
<li>消息消费区别：广播消费，订阅该 Topic 的消息者们都会消费<strong>每个</strong>消息。集群消费，订阅该 Topic 的消息者们只会有一个去消费<strong>某个</strong>消息</li>
<li>消息落盘区别：具体表现在消息消费进度的保存上。广播消费，由于每个消费者都独立的去消费每个消息，因此每个消费者各自保存自己的消息消费进度。而集群消费下，订阅了某个 Topic，而旗下又有多个 MessageQueue，每个消费者都可能会去消费不同的 MessageQueue，因此总体的消费进度保存在 Broker 上集中的管理</li>
</ol>
<h4 id="_2-1-10-rocketmq-不使用-zookeeper-作为注册中心的原因-以及自制的-nameserver-优缺点"> 2.1.10 RocketMQ 不使用 ZooKeeper 作为注册中心的原因，以及自制的 NameServer 优缺点？</h4>
<ol>
<li>ZooKeeper 作为支持顺序一致性的中间件，在某些情况下，它为了满足一致性，会丢失一定时间内的可用性，RocketMQ 需要注册中心只是为了发现组件地址，在某些情况下，RocketMQ 的注册中心可以出现数据不一致性，这同时也是 NameServer 的缺点，因为 NameServer 集群间互不通信，它们之间的注册信息可能会不一致</li>
<li>另外，当有新的服务器加入时，NameServer 并不会立马通知到 Producer，而是由 Producer 定时去请求 NameServer 获取最新的 Broker/Consumer 信息（这种情况是通过 Producer 发送消息时，负载均衡解决）</li>
</ol>
<h4 id="_2-1-11-其它"> 2.1.11 其它</h4>
<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/RocketMQ流程.png" alt="" /></p>
<p>加分项咯</p>
<ol>
<li>包括组件通信间使用 Netty 的自定义协议</li>
<li>消息重试负载均衡策略（具体参考 Dubbo 负载均衡策略）</li>
<li>消息过滤器（Producer 发送消息到 Broker，Broker 存储消息信息，Consumer 消费时请求 Broker 端从磁盘文件查询消息文件时,在 Broker 端就使用过滤服务器进行过滤）</li>
<li>Broker 同步双写和异步双写中 Master 和 Slave 的交互</li>
<li>Broker 在 4.5.0 版本更新中引入了基于 Raft 协议的多副本选举，之前这是商业版才有的特性 <a href="http://rocketmq.apache.org/release_notes/release-notes-4.5.0/" target="_blank" rel="noopener noreferrer">ISSUE-1046</a></li>
</ol>
<h2 id="_3-参考"> 3 参考</h2>
<ol>
<li>《RocketMQ技术内幕》：https://blog.csdn.net/prestigeding/article/details/85233529</li>
<li>关于 RocketMQ 对 MappedByteBuffer 的一点优化：https://lishoubo.github.io/2017/09/27/MappedByteBuffer%E7%9A%84%E4%B8%80%E7%82%B9%E4%BC%98%E5%8C%96/</li>
<li>十分钟入门RocketMQ：https://developer.aliyun.com/article/66101</li>
<li>分布式事务的种类以及 RocketMQ 支持的分布式消息：https://www.infoq.cn/article/2018/08/rocketmq-4.3-release</li>
<li>滴滴出行基于RocketMQ构建企业级消息队列服务的实践：https://yq.aliyun.com/articles/664608</li>
<li>基于《RocketMQ技术内幕》源码注释：https://github.com/LiWenGu/awesome-rocketmq</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>读写分离&amp;分库分表</title>
      <link>https://javaguide.cn/high-performance/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB&amp;%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</link>
      <guid>https://javaguide.cn/high-performance/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB&amp;%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</guid>
      <source url="https://javaguide.cn/rss.xml">读写分离&amp;分库分表</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="读写分离-分库分表"> 读写分离&amp;分库分表</h1>
<p>大家好呀！今天和小伙伴们聊聊读写分离以及分库分表。</p>
<p>相信很多小伙伴们对于这两个概念已经比较熟悉了，这篇文章全程都是大白话的形式，希望能够给你带来不一样的感受。</p>
<p>如果你之前不太了解这两个概念，那我建议你搞懂之后，可以把自己对于读写分离以及分库分表的理解讲给你的同事/朋友听听。</p>
<p><strong>原创不易，若有帮助，点赞/分享就是对我最大的鼓励！</strong></p>
<p><em>个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！</em></p>
<h2 id="读写分离"> 读写分离</h2>
<h3 id="何为读写分离"> 何为读写分离？</h3>
<p>见名思意，根据读写分离的名字，我们就可以知道：<strong>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。</strong> 这样的话，就能够小幅提升写性能，大幅提升读性能。</p>
<p>我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/9c624bc130d053860a5089cb9a53310a.png" alt="读写分离" /></p>
<p>一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p>
<h3 id="读写分离会带来什么问题-如何解决"> 读写分离会带来什么问题？如何解决？</h3>
<p>读写分离对于提升数据库的并发非常有效，但是，同时也会引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 <strong>主从同步延迟</strong> 。</p>
<p>主从同步延迟问题的解决，没有特别好的一种方案（可能是我太菜了，欢迎评论区补充）。你可以根据自己的业务场景，参考一下下面几种解决办法。</p>
<p><strong>1.强制将读请求路由到主库处理。</strong></p>
<p>既然你从库的数据过期了，那我就直接从主库读取嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。</p>
<p>比如 <code>Sharding-JDBC</code> 就是采用的这种方案。通过使用 Sharding-JDBC 的 <code>HintManager</code> 分片键值管理器，我们可以强制使用主库。</p>
<div><pre><code><span>HintManager</span> hintManager <span>=</span> <span>HintManager</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
hintManager<span>.</span><span>setMasterRouteOnly</span><span>(</span><span>)</span><span>;</span>
<span>// 继续JDBC操作</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。</p>
<p><strong>2.延迟读取。</strong></p>
<p>还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s,那我就 1s 之后再读取数据。这样多方便啊！方便是方便，但是也很扯淡。</p>
<p>不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</p>
<p>另外，<a href="https://time.geekbang.org/column/intro/100020801?code=ieY8HeRSlDsFbuRtggbBQGxdTh-1jMASqEIeqzHAKrI%3D" target="_blank" rel="noopener noreferrer">《MySQL 实战 45 讲》</a>这个专栏中的<a href="https://time.geekbang.org/column/article/77636" target="_blank" rel="noopener noreferrer">《读写分离有哪些坑？》</a>这篇文章还介绍了很多其他比较实际的解决办法，感兴趣的小伙伴可以自行研究一下。</p>
<h3 id="如何实现读写分离"> 如何实现读写分离？</h3>
<p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：</p>
<ol>
<li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li>
<li>保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的<strong>主从复制</strong>。</li>
<li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li>
</ol>
<p>落实到项目本身的话，常用的方式有两种：</p>
<p><strong>1.代理方式</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/461112716e30db118f4c784adc6e2ff7.png" alt="读写分离-代理层" /></p>
<p>我们可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。</p>
<p>提供类似功能的中间件有 <strong>MySQL Router</strong>（官方）、<strong>Atlas</strong>（基于 MySQL Proxy）、<strong>Maxscale</strong>、<strong>MyCat</strong>。</p>
<p><strong>2.组件方式</strong></p>
<p>在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。</p>
<p>这也是我比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</p>
<p>你可以在 shardingsphere 官方找到<a href="https://shardingsphere.apache.org/document/legacy/3.x/document/cn/manual/sharding-jdbc/usage/read-write-splitting/" target="_blank" rel="noopener noreferrer">sharding-jdbc 关于读写分离的操作</a>。</p>
<h3 id="主从复制原理了解么"> 主从复制原理了解么？</h3>
<p>MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。</p>
<p>更具体和详细的过程是这个样子的（图片来自于：<a href="https://www.toptal.com/mysql/mysql-master-slave-replication-tutorial" target="_blank" rel="noopener noreferrer">《MySQL Master-Slave Replication on the Same Machine》</a>）：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/78816271d3ab52424bfd5ad3086c1a0f.png" alt="MySQL主从复制" /></p>
<ol>
<li>主库将数据库中数据的变化写入到 binlog</li>
<li>从库连接主库</li>
<li>从库会创建一个 I/O 线程向主库请求更新的 binlog</li>
<li>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收</li>
<li>从库的 I/O 线程将接收的 binlog 写入到 relay log 中。</li>
<li>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</li>
</ol>
<p>怎么样？看了我对主从复制这个过程的讲解，你应该搞明白了吧!</p>
<p>你一般看到 binlog 就要想到主从复制。当然，除了主从复制之外，binlog 还能帮助我们实现数据恢复。</p>
<p>🌈 拓展一下：</p>
<p>不知道大家有没有使用过阿里开源的一个叫做 canal 的工具。这个工具可以帮助我们实现 MySQL 和其他数据源比如 Elasticsearch 或者另外一台 MySQL 数据库之间的数据同步。很显然，这个工具的底层原理肯定也是依赖 binlog。canal 的原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。</p>
<p>另外，像咱们常用的分布式缓存组件 Redis 也是通过主从复制实现的读写分离。</p>
<p>🌕 简单总结一下：</p>
<p><strong>MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</strong></p>
<h2 id="分库分表"> 分库分表</h2>
<p>读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：<strong>如果 MySQL 一张表的数据量过大怎么办?</strong></p>
<p>换言之，<strong>我们该如何解决 MySQL 的存储压力呢？</strong></p>
<p>答案之一就是 <strong>分库分表</strong>。</p>
<h3 id="何为分库"> 何为分库？</h3>
<p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上。</p>
<p>下面这些操作都涉及到了分库：</p>
<ul>
<li>你将数据库中的用户表和用户订单表分别放在两个不同的数据库。</li>
<li>由于用户表数据量太大，你对用户表进行了水平切分，然后将切分后的 2 张用户表分别放在两个不同的数据库。</li>
</ul>
<h3 id="何为分表"> 何为分表？</h3>
<p><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>
<p><strong>何为垂直拆分？</strong></p>
<p>简单来说，垂直拆分是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p>
<p><strong>何为水平拆分？</strong></p>
<p>简单来说，水平拆分是对数据表行的拆分，把一张行比较多的表拆分为多张表。</p>
<p>举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p><a href="https://time.geekbang.org/column/intro/100006601?code=i00Nq3pHUcUj04ZWy70NCRl%2FD2Lfj8GVzcGzZ3Wf5Ug%3D" target="_blank" rel="noopener noreferrer">《从零开始学架构》</a> 中的有一张图片对于垂直拆分和水平拆分的描述还挺直观的。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/662ea3bda90061d0b40177e3a46fefc3.jpg" alt="" /></p>
<h3 id="什么情况下需要分库分表"> 什么情况下需要分库分表？</h3>
<p>遇到下面几种场景可以考虑分库分表：</p>
<ul>
<li>单表的数据达到千万级别以上，数据库读写速度比较缓慢（分表）。</li>
<li>数据库中的数据占用的空间越来越大，备份时间越来越长（分库）。</li>
<li>应用的并发量太大（分库）。</li>
</ul>
<h3 id="分库分表会带来什么问题呢"> 分库分表会带来什么问题呢？</h3>
<p>记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本。</p>
<p>引入分库分表之后，会给系统带来什么挑战呢？</p>
<ul>
<li><strong>join 操作</strong> ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。</li>
<li><strong>事务问题</strong> ：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。</li>
<li><strong>分布式 id</strong> ：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 id 了。</li>
<li>......</li>
</ul>
<p>另外，引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器，这些都属于成本。</p>
<h3 id="分库分表有没有什么比较推荐的方案"> 分库分表有没有什么比较推荐的方案？</h3>
<p>ShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/60649996bfc69acb1953063dddf0c2e6.png" alt="" /></p>
<p>ShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。</p>
<p>另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p>
<p>艿艿之前写了一篇分库分表的实战文章，各位朋友可以看看：<a href="https://mp.weixin.qq.com/s/A2MYOFT7SP-7kGOon8qJaw" target="_blank" rel="noopener noreferrer">《芋道 Spring Boot 分库分表入门》</a> 。</p>
<h3 id="分库分表后-数据怎么迁移呢"> 分库分表后，数据怎么迁移呢？</h3>
<p>分库分表之后，我们如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？</p>
<p>比较简单同时也是非常常用的方案就是<strong>停机迁移</strong>，写个脚本老库的数据写到新库中。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。</p>
<p>如果你不想停机迁移数据的话，也可以考虑<strong>双写方案</strong>。双写方案是针对那种不能停机迁移的场景，实现起来要稍微麻烦一些。具体原理是这样的：</p>
<ul>
<li>我们对老库的更新操作（增删改），同时也要写入新库（双写）。如果操作的数据不存在于新库的话，需要插入到新库中。 这样就能保证，咱们新库里的数据是最新的。</li>
<li>在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们还需要自己写脚本将老库中的数据和新库的数据做比对。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。</li>
<li>重复上一步的操作，直到老库和新库的数据一致为止。</li>
</ul>
<p>想要在项目中实施双写还是比较麻烦的，很容易会出现问题。我们可以借助上面提到的数据库同步工具 Canal 做增量数据迁移（还是依赖 binlog，开发和维护成本较低）。</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/9c624bc130d053860a5089cb9a53310a.png" type="image/png"/>
    </item>
    <item>
      <title>负载均衡</title>
      <link>https://javaguide.cn/high-performance/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
      <guid>https://javaguide.cn/high-performance/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
      <source url="https://javaguide.cn/rss.xml">负载均衡</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="负载均衡"> 负载均衡</h1>
<p>负载均衡系统通常用于将任务比如用户请求处理分配到多个服务器处理以提高网站、应用或者数据库的性能和可靠性。</p>
<p>常见的负载均衡系统包括 3 种：</p>
<ol>
<li><strong>DNS 负载均衡</strong> ：一般用来实现地理级别的均衡。</li>
<li><strong>硬件负载均衡</strong> ： 通过单独的硬件设备比如 F5 来实现负载均衡功能（硬件的价格一般很贵）。</li>
<li><strong>软件负载均衡</strong> ：通过负载均衡软件比如 Nginx 来实现负载均衡功能。</li>
</ol>
<h2 id="推荐阅读"> 推荐阅读</h2>
<ul>
<li><a href="http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/load-balancing.html" target="_blank" rel="noopener noreferrer">《凤凰架构》-负载均衡</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>给想成长为高级别开发同学的七条建议</title>
      <link>https://javaguide.cn/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer/</link>
      <guid>https://javaguide.cn/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer/</guid>
      <source url="https://javaguide.cn/rss.xml">给想成长为高级别开发同学的七条建议</source>
      <category>技术文章精选集</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>普通程序员要想成长为高级程序员甚至是专家等更高级别，应该注意在哪些方面注意加强？</p>
<p>开发内功修炼号主飞哥在这篇文章中就给出了七条实用的建议。</p>
<p>原文：https://mp.weixin.qq.com/s/8lMGzBzXine-NAsqEaIE4g</p>
</blockquote>
<h3 id="建议1-刻意加强需求评审能力"> 建议1：刻意加强需求评审能力</h3>
<p>先从需求评审开始说。在互联网公司，需求评审是开发工作的主要入口。</p>
<p>对于普通程序员来说，一般就是根据产品经理提的需求细节，开始设想这个功能要怎么实现，开发成本大概需要多长时间。把自己当成了需求到代码之间的翻译官。很少去思考需求的合理性，对于自己做的事情有多大价值，不管也不问。</p>
<p>而对于高级别的程序员来说，并不会一开始就陷入细节，而是会更多地会从产品本身出发，询问产品经理为啥要做这个细节，目的是啥。换个说法，就是会先考虑这个需求是不是合理。</p>
<p>如果需求高级不合理就进行 PK ，要么对需求进行调整，要么就砍掉。不过要注意的是 PK 和调整需求不仅仅砍需求，还有另外一个方向，那就是对需求进行加强。</p>
<p>产品同学由于缺乏技术背景，很可能想的并不够充分，这个时候如果你有更好的想法，也完全可以提出来，加到需求里，让这个需求变得更有价值。</p>
<p>总之，高级程序员并不会一五一十地按产品经理的需求文档来进行后面的开发，而是<strong>一切从有利于业务的角度出发思考，对产品经理的需求进行删、改、增。</strong></p>
<p>这样的工作表面看似和开发无关，但是只有这样才能保证后续所有开发同学都是有价值的，而不是做一堆无用功。无用功做的多了会极大的挫伤开发的成就感。</p>
<p>所以，<strong>普通程序员要想成长为更高级别的开发，一定要加强需求评审能力的培养</strong>。</p>
<h3 id="建议2-主动思考效率"> 建议2：主动思考效率</h3>
<p>普通的程序员，按部就班的去写代码，有活儿来我就干，没活儿的时候我就呆着。很少去深度思考现有的这些代码为什么要这么写，这么写的好处是啥，有哪些地方存在瓶颈，我是否可以把它优化一些。</p>
<p>而高级一点程序员，并不会局限于把手头的活儿开发就算完事。他们会主动去琢磨，现在这种开发模式是不是不够的好。那么我是否能做一个什么东西能把这个效率给提升起来。</p>
<p>举一个小例子，我 6 年前接手一个项目的时候，我发现运营一个月会找我四次，就是找我给她发送一个推送。她说以前的开发都是这么帮他弄的。虽然这个需求处理起来很简单，改两行发布一下就完事。但是烦啊，你想象一下你正专心写代码呢，她又双叒来找你了，思路全被她中断了。而且频繁地操作线上本来就会引入不确定的风险，万一那天手一抽抽搞错了，线上就完蛋了。</p>
<p>我的做法就是，我专门抽了一周的时间，给她做了一套运营后台。这样以后所有的运营推送她就直接在后台上操作就完事了。我倒出精力去做其它更有价值的事情去了。</p>
<p>所以，<strong>第二个建议就是要主动思考一下现有工作中哪些地方效率有改进的空间，想到了就主动去改进它！</strong></p>
<h3 id="建议3-加强内功能力"> 建议3：加强内功能力</h3>
<p>哪些算是内功呢，我想内功修炼的读者们肯定也都很熟悉的了，指的就是大家学校里都学过的操作系统、网络等这些基础。</p>
<p>普通的程序员会觉得，这些基础知识我都会好么，我大学可是足足学了四年的。工作了以后并不会刻意来回头再来加强自己在这些基础上的深层次的提升。</p>
<p>高级的程序员，非常清楚自己当年学的那点知识太皮毛了。工作之余也会深入地去研究 Linux、研究网络等方向的底层实现。</p>
<p>事实上，互联网业界的技术大牛们很大程度是因为对这些基础的理解相当是深厚，具备了深厚的内功以后才促使他们成长为了技术大牛。</p>
<p>我很难相信一个不理解底层，只会 CURD，只会用别人框架的开发将来能在技术方向成长为大牛。</p>
<p>所以，<strong>还建议多多锻炼底层技术内功能力</strong>。如果你不知道怎么练，那就坚持看「开发内功修炼」公众号。</p>
<h3 id="建议4-思考性能"> 建议4：思考性能</h3>
<p>普通程序员往往就是把需求开发完了就不管了，只要需求实现了，测试通过了就可以交付了。将来流量会有多大，没想过。自己的服务 QPS 能支撑多少，不清楚。</p>
<p>而高级的程序员往往会关注自己写出来的代码的性能。</p>
<p>在需求评审的时候，他们一般就会估算大概的请求流量有多大。进而设计阶段就会根据这个量设计符合性能要求的方案。</p>
<p>在上线之前也会进行性能压测，检验一下在性能上是否符合预期。如果性能存在问题，瓶颈在哪儿，怎么样能进行优化一下。</p>
<p>所以，<strong>第四个建议就是一定要多多主动你所负责业务的性能，并多多进行优化和改进</strong>。我想这个建议的重要程度非常之高。但这是需要你具备深厚的内功才可以办的到的，否则如果你连网络是怎么工作的都不清楚，谈何优化！</p>
<h3 id="建议5-重视线上"> 建议5：重视线上</h3>
<p>普通程序员往往对线上的事情很少去关注，手里记录的服务器就是自己的开发机和发布机，线上机器有几台，流量多大，最近有没有波动这些可能都不清楚。</p>
<p>而高级的程序员深深的明白，有条件的话，会尽量多多观察自己的线上服务，观察一下代码跑的咋样，有没有啥 error log。请求峰值的时候 CPU、内存的消耗咋样。网络端口消耗的情况咋样，是否需要调节一些参数配置。</p>
<p>当性能不尽如人意的时候，可能会回头再来思考出性能的改进方案，重新开发和上线。</p>
<p>你会发现在线上出问题的时候，能紧急扑上前线救火的都是高级一点的程序员。</p>
<p>所以，<strong>飞哥给的第五个建议就是要多多观察线上运行情况</strong>。只有多多关注线上，当线上出故障的时候，你才能承担的起快速排出线上问题的重任。</p>
<h3 id="建议6-关注全局"> 建议6：关注全局</h3>
<p>普通程序员是你分配给我哪个模块，我就干哪个模块，给自己的工作设定了非常小的一个边界，自己所有的眼光都聚集在这个小框框内。</p>
<p>高级程序员是团队内所有项目模块，哪怕不是他负责的，他也会去熟悉，去了解。具备这种思维的同学无论在技术上，无论是在业务上，成长的也都是最快的。在职级上得到晋升，或者是职位上得到提拔的往往都是这类同学。</p>
<p>甚至有更高级别的同学，还不止于把目光放在团队内，甚至还会关注公司内其它团队，甚至是业界的业务和技术栈。写到这里我想起了张一鸣说过的，不给自己的工作设边界。</p>
<p>所以，<strong>建议要有大局观，不仅仅是你负责的模块，整个项目其实你都应该去关注</strong>。而不是连自己组内同学做的是啥都不知道。</p>
<h3 id="建议7-归纳总结能力"> 建议7：归纳总结能力</h3>
<p>普通程序员往往是工作的事情做完就拉到，很少回头去对自己的技术，对业务进行归纳和总结。</p>
<p>而高级的程序员往往都会在一件比较大的事情做完之后总结一下，做个ppt，写个博客啥的记录下来。这样既对自己的工作是一个归纳，也可以分享给其它同学，促进团队的共同成长。</p>
]]></content:encoded>
    </item>
    <item>
      <title>包装严重的IT行业，作为面试官，我是如何甄别应聘者的包装程度</title>
      <link>https://javaguide.cn/high-quality-technical-articles/interview/screen-candidates-for-packaging/</link>
      <guid>https://javaguide.cn/high-quality-technical-articles/interview/screen-candidates-for-packaging/</guid>
      <source url="https://javaguide.cn/rss.xml">包装严重的IT行业，作为面试官，我是如何甄别应聘者的包装程度</source>
      <category>技术文章精选集</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>经常听到培训班待过的朋友给我说他们的老师是怎么教他们“包装”自己的，不光是培训班，我认识的很多朋友也都会在面试之前“包装”一下自己，所以这个现象是普遍存在的。但是面试官也不都是傻子，通过下面这篇文章来看看面试官是如何甄别应聘者的包装程度。</p>
<p><strong>原文地址</strong> ： https://dwz.cn/mUjRa2Jr</p>
</blockquote>
<h2 id="前言"> 前言</h2>
<p>上到职场干将下到职场萌新，都会接触到包装简历这个词语。当你简历投到心仪的公司，公司内负责求职的工作人员是如何甄别简历的包装程度的？Coody 老师根据自己的经验写下了这篇文章，谁都不是天才，包装无可厚非，切勿对号入座!</p>
<h2 id="正文"> 正文</h2>
<p>在互联网极速膨胀的社会背景下，各行各业涌入互联网的 IT 民工日益增大。</p>
<p>早在 2016 年，我司发布了 Java、Ios 工程师的招聘信息，就 Java 工程师单个岗位而言，日收简历近 200 份，Ios 日收简历近一千份。</p>
<p>没错，这就是当年培训机构对 Ios 工程师这个岗位发起的市场讨伐。而随着近几年的发展，市场供大于求现象日益严重。人员摸底成为用人单位对人才考核的重大难题。</p>
<p>笔者初次与求职者以面试的形式进行沟通是 2015 年 6 月。由于当时笔者从业时间短，经验不够丰富，错过了一些优秀的求职者。</p>
<p>三年后的，今天，笔者再次因公司规模扩大而深入与求职者进行沟通。</p>
<h3 id="_1-初选如何鉴别劣质简历"> 1.初选如何鉴别劣质简历</h3>
<p>培训机构除了提供技术培训，往往还提供<strong>简历编写指导</strong>、<strong>面试指导</strong>。很多潜移默化的东西，我们很难甄别。但培训机构包装的简历，存在千遍一律的特征。</p>
<p><strong>年龄较小却具备高级文凭</strong></p>
<p>年龄较小却具备高级文凭，这个或许不能作为一项标准，但是大部分的应聘者，均符合传统文凭的市场情况。个别技术爱好者可能通过自考获得文凭，这种情况需提供独有的技术亮点。</p>
<p><strong>年龄较大却几乎不具备技术经验</strong></p>
<p>年龄较大却几乎不具备技术经验，相对前一点，这个问题就比较严重了。大家都知道，一个正常的人，对新事物的接受能力会随着年龄的增长而降低，互联网技术也包括其内。如果一个人年龄较大不具备技术经验，那么只有两种情况：</p>
<ol>
<li>中途转行(通过培训、自学等方式强行入行)。</li>
<li>由于能力问题，已有的经验不敢写入简历中(能力与经验/薪资不符)。</li>
</ol>
<p><strong>项目经验多为管理系统</strong></p>
<p>项目经验，这一项用来评估应聘者的水平太合适不过了。随着互联网的发展迭代，每一年都会出来很多创新型的互联网公司和新兴行业。笔者最近发布的招聘需求里面。CRM 系统、商城、XX 管理系统、问卷系统、课堂系统占了 90%的份额。试问现在 2019 年，内部管理系统这么火爆么。言归正传，我们对于简历的评估，应当多考虑“确有其事”的项目。比如说该人员当时就职于 XX 公司，该公司当时的背景下确实研发了该项目（外包除外）。</p>
<p><strong>项目的背景不符合互联网发展背景</strong></p>
<p>项目背景，每年的市场走向不同，从早些年的电商、彩票风波，到后来的 O2O、夺宝、直播、新零售。每个系列的产品的出现，都符合市场的定义。如果简历中出现 18 年、19 年才刚立项做彩票(15 年政府禁止互联网彩票)、O2O、商城、夺宝(17 年初禁止夺宝类产品)、直播等产品。显然是非常不符合市场需求的。这种情况下需考虑具体情况是否存在理解空间。</p>
<p><strong>缺乏新意</strong></p>
<p>不同工作经验下多个项目技术架构或项目结构一致，缺乏新意。一般情况而言，不同的公司技术栈不同，甚至产品的走向和模式完全不同。故此，当一个应聘者多家公司的多个项目中写到的技术千遍一律，业务流程异曲同工。看似整洁，实则更加缺乏说服力。</p>
<p><strong>技术过于新颖，对旧技术却只字不提</strong></p>
<p>技术过于新颖，根据互联网技术发展的走向来看，我们在不断向新型技术靠拢。但是任何企业作为资历深厚的 CTO、架构师来说。往往会选择更稳定、更成熟、学习成本更低的已有技术。对新技术的追求不会过于明显。而培训机构则是“哪项技术火我们就教哪项”。故此，出现了很多走入互联网行业的新人对旧技术一窍不通。甚至很多技术都没听过。</p>
<p><strong>工作经验较丰富，但从事的工作较低级。</strong></p>
<p>工作经验比较丰富，单从事的工作比较低级，这里存在很大的问题，要么就是原公司没法提供合理的舞台给该人员更好的发展空间，要么就是该人员能力不够，没法完成更高级的工作。当然，还有一种情况就是该人员包装过多的经验导致简历中不和谐。这种情况需要评估公司规模和背景。</p>
<p><strong>公司背景跨省跨市</strong></p>
<p>可能很多用人单位和鄙人一样，最近接受到的简历，90%为跨市跳槽的人员。其中武汉占了 60%以上。均为武汉 XX 网络科技有限公司。公司规模均小于 50 人。也有厦门、宁波、南京等等。这个问题笔者就不提了，大家都懂的。跨地区跳槽不好查证。</p>
<p><strong>缺少业余热情于技术的证明</strong></p>
<p>有些眼高手低的技术员，做了几个管理系统。用到的技术确是各种分布式、集群、高并发、大数据、消息队列、搜索引擎、镜像容器、多数据库、数据中心等等。期望的薪资也高于行业标准。一个对技术很热情的人，业余时间肯定在技术方面花费过不少时间。那么可以从该人员的博客、git 地址入手。甚至可以通过手机号、邮箱、昵称、马甲。去搜索引擎进行搜集，核实该人员是否在论坛、贴吧、开源组织有过技术背景。</p>
<h3 id="_2-进入面试阶段-如何甄别对方的水分"> 2. 进入面试阶段，如何甄别对方的水分</h3>
<p>在甄别对方水分这一块，并没有明确的标准，但是笔者可以提几个点。这也是笔者在实际面试中惯用的做法。</p>
<p><strong>通过公司规模、团队规模、人员分配是否合理、人员合作方式来判断对方是否具备工作经验</strong></p>
<p>当招聘初级、初中级 IT 人员的时候，可以询问一些问题，比如公司有多少人、产品团队多少人、产品、技术、后端、前端、客户端、UI、测试各多少人。工作中如何合作的、产品做了多少时间、何时上线的、上线后多长时间迭代一个版本、多长时间迭代一个活动、发展至今多少用户(后端)、多大并发等等(后端)。根据笔者的经验，如果一个人没有任何从业周期，面对这些问题的时候，或多或少答非所问或者给出的答案非常不合理。</p>
<p><strong>背景公司入职时间、项目立项实现、完工时间、产品技术栈、迭代流程的核实</strong></p>
<p>很多应聘者对于简历过于包装，只为了追求更高的薪资。当我们问起：你是 xx 年 xx 月入职的该公司？你们项目是 xx 年 xx 月上线的？你们项目使用到 xx 技术？你们每次上线前夕是如何评审的。面对这些问题，应聘者给出的答案经常与简历不符合。这样问题就来了。关于项目使用到的技术，很多项目我们可以通过搜索该项目的地址、APP。通过 http 协议、技术特征、抛出异常特征来大致判别对方使用到的技术。如果应聘者给出的答案明显与之不匹配，嘿嘿。</p>
<p><strong>通过技术深度，甄别对方的技术水平</strong></p>
<ol>
<li>
<p>确定对方的技术栈，如：你做过最满意的项目是哪个，为什么？你最喜欢使用的技术是哪些，为什么？</p>
</li>
<li>
<p>确定对方项目的发展程度，如：你们产品做了多久，迭代了多久，发布了多少版本，发展到了多少用户，带来多大并发，多少流水？</p>
</li>
<li>
<p>确定对方的技术属性，如：平时你会通过什么渠道跟其他技术人形成技术沟通与交流，主要交流过哪些技术？</p>
</li>
</ol>
<p>笔者最近接待的面试者，很多面试者的简历上，写着层出不穷的各种技术，为了不跨越求职者的技术栈，笔者专门挑应聘者简历写到或用到的技术来进行询问。笔者举几个例子。</p>
<p><strong>1)某求职者简历上写着熟练使用 redis。</strong></p>
<ol>
<li>介绍一下你使用过 redis 的哪些数据结构，并描述一下使用的业务场景；</li>
<li>介绍一下你操作 redis 用到的是什么插件；</li>
<li>介绍一下你们使用的序列化方式；</li>
<li>介绍一下你们使用 redis 遇到过给你印象较深的问题；</li>
</ol>
<p><strong>2)某求职者声称熟练 http 协议并编写过爬虫。</strong></p>
<ol>
<li>介绍一下你所了解的几个 http head 头并描述其用途；</li>
<li>如果前端提交成功，后端无法接受数据，这时候你将如何排查问题；</li>
<li>描述一下 http 基本报文结构;</li>
<li>如果服务器返回 cookie，存储在响应内容里面 head 头的字段叫做什么;</li>
<li>当服务端返回 Transer-Encoding：chunked 代表什么含义</li>
<li>是否了解分段加载并描述下其技术流程。</li>
</ol>
<p>当然，面向不同的技术，对应的技术深度自然也不一样。</p>
<p>大体上的套路便是如此：你说你杀过猪。那么你杀过几头猪，分别是啥时候，杀过多大的猪，有啥毛色。事实上对方可能给你的回答是：杀过、十几头、杀过五十斤的、杀过绿色、黄色、红色、蓝色的猪。那么问题就来了。</p>
<p>然而笔者碰到的问题是：使用 git 两年却不知道 github、使用 redis 一年却不知道数据结构也不知道序列化、专业做爬虫却不懂 content-type 含义、使用搜索引擎技术却说不出两个分词插件、使用数据库读写分离却不知道同步延时等等。</p>
<p>写在最后，笔者认为在招聘途中，并不是不允许求职者包装，但是尽可能满足能筹平衡。虽然这篇文章没有完美的结尾，但是笔者提供了面试失败的各种经验。笔者最终招到了如意的小伙伴。也希望所有技术面试官早日找到符合自己产品发展的 IT 伙伴。</p>
]]></content:encoded>
    </item>
    <item>
      <title>从面试官和候选者的角度谈如何准备技术初试</title>
      <link>https://javaguide.cn/high-quality-technical-articles/interview/technical-preliminary-preparation/</link>
      <guid>https://javaguide.cn/high-quality-technical-articles/interview/technical-preliminary-preparation/</guid>
      <source url="https://javaguide.cn/rss.xml">从面试官和候选者的角度谈如何准备技术初试</source>
      <category>技术文章精选集</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><strong>内容总结：</strong></p>
<p>从面试官和面试者两个角度探讨了技术面试！非常不错！</p>
<ul>
<li>通过技术基础考察候选者，才能考察到候选者的真实技术实力：技术深度和广度。</li>
<li>实战与理论结合。比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题?</li>
<li>项目经历考察不宜超过两个。因为要深入考察一个项目的详情，所占用的时间还是比较大的。一般来说，会让候选人挑选一个他或她觉得最有收获的/最有挑战的/印象最深刻的/自己觉得特有意思的项目。然后围绕这个项目进行发问。通常是从项目背景出发，考察项目的技术栈、项目模块及交互的整体理解、项目中遇到的有挑战性的技术问题及解决方案、排查和解决问题、代码可维护性问题、工程质量保障等。</li>
<li>多问少说，让候选者多表现。根据候选者的回答适当地引导或递进或横向移动。</li>
</ul>
<p><strong>原文地址：</strong> https://www.cnblogs.com/lovesqcc/p/15169365.html</p>
</blockquote>
<h2 id="考察目标和思路"> 考察目标和思路</h2>
<p>首先明确，技术初试的考察目标：</p>
<ul>
<li>候选人的技术基础；</li>
<li>候选人解决问题的思路和能力。</li>
</ul>
<p>技术基础是基石（冰山之下的东西），占七分， 解决问题的思路和能力是落地（冰山之上露出的部分），占三分。 业务和技术基础考察，三七开。</p>
<h2 id="技术基础考察"> 技术基础考察</h2>
<h3 id="为什么要考察技术基础"> 为什么要考察技术基础?</h3>
<p>程序员最重要的两种技术思维能力，是逻辑思维能力和抽象设计能力。逻辑思维能力是基础，抽象设计能力是高阶。 考察技术基础，正好可以同时考察这两种思维能力。能不能理解基础技术概念及关联，是考察逻辑思维能力；能不能把业务问题抽象成技术问题并合理的组织映射，是考察抽象设计能力。</p>
<p>绝大部分业务问题，都可以抽象成技术问题。在某种意义上，业务问题只是技术问题的领域化表述。</p>
<p>因此，<strong>通过技术基础考察候选者，才能考察到候选者的真实技术实力：技术深度和广度。</strong></p>
<h3 id="技术基础怎么考察"> 技术基础怎么考察？</h3>
<p>技术基础怎么考察？通过有效的多角度的发问模式来考察。</p>
<h4 id="是什么-为什么"> 是什么-为什么</h4>
<p>是什么考察对概念的基本理解，为什么考察对概念的实现原理。</p>
<p>比如：索引是什么？ 索引是如何实现的？</p>
<h4 id="引导-横向发问-深入发问"> 引导-横向发问-深入发问</h4>
<p>引导性，比如 “你对 Java 同步工具熟悉吗？” 作个试探，得到肯定答复后，可以进一步问： “你熟悉哪些同步工具类？” 了解候选者的广度；</p>
<p>获取候选者的回答后，可以进一步问：“ 谈谈 <code>ConcurrentHashMap</code> 或 <code>AQS</code> 的实现原理？”</p>
<p>一个人在多大程度上把技术原理能讲得清晰，包括思路和细节，说明他对技术的掌握能力有多强。</p>
<h4 id="跳跃式-交叉式发问"> 跳跃式/交叉式发问</h4>
<p>比如：讲到哈希高效查找，可以谈谈哈希一致性算法 。 两者既有关联又有很多不同点。也是一种技术广度的考察方法。</p>
<h4 id="总结性发问"> 总结性发问</h4>
<p>比如：你在做 XXX 中，获得了哪些可以分享的经验？ 考察候选人的归纳总结能力。</p>
<h4 id="实战与理论结合"> 实战与理论结合</h4>
<p>比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题?</p>
<p>比如，候选人有谈到 SQL 优化和索引优化，那就正好谈谈索引的实现原理，如何建立最佳索引？</p>
<p>再比如，候选人有谈到事务，那就正好谈谈事务实现原理，隔离级别，快照实现等；</p>
<h4 id="熟悉与不熟悉结合"> 熟悉与不熟悉结合</h4>
<p>针对候选人简历上写的熟悉的部分，和没有写出的都问下。比如候选人简历上写着：熟悉 JVM 内存模型， 那我就考察下内存管理相关（熟悉部分），再考察下 Java 并发工具类（不确定是否熟悉部分）。</p>
<h4 id="死知识与活知识结合"> 死知识与活知识结合</h4>
<p>比如，查找算法有哪些？顺序查找、二分查找、哈希查找。这些大家通常能说出来，也是“死知识”。</p>
<p>这些查找算法各适用于什么场景？在你工作中，有哪些场景用到了哪些查找算法？为什么？ 这些是“活知识”。</p>
<h4 id="学习或工作中遇到的"> 学习或工作中遇到的</h4>
<p>有时，在学习和工作中遇到的问题，也可以作为面试题。</p>
<p>比如，最近在学习《操作系统导论》并发部分，有一章节是如何使数据结构成为线程安全的。这里就有一些可以提问的地方：如何实现一个锁？如何实现一个线程安全的计数器？如何实现一个线程安全的链表？如何实现一个线程安全的 <code>Map</code> ？如何提升并发的性能？</p>
<p>工作中遇到的问题，也可以抽象提炼出来，作为技术基础面试题。</p>
<h4 id="技术栈适配度发问"> 技术栈适配度发问</h4>
<p>如果候选人（简历上所写的）使用的某些技术与本公司的技术栈比较契合，则可以针对这些技术点进行深入提问，考察候选人在这些技术点的掌握程度。如果掌握程度比较好，则技术适配度相对更高一些。</p>
<p>当然，这一点并不能作为筛掉那些没有使用该技术栈的候选人的依据。比如本公司使用 <code>MongoDB</code> 和 <code>MySQL</code>， 而一个候选人没有用过 <code>Mongodb，</code> 但使用过 <code>MySQL</code>, <code>Redis</code>, <code>ES</code>, <code>HBase</code> 等多种存储系统，那么适配度并不比仅使用过 <code>MySQL</code> 和 <code>MongoDB</code> 的候选人逊色，因为他所涉及的技术广度更大，可以推断出他有足够能力掌握 <code>Mongodb</code>。</p>
<h4 id="创造有个性的面试题库"> 创造有个性的面试题库</h4>
<p>每个技术面试官都会有一个面试题库。持续积累面试题库，日常中突然想到的问题，就随手记录下来。</p>
<h2 id="业务维度考察"> 业务维度考察</h2>
<h3 id="为什么要考察业务维度"> 为什么要考察业务维度？</h3>
<p>技术基础考察，容易错过的地方是，候选人的非技术能力特质，比如沟通组织能力、带项目能力、抗压能力、解决实际问题的能力、团队影响力、其它性格特质等。</p>
<h3 id="为什么不能单考察业务维度"> 为什么不能单考察业务维度？</h3>
<p>因为业务方面通常比较熟悉，可能就直接按照现有方案说出来了，很难考察到候选人的深入理解、横向拓展和归纳总结能力。</p>
<p>这一点，建议有针对性地考察下候选人的归纳总结能力：比如， 微服务搭建或开发或维护/保证系统稳定性或性能方面的过程中，你收获了哪些可以分享的经验？</p>
<h2 id="解决问题能力考察"> 解决问题能力考察</h2>
<p>仅仅只是技术基础还不够，通常最好结合实际业务，针对他项目里的业务，抽象出技术问题进行考察。</p>
<p>解决思路重在层层递进。这一点对于面试官的要求也比较高，兼具良好的倾听能力、技术深度和业务经验。首先要仔细倾听候选人的阐述，找到适当的技术切入点，然后进行发问。如果进不去，那就容易考察失败。</p>
<h3 id="设计问题"> 设计问题</h3>
<ul>
<li>比如多个机器间共享大量业务对象，这些业务对象之间有些联合字段是重复的，如何去重？</li>
<li>如果瞬时有大量请求涌入，如何保证服务器的稳定性？</li>
</ul>
<h3 id="项目经历"> 项目经历</h3>
<p>项目经历考察不宜超过两个。因为要深入考察一个项目的详情，所占用的时间还是比较大的。</p>
<p>一般来说，会让候选人挑选一个他或她觉得最有收获的/最有挑战的/印象最深刻的/自己觉得特有意思的项目。然后围绕这个项目进行发问。通常是从项目背景出发，考察项目的技术栈、项目模块及交互的整体理解、项目中遇到的有挑战性的技术问题及解决方案、排查和解决问题、代码可维护性问题、工程质量保障等。</p>
<h2 id="面试官如何做好一场面试"> 面试官如何做好一场面试?</h2>
<h3 id="预先准备"> 预先准备</h3>
<p>面试官也需要做一些准备。比如熟悉候选者的技能优势、工作经历等，做一个面试设计。</p>
<p>在面试将要开始时，做好面试准备。此外，面试官也需要对公司的一些基本情况有所了解，尤其是公司所使用技术栈、业务全景及方向、工作内容、晋升制度等，这一点技术型候选人问得比较多。</p>
<h3 id="面试启动"> 面试启动</h3>
<p>一般以候选人自我介绍启动，不过候选人往往会谈得比较散，因此，我会直接提问：谈谈你有哪些优势以及自己觉得可以改进的地方？</p>
<p>然后以一个相对简单的基础题作为技术提问的开始：你熟悉哪些查找算法？大多数人是能答上顺序查找、二分查找、哈希查找的。</p>
<h3 id="问题设计"> 问题设计</h3>
<p>提前阅读候选人简历，从简历中筛选出关键词，根据这些关键词进行有针对性地问题设计。</p>
<p>比如候选人简历里提到 <code>MVVM</code> ，可以问 <code>MVVM</code> 与 <code>MVC</code> 的区别； 提到了观察者模式，可以谈谈观察者模式，顺便问问他还熟悉哪些设计模式。</p>
<h3 id="宽松氛围"> 宽松氛围</h3>
<p>即使问的问题比较多比较难，也要注意保持宽松氛围。</p>
<p>在面试前，根据候选人基本信息适当调侃一下，比如一位候选人叫汪奎，那我就说：之前我们团队有位叫袁奎，我们都喊他奎爷。</p>
<p>在面试过程中，适当提示，或者给出少量自己的看法，也能缓解候选人的紧张情绪。</p>
<h3 id="学会倾听"> 学会倾听</h3>
<p>多问少说，让候选者多表现。根据候选者的回答适当地引导或递进或横向移动。</p>
<p>引导候选人表现他最优势的一面，让他或她感觉好一些：毕竟一场面试双方都付出了时间和精力，不应该是面试官 Diss 候选人的场合，而应该让彼此有更好的交流。很大可能，你也能从候选人那里学到不少东西。</p>
<p>面试这件事，只不过双方的角色和立场有所不同，但并不代表面试官的水平就一定高于候选人。</p>
<h3 id="记录重点"> 记录重点</h3>
<p>认真客观地记录候选人的回答，尽可能避免任何主观评价，亦不作任何加工（比如自己给总结一下，总结能力也是候选人的一个特质）。</p>
<h2 id="作出判断"> 作出判断</h2>
<p>面试过程是一种铺垫，关键的是作出判断。</p>
<p>作出判断最容易陷入误区的是：贪深求全。总希望候选人技术又深入又全面。实际上，这是一种奢望。如果候选人的技术能力又深入又全面，很可能也会面临两种情况：</p>
<ol>
<li>候选人有更好的选择；</li>
<li>候选人在其它方面可能存在不足，比如团队协作方面。</li>
</ol>
<p>一个比较合适的尺度是：</p>
<ol>
<li>他或她的技术水平能否胜任当前工作；</li>
<li>他或她的技术水平与同组团队成员水平如何；</li>
<li>他或她的技术水平是否与年限相对匹配，是否有潜力胜任更复杂的任务。</li>
</ol>
<p><strong>不同年龄看重的东西不一样。</strong></p>
<p>对于三年以下的工程师，应当更看重其技术基础，因为这代表着他的未来潜能；同时也考察下他在实际开发中的体现，比如团队协作、业务经验、抗压能力、主动学习的热情和能力等。</p>
<p>对于三年以上的工程师，应当更看重其业务经验、解决问题能力，看看他或她是如何分析具体问题，在业务范畴内考察其技术基础的深度和广度。</p>
<p>如何判断一个候选人的真实技术水平及是否适合所需，这方面，我也在学习中。</p>
<h2 id="给候选人的话"> 给候选人的话</h2>
<h3 id="关注技术基础"> 关注技术基础</h3>
<p>一个常见的疑惑是：开发业务系统的大多数时候，基本不涉及数据结构与算法的设计与实现，为什么要考察 <code>HashMap</code> 的实现原理？为什么要学好数据结构与算法、操作系统、网络通信这些基础课程？</p>
<p>现在我可以给出一个答案了：</p>
<ul>
<li>正如上面所述，绝大多数的业务问题，实际上最终都会映射到基础技术问题上：数据结构与算法的实现、内存管理、并发控制、网络通信等；这些是理解现代互联网大规模程序以及解决程序疑难问题的基石，—— 除非能祝福自己永远都不会遇到疑难问题，永远都只满足于编写 CRUD；</li>
<li>这些技术基础正是程序世界里最有趣最激动人心的地方。如果对这些不感兴趣，就很难在这个领域里深入进去，不如及早转行从事其它职业，非技术的世界一直都很精彩广阔（有时我也想多出去走走，不想局限于技术世界）；</li>
<li>技术基础是程序员的内功，而具体技术则是招式。徒有招式而内功不深，遇到高手（优秀同行从业者的竞争及疑难杂症）容易不堪一击；</li>
<li>具备扎实的专业技术基础，能达到的上限更高，未来更有可能胜任复杂的技术问题求解，或者在同样的问题上能够做到更好的方案；</li>
<li>人们喜欢跟与自己相似的人合作，牛人倾向于与牛人合作能得到更好的效果；如果一个团队大部分人技术基础比较好，那么进来一个技术基础比较薄弱的人，协作成本会变高；如果你想和牛人一起合作拿到更好的结果，那就要让自己至少在技术基础上能够与牛人搭配的上；</li>
<li>在 CRUD 的基础上拓展其它才能也不失为一种好的选择，但这不会是一个真正的程序员的姿态，顶多是有技术基础的产品经理、项目经理、HR、运营、客满等其它岗位人才。这是职业选择的问题，已经超出了考察程序员的范畴。</li>
</ul>
<h3 id="不要在意某个问题回答不上来"> 不要在意某个问题回答不上来</h3>
<p>如果面试官问你很多问题，而有些没有回答上来，不要在意。面试官很可能只是在测试你的技术深度和广度，然后判断你是否达到某个水位线。</p>
<p>重点是：有些问题你答得很有深度，也体现了你的深度思考能力。</p>
<p>这一点是我当了技术面试官才领会到的。当然，并不是每位技术面试官都是这么想的，但我觉得这应该是个更合适的方式。</p>
]]></content:encoded>
    </item>
    <item>
      <title>一个中科大差生的 8 年程序员工作总结</title>
      <link>https://javaguide.cn/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary/</link>
      <guid>https://javaguide.cn/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary/</guid>
      <source url="https://javaguide.cn/rss.xml">一个中科大差生的 8 年程序员工作总结</source>
      <category>技术文章精选集</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><strong>《一个中科大差生的 8 年程序员工作总结》</strong> 这篇文章是我上上个星期发现的一篇好文，我刚刚才把它看完。</p>
<p>说实话，我对别人的经历还是非常感兴趣的。高中、大学那会，看过了很多人的传记。</p>
<p>这篇文章讲述了一位中科大的朋友 8 年的经历：<strong>从 2013 年毕业之后加入上海航天 x 院某卫星研究所，再到入职华为，从华为离职。</strong></p>
<p>除了丰富的经历之外，作者在文章还给出了很多自己对于工作/生活的思考。我觉得非常受用！我在这里，向这位作者表达一下衷心的感谢。</p>
<p>我对这篇文章进行了重新排版，在这里分享一下（已经通过微信联系原作者申请了转载权限）！</p>
<p><strong>原文地址</strong> ：https://www.cnblogs.com/scada/p/14259332.html</p>
</blockquote>
<hr>
<h2 id="前言"> 前言</h2>
<p>今年终于从大菊花厂离职了，离职前收入大概 60w 不到吧！在某乎属于比较差的，今天终于有空写一下自己的职场故事，也算是给自己近 8 年的程序员工作做个总结复盘。</p>
<p>近 8 年有些事情做对了，也有更多事情做错了，在这里记录一下，希望能够给后人一些帮助吧，也欢迎私信交流。文笔不好，见谅，有些细节记不清了，如果有出入，就当是我编的这个故事吧。</p>
<p><em>PS：有几个问题先在这里解释一下，评论就不一一回复了</em></p>
<ol>
<li>关于差生，我本人在科大时确实成绩偏下，差生主要讲这一点，没其他意思。</li>
<li>因为买房是我人生中的大事，我认为需要记录和总结一下，本文中会有买房，房价之类的信息出现，您如果对房价，炒房等反感的话，请您停止阅读，并且我再这里为浪费您的时间先道个歉。</li>
</ol>
<h2 id="_2013-年"> 2013 年</h2>
<h3 id="加入上海航天-x-院某卫星研究所"> 加入上海航天 x 院某卫星研究所</h3>
<p>本人 86 年生人，13 年从中科大软件相关专业毕业，由于父母均是老师，从小接受的教育就是努力学习，找个稳定的“好工作”，报效国家。</p>
<p>于是乎，毕业时候头脑一热加入了上海航天 x 院某卫星研究所，没有经过自己认真思考，仅仅听从父母意见，就草率的决定了自己的第一份工作，这也为我 5 年后离职埋下了隐患。这里总结第一条经验：</p>
<p><strong>如果你的亲人是普通阶层，那对于人生中一些大事来说，他们给的建议往往就是普通阶层的思维，他们的阶层就是他们一生思维决策的结果，如果你的目标是跳出本阶层，那最好只把他们的建议当成参考。</strong></p>
<p>13 年 4 月份，我坐上火车来到上海，在一路换乘地铁来到了大闵行，出了地铁走路到单位，一路上建筑都比较老旧，我心里想这跟老家也没什么区别嘛，还大上海呢。</p>
<p>到达单位报道，负责报道的老师很亲切，填写完资料，分配了一间宿舍，还给了大概 3k 左右安家费，当时我心里那个激动啊（乡下孩子没有见过钱啊，见谅），拿了安家费，在附近小超市买好生活用品，这样我就开始了自己航天生涯。</p>
<p>经过 1 个月集中培训后，我分配到部门，主要负责卫星上嵌入式软件开发。不过说是高大上的卫星软件开发，其实刚开始就是打杂，给实验室、厂房推箱子搬设备，呵呵，说航天是个体力活相信很多航天人都有同感吧。不过当时年轻，心思很单纯，每天搬完设备，晚上主动加班，看文档材料，画软件流程图，编程练习，日子过得很充实。</p>
<p>记得第一个月到手大概 5k 左右（好少呀），当时很多一起入职的同事抱怨，我没有，我甚至不太愿意和他们比较工资，这里总结第二条经验：</p>
<p><strong>不要和你的同事比工资，没有意义，比工资总会有人受伤，更多的是负面影响，并且很多时候受伤的会是你。</strong></p>
<h3 id="工作中暂露头角"> 工作中暂露头角</h3>
<p>工作大概一个月的时候，我遇到了一件事情，让我从新员工里面开始暂露头角。事情是这样的当时国家要对军工单位进行 GJB5000A 软件开发等级认证（搞过这个认证的同学应该都知道，过这个认证那是要多酸爽有多酸爽），但是当时一个负责配置管理的同事却提出离职，原因是他考上了公务员，当时我们用的那个软件平台后台的版本控制是 SVN 实现的，恰好我在学校写程序时用过，呵呵，话说回来现在学生自己写软件很少有人会在本地搭版本控制器吧！我记得当时还被同学嘲笑过，这让我想起了乔布斯学习美术字的故事，这里总结一下：</p>
<p><strong>不要说一项技能没有用，任何你掌握的技能都有价值，但是你要学会找到发挥它的场景。如果有一天你落水了，你可能会很庆幸，自己以前学会了游泳。</strong></p>
<p><strong>工作中如果要上升，你要勇于承担麻烦的、有挑战的任务，当你推掉麻烦的时候，你也推掉了机遇。</strong></p>
<p>好了，扯远了，回到前面，当时我主动跟单位认证负责人提出，我可以帮忙负责这方面的工作，我有一定经验。这里要提一下这个负责人，是位女士，她是我非常敬佩的一个前辈，认真，负责，无私，整个人为国家的航天事业奉献了几十年，其实航天领域有非常多这样的老前辈，他们默默奋斗，拿着不高的薪水，为祖国的国防建设做出了巨大的贡献。当时这位负责人，看我平时工作认真积极，思维反应也比较灵活（因为过认证需要和认证专家现场答辩的）就同意了我的请求，接受到这个任务之后，我迅速投入，学习认证流程、体系文件、迅速掌握认证工作要点，一点一点把相关的工作做好，同时周期性对业务进行复盘，总结复盘可能是我自己的一个优点：</p>
<p><strong>很多人喜欢不停的做事，但不会停下来思考，缺乏总结复盘的能力，其实阶段性总结复盘，不仅能够固化前面的经验，也能梳理后面的方向；把事情做对很重要，但是更重要的是做对的事；另外不要贪快，方向正确慢就是快</strong>(后半句是我后来才想明白的，如果早想明白，就不会混成目前这样了）</p>
<p>1 个月后，当时有惊无险通过了当年的认证，当时负责人主动向单位申请了 2k 特别奖，当时我真的非常高兴，主要是自己的工作产生了价值，得到了认可。后来几个月的日子平淡无奇，有印象的好像只有两件事情。</p>
<p>一件事情是当年端午，当时我们在单位的宿舍休息，突然楼道上一阵骚动，我打开宿舍门一看，原来是书记来慰问，还给每个人送了一箱消暑饮料，这件事印象比较深刻，是我觉得国企虽然有各种各样的问题，但是论人文关怀，还是国企要好得多。</p>
<h3 id="错失一次暴富的机会"> 错失一次暴富的机会</h3>
<p>另一件事是当年室友刚买房，然后天天研究生财&amp;之道，一会劝我买房，一会劝我买比&amp;特&amp;币，我当时没有鸟他，为什么呢，因为当时的室友生活习惯不太好，会躺在床上抽烟，还在宿舍内做饭(我们宿舍是那种很老的单位房，通风不好），我有鼻炎，所以不是很喜欢他（嗯，这里要向室友道歉，当年真是太幼稚了）。现在 B&amp;T&amp;C4 万美元了，我当时要是听了室友也能小发一笔了（其实我后来 18 年买了，但是没有拿住这是后话），这里要总结一下：</p>
<p><strong>不要因为某人的外在，如外貌、习惯、学历等对人贴上标签，去盲目否定别人，对于别人的建议，应该从客观出发，综合分析，从善如流是一项非常难得的品质。</strong></p>
<p><strong>人很难挣到他认知之外的财富，就算偶然拿到了，也可能很快失去。所以不要羡慕别人投机获得的财富，努力提升你的思维，财商才是正道。</strong></p>
<h3 id="航天生涯的第一个正式项目"> 航天生涯的第一个正式项目</h3>
<p>转眼到了 9 月份（我 4 月份入职的），我迎来了我航天生涯第一个正式的型号项目（型号，是军工的术语，就相当于某个产品系列比如华为的 mate）,当时分配给我的型号正式启动，我终于可以开始写卫星上的代码了。</p>
<p>当时真的是心无旁骛，一心投身军工码农事业，每天实验室，测试厂房，评审会，日子虽然忙碌，但是也算充实。并且由于我的努力工作，加上还算可以的技术水平，我很快就能独立胜任一些型号基础性的工作了，并且我的努力也受到了型号（产品）线的领导的认可，他们开始计划让我担任型号主管设计师，这是一般工作 1-2 年的员工的岗位，当时还是有的激动的。</p>
<h2 id="_2014-年"> 2014 年</h2>
<h3 id="升任主管设计师后的一次波折"> 升任主管设计师后的一次波折</h3>
<p>转眼间到 2014 年了，大概上半年吧，我正式升任主管设计师，研发工作上也开时独挡一面了，但是没多久产品研发就给了我当头一棒。</p>
<p>事情是这样的，当时有一个版本软件编写完毕，加载到整星上进行测试，有一天大领导来检查，当时非常巧，领导来时测试主岗按某个岗位的人员要求，发送了一串平时整星没有使用的命令（我在实验室是验证过的），结果我的软件立刻崩溃，无法运行。由于正好领导视察，这个问题立马被上报到质量处，于是我开始了苦逼的技术归零攻关（搞航天的都懂，我就不解释了）。</p>
<p>期间每天都有 3 个以上领导，询问进度，当时作为新人的我压力可想而知，可是我无论如何都查不出来问题，在实验室我的软件完全正常！后来，某天中午我突然想到，整星上可能有不同的环境，具体过程就不说了。后人查出来是一个负责加载我软件的第三方软件没有受控，非法篡改了我程序的 4 个字节，而这 4 字节正好是那天发送命令才会执行的代码，结果导致我的软件崩溃。最后我花了进一个月完成了所有质量归零报告，技术分析报告，当然负责技术的领导没有责怪，相反的还更加看重我了，后来我每遇到一个质量问题，无论多忙最后定要写一份总结分析报告，这成了我一个技术习惯，也为后来我升任软件开发组长奠定了技术影响基础。</p>
<p><strong>强烈建议技术团队定期开展质量回溯，需要文档化，还要当面讲解，深入的技术回溯有助于增加团队技术交流活跃度，同时提升团队技术积淀，是提升产品质量，打造优秀团队的有效方法。</strong></p>
<p><strong>个人的话建议养成写技术总结文章的习惯，这不仅能提升个人技术，同时分享也可以增加你的影响力</strong></p>
<h3 id="职场软技能的重新认识"> 职场软技能的重新认识</h3>
<p>上半年就在忙碌中度过了，到了年底，发生了一件对我们组影响很大的事情，年底单位开展优秀小组评比， 其实这个很多公司都有，那为什么说对我们组影响很大内，这里我先卖关子。这里先不得不提一个人，是个女孩子，南京大学的，比我晚来一年，她做事积极，反应灵敏，还做得一手不错的 PPT，非常优秀，就是黑了点（希望她看到了不要来找我，呵呵）。</p>
<p>当时单位开展优秀小组评比，我们当时是新员工，什么都很新鲜，就想参加一下，当时领导说我们每年都参加的，我们问，我们每年做不少东西，怎么没有看到过评比的奖状，领导有点不好意思，说我们没有进过决赛。我们又问，多少名可以进入决赛圈，答曰前 27 名即可（总共好像 50+个组）我们当时心里真是一万个羊驼跑过。。。。</p>
<p>其实当时我们组每年是做不少事情的，我们觉得我们不应该排名如此之低，于是我们几个年轻人开始策划，先是对我们的办公室彻底改造(因为要现场先打分，然后进决赛），然后好好梳理了我们当年取得的成绩，现场评比时我自告奋勇进行答辩（我沟通表达能力还不错，这也算我一个优势吧），后面在加上前文提到的女孩子做的漂亮 PPT，最后我们组拿到了铜牌班组的好成绩，我也因为这次答辩的优秀表现在领导那里又得到了认可，写了大半段了，再总结一下：</p>
<p><strong>职场软技能如自我展示很重要，特别是程序员，往往在这方面是个弱项，如果可以的话，可以通过练习，培训强化一下这些软技能，对职场的中后期非常有帮助。</strong></p>
<h2 id="_2015-年"> 2015 年</h2>
<p>时间总是过得很快，一下就到 2015 年了，这一年发生了一件对我影响很大的事情。</p>
<h3 id="升任小组副组长"> 升任小组副组长</h3>
<p>当时我们小组有 18 个人了，有一天部门开会，主任要求大家匿名投票选副组长（当时部门领导还是很民主的），因为日常事务逐渐增多，老组长精力有限，想把一些事物分担出来，当天选举结果就出来了，我由于前面的技术积累和沟通表达能力的展现，居然升任副组长，当时即有些意外，因为总是有传言说国企没背景一辈子就是最最底层，后来我仔细思考过，下面是我不成熟的想法：</p>
<p><strong>不要总觉得国企事业单位的人都是拼背景，拼关系，我承认存在关系户，但是不要把关系户和低能力挂钩，背景只是一个放大器，当关系户做出了成绩时它会正面放大影响，当关系户做了不光彩的事情是，它也会让影响更坏。没有背景，你可以作出更大的贡献来达到自己的目标，你奋斗的过程是更大的财富。另外，我遇到的关系户能力都很强，也可能是巧合，也可能是他们的父辈给给他们在经验层次上比我们更优秀的教育。</strong></p>
<h3 id="学习团队管理技巧"> 学习团队管理技巧</h3>
<p>升任副组长后，我的工作更加忙碌了，不仅要做自己项目的事情，还要横向管理和协调组内其他项目的事情，有人说要多体谅军工单位的基层班组长，这话真是没错啊。这个时候我开始学习一些管理技巧，如何凝聚团队，如何统一协调资源等等，这段时间我还是在不断成长。不过记得当年还是犯了一个很大的方向性错误，虽然更多的原因可能归结为体制吧，但是当时其实可以在力所能及的范围内做一些事情的。</p>
<p>具体是这样的，当时管理上有项目线，有行政线，就是很常见的矩阵式管理体系，不过在这个特殊的体制下面出现了一些问题。当时部门一把手被上级强制要求不得挂名某个型号，因为他要负责部门资源调配，而下面的我们每个人都归属 1-2 个型号（项目），在更高层的管理上又有横向的行政线（不归属型号），又有纵向的型号管理线。</p>
<p>而型号的任务往往是第一线的，因为产品还是第一位的，但是个人的绩效、升迁又归属行政线管理，这种形式在能够高效沟通的民企或者外企一般来说不是问题，但是在沟通效率缓慢，还有其他掣肘因素的国企最终导致组内每个人忙于自身的型号任务，各自单打独斗，无法聚焦，一年忙到头最终却得不到部门认可，我也因为要两面管理疲于应付，后来曾经反思过，其实可以聚焦精力打造通用平台（虽然这在我们行业很难）部分解决这个问题：</p>
<p><strong>无论个人还是团队，做事情要聚焦，因为个人和团队资源永远都是有限的，如果集中一个事情都做不好，那分散就更难以成功，但是在聚焦之前要深入思考，往什么方向聚焦才是正确的，只有持续做正确的事情才是最重要的。</strong></p>
<h2 id="_2016-年"> 2016 年</h2>
<p>这一年是我人生的关键一年，发生了很多事情。</p>
<h3 id="升任小组副组长-2"> 升任小组副组长</h3>
<p>第一件事情是我正式升任组长，由于副组长的工作经验，在组长的岗位上也做得比较顺利，在保证研发工作的同时，继续带领团队连续获得铜牌以上班组奖励，另外各种认证检查都稳稳当通过，但是就在这个时候，因为年轻，我犯下了一个至今非常后悔的错误。</p>
<p>大概是这样的，我们部门当时有两个大组，一个是我们的软件研发组，一个是负责系统设计的系统分析组。</p>
<p>当时两个组的工作界面是系统组下发软件任务书给软件组，软件组依照任务书开发，当时由于历史原因，软件组有不少 10 年以上的老员工，而系统组由于新成立由很多员工工作时间不到 2 年，不知道从什么时候起，也不知道是从哪位人员开始，软件组的不少同事认为自己是给系统组打工的。并且，由于系统组同事工作年限较短，实际设计经验不足，任务书中难免出现遗漏，从而导致实际产品出错，两组同事矛盾不断加深。</p>
<p>最后，出现了一个爆发：当时系统组主推一项新的平台，虽然这个平台得到了行政线的支持，但是由于军工产品迭代严谨，这个新平台当时没有型号愿意使用，同时平台的部分负责人，居然没有完整的型号经验！由于这个新平台的软件需要软件组实现，但是因为已经形成的偏见，软件同事认为这项工作中自己是为利益既得者打工。</p>
<p>我当时也因为即负责实际软件开发，又负责部分行政事务，并且年轻思想不成熟，也持有类似的思想。过程中的摩擦、冲突就不说了，最后的结果是系统组、软件组多人辞职，系统组组长离职，部门主任离职创业（当然他们辞职不全是这个原因，包括我离职也不全是这个原因，但是我相信这件事情有一定的影响），这件事情我非常后悔，后来反思过其实当时自己应该站出来，协调两组矛盾，全力支持部门技术升级，可能最终就不会有那么多优秀的同事离开了。</p>
<p><strong>公司战略的转型，技术的升级迭代，一定会伴随着阵痛，作为基层组织者，应该摒弃个人偏见，带领团队配合部门、公司主战略，主战略的成功才是团队成功的前提。</strong></p>
<h3 id="买房"> 买房</h3>
<p>16 年我第二件大事情就是买房，关注过近几年房价的人都可能还记得，16 年一线城市猛涨的情景。其实当时 15 年底，上海市中心和学区房已经开始上涨，我 15 年底听同事开始讨论上涨的房价，我心里开始有了买房的打算，大约 16 春节（2 月份吧，具体记不得了），我回老家探望父母，同时跟他们提出了买房的打算。</p>
<p>我的父亲是一个“央视新闻爱好者”，爱好看狼咸平，XX 刀，XX 檀的节目，大家懂了吧，父亲说上海房价太高了，都是泡沫，不要买。这个时候我已经不是菜鸟了，我想起我总结的第一条经验（见上文），我开始收集往年的房价数据，中央历年的房价政策，在复盘 15 年的经济政策时我发现，当年有 5 次降息降准，提升公积金贷款额度，放松贷款要求于是我判定房价一定会继续涨，涨到一个幅度各地才会出台各种限购政策，并且房价在城市中是按内环往外涨的于是我开始第一次在人生大事上反对父母，我坚决表态要买房。父亲还是不太同意，他说年底吧，先看看情况（实际是年底母亲的退休公积金可以拿出来大概十几万吧，另外未来丈母娘的公积金也能拿出来了大概比这多些）。我还是不同意，父亲最终拗不过我，终于松口，于是我们拿着双方家庭凑的 50w 现金开始买房，后来上海的房价大家都看到了。这件事也是我做的不多的正确的事情之一。</p>
<p>但是最可笑的是，我研究房价的同时居然犯下了一个匪夷所思的错误，我居然没有研究买房子最重要的因素是什么，我们当时一心想买一手房（现在想想真是脑子进水），最后买了一套松江区交通不便的房子，这第一套房子的地理位置也为我后来第二次离职埋下了隐患，这个后面会说。</p>
<p><strong>一线或者准一线城市能买尽量买，不要听信房产崩溃论，如果买不起，那可以在有潜力的城市群里用父母的名义先买一套，毕竟大多数人的财富其实是涨不过通货膨胀的。另外买房最重要的三个要素是，地段，地段，地段。</strong></p>
<p>买房的那天上午和女朋友领的证，话说当时居然把身份证写错了三次 。。。</p>
<p>这下我终于算是有个家了，交完首付那个时候身上真的是身无分文了。航天的基层员工的收入真的是不高，我记得我当时作为组长，每月到手大概也就 7k-8k 的样子，另外有少量的奖金，但是总数仍然不高，好在公积金比较多，我日常也没什么消费欲望，房贷到是压力不大。</p>
<p>买完房子之后，我心里想，这下真的是把双方家庭都掏空了（我们双方家庭都比较普通，我的收入也在知乎垫底，没办法）万一有个意外怎么办，我思来想去，于是在我下一个月发工资之后，做了一个我至今也不知道是对是错的举动，我利用当月的工资，给全家人家人买了保险保险，各种重疾，意外都配好了。但是为什么我至今也不知道对错呢，因为后来老丈人，我母亲都遭遇病魔，但是两次保险公司都拒赔，找出的理由我真是哑口无言，谁叫我近视呢。另外真的是要感谢国家，亲人重病之后，最终还是走了医保，赔偿了部分，不然真的是一笔不小的负担。</p>
<h2 id="_2017-年"> 2017 年</h2>
<p>对我人生重大影响的 2016 年，在历史的长河中终究连浪花都激不起来。历史长河静静流淌到了 2017 年，这一年我参加了中国深空探测项目，当然后面我没有等到天问一号发射就离开了航天，但是有时候仰望星空的时候，想想我的代码正在遥远的星空发挥作用，心里也挺感慨的，我也算是重大历史的参与者了，呵呵。好了不说工作了，平淡无奇的 2017 年，对我来说也发生了两件大事。</p>
<h3 id="买了第二套房子"> 买了第二套房子</h3>
<p>第一件事是我买了第二套房子，说来可笑，当年第一套房子都是掏空家里，这第二年就买了第二套房子，生活真的是难以捉摸。到 2017 年时，前文说道，我母亲和丈母娘先后退休，公积金提取出来了，然后在双方家里各自办了酒席，酒席之后，双方父母都把所有礼金给了我们，父母对自己的孩子真的是无私之至。当时我们除了月光之外，其实没有什么外债，就是生活简单点。拿到这笔钱后，我们就在想如何使用，一天我在菜市场买菜，有人给我一张 xuanchuan 页，本来对于这样的 xuanchuan 页我一般是直接扔掉的，但是当天鬼死神差我看了一眼，只见上面写着“嘉善高铁房，紧邻上海 1.5w”我当时就石化了，我记得去年我研究上海房价的时候，曾经在网站上看到过嘉善的房价，我清楚的记得是 5-6k，我突然意识到我是不是错过了什么机会，反思一下：</p>
<p><strong>工作生活中尽量保持好奇心，不要对什么的持怀疑态度，很多机会就隐藏在不起眼的细节中，比如二十年前有人告诉你未来可以在网上购物，有人告诉你未来可以用手机支付，你先别把他直接归为骗子，静下来想一想，凡事要有好奇心，但是要有自己的判断。</strong></p>
<p>于是我立马飞奔回家，开始分析，大城市周边的房价。我分析了昆山，燕郊，东莞，我发现燕郊极其特殊，几乎没有产业，纯粹是承接大城市人口溢出，因此房价成高度波动。而昆山和东莞，由于自身有产业支撑，又紧邻大城市，因此房价稳定上涨。我和妻子一商量，开始了外地看房之旅，后来我们去了嘉善，觉得没有产业支撑，昆山限购，我们又到嘉兴看房，我发现嘉兴房价也涨了很多，但是这里购房的大多数新房，都是上海购房者，入住率比较低，很多都是打算买给父母住的，但是实际情况是父母几乎不在里面住，我觉得这里买房不妥，存在一个变现的问题。于是我开始继续寻找，一天我看着杭州湾的地图，突然想到，杭州湾北侧不行，那南侧呢？南侧绍兴，宁波经济不是更达吗。于是我们目光投向绍兴，看了一个月后，最后在绍兴紧贴杭州的一个区，购买了一套小房子，后来 17 年房价果然如我预料的那样完成中心城市的上涨之后开始带动三四线城市上涨。后来国家出台了大湾区政策，我对我的小房子更有信心了。这里稍微总结一下我个人不成熟的看法：</p>
<p><strong>在稳定通胀的时代，负债其实是一种财富。长三角城市群会未来强于珠港澳，因为香港和澳门和深圳存在竞争关系，而长三角城市间更多的是互补，未来我们看澳门可能就跟看一个中等省会城市一样了。</strong></p>
<h3 id="准备要孩子"> 准备要孩子</h3>
<p>2017 年的第二件事是，我们终于准备要孩子了，但是妻子怎么也备孕不成功，我们开始频繁的去医院，从 10 元挂号费的普通门诊，看到 200 元，300 元挂号费的专家门诊，看到 600 元的特需门诊，从综合医院看到妇幼医院，从西医看到中医，每个周末不是在医院排队，就是在去医院的路上。最后的诊疗结果是有一定的希望，但是有困难，得到消息时我真的感觉眼前一片黑暗，这种从来在新闻上才能看到了事情居然落到了我们头上，我们甚至开始接触地下 XX 市场。同时越来越高的医疗开销（专家门诊以上就不能报销了）也开始成为了我的负担，前文说了，我收入一直不高，又还贷款，又支付医疗开支渐渐的开始捉襟见肘，我甚至动了卖小房子的打算。</p>
<h2 id="_2018-年"> 2018 年</h2>
<p>前面说到，2017 年开始频繁出入医院，同时项目也越来越忙，我渐渐的开始喘不过气起来，最后医生也给了结论，需要做手术，手术有不小的失败的几率。我和妻子商量后一咬牙做吧，如果失败就走地下的路子，但是可能需要准备一笔钱（手术如果成功倒是花销不会太大），哎，古人说一分钱难倒英雄汉，真是诚不欺我啊，这个时候我已经开始萌生离职的想法了。怎么办呢，生活还是要继续，我想起了经常来单位办理贷款的银行人员，贷款吧，这种事情保险公司肯定不赔的嘛，于是我办理了一笔贷款，准备应急。</p>
<h3 id="项目结束-离职"> 项目结束，离职</h3>
<p>时间慢慢的时间走到了 8 月份，我的项目已经告一定段落，一颗卫星圆满发射成功，深空项目也通过了初样阶段我的第一份工作也算有始有终了。我开始在网上投递简历，我技术还算可以，沟通交流也不错，面试很顺利，一个月就拿到了 6 个 offer，其中就有大菊花厂的 offer，定级 16A，25k 月薪后来政策改革加了绩效工资 6k(其实我定级和总薪水还是有些偏低了和我是国企，本来总薪水就低有很大关系，话说菊花厂级别后面真的是注水严重，博士入职轻松 17 级)菊花厂的 offer 审批流程是我见过最长，我当时的接口人天天催于流程都走了近 2 个月。我向领导提出了离职，离职的过程很痛苦，有过经历的人估计都知道，这里就不说了。话说我为什么会选择华为呢，一是当时急需钱，二是总觉得搞嵌入式的不到华为看看真的是人生遗憾。现在想想没有认真去理解公司的企业文化就进入一家公司还是太草率了：</p>
<p><strong>如果你不认同一个公司的企业文化，你大概率干不长，干不到中高层，IT 人你不及时突破到中高层很快你就会面临非常多问题；公司招人主要有两种人，一种是合格的人，一种是合适的人，合格的人是指技能合格，合适的人是指认同文化。企业招人就是先把合格的人找进来，然后通过日日宣讲，潜移默化把不合适的人淘汰掉。</strong></p>
<h3 id="入职华为"> 入职华为</h3>
<p>经过一阵折腾终于离职成功，开始入职华为。离职我做了一件比较疯狂的事情，当时因为手上有一笔现金了，一直在支付利息，心里就像拿它干点啥。那时由于看病，接触了地下 XX 市场，听说了 B&amp;TC，走之前我心一横买 B&amp;T&amp;C，后来不断波动，最终我还是卖了，挣了一些钱，但是最终没有拿到现在，果然是考验人性啊。</p>
<h2 id="_2019-年"> 2019 年</h2>
<h3 id="成功转正"> 成功转正</h3>
<p>华为的试用期真长，整整 6 个月，每个月还有流程跟踪，交流访谈，终于我转正了，转正答辩我不出意料拿到了 Excellent 评价，涨了点薪水，呵呵还不错。华为的事情我不太想说太多，总之我觉得自己没有资格评判这个公司，从公司看公司的角度华为真正是个伟大的公司，任老爷子也是一个值得敬佩的企业家。</p>
<p>在华为干了半年后，我发现我终究还是入职的时候太草率了，我当时没有具体的了解这个岗位，这个部门。入职之后我发现，<strong>我所在的是硬件部门，我在一个硬件部门的软件组，我真是脑子秀逗了</strong>。</p>
<p><strong>在一个部门，你需要尽力进入到部门主航道里，尽力不要在边缘的航道工作，特别是那些节奏快，考核严格的部门。</strong></p>
<p>更严峻的是我所在的大组，居然是一个分布在全国 4 地的组，大组长（华为叫 LM）在上海，4 地各有一个本地业务负责人。我立刻意识到，到年终考评时，所有的成果一定会是 4 地分配，并且 4 地的负责人会占去一大部分，这是组织结构形成的优势。我所在的小组到时候会难以突破，资源分配会非常激烈。</p>
<h3 id="备孕成功"> 备孕成功</h3>
<p>先不说这些，在 18 年时妻子做完了手术，手术居然很成功。休息完之后我们 19 年初开始备孕了，这次真的是上天保佑，运气不错，很快就怀上了。这段时间，我虽然每天做地铁 1.5 小时到公司上班，经受高强度的工作，我心里每天还是乐滋滋的。但是，突然有一天，PL（华为小组长）根我说，LM 需要派人去杭研所支持工作，我是最合适人选，让我有个心里准备。当时我是不想去的，这个时候妻子是最需要关怀的时候，我想 LM 表达了我的意愿，并且我也知道如果去了杭州年底绩效考评肯定不高。过程不多说了，反正结果是我去了杭州。</p>
<p>于是我开始了两头奔波的日子，每个月回上海一趟。这过程中还有个插曲，家里老家城中村改造，分了一点钱，父母执意卖掉了老家学校周边的房子，丈母娘也处理老家的一些房子，然后把钱都给了我们，然后我用这笔家里最后的资产，同时利用华为的现金流在绍、甬不限购地区购买一些房子，我没有炒房的想法，只是防止被通货膨胀侵蚀而已，不过后来结果证明我貌似又蒙对了啊，我自己的看法是：</p>
<p><strong>杭绍甬在经济层面会连成紧密的一片，在行政区上杭州兼并绍 部分区域的概率其实不大，行政区的扩展应该是先兼并自身的下级代管城市。</strong></p>
<h3 id="宝宝出生"> 宝宝出生</h3>
<p>不说房子了，继续工作吧。10 月份干了快一年时候，我华为的师傅（华为有师徒培养体系）偷偷告诉我被定为备选 PL 了，虽然不知道真假，但是我心里还是有点小高兴。不过我心里也慢慢意识到这个公司可能不是我真正想要的公司，这么多年了，愚钝如我慢慢也开始知道自己想干什么了。因为我的宝宝出生了，看着这只四脚吞金兽，我意识到自己已经是一个父亲了。</p>
<p>2019 年随着美国不断升级的制裁消息，我在华为的日子也走到年底，马上将迎来神奇的 2020 年。</p>
<h2 id="_2020"> 2020</h2>
<blockquote>
<p>2020 就少写一些了，有些东西真的可能忘却更好。</p>
</blockquote>
<h3 id="在家办公"> 在家办公</h3>
<p>年初就给大家来了一个重击，新冠疫情改变了太多的东西。这个时候真的是看出华为的执行力，居家办公也效率不减多少，并且迅速实现了复工。到了 3-4 月份，华为开始正式评议去年绩效等级，我心里开始有预感，以前的分析大概率会兑现，并且绩效和收入挂钩，华为是个风险意识极强的公司，去年的制裁会导致公司开始风险预备，虽然我日常工作还是受到多数人好评，但是我知道这其实在评议人员那里，没有任何意义。果然绩效评议结果出来了，呵呵，我很不满意。绩效沟通时 LM 破例跟我沟通了很长时间，我直接表达了我的想法。LM 承诺钱不会少，呵呵，我不评价吧。后来一天开始组织调整，成立一个新的小组，LM 给我电话让我当组长,我拒绝了，这件事情我不知道对错，我当时是这样考虑的</p>
<ol>
<li><strong>升任新的职位，未必是好事，更高的职位意味着更高的要求，因此对备选人员要么在原岗位已经能力有余，要么时间精力有余；我认为当时我这两个都不满足，呵呵离家有点远，LM 很可以只是因为绩效事情做些补偿。</strong></li>
<li><strong>华为不会垮，这点大家有信心，但未来一定会出现战略收缩，最后这艘大船上还剩下哪些人不清楚，底层士兵有可能是牺牲品。</strong></li>
<li><strong>我 34 岁了</strong></li>
</ol>
<h3 id="提出离职"> 提出离职</h3>
<p>另外我一直思考未来想做什么，已经有了一丝眉目，就这样，我拿了年终奖约 7 月就提出了离职，后来部门还让我做了最后一次贡献，把我硬留到 10 月份，这样就可以参加上半年考核了，让帮忙背了一个 C 呵呵，这是工作多年，最差绩效吧。</p>
<p>这里还有一个小插曲，最后这三个月我负责什么工作呢，因为 20 年 3 月开始我就接手了部分部门招聘工作（在华为干过的都知道为什么非 HR 也要帮忙招聘，呵呵大坑啊，就不多解释了），结果最后三个月我这个待离职员工居然继续负责招聘，真的是很搞笑，不过由于我在上一份工作中其实一直也有招聘的工作，所以也算做的轻车熟路，每天看 50 份左右简历（我看得都非常仔细，我害怕自己的疏忽会导致一个优秀的人才错失机会，所以比较慢）其实也蛮有收货，最后好歹对程序员如何写简历有了一些心得。</p>
<h2 id="总结"> 总结</h2>
<p>好了 7 年多，近 8 年的职场讲完了，不管过去如何，未来还是要继续努力，希望看到这篇文章觉得有帮助的朋友，可以帮忙点个推荐，这样可能更多的人看到，也许可以避免更多的人犯我犯的错误。另外欢迎私信或者其他方式交流（某 Xin 号，jingyewandeng），可以讨论职场经验，方向，我也可以帮忙改简历（免费啊），不用怕打扰，能帮助别人是一项很有成绩感的事，并且过程中也会有收获，程序员也不要太腼腆呵呵</p>
]]></content:encoded>
    </item>
    <item>
      <title>一位大龄程序员所经历的面试的历炼和思考</title>
      <link>https://javaguide.cn/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer/</link>
      <guid>https://javaguide.cn/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer/</guid>
      <source url="https://javaguide.cn/rss.xml">一位大龄程序员所经历的面试的历炼和思考</source>
      <category>技术文章精选集</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><strong>内容总结</strong> ：</p>
<p>本文的作者，今年 36 岁，已有 8 年 JAVA 开发经验。在阿里云三年半，有赞四年半，已是标准的大龄程序员了。</p>
<p>下面是本文作者关于面试和个人能力提升的一些小建议（很实用） ：</p>
<ol>
<li>个人介绍，是对自己的一个更为清晰、深入和全面的认识契机。</li>
<li>简历是充分展示自己的浓缩精华，也是重新审视自己和过往经历的契机。不仅仅是简要介绍技能和经验，更要最大程度凸显自己的优势领域（差异化）。</li>
<li>我个人是不赞成海投的，而倾向于定向投。找准方向投，虽然目标更少，但更有效率。</li>
<li>技术探索，一定要先理解原理。原理不懂，就会浮于表层，不能真正掌握它。技术原理探究要掌握到什么程度？数据结构与算法设计、考量因素、技术机制、优化思路。要在脑中回放，直到一切细节而清晰可见。如果能够清晰有条理地表述出来，就更好了。技术原理探究，一定要看源码。看了源码与没看源码是有区别的。没看源码，虽然说得出来，但终是隔了一层纸；看了源码，才捅破了那层纸，有了自己的理解，也就能说得更加有底气了。当然，也可能是我缺乏演戏的本领。</li>
<li>要善于从失败中学习。正是在杭州四个月空档期的持续学习、思考、积累和提炼，以及面试失败的反思、不断调整对策、完善准备、改善原有的短板，采取更为合理的方式，才在回武汉的短短两个周内拿到比较满意的 offer 。</li>
<li>面试是通过沟通来理解双方的过程。面试中的问题，千变万化，但有一些问题是需要提前准备好的。</li>
</ol>
<p><strong>原文地址</strong> ：https://www.cnblogs.com/lovesqcc/p/14354921.html</p>
</blockquote>
<p>从每一段经历中学习，在每一件事情中修行。善于从挫折中学习。</p>
<h2 id="引子"> 引子</h2>
<p>我今年 36 岁，已有 8 年 JAVA 开发经验。在阿里云三年半，有赞四年半，已是标准的大龄程序员了。</p>
<p>在多年的读书、学习和思考中，我的价值观、人生观和世界观也逐步塑造成型。我意识到自己的志趣在于做教育文化方面，因此在半冲动之下，8 月份下旬，裸辞去找工作了。有限理性难以阻挡冲动的个性。不建议裸辞，做事应该有规划、科学合理。</p>
<p>尽管我最初认为自己“有理想有目标有意愿有能力”，找一份教育开发的工作应该不难，但事实上我还是过于乐观了。现实很快给我泼了一瓢瓢冷水。我屡战屡败，又屡败屡战。惊讶地发现自己还有这个韧性。面试是一项历炼，如果没有被失败击倒，那么从中会生长出一份韧性，这种韧性能让人走得更远。谁没有经历过失败的历练呢？失败是最伟大的导师了，如果你愿意跟他学一学的话。</p>
<p>在面试的过程中，我很快发现自己的劣势：</p>
<ul>
<li>投入精力做业务，技术深度不够，对原理的理解局限于较浅的层次；</li>
<li>视野不够开阔，局限于自己所做的订单业务线，对其它关联业务线（比如商品、营销、支付等）了解不够；</li>
<li>思维不够开阔，大部分时间投入在开发和测试上，对运维、产品、业务、商业层面思考都思考不多；</li>
<li>缺乏管理经验，年龄偏大；这两项劣势我一度低估，但逐渐凸显出来，甚至让我一度不自信，但最终我还是走出来了。</li>
</ul>
<p>但我也有自己的优势。职业竞争的基本法则是稀缺性和差异化。能够解决大型项目的架构设计和攻克技术难题，精通某个高端技术领域是稀缺性体现；而能够做事能做到缜密周全精细化，有高并发大流量系统开发经验，则是差异性体现。稀缺性是上策，差异化是中策，而降格以求就是下策了。</p>
<p>我缺乏稀缺性优势，但还有一点差异化优势：</p>
<ul>
<li>对每一份工作都很踏实，时间均在 3 年 - 5 年之间，有一点大厂光环，能获得更多面试机会（虽然不一定能面上）；</li>
<li>坚持写博客，孜孜不倦地追求软件开发的“道”，时常思考记录开发中遇到的问题及解决方案；</li>
<li>做事认真严谨，能够从整体分析和思考问题，也很注重基础提升；</li>
<li>对工程质量、性能优化、稳定性建设、业务配置化设计有实践经验；</li>
<li>大流量微服务系统的长期开发维护经验。</li>
</ul>
<p>我投出简历的公司并不多。在不多的面试中，我逐渐意识到网上的“斩获几十家大厂 offer”的说法并不可信。理由如下：</p>
<ul>
<li>如果能真斩获大量大厂 offer ，面试的级别很大概率是初级工程师。要知道面试 4 年以上的工程师，面试的深度和广度令人发指，从基础的算法、到各种中间件的原理机制到实际运维架构，无所不包，真个是沉浸在“技术的海洋”，除非一个人的背景和实力非常强大，平时也做了非常深且广的沉淀；</li>
<li>一个背景和实力非常强大的人，是不会有兴趣去投入这么多精力去面各种公司，仅仅是为了吹嘘自己有多能耐；实力越强的人，他会有自己的选择逻辑，投的简历会更定向精准。话说，他为什么不花更多精力投入在那些能够让他有最大化收益的优秀企业呢？</li>
<li>培训机构做的广告。因为他们最清楚新手需要的是信心，哪怕是伪装出来的信心。</li>
</ul>
<p>好了，闲话不多说了。我讲讲自己在面试中所经受的历练和思考吧。</p>
<h2 id="准备工作"> 准备工作</h2>
<p>人生或许很长，但面试的时间很短，最长不过一小时或一个半小时。别人如何在短短一小时内能够更清晰地认识长达三十多年的你呢？这就需要你做大量细致的准备工作了。在某种程度上，面试与舞蹈有异曲同工之妙：台上五分钟，台下十年功。</p>
<p>准备工作主要包括简历准备、个人介绍、公司了解、技术探索、表述能力、常见问题、中高端职位、好的心态。准备工作是对自身和对外部世界的一次全面深入的重新认知。</p>
<p>初期，我以为自己准备很充分，简历改改就完事了。随着一次次受挫，才发现自己的准备很不充分。在现在的我看来，准备七分，应变三分。准备，就是要知己知彼，知道对方会问哪些问题（通常是系统/项目/技术的深度和广度）、自己应当如何作答；应变，就是当自己遇到不会、不懂、不知道的问题时，如何合理地展示自己的解决思路，以及根据面试中答不上来的问题查漏补缺，夯实基础。</p>
<p>这个过程，实际上也是学习的过程。持续的反思和提炼、学习新的内容、重新认识自己和过往经历等。</p>
<h3 id="简历准备"> 简历准备</h3>
<p>最开始，我做得比较简单。把以前的简历拿出来，添加上新的工作经历，略作修改，但整体上模板基本不变。</p>
<p>在基本面上，我做的是较为细致的，诚实地写上了自己擅长和熟悉的技能和经验经历，排版也尽力做得整洁美观（学过一些 UI 设计）。不浮夸也不故作谦虚。</p>
<p>在扩展面上，我做的还是不够的。有一天，一位猎头打电话给我，问：“你最大的优势是什么？”。我顿时说不上来。当时也未多加思考。在后续面试屡遭失败之后，一度有些不自信之后，我开始仔细思考自己的优势来。然后将“对工程质量、性能优化、稳定性建设、业务配置化设计有深入思考和实践经验”写在了“技能素养”栏的第一行，因为这确实是我所做过的、最实在且脚踏实地的且具备概括性的。</p>
<p>有时，简历内容的编排顺序也很重要。之前，我把掌握的语言及技术写在前面，而“项目管理能力和团队影响力”之类的写在后面。但投年糕妈妈之后，未有面试直接被拉到不合适里面，受到了刺激，我意识到或许是对方觉得我管理经验不足。因此，刻意将“项目管理能力和团队影响力”提到了前面，表示自己是重视管理方面的，不过，投过新的简历之后，没有回应。我意识到，这样的编排顺序可能会让人误解我是管理能力偏重的（事实上有一位 HR 问我是不是还在写代码），但实际上管理方面我是欠缺的，最后，我还是调回了原来的顺序，凸出自己“工程师的本色”。后面，我又做了一些语句的编排上的修改。</p>
<p>随着面试的进展，有时，也会发现自己的简历上写得不够或者以前做得不够的地方。比如，在订单导出这段经历里，我只是写了大幅提升性能和稳定性，显得定性描述化，因此，我添加了一些量化的东西（2w 阻塞 =&gt; 300w+，1w/1min）作为证实；比如，8 月份离职，到 12 月份面试的时候，有一段空档期，有些企业会问到这个。因此，我索性加了一句话，说明这段时间我在干些啥；比如，代表性系统和项目，每一个系统和项目的价值和意义（不一定写在上面，但是心里要有数）。功夫要下足。</p>
<p>再比如，我很详细地写了有赞的工作经历及经验，但阿里云的那段基本没动。而有些企业对这段经历更感兴趣，我却觉得没太多可说的，留在脑海里的只有少量印象深刻的东西，以及一些博客文章的记录，相比这段工作经历来说显得太单薄。这里实质上不是简历的问题，而是过往经历复盘的问题。建议，在每个项目结束后，都要写个自我复盘。避免时间将这些可贵的经历冲淡。</p>
<p>每个人其实都有很多可说的东西，但记录下来的又有多少呢？值得谈道的有多少呢？过往不努力，面试徒伤悲。</p>
<p><strong>简历更新的心得</strong> ：</p>
<ul>
<li>简历是充分展示自己的浓缩精华，也是重新审视自己和过往经历的契机；</li>
<li>不仅仅是简要介绍技能和经验，更要最大程度凸显自己的优势领域（差异化）；</li>
<li>增强工作经历的表述，凸显贡献，赢得别人的认可；</li>
<li>复盘并记录每一个项目中的收获，为跳槽和面试打下好的铺垫。</li>
</ul>
<h3 id="个人介绍"> 个人介绍</h3>
<p>面试前通常会要求做个简要的个人介绍。个人介绍通常作为进入面试的前奏曲和缓冲阶段，缓和下紧张气氛。</p>
<p>我最开始的个人介绍，个性啊业余生活啊工作经历啊志趣啊等等，似乎不知道该说些什么。实际上，个人介绍是一个充分展示自己的主页。主页应当让自己最最核心的优势一目了然（需要挖掘自己的经历并仔细提炼）。我现在的个人介绍一般会包括：个性（比如偏安静）、做事风格（工作认真严谨、注重质量、善于整体思考）、最大优势（owner 意识、执行力、工程把控能力）、工作经历简述（在每个公司的工作负责什么、贡献了什么、收获了什么）。个人介绍简明扼要，无需赘言。</p>
<p>个人介绍，是对自己的一个更为清晰、深入和全面的认识契机。</p>
<h3 id="公司了解"> 公司了解</h3>
<p>很多人可能跟我一样，对公司业务了解甚少，就直接投出去了。这样其实是不合理的。首先，我个人是不赞成海投的，而倾向于定向投。找准方向投，虽然目标更少，但更有效率。这跟租房一样，我一般在豆瓣上租房，虽然目标源少，但逮着一个就是好运。</p>
<p>投一家公司，是因为这家公司符合意向，值得争取，而不是因为这是一家公司。就像找对象，不是为了找一个女人。要确定这家公司是否符合意向，就应当多去了解这家公司：主营业务、未来发展及规划、所在行业及地位、财务状况、业界及网络评价等。</p>
<p>在面试的过程中适当谈到公司的业务及思考，是可加分项。亦可用于“你有什么想问的？”的提问。</p>
<h3 id="技术探索"> 技术探索</h3>
<p>技术能力是一个技术人的基本素养。因此，我觉得，无论未来做什么工作，技术能力过硬，总归是最不可或缺的不可忽视的。</p>
<p>原理和设计思想是软件技术中最为精髓的东西。一般软件技术可以分为两个方面：</p>
<ul>
<li>原理：事物如何工作的基本规律和流程；</li>
<li>架构：如何组织大规模逻辑的艺术。</li>
</ul>
<p><strong>技术探索，一定要先理解原理。原理不懂，就会浮于表层，不能真正掌握它。技术原理探究要掌握到什么程度？数据结构与算法设计、考量因素、技术机制、优化思路。要在脑中回放，直到一切细节而清晰可见。如果能够清晰有条理地表述出来，就更好了。</strong></p>
<p><strong>技术原理探究，一定要看源码。看了源码与没看源码是有区别的。没看源码，虽然说得出来，但终是隔了一层纸；看了源码，才捅破了那层纸，有了自己的理解，也就能说得更加有底气了。当然，也可能是我缺乏演戏的本领。</strong></p>
<p>我个人不太赞成刷题式面试。虽然刷题确实是进厂的捷径，但也有缺点：</p>
<ul>
<li>它依然是别人的知识体系，而不是自己总结的知识体系；</li>
<li>技术探究是为了未来的工作准备，而不是为了应对一时之需，否则即使进去了还是会处于麻痹状态。</li>
</ul>
<p>经过系统的整理，我逐步形成了适合自己的技术体系结构：<a href="https://www.cnblogs.com/lovesqcc/p/13633409.html" target="_blank" rel="noopener noreferrer">“互联网应用服务端的常用技术思想与机制纲要”</a> 。在这个基础上，再博采众长，看看面试题进行自测和查漏补缺，是更恰当的方式。我会在这个体系上深耕细作。</p>
<h3 id="表述能力"> 表述能力</h3>
<p>目前，绝大多数企业的主要面试形式是通过口头沟通进行的，少部分企业可能有笔试或机试。口头沟通的形式是有其局限性的。对表述能力的要求比较高，而对专业能力的凸显并不明显。一个人掌握的专业和经验的深度和广度，很难通过几分钟的表述呈现出来。往往深度和广度越大，反而越难表述。而技术人员往往疏于表达。</p>
<p>我平时写得多说得少，说起来不利索。有时没讲清楚背景，就直接展开，兼之啰嗦、跳跃和回旋往复（这种方式可能更适合写小说），让面试官有时摸不着头脑。表述的条理性和清晰性也是很重要的。不妨自己测试一下：Dubbo 的架构设计是怎样的？ Redis 的持久化机制是怎样的？然后自己回答试试看。</p>
<p>表述能力的基本法则：</p>
<ul>
<li>先总后分，先整体后局部；</li>
<li>先说基本思路，然后说优化；</li>
<li>体现互动。先综述，然后向面试官询问要听哪方面，再分述。避免自己一脑瓜子倾倒出来，让面试官猝不及防；系统设计的场景题，多问一些要求，比如时间要求、空间要求、要支持多大数据量或并发量、是否要考虑某些情况等。</li>
</ul>
<h3 id="常见问题"> 常见问题</h3>
<p>面试是通过沟通来理解双方的过程。面试中的问题，千变万化，但有一些问题是需要提前准备好的。</p>
<p>比如“灵魂 N 问”：</p>
<ul>
<li>你为什么从 XXX 离职？</li>
<li>你的期望薪资是多少？</li>
<li>你有一段空档期，能解释下怎么回事么？</li>
<li>你的职业规划是怎样的？</li>
</ul>
<p>高频技术问题：</p>
<ul>
<li>基础：数据结构与算法、网络；</li>
<li>微服务：技术体系、组件、基础设施等；</li>
<li>Dubbo：Dubbo 整体架构、扩展机制、服务暴露、引用、调用、优雅停机等；</li>
<li>MySQL：索引与事务的实现原理、SQL 优化、分库分表；</li>
<li>Redis : 数据结构、缓存、分布式锁、持久化机制、复制机制；</li>
<li>分布式：分布式事务、一致性问题；</li>
<li>消息中间件：原理、对比；</li>
<li>架构： 架构设计方法、架构经验、设计模式；</li>
<li>性能优化： JVM、GC、应用层面的性能优化；</li>
<li>并发基础：ConcurrentHashMap, AQS, CAS，线程池等；</li>
<li>高并发：IO 多路复用；缓存问题及方案；</li>
<li>稳定性：稳定性的思想及经验；</li>
<li>生产问题：工具及排查方法。</li>
</ul>
<h3 id="中高端职位"> 中高端职位</h3>
<p>说起来，我这人可能有点不太自信。我是怀着“踏实做一个工程师”的思想投简历的。</p>
<p>对于大龄程序员，企业的期望更高。我的每一份“高级工程师”投递，自动被转换为“技术专家”或“架构师”。无力反驳，倍感压力。面试中高端职位，需要更多准备：</p>
<ul>
<li>你有带团队经历吗？</li>
<li>在你 X 年的工作经历中，有多少时间用于架构设计？</li>
<li>架构过程是怎样的？你有哪些架构设计思想或方法论？</li>
</ul>
<p>如果不作准备，就被一下子问懵，乱了阵脚。实际上，我或许还是存着侥幸心理把“技术专家”和“架构师”岗位当做“高工”来面试的，也就无一不遭遇失败了。显然，我把次序弄反了：应当以“技术专家”和“架构师”的规格来面试高级工程师。</p>
<p>好吧，那就迎难而上吧！我不是惧怕挑战的人。</p>
<p>此外，“技术专家”和“架构师”职位应当至少留一天的时间来准备。已经有丰富经验的技术专家和架构师可以忽略。</p>
<h3 id="好的心态"> 好的心态</h3>
<p>保持好的心态也尤为重要。我经历了“乐观-不自信-重拾信心”的心态变化过程。</p>
<p>很长一段时间，由于“求成心切”，生怕某个技术问题回答不上来搞砸，因此小心谨慎，略显紧张，结果已经梳理好的往往说不清楚或者说得不够有条理。冲着“拿 offer ”的心态去面试，真的很难受，会觉得每场面试都很被动那么难过，甚至有点想要“降格以求”。</p>
<p>有时，我在想：咋就混成这个样子了呢？按理来说，这个时候我应该有能力去追求自己喜爱的事业了啊！还是平时有点松懈了，视野狭窄，积累不够，导致今天的不利处境。</p>
<p>我是一个守时的人，也希望对方尽可能守时。杭州的面试官中，基本是守时的，即使迟到也在心理接受范围内，回武汉面试后，节奏就有点被少量企业带偏了。有一两次，我甚至不确定面试官什么时候进入会议。我想，难道这是人才应该受到的“礼待”吗？我有点被轻微冒犯的感觉了。不过我还是“很有涵养地”表示没事。但我始终觉得：面试官迟到，是对人才的不尊重。进入不尊重人才的公司，我是怀有疑虑的。良禽择木而栖，良臣择主而事。难道我能因为此刻的不利处境，而放弃一些基本的原则底线，而屈从于一份不尊重人才的 offer 吗？</p>
<p>我意识到：一个人应当用其实力去赢得对方的尊重和赏识，以后的合作才会更顺畅。不若，哪怕惜其无缘，亦不可强留。无论别人怎么存疑，心无旁骛地打磨实力，挖掘自己的才干和优势，终会发出自己的光芒。因此，我的心态顿时转变了：应当专注去沟通，与对方充分认识了解，赢得对方心服的认可，而不是拿到一张入门券，成为干活的工具。</p>
<p>有一个“石头和玉”的小故事，把自己当做人才，并努力去提升自己，才能获得“人才的礼遇”；把自己当石头贱卖，放松努力，也就只能得到“石头的礼遇”。尽管一个人不一定马上就具备人才的能力，但在自己的内心里，就应当从人才的视角去观察待入职的企业，而不仅仅是为了找一份“赚更多钱”的工作。</p>
<p>此外，焦虑也是不必要的。焦虑的实质是现实与目标的差距。一个人总可以评估目标的合理性及如何达成目标。如果目标过高，则适当调整目标级别；目标可行，则作出合理的决策，并通过持续的努力和恰当的出击来实现目标。决策、努力和出击能力都是可以持续修炼的。</p>
<h2 id="面试历炼"> 面试历炼</h2>
<p>技术人的面试还是更偏重于技术，因此，技术的深度和广度还是要好好准备的。面试官和候选人的处境是不一样的，一个面试官问的只是少量点，但是多个面试官合起来就是一个面。明白这一点，作为面试官的你就不要忘乎所以，以为自己就比候选人厉害。</p>
<p>我面的企业不多，因为我已经打算从事教育事业，用“志趣和驱动力”这项就直接过滤了很多企业的面试邀请。在杭州面试的基本是教育企业，连阿里华为等抛来的橄榄枝都婉拒了（尽管我也不一定能面上）。虽然做法有点“直男”，但投入最多精力于自己期望从事的行业和事业，才是值得的。</p>
<p>我所认为的教育事业，并不局限于现在常谈起的在线教育或 K12 教育，而是一个教育体系，任何可以更好滴起到教育效果的事业，包括而不限于教学、阅读、音乐、设计等。</p>
<h3 id="接力棒科技-高工"> 接力棒科技-高工</h3>
<p>面的第一家。畅谈一番后，没音讯了。但我也没有太在意。面试官问的比较偏交易业务性的东西，较深的就是如何保证应用的数据一致性了。</p>
<p>此时的我，就像在路上扔了一颗探路的小石子，尚未意识到自己的处境。</p>
<h3 id="网易云音乐-高工"> 网易云音乐-高工</h3>
<p>接着是网易云音乐。大厂就是大厂。一面问的尽是缓存、分布式锁、Dubbo、ZK， MQ 中间件相关的机制。很遗憾，由于我平时关于技术原理的沉淀还是很少，基本是“一问两不知”，挂得很出彩。</p>
<p>此时，我初步意识到自己的技术底子还很薄弱，也就开始了广阔的技术学习和夯实，自底向上地梳理原理和逻辑，系统地进行整理总结，最终初步形成了自己的互联网服务端技术知识体系结构。</p>
<h3 id="铭师堂-技术专家"> 铭师堂-技术专家</h3>
<p>架构师面试的。问的相对多了一些，DB, Redis 等。反馈是技术还行，但缺乏管理经验。这是我第一次意识到大龄程序员缺乏管理经验的不利。中小企业的技术专家线招聘中，往往附加了管理经验的需求。应聘时要注意。</p>
<p>缺乏管理经验，该怎么办呢？思考过一段时间后，我的想法是：</p>
<ul>
<li>改变能改变的，不能改变的，学习它。比如技术原理的学习是我能够改变的，但管理经验属于难以一时改变的，那就多了解点管理的基本理论吧。</li>
<li>从经历中挖掘相关经验。虽然我没有正式带团队的实际经验，但是有带项目和带工程师，管控某个业务线的基本管理经验。多多挖掘自己的经历。</li>
</ul>
<h3 id="字节教育-高工"> 字节教育-高工</h3>
<p>字节教育面试，我给自己挖了不少坑往里跳。</p>
<p>比如面试官问，讲一个你比较成就感的项目经历。我选择的是近 4 年前的周期购项目。虽然这是我入职有赞的第一个有代表性的项目，但时间太久，又没有详细记录，很多技术细节遗忘不清晰了。我讲到当时印象比较深的“一体化”设计思想，却忘记了当时为什么会有这种思想（未做仔细记录）。</p>
<p>再比如，一个上课的场景题，我问是用 CS 架构还是 BS 架构？面试官说用 CS 架构吧。这不是给自己挖坑吗？明明自己不熟悉 CS 架构，何必问这个选择呢，不如直接按照 BS 架构来讲解。哎！</p>
<p>字节教育给我的反馈是：业务 Sense 不错，系统设计能力有待提高。我觉得还是比较中肯的。因此，也开始注重系统设计实战方面的文章阅读和思考训练。</p>
<p>经验是：</p>
<ul>
<li>做项目时，要详细记录每个项目的技术栈、技术决策及原因、技术细节，为面试做好铺垫；</li>
<li>提前准备好印象最深刻的最代表性的系统和项目，避免选择距离当前时间较久的缺乏详细记录的项目；</li>
<li>选择熟悉的项目和架构，至少有好的第一印象，不然给面试官的印象就是你啥都不会。</li>
</ul>
<h3 id="咪咕数媒-架构师"> 咪咕数媒-架构师</h3>
<p>好家伙，一下子 3 位面试官群面。可能我以前经历的太少了吧。似乎国企面试较高端职位，喜欢采取这种形式。兼听则明偏听则暗嘛。问的问题也很广泛，从 ES 的基本原理，到机房的数据迁移。有些技术机制虽然学习过，但不牢固，不清晰，答的也不好。比如 ES 的搜索原理优化，讲过倒排索引后，我对 Term Index 和 Trie 树 讲不清楚。这说明，知道并不代表真正理解了。只有能够清晰有条理地把思路和细节都讲清楚，才算是真正理解了。</p>
<p>印象深刻的是，有一个问题：你有哪些架构思想？这是第一次被问到架构设计方面的东西，我顿时有点慌乱。虽然平时多有思考，也有写过文章，却没有形成系统精炼的方法论，结果就是答的比较凌乱。</p>
<h3 id="涂鸦智能-高工"> 涂鸦智能-高工</h3>
<p>应聘涂鸦智能，是因为我觉得这家企业不错。优秀的企业至少应该多沟通一下，说不准以后有合作机会呢！看问题的思维要开阔一些，不能死守在自己想到的那一个事情上。</p>
<p>涂鸦智能给我的整体观感还是不错的。面试官也很有礼貌有耐心，整体架构、技术和项目都问了很多，问到了我熟悉的地方，答得也还可以。也许我的经验正好是切中他们的需求吧。</p>
<p>若不是当时想做教育的执念特别强，我很大概率会入职涂鸦智能。物联网在我看来应该是很有趣的领域。</p>
<h3 id="跟谁学-技术专家"> 跟谁学-技术专家</h3>
<p>“跟谁学”基本能答上来。不过反馈是：对于提问抓重点的能力有所欠缺，对于技术的归纳整理也不够。我当时还有点不服气，认为自己写了那么多文章，也算是有不少思考，怎能算是总结不够呢？顶多是有技术盲点。技术犹如海洋，谁能没有盲点？</p>
<p>不过现在反观，确实距离自己应该有的程度不够。对技术原理机制和生产问题排查的总结不够，不够清晰细致；对设计实践的经验总结也不够，不够系统扎实。这个事情还要持续深入地去做。</p>
<p>此外，面得越多，越发现自己的表述能力确实有所欠缺。啰嗦、容易就一点展开说个没完、脱离背景直接说方案、跳跃、回旋往复，然后面试官很可能没耐心了。应该遵循“先总后分”、“基本思路-实现-优化”的一些基本逻辑来作答会更好一些。表述能力真的很重要，不可只顾着敲代码。还有每次面教育企业就不免紧张，生怕错过这个机会。</p>
<p>这是第二家直接告诉我年龄与经验不匹配的企业，加深了我对年龄偏大的忧虑，以致于开始有点不自信了。</p>
<p>那么我又是怎么重拾信心的呢？有一句老话：“留得青山在，不怕没柴烧”。就算我年龄比较大，如果我的技术能力打磨得足够硬朗，就不信找不到一家能够认可我的企业。大不了我去做开源项目好了。具备好的技术能力，并不一定就局限在企业的范围内去发挥作用，也没必要局限于那些被年龄偏见所蒙蔽的人的认知里。外界的认可固然重要，内在的可贵性却远胜于外在。</p>
<h3 id="亿童文教-架构师"> 亿童文教-架构师</h3>
<p>也是采用的 3 人同时面试。主要问的是项目经历，技术方面问得倒不是深入。个人觉得答得还行。面试官也问了架构设计相关的问题，我答得一般。此时，我仍然没有意识到自己在以面“高级工程师”的规格来面试“架构师”岗位。</p>
<p>面试官比较温和，HR 也在积极联系和沟通，感觉还不错。只是，我没有主动去问反馈意见，也就没有下文了。</p>
<h3 id="新东方-高工"> 新东方-高工</h3>
<p>面试新东方，主要是因为切中我做教育的期望，虽然职位需求是做信息管理系统，距离我理想中的业务还有一定距离。经过沟通了解，他们更需要的是对运维方面更熟悉的工程师，不过我正好对运维方面不太熟悉，平时关注不多，因此不太符合他们的真实招聘要求。面试官也是很温和的人，老家在宜昌，是我本科上大学的地方，面试体验不错。</p>
<p>以后要花些时间学习一些运维相关的东西。作为一名优秀的工程师和合格的架构师，是要广泛学习和熟悉系统所采用的各种组件、中间件、运维部署等的。要有综观能力，不过我醒悟的可能有点迟。Better later than never.</p>
<h3 id="zoom-高工"> ZOOM-高工</h3>
<p>ZOOM 的一位面试官或许是我见过的所有面试官中最差劲的。共有两位面试官，一位显得很有耐心，另一位则挺着胖胖的肚子，还打着哈欠，一副不怎么关心面试和候选人的样子。我心想，你要不想面，为啥还要来面呢？你以为候选人就低你一等么？换个位置我可以暴打你。不过我还是很有礼貌的，当做什么事也没发生。公司在挑人，候选人也在挑选公司。</p>
<p>想想，ZOOM 还是疫情期间我们公司用过的远程通信会议软件。印象还不错，有这样的工程师和面试官藏于其中，我也是服了。难倒他是传说中的大大神？据我所知，国外对国内的互联网软件技术设施基本呈碾压态势，中国大部分企业所用的框架、中间件、基础设施等基本是拿国外的来用或者做定制化，真正有自研的很少，有什么好自满的呢？</p>
<h3 id="阿优文化-高工"> 阿优文化-高工</h3>
<p>阿优文化有四轮技术面。其中第一个技术面给我印象比较深刻。看上去，面试官对操作系统的原理机制特别擅长和熟悉。很多问题我都没答上来。本以为挂了，不过又给了扳回一局的机会。第二位面试问的项目经历和技术问题是我很熟悉的。第三位面试官问的比较广泛，有答的上来的，有答不上来的。不过面试官很耐心。第四位是技术总监，也问得很广泛细致。</p>
<p>整体来说，面试氛围还是很宽松的。不过，阿优当时的招聘需求并不强烈，估计是希望后续有机会时再联系我。可惜我那时准备回武汉了。主要是考虑父母年事已高，希望能多陪陪父母。</p>
<p>想想，我想问题做决策还是过于简单的，不会做很复杂的计算和权衡。</p>
<h3 id="小米-专家-架构"> 小米-专家/架构</h3>
<p>应聘小米，主要是因为职位与之前在有赞做的很相似，都是做交易中台相关。浏览小米官网之后，觉得他们做的事情很棒，可是与我想做教育文化事业的初衷不太贴合。</p>
<p>加入小米的意愿不太强烈，面试也就失去了大半动力。我这个性子还是要改一改。</p>
<h3 id="视觉中国-高工"> 视觉中国-高工</h3>
<p>围绕技术、项目和经历来问。总体来说，技术深度并不是太难，项目方面也涉及到了。人力面前辈很温和，我以为会针对自己的经历进行一番“轰炸”，结果是为前辈讲了讲有赞的产品服务和生意模式，然后略略带了下自己的一些经历。</p>
<h3 id="科大讯飞-架构师"> 科大讯飞-架构师</h3>
<p>一二面，感觉面试官对安排的面试不太感兴趣。架构师，至少是一个对技术和设计能力非常高要求的职位。一面的技术和架构都问了些，二面总围绕我的背景和非技术相关的东西问，似乎对我的外在更关注，而对我自身的技术和设计能力不感兴趣。交流偏浅。</p>
<p>能力固然有高下之分，但尊重人才的基本礼节却是不变的。尊重人才，是指聚焦人才的能力和才学，而不是一些与才学不甚相关的东西。</p>
<h3 id="青藤云-高工"> 青藤云-高工</h3>
<p>青藤云的技术面试风格是温和的。感受到坦率交流的味道，被认可的感觉。感受到 HR 求才若渴的心情。和我之前认为的“应当用其实力去赢得对方的尊重和赏识”不谋而合。</p>
<h3 id="腾讯会议-高工"> 腾讯会议-高工</h3>
<p>和腾讯面试官是用腾讯会议软件面试腾讯会议的职位。哈哈。由于网络不太稳定，面试过程充满了磕磕碰碰，一句话没说完整就听不清楚了。可想情况如何。但是我们都很有很有很有耐心，最终一起完成了一面。面试是双方智慧与力量的较量，更是双方一起去完成一件事情、发现彼此的合作。这样想来，传统的“单方考验筛选式”的面试观念需要革新。</p>
<p>由于我已经拿到 offer , 且腾讯会议的事情并不太贴合自己的初衷，因此，我与腾讯方面沟通，停止了二面。</p>
<h3 id="最终选择"> 最终选择</h3>
<p>当拿到多个 offer 时，如何选择呢？我个人主要看重：</p>
<ol>
<li>志趣与驱动力；</li>
<li>薪资待遇；</li>
<li>公司发展前景和个人发展空间；</li>
<li>工作氛围；</li>
<li>小而有战斗力的企业。</li>
</ol>
<p>在视觉中国与青藤云之间如何选择？作个对比：</p>
<ul>
<li>薪资待遇：两者的薪资待遇不相上下，也都是认可我的；视觉中国给出的是 Leader 的职位，而青藤云给出的是核心业务的承诺；</li>
<li>工作氛围：青藤云应该更偏工程师文化氛围，而视觉中国更偏业务化；</li>
<li>挑战性：青藤云的技术挑战更强，而视觉中国的业务挑战性更强；</li>
<li>志趣与驱动力：视觉中国更符合我想做文化的事情，而青藤云安全并不贴合我想做教育文化事业的初衷，而且比较偏技术和底层（我更希望做一些人文性的事情）。但青藤云做的是关于安全的事情，安全是一件很有价值很有意义的事情。而且，以后安全也可以服务于教育行业。有点曲线救国的味道。尤其是创始人张福的理想主义信念“让安全之光照亮互联网的每个角落”及自己的身体力行，让人更有一些触动。最终，我觉得做安全比做图片版权保护稍胜出一小筹。</li>
</ul>
<p>此外，我觉得做教育，更适合自己的是编程教育，或者是工程师教育。我还想成为一名系统设计师。还需要积累更多生产实践经验。可以多与初中级工程师打交道，在企业内部做培训指导。或者工作之余录制视频，上传到 B 站，服务广大吃瓜群众。将来，我或许还会写一本关于编程设计的书，汇聚毕生所学。</p>
<p>因此，经过一天慎重的考虑，我决定，加入青藤云安全。当然，做这个选择的同时，也意味着我选择了一个更大的挑战：在安全方面我基本一穷二白，需要学习很多很多的知识和经验，对于我这个大龄程序员来说，是一项不小的挑战。</p>
<h2 id="小结"> 小结</h2>
<p>很多事情都有解决的方法，即使“头疼的”大龄程序员找工作也不例外。确立明确清晰的目标、制定科学合理的决策、持续的努力、掌握基本面、恰当的出击，终能斩获胜利的果实。但要强调一下：功夫在平时。平时要是不累积好，面试的时候就要花更多时间去学习，会受挫、磕磕碰碰、过得也不太舒坦。还是平摊到平时比较好。此外，平时视野也要保持开阔，切忌在面试的时候才“幡然醒悟”。</p>
<p>一个重要经验是，要善于从失败中学习。正是在杭州四个月空档期的持续学习、思考、积累和提炼，以及面试失败的反思、不断调整对策、完善准备、改善原有的短板，采取更为合理的方式，才在回武汉的短短两个周内拿到比较满意的 offer 。</p>
<p>此外，值得提及的是，对于技术人员，写博客是一件很有价值的事情。面试通过沟通去了解对方，有其局限性所在。面试未能筛选出符合的人才其实是有比较大概率的：</p>
<ol>
<li>面试的时间很短，即使是很有经验的面试官，也会看走眼（根本局限性）；</li>
<li>面试官问到的正好是自己不会的（运气问题）；</li>
<li>面试官情绪不好，没兴趣（运气问题）；</li>
<li>面试官自身的水平。</li>
</ol>
<p>因此，具备真才实学而被 PASS 掉，并不值得伤心。写博客的意义在于，有更多展示自己思考和平时工作的维度。</p>
<p>尊重人才的企业，一定是希望从多方面去认识候选人（在优点和缺点之间选择确认是否符合期望），包括博客；不尊重人才的企业，则会倾向于用偷懒的方法，对候选人真实的本领不在意，用一些外在的标准去快速过滤，固然高效，最终对人才的识别能力并不会有多大进步。</p>
<p>经过这一段面试的历炼，我觉得现在相比离职时的自己，又有了不少进步的。不说脱胎换骨，至少也是蜕了一层皮吧。差距，差距还是有的。起码面试那些知名大厂企业的技术专家和架构师还有差距。这与我平时工作的挑战性、认知视野的局限性及总结不足有关。下一次，我希望积蓄足够实力做到更好，和内心热爱的有价值有意义的事情再近一些些。</p>
<p>面试，其实也是一段工作经历。</p>
]]></content:encoded>
    </item>
    <item>
      <title>新入职一家公司如何快速进入工作状态</title>
      <link>https://javaguide.cn/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company/</link>
      <guid>https://javaguide.cn/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company/</guid>
      <source url="https://javaguide.cn/rss.xml">新入职一家公司如何快速进入工作状态</source>
      <category>技术文章精选集</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>强烈建议每一位即将入职/在职的小伙伴看看这篇文章，看完之后可以帮助你少踩很多坑。整篇文章逻辑清晰，内容全面！</p>
<p>我对原文进行了内容和排版完善。</p>
<p><strong>原文地址</strong> ：https://www.cnblogs.com/hunternet/p/14675348.html</p>
</blockquote>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/新入职一家公司如何快速进入状态.png" alt="新入职一家公司如何快速进入状态" /></p>
<p>一年一度的金三银四跳槽大戏即将落幕，相信很多跳槽的小伙伴们已经找到了心仪的工作，即将或已经有了新的开始。</p>
<p>相信有过跳槽经验的小伙伴们都知道，每到一个新的公司面临的可能都是新的业务、新的技术、新的团队......这些可能会打破你原来工作思维、编码习惯、合作方式......</p>
<p>而于公司而言，又不能给你几个月的时间去慢慢的熟悉。这个时候，如何快速进入工作状态，尽快发挥自己的价值是非常重要的。</p>
<p>有些人可能会很幸运，入职的公司会有完善的流程与机制，通过一带一、各种培训等方式可以在短时间内快速的让新人进入工作状态。有些人可能就没有那么幸运了，就比如我在几年前跳槽进入某厂的时候，当时还没有像我们现在这么完善的带新人融入的机制，又赶上团队最忙的一段时间，刚一入职的当天下午就让给了我几个线上问题去排查，也没有任何的文档和培训。遇到情况，很多人可能会因为难以快速适应，最终承受不起压力而萌生退意。</p>
<p><img src="https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/bad175e3a380bea..jpg" alt="bad175e3a380bea." /></p>
<p>那么，<strong>我们应该如何去快速的让自己进入工作状态，适应新的工作节奏呢？</strong></p>
<p>新的工作面对着一堆的代码仓库，很多人常常感觉无从下手。但回顾一下自己过往的工作与项目的经验，我们可以发现它们有着异曲同工之处。当开始一个新的项目，一般会经历几个步骤：需求-&gt;设计-&gt;开发-&gt;测试-&gt;发布，就这么循环往复，我们完成了一个又一个的项目。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/项目流程.png" alt="项目流程" /></p>
<p>而在这个过程中主要有四个方面的知识那就是业务、技术、项目与团队贯穿始终。新入职一家公司，我们第一阶段的目标就是要具备能够跟着团队做项目的能力，因此我们所应尽快掌握的知识点也要从这四个方面入手。</p>
<h2 id="业务"> 业务</h2>
<p>很多人可能会认为作为一个技术人，最应该了解的不应该是技术吗？于是他们在进入一家公司后，就迫不及待的研究起来了一些技术文档，系统架构，甚至抱起来源代码就开始“啃”，如果你也是这么做的，那就大错特错了！在几乎所有的公司里，技术都是作为一个工具存在的，虽然它很重要，但是它也是为了承载业务所存在的，技术解决了如何做的问题，而业务却告诉我们，做什么，为什么做。一旦脱离了业务，那么技术的存在将毫无意义。</p>
<p>想要了解业务，有两个非常重要的方式</p>
<p><strong>一是靠问</strong></p>
<p>如果你加入的团队，有着完善的业务培训机制，详尽的需求文档，也许你不需要过多的询问就可以了解业务，但这只是理想中的情况，大多数公司是没有这个条件的。因此我们只能靠问。</p>
<p>这里不得不提的是，作为一个新人一定要有一定的脸皮厚度，不懂就要问。我见过很多新人会因为内向、腼腆，遇到疑问总是不好意思去问，这导致他们很长一段时间都难以融入团队、承担更重要的责任。不怕要怕挨训、怕被怼，而且我相信绝对多数的程序员还是很好沟通的！</p>
<p><strong>二是靠测试</strong></p>
<p>我认为测试绝对是一个人快速了解团队业务的方式。通过测试我们可以走一走自己团队所负责项目的整体流程，如果遇到自己走不下去或想不通的地方及时去问，在这个过程中我们自然而然的就可以快速的了解到核心的业务流程。</p>
<p>在了解业务的过程中，我们应该注意的是不要让自己过多的去追求细节，我们的目的是先能够整体了解业务流程，我们面向哪些用户，提供了哪些服务......</p>
<h2 id="技术"> 技术</h2>
<p>在我们初步了解完业务之后，就该到技术了，也许你已经按捺不住翻开源代码的准备了，但还是要先提醒你一句先不要着急。</p>
<p>这个时候我们应该先按照自己了解到的业务，结合自己过往的工作经验去思考一下如果是自己去实现这个系统，应该如何去做？这一步很重要，它可以在后面我们具体去了解系统的技术实现的时候去对比一下与自己的实现思路有哪些差异，为什么会有这些差异，哪些更好，哪些不好，对于不好我们可以提出自己的意见，对于更好的我们可以吸收学习为己用！</p>
<p>接下来，我们就是要了解技术了，但也不是一上来就去翻源代码。 <strong>应该按照从宏观到细节，由外而内逐步地对系统进行分析。</strong></p>
<p>首先，我们应该简单的了解一下 <strong>自己团队/项目的所用到的技术栈</strong> ，Java 还是.NET、亦或是多种语言并存，项目是前后端分离还是服务端全包，使用的数据库是 MySQL 还是 PostgreSQL......，这样我们可能会对所用到的技术和框架，以及自己所负责的内容有一定的预期，这一点有的人可能在面试的时候就会简单了解过。</p>
<p>下一步，我们应该了解的是 <strong>系统的宏观业务架构</strong> 。自己的团队主要负责哪些系统，每个系统又主要包含哪些模块，又与哪些外部系统进行交互......对于这些，最好可以通过流程图或者思维导图等方式整理出来。</p>
<p>然后，我们要做的是看一下 <strong>自己的团队提供了哪些对外的接口或者服务</strong> 。每个接口和服务所提供功能是什么。这一点我们可以继续去测试自己的系统，这个时候我们要看一看主要流程中主要包含了哪些页面，每个页面又调用了后端的哪些接口，每个后端接口又对应着哪个代码仓库。(如果是单纯做后端服务的，可以看一下我们提供了哪些服务，又有哪些上游服务，每个上游服务调用自己团队的哪些服务......)，同样我们应该用画图的形式整理出来。</p>
<p>接着，我们要了解一下 <strong>自己的系统或服务又依赖了哪些外部服务</strong> ，也就是说需要哪些外部系统的支持，这些服务也许是团队之外、公司之外，也可能是其他公司提供的。这个时候我们可以简单的进入代码看一下与外部系统的交互是怎么做的，包括通讯框架(REST、RPC)、通讯协议......</p>
<p>到了代码层面，我们首先应该了解每个模块代码的层次结构，一个模块分了多少层，每个层次的职责是什么，了解了这个就对系统的整个设计有了初步的概念，紧接着就是代码的目录结构、配置文件的位置。</p>
<p>最后，我们可以寻找一个示例，可以是一个接口，一个页面，让我们的思路跟随者代码的运行的路线，从入参到出参，完整的走一遍来验证一下我们之前的了解。</p>
<p>到了这里我们对于技术层面的了解就可以先告一段落了，我们的目的知识对系统有一个初步的认知，更细节的东西，后面我们会有大把的时间去了解</p>
<h2 id="项目与团队"> 项目与团队</h2>
<p>上面我们提到，新入职一家公司，第一阶段的目标是有跟着团队做项目的能力，接下来我们要了解的就是项目是如何运作的。</p>
<p>我们应该把握从需求设计到代码编写入库最终到发布上线的整个过程中的一些关键点。例如项目采用敏捷还是瀑布的模式，一个迭代周期是多长，需求的来源以及展现形式，有没有需求评审，代码的编写规范是什么，编写完成后如何构建，如何入库，有没有提交规范，如何交付测试，发布前的准备是什么，发布工具如何使用......</p>
<p>关于项目我们只需要观察同事，或者自己亲身经历一个迭代的开发，就能够大概了解清楚。</p>
<p>在了解项目运作的同时，我们还应该去了解团队，同样我们应该先从外部开始，我们对接了哪些外部团队，比如需求从哪里来，是否对接公司外部的团队，提供服务的上游团队有哪些，依赖的下游团队有哪些，团队之间如何沟通，常用的沟通方式是什么.......</p>
<p>接下来则是团队内部，团队中有哪些角色，每个人的职责是什么，这样遇到问题我们也可以清楚的找到对应的同事寻求帮助。是否有一些定期的活动与会议，例如每日站会、周例会，是否有一些约定俗成的规矩，是否有一些内部评审，分享机制......</p>
<h2 id="总结"> 总结</h2>
<p>新入职一家公司，面临新的工作挑战，能够尽快进入工作状态，实现自己的价值，将会给你带来一个好的开始。</p>
<p>作为一个程序员，能够尽快进入工作状态，意味着我们首先应该具备跟着团队做项目的能力，这里我站在了一个后端开发的角度上从业务、技术、项目与团队四个方面总结了一些方法和经验。</p>
<p>关于如何快速进入工作状态，如果你有好的方法与建议，欢迎在评论区留言。</p>
<p>最后我们用一张思维导图来回顾一下这篇文章的内容。如果你觉得这篇文章对你有所帮助，可以关注文末公众号，我会经常分享一些自己成长过程中的经验与心得，与大家一起学习与进步。</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/%E6%96%B0%E5%85%A5%E8%81%8C%E4%B8%80%E5%AE%B6%E5%85%AC%E5%8F%B8%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%BF%9B%E5%85%A5%E7%8A%B6%E6%80%81.png" type="image/png"/>
    </item>
    <item>
      <title>我在滴滴和头条的两年后端研发工作经验分享</title>
      <link>https://javaguide.cn/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi&amp;toutiao/</link>
      <guid>https://javaguide.cn/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi&amp;toutiao/</guid>
      <source url="https://javaguide.cn/rss.xml">我在滴滴和头条的两年后端研发工作经验分享</source>
      <category>技术文章精选集</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>内容总结：</p>
<ul>
<li>要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。</li>
<li>积极学习，保持技术热情。如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了 35 岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？</li>
<li>在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。</li>
<li>脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。</li>
<li>想舔就舔，不想舔也没必要酸别人，Respect Greatness。</li>
<li>时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。</li>
<li>平时积极总结沉淀，多跟别人交流，形成方法论。</li>
<li>......</li>
</ul>
<p>原文地址：https://www.nowcoder.com/discuss/351805</p>
</blockquote>
<p>先简单交代一下背景吧，某不知名 985 的本硕，17 年毕业加入滴滴，当时找工作时候也是在牛客这里跟大家一起奋战的。今年下半年跳槽到了头条，一直从事后端研发相关的工作。之前没有实习经历，算是两年半的工作经验吧。这两年半之间完成了一次晋升，换了一家公司，有过开心满足的时光，也有过迷茫挣扎的日子，不过还算顺利地从一只职场小菜鸟转变为了一名资深划水员。在这个过程中，总结出了一些还算实用的划水经验，有些是自己领悟到的，有些是跟别人交流学到的，在这里跟大家分享一下。</p>
<h2 id="学会深入思考-总结沉淀"> 学会深入思考，总结沉淀</h2>
<p><strong>我想说的第一条就是要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。</strong></p>
<p><strong>先来说深入思考。</strong> 在程序员这个圈子里，常能听到一些言论：<em>“我这个工作一点技术含量都没有，每天就 CRUD，再写写 if-else，这 TM 能让我学到什么东西？”</em></p>
<p>抛开一部分调侃和戏谑的论调不谈，这可能确实是一部分同学的真实想法，至少曾经的我，就这么认为过。后来随着工作经验的积累，加上和一些高 level 的同学交流探讨之后，我发现这个想法其实是非常错误的。之所以出现没什么可学的这样的看法，基本上是思维懒惰的结果。<strong>任何一件看起来很不起眼的小事，只要进行深入思考，稍微纵向挖深或者横向拓宽一下，都是足以让人沉溺的知识海洋。</strong></p>
<p>举一个例子。某次有个同学跟我说，这周有个服务 OOM 了，查了一周发现有个地方 defer 写的有问题，改了几行代码上线修复了，周报都没法写。可能大家也遇到过这样的场景，还算是有一定的代表性。其实就查 bug 这件事来说，是一个发现问题，排查问题，解决问题的过程，包含了触发、定位、复现、根因、修复、复盘等诸多步骤，花了一周来做这件事，一定有不断尝试与纠错的过程，这里面其实就有很多思考的空间。比如说定位，如何缩小范围的？走了哪些弯路？用了哪些分析工具？比如说根因，可以研究的点起码有 linux 的 OOM，k8s 的 OOM，go 的内存管理，defer 机制，函数闭包的原理等等。如果这些真的都不涉及，仍然花了一周时间做这件事，那复盘应该会有很多思考，提出来几十个 WHY 没问题吧...</p>
<p><strong>再来说下总结沉淀。</strong> 这个我觉得也是大多数程序员比较欠缺的地方，只顾埋头干活，可以把一件事做的很好。但是几乎从来不做抽象总结，以至于工作好几年了，所掌握的知识还是零星的几点，不成体系，不仅容易遗忘，而且造成自己视野比较窄，看问题比较局限。适时地做一些总结沉淀是很重要的，这是一个从术到道的过程，会让自己看问题的角度更广，层次更高。遇到同类型的问题，可以按照总结好的方法论，系统化、层次化地推进和解决。</p>
<p>还是举一个例子。做后台服务，今天优化了 1G 内存，明天优化了 50%的读写耗时，是不是可以做一下性能优化的总结？比如说在应用层，可以管理服务对接的应用方，梳理他们访问的合理性；在架构层，可以做缓存、预处理、读写分离、异步、并行等等；在代码层，可以做的事情更多了，资源池化、对象复用、无锁化设计、大 key 拆分、延迟处理、编码压缩、gc 调优还有各种语言相关的高性能实践...等下次再遇到需要性能优化的场景，一整套思路立马就能套用过来了，剩下的就是工具和实操的事儿了。</p>
<p>还有的同学说了，我就每天跟 PM 撕撕逼，做做需求，也不做性能优化啊。先不讨论是否可以搞性能优化，单就做业务需求来讲，也有可以总结的地方。比如说，如何做系统建设？系统核心能力，系统边界，系统瓶颈，服务分层拆分，服务治理这些问题有思考过吗？每天跟 PM 讨论需求，那作为技术同学该如何培养产品思维，引导产品走向，如何做到架构先行于业务，这些问题也是可以思考和总结的吧。就想一下，连接手维护别人烂代码这种蛋疼的事情，都能让 Martin Fowler 整出来一套重构理论，还显得那么高大上，我们确实也没啥必要对自己的工作妄自菲薄...</p>
<p>所以说： <strong>学习和成长是一个自驱的过程，如果觉得没什么可学的，大概率并不是真的没什么可学的，而是因为自己太懒了，不仅是行动上太懒了，思维上也太懒了。可以多写技术文章，多分享，强迫自己去思考和总结，毕竟如果文章深度不够，大家也不好意思公开分享。</strong></p>
<h2 id="积极学习-保持技术热情"> 积极学习，保持技术热情</h2>
<p>最近两年在互联网圈里广泛传播的一种焦虑论叫做 35 岁程序员现象，大意是说程序员这个行业干到 35 岁就基本等着被裁员了。不可否认，互联网行业在这一点上确实不如公务员等体制内职业。但是，这个问题里 35 岁程序员并不是绝对生理意义上的 35 岁，应该是指那些工作十几年和工作两三年没什么太大区别的程序员。后面的工作基本是在吃老本，没有主动学习与充电，35 岁和 25 岁差不多，而且没有了 25 岁时对学习成长的渴望，反而添了家庭生活的诸多琐事，薪资要求往往也较高，在企业看来这确实是没什么竞争力。</p>
<p><strong>如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了 35 岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？</strong> 但是，<strong>学习这件事，其实是一个反人类的过程，这就需要我们强迫自己跳出自己的安逸区，主动学习，保持技术热情。</strong> 在滴滴时有一句话大概是，<strong>主动跳出自己的舒适区，感到挣扎与压力的时候，往往是黎明前的黑暗，那才是成长最快的时候。相反如果感觉自己每天都过得很安逸，工作只是在混时长，那可能真的是温水煮青蛙了。</strong></p>
<p>刚毕业的这段时间，往往空闲时间还比较多，正是努力学习技术的好时候。借助这段时间夯实基础，培养出良好的学习习惯，保持积极的学习态度，应该是受益终身的。至于如何高效率学习，网上有很多大牛写这样的帖子，到了公司后内网也能找到很多这样的分享，我就不多谈了。</p>
<p><strong><em>可以加入学习小组和技术社区，公司内和公司外的都可以，关注前沿技术。</em></strong></p>
<h2 id="主动承担-及时交流反馈"> 主动承担，及时交流反馈</h2>
<p>前两条还是从个人的角度出发来说的，希望大家可以提升个人能力，保持核心竞争力，但从公司角度来讲，公司招聘员工入职，最重要的是让员工创造出业务价值，为公司服务。虽然对于校招生一般都会有一定的培养体系，但实际上公司确实没有帮助我们成长的义务。</p>
<p><strong>在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。</strong></p>
<p>我当初刚入职的时候，基本就是 leader 给分配什么任务就把本职工作做好，然后就干自己的事了，几乎从来不主动去跟别人交流或者主动去思考些能帮助项目发展的点子。自以为把本职工作保质保量完成就行了，后来发现这么做其实是非常不够的，这只是最基本的要求。而有些同学的做法则是 leader 只需要同步一下最近要做什么方向，下面的一系列事情基本不需要 leader 操心了 ，这样的同学我是 leader 我也喜欢啊。入职后经常会听到的一个词叫 owner 意识，大概就是这个意思吧。</p>
<p>在这个过程中，另外很重要的一点就是及时向上沟通反馈。项目进展不顺利，遇到什么问题，及时跟 leader 同步，技术方案拿捏不准可以跟 leader 探讨，一些资源协调不了可以找 leader 帮忙，不要有太多顾忌，认为这些会太麻烦，leader 其实就是干这个事的。。如果项目进展比较顺利，确实也不需要 leader 介入，那也需要及时把项目的进度，取得的收益及时反馈，自己有什么想法也提出来探讨，问问 leader 对当前进展的建议，还有哪些地方需要改进，消除信息误差。做这些事一方面是合理利用 leader 的各种资源，另一方面也可以让 leader 了解到自己的工作量，对项目整体有所把控，毕竟 leader 也有 leader，也是要汇报的。可能算是大家比较反感的向上管理吧，有内味了，这个其实我也做得不好。但是最基本的一点，不要接了一个任务闷着头干活甚至与世隔绝了，一个月了也没跟 leader 同步过，想着憋个大招之类的，那基本凉凉。</p>
<p><strong>一定要主动，可以先从强迫自己在各种公开场合发言开始，有问题或想法及时 one-one。</strong></p>
<p>除了以上几点，还有一些小点我觉得也是比较重要的，列在下面：</p>
<h2 id="第一件事建立信任"> 第一件事建立信任</h2>
<p>无论是校招还是社招，刚入职的第一件事是非常重要的，直接决定了 leader 和同事对自己的第一印象。入职后要做的第一件事一定要做好，最起码的要顺利完成而且不能出线上事故。这件事的目的就是为了建立信任，让团队觉得自己起码是靠谱的。如果这件事做得比较好，后面一路都会比较顺利。如果这件事就搞杂了，可能有的 leader 还会给第二次机会，再搞不好，后面就很难了，这一条对于社招来说更为重要。</p>
<p>而刚入职，公司技术栈不熟练，业务繁杂很难理清什么头绪，压力确实比较大。这时候一方面需要自己投入更多的精力，另一方面要多跟组内的同学交流，不懂就问。<strong>最有效率的学习方式，我觉得不是什么看书啊学习视频啊，而是直接去找对应的人聊，让别人讲一遍自己基本就全懂了，这效率比看文档看代码快多了，不仅省去了过滤无用信息的过程，还了解到了业务的演变历史。当然，这需要一定的沟通技巧，毕竟同事们也都很忙。</strong></p>
<p><strong>脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。</strong></p>
<h2 id="超出预期"> 超出预期</h2>
<p>超出预期这个词的外延范围很广，比如 leader 让去做个值周，解答用户群里大家的问题，结果不仅解答了大家的问题，还收集了这些问题进行分类，进而做了一个智能问答机器人解放了值周的人力，这可以算超出预期。比如 leader 让给运营做一个小工具，结果建设了一系列的工具甚至发展成了一个平台，成为了一个完整的项目，这也算超出预期。超出预期要求我们有把事情做大的能力，也就是想到了 leader 没想到的地方，并且创造了实际价值，拿到了业务收益。这个能力其实也比较重要，在工作中发现，有的人能把一个小盘子越做越大，而有的人恰好反之，那么那些有创新能力，经常超出预期的同学发展空间显然就更大一点。</p>
<p><strong>这块其实比较看个人能力，暂时没想到什么太好的捷径，多想一步吧。</strong></p>
<h2 id="体系化思考-系统化建设"> 体系化思考，系统化建设</h2>
<p>这句话是晋升时候总结出来的，大意就是做系统建设要有全局视野，不要局限于某一个小点，应该有良好的规划能力和清晰的演进蓝图。比如，今天加了一个监控，明天加一个报警，这些事不应该成为一个个孤岛，而是属于稳定性建设一期其中的一小步。这一期稳定性建设要做的工作是报警配置和监控梳理，包括机器监控、系统监控、业务监控、数据监控等，预期能拿到 XXX 的收益。这个工作还有后续的 roadmap，稳定性建设二期要做容量规划，接入压测，三期要做降级演练，多活容灾，四期要做...给人的感觉就是这个人思考非常全面，办事有体系有规划。</p>
<p><strong>平时积极总结沉淀，多跟别人交流，形成方法论。</strong></p>
<h2 id="提升自己的软素质能力"> 提升自己的软素质能力</h2>
<p>这里的软素质能力其实想说的就是 PPT、沟通、表达、时间管理、设计、文档等方面的能力。说实话，我觉得我当时能晋升就是因为 PPT 做的好了一点...可能大家平时对这些能力都不怎么关注，以前我也不重视，觉得比较简单，用时候直接上就行了，但事实可能并不像想象得那样简单。比如晋升时候 PPT+演讲+答辩这个工作，其实有很多细节的思考在里面，内容如何选取，排版怎么设计，怎样引导听众的情绪，如何回答评委的问题等等。晋升时候我见过很多同学 PPT 内容编排杂乱无章，演讲过程也不流畅自然，虽然确实做了很多实际工作，但在表达上欠缺了很多，属于会做不会说，如果再遇到不了解实际情况的外部门评委，吃亏是可以预见的。</p>
<p><strong><em>公司内网一般都会有一些软素质培训课程，可以找一些场合刻意训练。</em></strong></p>
<p>以上都是这些分享还都算比较伟光正，但是社会吧也不全是那么美好的。。下面这些内容有负能量倾向，三观特别正的同学以及观感不适者建议跳过。</p>
<h2 id="拍马屁是真的香"> 拍马屁是真的香</h2>
<p>拍马屁这东西入职前我是很反感的，我最初想加入互联网公司的原因就是觉得互联网公司的人情世故没那么多，事实证明，我错了...入职前几天，部门群里大 leader 发了一条消息，后面几十条带着大拇指的消息立马跟上，学习了，点赞，真不错，优秀，那场面，说是红旗招展锣鼓喧天鞭炮齐鸣一点也不过分。除了惊叹大家超强的信息接收能力和处理速度外，更进一步我还发现，连拍马屁都是有队形的，一级部门 leader 发消息，几个二级部门 leader 跟上，后面各组长跟上，最后是大家的狂欢，让我一度怀疑拍马屁的速度就决定了职业生涯的发展前景（没错，现在我已经不怀疑了）。</p>
<p>坦诚地说，我到现在也没习惯在群里拍马屁，但也不反感了，可以说把这个事当成一乐了。倒不是说我没有那个口才和能力（事实上也不需要什么口才，大家都简单直接），在某些场合，为活跃气氛的需要，我也能小嘴儿抹了蜜，甚至能把古诗文彩虹屁给 leader 安排上。而是我发现我的直属 leader 也不怎么在群里拍马屁，所以我表面上不公开拍马屁其实属于暗地里事实上迎合了 leader 的喜好...</p>
<p>但是拍马屁这个事只要掌握好度，整体来说还是香的，最多是没用，至少不会有什么坏处嘛。大家能力都差不多，每一次在群里拍马屁的机会就是一次露脸的机会，按某个同事的说法，这就叫打造个人技术影响力...</p>
<p><strong>想舔就舔，不想舔也没必要酸别人，Respect Greatness。</strong></p>
<h2 id="永不缺席的撕逼甩锅实战"> 永不缺席的撕逼甩锅实战</h2>
<p>有人的地方，就有江湖。虽然搞技术的大多城府也不深，但撕逼甩锅邀功抢活这些闹心的事儿基本也不会缺席，甚至我还见到过公开群发邮件撕逼的...这部分话题涉及到一些敏感信息就不多说了，而且我们低职级的遇到这些事儿的机会也不会太多。只是给大家提个醒，在工作的时候迟早都会吃到这方面的瓜，到时候留个心眼。</p>
<p><strong>稍微注意一下，咱不会去欺负别人，但也不能轻易让别人给欺负了。</strong></p>
<h2 id="不要被画饼蒙蔽了双眼"> 不要被画饼蒙蔽了双眼</h2>
<p>说实话，我个人是比较反感灌鸡汤、打鸡血、谈梦想、讲奋斗这一类行为的，9102 年都快过完了，这一套***治还在大行其道，真不知道是该可笑还是可悲。当然，这些词本身并没有什么问题，但是这些东西应该是自驱的，而不应该成为外界的一种强 push。『我必须努力奋斗』这个句式我觉得是正常的，但是『你必须努力奋斗』这种话多少感觉有点诡异，努力奋斗所以让公司的股东们发家致富？尤其在钱没给够的情况下，这些行为无异于耍流氓。我们需要对 leader 的这些画饼操作保持清醒的认知，理性分析，作出决策。比如感觉钱没给够（或者职级太低，同理）的时候，可能有以下几种情况：</p>
<ol>
<li>leader 并没有注意到你薪资较低这一事实</li>
<li>leader 知道这个事实，但是不知道你有多强烈的涨薪需求</li>
<li>leader 知道你有涨薪的需求，但他觉得你能力还不够</li>
<li>leader 知道你有涨薪的需求，能力也够，但是他不想给你涨</li>
<li>leader 想给你涨，也向上反馈和争取了，但是没有资源</li>
</ol>
<p>这时候我们需要做的是向上反馈，跟 leader 沟通确认。如果是 1 和 2，那么通过沟通可以消除信息误差。如果是 3，需要分情况讨论。如果是 4 和 5，已经可以考虑撤退了。对于这些事儿，也没必要抱怨，抱怨解决不了任何问题。我们要做的就是努力提升好个人能力，保持个人竞争力，等一个合适的时机，跳槽就完事了。</p>
<p><strong>时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。</strong></p>
<h2 id="学会包装"> 学会包装</h2>
<p>这一条说白了就是，要会吹。忘了从哪儿看到的了，能说、会写、善做是对职场人的三大要求。能说是很重要的，能说才能要来项目，拉来资源，招来人。同样一件事，不同的人能说出来完全不一样的效果。比如我做了个小工具上线了，我就只能说出来基本事实，而让 leader 描述一下，这就成了，打造了 XXX 的工具抓手，改进了 XXX 的完整生态，形成了 XXX 的业务闭环。老哥，我服了，硬币全给你还不行嘛。据我的观察，每个互联网公司都有这么几个词，抓手、生态、闭环、拉齐、梳理、迭代、owner 意识等等等等，我们需要做的就是熟读并背诵全文，啊不，是牢记并熟练使用。</p>
<p>这是对事情的包装，对人的包装也是一样的，尤其是在晋升和面试这样的应试型场合，特点是流程短一锤子买卖，包装显得尤为重要。晋升和面试这里就不展开说了，这里面的道和术太多了。。下面的场景提炼自面试过程中和某公司面试官的谈话，大家可以感受一下：</p>
<ol>
<li>我们背后是一个四五百亿美金的市场...</li>
<li>我负责过每天千亿级别访问量的系统...</li>
<li>工作两年能达到这个程度挺不错的...</li>
<li>贵司技术氛围挺好的，业务发展前景也很广阔...</li>
<li>啊，彼此彼此...</li>
<li>嗯，久仰久仰...</li>
</ol>
<p>人生如戏，全靠演技</p>
<p><strong>可以多看 leader 的 PPT，多听老板的向上汇报和宣讲会。</strong></p>
<h2 id="选择和努力哪个更重要"> 选择和努力哪个更重要？</h2>
<p>这还用问么，当然是选择。在完美的选择面前，努力显得一文不值，我有个多年没联系的高中同学今年已经在时代广场敲钟了...但是这样的案例太少了，做出完美选择的随机成本太高，不确定性太大。对于大多数刚毕业的同学，对行业的判断力还不够成熟，对自身能力和创业难度把握得也不够精准，此时拉几个人去创业，显得风险太高。我觉得更为稳妥的一条路是，先加入规模稍大一点的公司，找一个好 leader，抱好大腿，提升自己的个人能力。好平台加上大腿，再加上个人努力，这个起飞速度已经可以了。等后面积累了一定人脉和资金，深刻理解了市场和需求，对自己有信心了，可以再去考虑创业的事。</p>
<h2 id="后记"> 后记</h2>
<p>本来还想分享一些生活方面的故事，发现已经这么长了，那就先这样叭。上面写的一些总结和建议我自己做的也不是很好，还需要继续加油，和大家共勉。另外，其中某些观点，由于个人视角的局限性也不保证是普适和正确的，可能再工作几年这些观点也会发生改变，欢迎大家跟我交流~（甩锅成功）</p>
<p>最后祝大家都能找到心仪的工作，快乐工作，幸福生活，广阔天地，大有作为。</p>
]]></content:encoded>
    </item>
    <item>
      <title>JavaGuide（Java学习&amp;&amp;面试指南）</title>
      <link>https://javaguide.cn/home/</link>
      <guid>https://javaguide.cn/home/</guid>
      <source url="https://javaguide.cn/rss.xml">JavaGuide（Java学习&amp;&amp;面试指南）</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p><a href="https://t.1yb.co/GXLF"><img src="https://img-blog.csdnimg.cn/2f61f3e2d1f2427da977340919e41616.png" style="margin: 0 auto;width:850px" /></a></p>
<blockquote>
<ol>
<li><strong>贡献指南</strong> ：欢迎参与 <a href="https://github.com/Snailclimb/JavaGuide/issues/1235" target="_blank" rel="noopener noreferrer">JavaGuide 的维护工作</a>，这是一件非常有意义的事情。</li>
<li><strong>知识星球</strong> : 简历指导/Java 学习/面试指导/面试小册。欢迎加入<a href="https://sourl.cn/v9dbdC" target="_blank" rel="noopener noreferrer">我的知识星球</a> 。</li>
<li><strong>面试专版</strong> ：准备面试的小伙伴可以考虑面试专版：<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试进阶指北 》</a> (质量很高，专为面试打造)</li>
<li><strong>转载须知</strong> ：以下所有文章如非文首说明为转载皆为我（Guide 哥）的原创，转载在文首注明出处，如发现恶意抄袭/搬运，会动用法律武器维护自己的权益。让我们一起维护一个良好的技术创作环境！⛽️</li>
</ol>
</blockquote>
<div align="center">
    <p>
        <a href="https://github.com/Snailclimb/JavaGuide" target="_blank">
            <img src="https://img-blog.csdnimg.cn/img_convert/1c00413c65d1995993bf2b0daf7b4f03.png#pic_center" width="" />
        </a>
    </p>
    <p>
        <a href="https://javaguide.cn/"><img src="https://img.shields.io/badge/阅读-read-brightgreen.svg" alt="阅读" /></a>
        <img src="https://img.shields.io/github/stars/Snailclimb/JavaGuide" alt="stars" />
        <img src="https://img.shields.io/github/forks/Snailclimb/JavaGuide" alt="forks" />
        <img src="https://img.shields.io/github/issues/Snailclimb/JavaGuide" alt="issues" />
    </p>
    <p>
        <a href="https://sourl.cn/v9dbdC">
            <img src="../media/sponsor/知识星球.png" style="margin: 0 auto; width: 850px;" />
        </a>
    </p>
</div>
在大三准备面试的时候，我开源了 JavaGuide 。我把自己准备面试过程中的一些总结都毫不保留地通过 JavaGuide 分享了出来。
<p>开源 JavaGuide 初始想法源于自己的个人那一段比较迷茫的学习经历。主要目的是为了通过这个开源平台来帮助一些在学习 Java 或者面试过程中遇到问题的小伙伴。</p>
<ul>
<li><strong>对于 Java 初学者来说：</strong> 本文档倾向于给你提供一个比较详细的学习路径，让你对于 Java 整体的知识体系有一个初步认识。另外，本文的一些文章也是你学习和复习 Java 知识不错的实践；</li>
<li><strong>对于非 Java 初学者来说：</strong> 本文档更适合回顾知识，准备面试，搞清面试应该把重心放在那些问题上。要搞清楚这个道理：提前知道那些面试常见，不是为了背下来应付面试，而是为了让你可以更有针对的学习重点。</li>
</ul>
<p>相比于其他通过 JavaGuide 学到东西或者说助力获得 offer 的朋友来说 ， JavaGuide 对我的意义更加重大。不夸张的说，有时候真的感觉像是自己的孩子一点一点长大一样，我一直用心呵护着它。</p>
<p>虽然，我花了很长时间来维护它，但是，我觉得非常值得！非常有意义！</p>
<p>另外，<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener noreferrer">JavaGuide</a> 的 Star 数量虽然比较多，但是它的价值和含金量一定是不能和 Dubbo、Nacos 、SkyWalking 这些优秀的国产开源项目比的。希望国内可以出更多优秀的开源项目！</p>
<p>希望大家对面试不要抱有侥幸的心理，打铁还需自身硬！ 我希望这个文档是为你学习 Java 指明方向，而不是用来应付面试用的。加油！奥利给！</p>
<h2 id="项目说明"> 项目说明</h2>
<ol>
<li>项目的 Markdown 格式参考：<a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener noreferrer">Github Markdown 格式</a>，表情素材来自：<a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener noreferrer">EMOJI CHEAT SHEET</a>。</li>
<li>Logo 下的小图标是使用<a href="https://shields.io/" target="_blank" rel="noopener noreferrer">Shields.IO</a> 生成的。</li>
</ol>
<h2 id="如何对该开源文档进行贡献"> 如何对该开源文档进行贡献</h2>
<p>欢迎参与 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：<a href="https://github.com/Snailclimb/JavaGuide/issues/1235" target="_blank" rel="noopener noreferrer">JavaGuide 贡献指南</a> 。</p>
<p>你可以从下面几个方向来做贡献：</p>
<ul>
<li>笔记内容大多是手敲，所以难免会有笔误，你可以帮我找错别字。</li>
<li>很多知识点我可能没有涉及到，所以你可以对其他知识点进行补充。</li>
<li>现有的知识点难免存在不完善或者错误，所以你可以对已有知识点进行修改/补充。</li>
</ul>
<p>如果要提 issue/question 的话，强烈推荐阅读 <a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="noopener noreferrer">《提问的智慧》</a>、<a href="https://github.com/seajs/seajs/issues/545" target="_blank" rel="noopener noreferrer">《如何向开源社区提问题》</a> 和 <a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html" target="_blank" rel="noopener noreferrer">《如何有效地报告 Bug》</a>、<a href="https://zhuanlan.zhihu.com/p/25795393" target="_blank" rel="noopener noreferrer">《如何向开源项目提交无法解答的问题》</a>。</p>
<h2 id="贡献者"> 贡献者</h2>
<p><a href="https://github.com/Snailclimb/JavaGuide/graphs/contributors" target="_blank" rel="noopener noreferrer">你可以点此链接查看 JavaGuide 的所有贡献者。</a> 感谢你们让 JavaGuide 变得更好！如果你们来到武汉一定要找我，我请你们吃饭玩耍。</p>
<p><em>悄悄话：JavaGuide 会不定时为贡献者们送福利。</em></p>
<h2 id="待办"> 待办</h2>
<ul>
<li>[ ] 计算机网络知识点完善</li>
<li>[ ] 分布式常见理论和算法总结完善</li>
</ul>
<h2 id="联系我"> 联系我</h2>
<p><img src="https://img-blog.csdnimg.cn/20210609102613344.png" alt="各种技术的学习路线" /></p>
<p>整理了一份各个技术的学习路线，需要的小伙伴加我微信：“<strong>JavaGuide1996</strong>”备注“<strong>Github-学习路线</strong>”即可！</p>
<p><img src="./../media/pictures/weixin.jpeg" alt="" /></p>
<h2 id="公众号"> 公众号</h2>
<p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号“<strong>JavaGuide</strong>”。</p>
<p><strong>《Java 面试突击》:</strong> 由本文档衍生的专为面试而生的《Java 面试突击》V4.0 PDF 版本后台回复 <strong>&quot;面试突击&quot;</strong> 即可领取！</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-08/167598cd2e17b8ec.png" alt="我的公众号" /></p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/20210609102613344.png" type="image/png"/>
    </item>
    <item>
      <title>Camel Case：命名之间快速切换</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/camel-case/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/camel-case/</guid>
      <source url="https://javaguide.cn/rss.xml">Camel Case：命名之间快速切换</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>非常有用！这个插件可以实现包含6种常见命名格式之间的切换。并且，你还可以对转换格式进行相关配置（转换格式），如下图所示：</p>
<p><img src="./pictures/camel-case/camel-case1.png" alt="img" /></p>
<p>有了这个插件之后，你只需要使用快捷键 <code>shift+option+u(mac)</code> / <code>shift+alt+u</code> 对准你要修改的变量或者方法名字，就能实现在多种格式之间切换了，如下图所示：</p>
<p><img src="./pictures/camel-case/camel-case2.gif" alt="" /></p>
<p>如果你突然忘记快捷键的话，可以直接在IDEA的菜单栏的 Edit 部分找到。</p>
<p><img src="./pictures/camel-case/camel-case3.png" alt="" /></p>
<p>使用这个插件对开发效率提升高吗？拿我之前项目组的情况举个例子：</p>
<p>我之前有一个项目组的测试名字是驼峰这种形式: <code>ShouldReturnTicketWhenRobotSaveBagGiven1LockersWith2FreeSpace</code> 。但是，使用驼峰形式命名测试方法的名字不太明显，一般建议用下划线_的形式： <code>should_return_ticket_when_robot_save_bag_given_1_lockers_with_2_free_space</code></p>
<p>如果我们不用这个插件，而是手动去一个一个改的话，工作量想必会很大，而且正确率也会因为手工的原因降低。</p>
<blockquote></blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>CodeGlance：代码微型地图</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/code-glance/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/code-glance/</guid>
      <source url="https://javaguide.cn/rss.xml">CodeGlance：代码微型地图</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>CodeGlance提供一个代码的微型地图，当你的类比较多的时候可以帮忙你快速定位到要去的位置。这个插件在我们日常做普通开发的时候用处不大，不过，在你阅读源码的时候还是很有用的，如下图所示：</p>
<p><img src="./pictures/code-glance.png" alt="" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>Statistic：项目代码统计</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/code-statistic/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/code-statistic/</guid>
      <source url="https://javaguide.cn/rss.xml">Statistic：项目代码统计</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>编程是一个很奇妙的事情，大部分的我们把大部分时间实际都花在了复制粘贴，而后修改代码上面。</p>
<p>很多时候，我们并不关注代码质量，只要功能能实现，我才不管一个类的代码有多长、一个方法的代码有多长。</p>
<p>因此，我们经常会碰到让自己想要骂街的项目，不过，说真的，你自己写的代码也有极大可能被后者 DISS。</p>
<p>为了快速分析项目情况，判断这个项目是不是一个“垃圾”项目，有一个方法挺简单的。</p>
<p>那就是<strong>对代码的总行数、单个文件的代码行数、注释行数等信息进行统计。</strong></p>
<p><strong>怎么统计呢？</strong></p>
<p>首先想到的是 Excel 。不过，显然太麻烦了。</p>
<p><strong>有没有专门用于代码统计的工具呢？</strong></p>
<p>基于Perl语言开发的cloc（count lines of code）或许可以满足你的要求。</p>
<p><strong>有没有什么更简单的办法呢？</strong></p>
<p>如果你使用的是 IDEA 进行开发的话，推荐你可以使用一下 <strong>Statistic</strong> 这个插件。</p>
<p>有了这个插件之后你可以非常直观地看到你的项目中所有类型的文件的信息比如数量、大小等等，可以帮助你更好地了解你们的项目。</p>
<p><img src="./pictures/Statistic1.png" alt="" /></p>
<p>你还可以使用它看所有类的总行数、有效代码行数、注释行数、以及有效代码比重等等这些东西。</p>
<p><img src="./pictures/Statistic2.png" alt="" /></p>
<p>如果，你担心插件过多影响IDEA速度的话，可以只在有代码统计需求的时候开启这个插件，其他时间禁用它就完事了！</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 技术文章精选集</title>
      <link>https://javaguide.cn/high-quality-technical-articles/</link>
      <guid>https://javaguide.cn/high-quality-technical-articles/</guid>
      <source url="https://javaguide.cn/rss.xml">Java 技术文章精选集</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="java-技术文章精选集"> Java 技术文章精选集</h1>
<p>在这里我会精选一些和 Java 相关的优质技术文章，每一篇都值得你阅读 3 遍以上！</p>
]]></content:encoded>
    </item>
    <item>
      <title>Git Commit Template：提交代码格式规范</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/git-commit-template/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/git-commit-template/</guid>
      <source url="https://javaguide.cn/rss.xml">Git Commit Template：提交代码格式规范</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>没有安装这个插件之前，我们使用IDEA提供的Commit功能提交代码是下面这样的：</p>
<p><img src="./pictures/git-commit-template/Git-Commit-Template1.png" alt="" /></p>
<p>使用了这个插件之后是下面这样的，提供了一个commit信息模板的输入框：</p>
<p><img src="./pictures/git-commit-template/Git-Commit-Template2.png" alt="" /></p>
<p>完成之后的效果是这样的：</p>
<p><img src="./pictures/git-commit-template/Git-Commit-Template3.png" alt="" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>GsonFormat：JSON转对象</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/gson-format/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/gson-format/</guid>
      <source url="https://javaguide.cn/rss.xml">GsonFormat：JSON转对象</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>GsonFormat 这个插件可以根据Gson库使用的要求,将JSONObject格式的String 解析成实体类。</p>
<blockquote>
<p>说明：2021.x 版本以上的 IDEA 可以使用：GsonFormatPlus</p>
</blockquote>
<p>这个插件使用起来非常简单，我们新建一个类，然后在类中使用快捷键 <code>option + s</code>(Mac)或<code>alt + s</code> (win)调出操作窗口（<strong>必须在类中使用快捷键才有效</strong>），如下图所示。</p>
<p><img src="./pictures/GsonFormat2.gif" alt="" /></p>
<p>这个插件是一个国人几年前写的，不过已经很久没有更新了，可能会因为IDEA的版本问题有一些小Bug。而且，这个插件无法将JSON转换为Kotlin（这个其实无关痛痒，IDEA自带的就有Java转Kotlin的功能）。</p>
<p><img src="./pictures/GsonFormat1.png" alt="" /></p>
<p>另外一个与之相似的插件是 <strong>：RoboPOJOGenerator</strong> ，这个插件的更新频率比较快。</p>
<p><code>File-&gt; new -&gt; Generate POJO from JSON</code></p>
<p><img src="./pictures/RoboPOJOGenerator1.png" alt="" /></p>
<p>然后将JSON格式的数据粘贴进去之后，配置相关属性之后选择“<em>Generate</em>”</p>
<p><img src="./pictures/RoboPOJOGenerator2.png" alt="" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>IDE Features Trainer：IDEA 交互式教程</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/idea-features-trainer/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/idea-features-trainer/</guid>
      <source url="https://javaguide.cn/rss.xml">IDE Features Trainer：IDEA 交互式教程</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>有了这个插件之后，你可以在 IDE 中以交互方式学习IDEA最常用的快捷方式和最基本功能。</strong> 非常非常非常方便！强烈建议大家安装一个，尤其是刚开始使用IDEA的朋友。</p>
<p>当我们安装了这个插件之后，你会发现我们的IDEA 编辑器的右边多了一个“<strong>Learn</strong>”的选项，我们点击这个选项就可以看到如下界面。</p>
<p><img src="./pictures/IDE-Features-Trainer1.png?lastModify=1633856821" alt="" /></p>
<p>我们选择“Editor Basics”进行，然后就可以看到如下界面，这样你就可以按照指示来练习了！非常不错！</p>
<p><img src="./pictures/IDE-Features-Trainer2.png?lastModify=1633856821" alt="" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>IDEA主题推荐</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/idea-themes/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/idea-themes/</guid>
      <source url="https://javaguide.cn/rss.xml">IDEA主题推荐</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>经常有小伙伴问我：“Guide哥，你的IDEA 主题怎么这么好看，能推荐一下不？”。就实在有点不耐烦了，才索性写了这篇文章。</p>
<p>在这篇文章中，我精选了几个比较是和 Java 编码的 IDEA 主题供小伙伴们选择。另外，我自己用的是 One Dark theme 这款。</p>
<p><strong>注意：以下主题按照使用人数降序排序。</strong></p>
<h2 id="material-theme-ui"> <a href="https://plugins.jetbrains.com/plugin/8006-material-theme-ui" target="_blank" rel="noopener noreferrer">Material Theme UI</a></h2>
<p><strong>推荐指数</strong> ：⭐⭐⭐⭐</p>
<p>这是 IDEA 中使用人数最多的一款主题。</p>
<p>当你安装完这个插件之后，你会发现这个主题本身又提供了多种相关的主题供你选择。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20/image-20201119182935201.png" alt="" /></p>
<p><strong>Material Deep Ocean</strong> 这款的效果图如下。默认的字体是真的小，小伙伴们需要自行调整一下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20/image-20201119183044068.png" alt="" /></p>
<h2 id="one-dark-theme"> <a href="https://plugins.jetbrains.com/plugin/11938-one-dark-theme" target="_blank" rel="noopener noreferrer">One Dark theme</a></h2>
<p><strong>推荐指数</strong> ：⭐⭐⭐⭐⭐</p>
<p>我比较喜欢的一款（<em>黄色比较多？</em>）。 没有花里花哨，简单大气，看起来比较舒服。颜色搭配也很棒，适合编码！</p>
<p>这款主题的效果图如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20-11/image-20201119180300975.png" alt="" /></p>
<h2 id="gradianto"> <a href="https://plugins.jetbrains.com/plugin/12334-gradianto" target="_blank" rel="noopener noreferrer">Gradianto</a></h2>
<p><strong>推荐指数</strong> ：⭐⭐⭐⭐⭐</p>
<p>Gradianto这个主题的目标是在保持页面色彩比较层次分明的情况下，让我们因为代码而疲惫的双眼更加轻松。</p>
<p>Gradianto附带了自然界的渐变色，看着挺舒服的。另外，这个主题本身也提供了多种相关的主题供你选择。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20/image-20201119183825753.png" alt="" /></p>
<p><strong>Gradianto Nature Green</strong> 的效果图如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20/image-20201119183920889.png" alt="" /></p>
<h2 id="dark-purple-theme"> <a href="https://plugins.jetbrains.com/plugin/12100-dark-purple-theme" target="_blank" rel="noopener noreferrer">Dark Purple Theme</a></h2>
<p><strong>推荐指数</strong> ：⭐⭐⭐⭐⭐</p>
<p>这是一款紫色色调的深色主题，喜欢紫色的小伙伴不要错过。</p>
<p>这个主题的效果图如下。个人觉得整体颜色搭配的是比较不错的，适合编码！</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20-11/image-20201119184654132.png" alt="" /></p>
<h2 id="hiberbee-theme"> <a href="https://plugins.jetbrains.com/plugin/12118-hiberbee-theme" target="_blank" rel="noopener noreferrer">Hiberbee Theme</a></h2>
<p><strong>推荐指数</strong> ：⭐⭐⭐⭐⭐</p>
<p>一款受到了  Monokai Pro 和 MacOS Mojave启发的主题，是一款色彩层次分明的深色主题。</p>
<p>这个主题的效果图如下。看着也是非常赞！适合编码！</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20-11/image-20201119191441248.png" alt="" /></p>
<p>上面推荐的都是偏暗色系的主题，这里我再推荐两款浅色系的主题。</p>
<h2 id="gray-theme"> <a href="https://plugins.jetbrains.com/plugin/12103-gray-theme" target="_blank" rel="noopener noreferrer">Gray Theme</a></h2>
<p><strong>推荐指数</strong> ：⭐⭐⭐</p>
<p>这是一款对比度比较低的一款浅色主题，不太适合代码阅读，毕竟这款主题是专门为在IntelliJ IDE中使用Markdown而设计的。</p>
<p>这个主题的效果图如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20-11/image-20201119194512164.png" alt="" /></p>
<h2 id="roboticket-light-theme"> <a href="https://plugins.jetbrains.com/plugin/12191-roboticket-light-theme" target="_blank" rel="noopener noreferrer">Roboticket Light Theme</a></h2>
<p><strong>推荐指数</strong> ：⭐⭐⭐</p>
<p>这是一款对比度比较低的浅色主题，不太适合代码阅读。</p>
<p>这个主题的效果图如下。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/194581c7b72d49b512b12814340f00c8.png" alt="" /></p>
<h2 id="后记"> 后记</h2>
<p>我个人还是比较偏爱深色系的主题。</p>
<p>小伙伴们比较喜欢哪款主题呢？可以在评论区简单聊聊不？如果你还有其他比较喜欢的主题也可以在评论区说出来供大家参考哦！</p>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20/image-20201119182935201.png" type="image/png"/>
    </item>
    <item>
      <title>IDEA 代码优化插件推荐</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/improve-code/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/improve-code/</guid>
      <source url="https://javaguide.cn/rss.xml">IDEA 代码优化插件推荐</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="lombok-帮你简化代码"> Lombok:帮你简化代码</h2>
<p>之前没有推荐这个插件的原因是觉得已经是人手必备的了。如果你要使用 Lombok 的话，不光是要安装这个插件，你的项目也要引入相关的依赖。</p>
<div><pre><code>        <span><span><span>&lt;</span>dependency</span><span>></span></span>
            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.projectlombok<span><span><span>&lt;/</span>groupId</span><span>></span></span>
            <span><span><span>&lt;</span>artifactId</span><span>></span></span>lombok<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
            <span><span><span>&lt;</span>optional</span><span>></span></span>true<span><span><span>&lt;/</span>optional</span><span>></span></span>
        <span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用 Lombok 能够帮助我们少写很多代码比如 Getter/Setter、Constructor等等。</p>
<p>关于Lombok的使用，可以查看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485385&amp;idx=2&amp;sn=a7c3fb4485ffd8c019e5541e9b1580cd&amp;chksm=cea24802f9d5c1144eee0da52cfc0cc5e8ee3590990de3bb642df4d4b2a8cd07f12dd54947b9&amp;token=1667678311&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">《十分钟搞懂Java效率工具Lombok使用与原理》</a>。</p>
<h2 id="codota-代码智能提示"> Codota：代码智能提示</h2>
<p>我一直在用的一个插件，可以说非常好用了（<em>我身边的很多大佬平时写代码也会用这个插件</em>）。</p>
<p>Codota 这个插件用于智能代码补全，它基于数百万Java程序，能够根据程序上下文提示补全代码。相比于IDEA自带的智能提示来说，Codota 的提示更加全面一些。</p>
<p>如果你觉得 IDEA 插件安装的太多比较卡顿的话，不用担心！Codota 插件还有一个对应的在线网站（<a href="https://www.codota.com/code" target="_blank" rel="noopener noreferrer">https://www.codota.com/code</a>），在这个网站上你可以根据代码关键字搜索相关代码示例，非常不错！</p>
<p>我在工作中经常会用到，说实话确实给我带来了很大便利，比如我们搜索 <code>Files.readAllLines</code>相关的代码，搜索出来的结果如下图所示：</p>
<p><img src="./pictures/Codota3.png" alt="" /></p>
<p>另外，Codota 插件的基础功能都是免费的。你的代码也不会被泄露，这点你不用担心。</p>
<p>简单来看看 Codota 插件的骚操作吧！</p>
<h3 id="代码智能补全"> 代码智能补全</h3>
<p>我们使用<code>HttpUrlConnection</code> 建立一个网络连接是真的样的：</p>
<p><img src="./pictures/Codota1.gif" alt="" /></p>
<p>我们创建线程池现在变成下面这样：</p>
<p><img src="./pictures/Codota4.gif" alt="" /></p>
<p>上面只是为了演示这个插件的强大，实际上创建线程池不推荐使用这种方式， 推荐使用 <code>ThreadPoolExecutor</code> 构造函数创建线程池。我下面要介绍的一个阿里巴巴的插件-<strong>Alibaba Java Code Guidelines</strong> 就检测出来了这个问题，所以，<code>Executors</code>下面用波浪线标记了出来。</p>
<h3 id="代码智能搜索"> 代码智能搜索</h3>
<p>除了，在写代码的时候智能提示之外。你还可以直接选中代码然后搜索相关代码示例。</p>
<p><img src="./pictures/Codota2.png" alt="" /></p>
<h2 id="alibaba-java-code-guidelines-阿里巴巴-java-代码规范"> Alibaba Java Code Guidelines：阿里巴巴 Java 代码规范</h2>
<p>阿里巴巴 Java 代码规范，对应的Github地址为：<a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/p3c</a> 。非常推荐安装！</p>
<p>安装完成之后建议将与语言替换成中文，提示更加友好一点。</p>
<p><img src="./pictures/p3c/Alibaba-Java-Code-Guidelines2.png" alt="" /></p>
<p>根据官方描述：</p>
<blockquote>
<p>目前这个插件实现了开发手册中的的53条规则，大部分基于PMD实现，其中有4条规则基于IDEA实现，并且基于IDEA <a href="https://www.jetbrains.com/help/idea/code-inspection.html" target="_blank" rel="noopener noreferrer">Inspection</a>实现了实时检测功能。部分规则实现了Quick Fix功能，对于可以提供Quick Fix但没有提供的，我们会尽快实现，也欢迎有兴趣的同学加入进来一起努力。 目前插件检测有两种模式：实时检测、手动触发。</p>
</blockquote>
<p>上述提到的开发手册也就是在Java开发领域赫赫有名的《阿里巴巴Java开发手册》。</p>
<h3 id="手动配置检测规则"> 手动配置检测规则</h3>
<p>你还可以手动配置相关 inspection规则：</p>
<p><img src="./pictures/p3c/Alibaba-Java-Code-Guidelines3.png" alt="" /></p>
<h3 id="使用效果"> 使用效果</h3>
<p>这个插件会实时检测出我们的代码不匹配它的规则的地方，并且会给出修改建议。比如我们按照下面的方式去创建线程池的话，这个插件就会帮我们检测出来,如下图所示。</p>
<p><img src="./pictures/p3c/Alibaba-Java-Code-Guidelines1.png" alt="" /></p>
<p>这个可以对应上 《阿里巴巴Java开发手册》 这本书关于创建线程池的方式说明。</p>
<p><img src="./pictures/p3c/阿里巴巴开发手册-线程池创建.png" alt="" /></p>
<h2 id="checkstyle-java代码格式规范"> CheckStyle: Java代码格式规范</h2>
<h3 id="为何需要checkstyle插件"> 为何需要CheckStyle插件？</h3>
<p><strong>CheckStyle 几乎是 Java 项目开发必备的一个插件了，它会帮助我们检查 Java 代码的格式是否有问题比如变量命名格式是否有问题、某一行代码的长度是否过长等等。</strong></p>
<p>在项目上，<strong>通过项目开发人员自我约束来规范代码格式必然是不靠谱的！</strong> 因此，我们非常需要这样一款工具来帮助我们规范代码格式。</p>
<p>如果你看过我写的轮子的话，可以发现我为每一个项目都集成了 CheckStyle，并且设置了 <strong>Git Commit 钩子</strong>，保证在提交代码之前代码格式没有问题。</p>
<blockquote>
<p><strong>Guide哥造的轮子</strong>（<em>代码简洁，结构清晰，欢迎学习，欢迎一起完善</em>）：</p>
<ol>
<li><a href="https://github.com/Snailclimb/guide-rpc-framework" target="_blank" rel="noopener noreferrer">guide-rpc-framework</a> ：A custom RPC framework implemented by Netty+Kyro+Zookeeper.（一款基于 Netty+Kyro+Zookeeper 实现的自定义 RPC 框架-附详细实现过程和相关教程）</li>
<li><a href="https://github.com/Snailclimb/jsoncat" target="_blank" rel="noopener noreferrer">jsoncat</a> ：仿 Spring Boot 但不同于 Spring Boot 的一个轻量级的 HTTP 框架</li>
</ol>
<p><strong>Git 钩子</strong>： Git 能在特定的重要动作比如commit、push发生时触发自定义脚本。 钩子都被存储在 Git 目录下的 <code>hooks</code> 子目录中。 也即绝大部分项目中的 <code>.git/hooks</code> 。</p>
</blockquote>
<h3 id="如何在maven-gradle项目中集成-checksytle"> 如何在Maven/Gradle项目中集成 Checksytle?</h3>
<p>一般情况下，我们都是将其集成在项目中，并设置相应的 Git 钩子。网上有相应的介绍文章，这里就不多提了。</p>
<p>如果你觉得网上的文章不直观的话，可以参考我上面提到了两个轮子：</p>
<ol>
<li><a href="https://github.com/Snailclimb/guide-rpc-framework" target="_blank" rel="noopener noreferrer">guide-rpc-framework</a> ：Maven项目集成 Checksytle。</li>
<li><a href="https://github.com/Snailclimb/jsoncat" target="_blank" rel="noopener noreferrer">jsoncat</a>  ：Gradle项目集成 Checksytle。</li>
</ol>
<p>如果你在项目中集成了 Checksytle 的话，每次检测会生成一个 HTML格式的文件告诉你哪里的代码格式不对，这样看着非常不直观。通过  Checksytle插件的话可以非常直观的将项目中存在格式问题的地方显示出来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/IDEA插件/image-20201013135044410.png" alt="" /></p>
<p>如果你只是自己在本地使用，并不想在项目中集成 Checksytle 的话也可以，只需要下载一个 Checksytle插件就足够了。</p>
<h3 id="如何安装"> 如何安装？</h3>
<p>我们直接在 IDEA 的插件市场即可找到这个插件。我这里已经安装好了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/IDEA插件/image-20201013103610557.png" alt="" /></p>
<p>安装插件之后重启 IDEA，你会发现就可以在底部菜单栏找到 CheckStyle 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/IDEA插件/image-20201013134644991.png" alt="" /></p>
<h3 id="如何自定义检测规则"> 如何自定义检测规则？</h3>
<p>如果你需要自定义代码格式检测规则的话，可以按照如下方式进行配置（你可以导入用于自定义检测规则的<code>CheckStyle.xml</code>文件）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/IDEA插件/setting-check-style.png" alt="" /></p>
<h3 id="使用效果-2"> 使用效果</h3>
<p>配置完成之后，按照如下方式使用这个插件！</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/IDEA插件/run-check-style.png" alt="run-check-style" /></p>
<p>可以非常清晰的看到：CheckStyle 插件已经根据我们自定义的规则将项目中的代码存在格式问题的地方都检测了出来。</p>
<h2 id="sonarlint-帮你优化代码"> SonarLint:帮你优化代码</h2>
<p>SonarLint 帮助你发现代码的错误和漏洞，就像是代码拼写检查器一样，SonarLint 可以实时显示出代码的问题，并提供清晰的修复指导，以便你提交代码之前就可以解决它们。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-2@main/系统设计/image-20201019222817359.png" alt="" /></p>
<p>并且，很多项目都集成了 SonarQube,SonarLint 可以很方便地与 SonarQube 集成。</p>
]]></content:encoded>
    </item>
    <item>
      <title>IDEA 界面美化插件推荐</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/interface-beautification/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/interface-beautification/</guid>
      <source url="https://javaguide.cn/rss.xml">IDEA 界面美化插件推荐</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="background-image-plus-背景图片"> Background Image Plus:背景图片</h2>
<p>我这里推荐使用国人 Jack Chu 基于 Background Image Plus 开发的最新版本，适用于 2021.x 版本的 IDEA。</p>
<p>前面几个下载量比较高的，目前都还未支持 2021.x 版本的 IDEA。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/image-20211010174138279.png" alt="Background Image Plus" /></p>
<p>通过这个插件，你可以将 IDEA 背景设置为指定的图片，支持随机背景。</p>
<p>效果图如下：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/image-20211010173730828.png" alt="Background Image Plus 设置背景效果图" /></p>
<p>如果你想要设置随机背景的话，可以通过 IDEA 设置页 <strong>Settings</strong> -&gt; <strong>Appearance &amp; Behaviour</strong> -&gt; <strong>Background Image Plus</strong> 自定义设置项，随机显示目录下的图片为背景图。</p>
<h2 id="power-mode-ii-代码特效"> Power Mode II : 代码特效</h2>
<p>使用了这个插件之后，写代码会自带特效，适用于 2021.x 版本的 IDEA。 2021.x 版本之前，可以使用 <strong>activate-power-mode</strong> 。</p>
<p><img src="./pictures/power-mode/Power-Mode-II.gif" alt="Power Mode II 效果图" /></p>
<p>你可以通过 IDEA 设置页 <strong>Settings</strong> -&gt; <strong>Appearance &amp; Behaviour</strong> -&gt; <strong>Power Mode II</strong> 自定义设置项。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/image-20211010175304108.png" alt="Power Mode II" /></p>
<h2 id="nyan-progress-bar-进度条美化"> Nyan Progress Bar : 进度条美化</h2>
<p>可以让你拥有更加漂亮的进度条。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/image-20211010175434133.png" alt="" /></p>
<h2 id="grep-console-控制台输出处理"> Grep Console:控制台输出处理</h2>
<p>可以说是必备的一个 IDEA 插件，非常实用！</p>
<p>这个插件主要的功能有两个：</p>
<p><strong>1. 自定义设置控制台输出颜色</strong></p>
<p>我们可以在设置中进行相关的配置:</p>
<p><img src="./pictures/grep-console/grep-console2.png" alt="" /></p>
<p>配置完成之后的 log warn 的效果对比图如下：</p>
<p><img src="./pictures/grep-console/grep-console3.png" alt="" /></p>
<p><strong>2. 过滤控制台输出</strong></p>
<p><img src="./pictures/grep-console/grep-console.gif" alt="" /></p>
<h2 id="rainbow-brackets-彩虹括号"> Rainbow Brackets : 彩虹括号</h2>
<p>使用各种鲜明的颜色来展示你的括号，效果图如下。可以看出代码层级变得更加清晰了，可以说非常实用友好了！</p>
<p><img src="./pictures/rainbow-brackets.png" alt="" /></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/image-20211010174138279.png" type="image/png"/>
    </item>
    <item>
      <title>jclasslib ：一款IDEA字节码查看神器</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/jclasslib/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/jclasslib/</guid>
      <source url="https://javaguide.cn/rss.xml">jclasslib ：一款IDEA字节码查看神器</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于后面要分享的一篇文章中用到了这篇文章要推荐的一个插件，所以这里分享一下。非常实用！你会爱上它的！</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/计算机专业学习指南/image-20201013084919965.png" alt="" /></p>
<p><strong>开始推荐 IDEA 字节码查看神器之前，先来回顾一下 Java 字节码是啥。</strong></p>
<h2 id="何为-java-字节码"> 何为 Java 字节码?</h2>
<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p><strong>什么是字节码?采用字节码的好处是什么?</strong></p>
<blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java 程序运行过程.png" alt="Java程序运行过程" /></p>
<h2 id="为什么要查看-java-字节码"> 为什么要查看 Java 字节码？</h2>
<p>我们在平时学习的时候，经常需要查看某个 java 类的字节码文件。查看字节码文件更容易让我们搞懂 java 代码背后的原理比如搞懂 java 中的各种语法糖的本质。</p>
<h2 id="如何查看-java-字节码"> 如何查看 Java 字节码?</h2>
<p>如果我们通过命令行来查看某个 class 的字节码文件的话，可以直接通过 <code>javap</code> 命令，不过这种方式太原始了，效率十分低，并且看起来不直观。</p>
<p>下面介绍两种使用 IDEA 查看类对应字节码文件的方式（<em><code>javap</code>这种方式就不提了</em>）。</p>
<p>我们以这段代码作为案例:</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Integer</span> i <span>=</span> <span>null</span><span>;</span>
        <span>Boolean</span> flag <span>=</span> <span>false</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>flag <span>?</span> <span>0</span> <span>:</span> i<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面这段代码由于使用三目运算符不当导致诡异了 NPE 异常。为了搞清楚事情的原因，我们来看其对应的字节码。</p>
<h3 id="使用-idea-自带功能"> 使用 IDEA 自带功能</h3>
<p>我们点击 <code>View -&gt; Show Bytecode</code> 即可通过 IDEA 查看某个类对应的字节码文件。</p>
<blockquote>
<p>需要注意的是：<strong>查看某个类对应的字节码文件之前确保它已经被编译过。</strong></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/IDEA插件/image-20201012143530226.png" alt="使用IDEA自带功能查看Java字节码" /></p>
<p>稍等几秒钟之后，你就可以直观到看到对应的类的字节码内容了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-10/image-20201012145127465.png" alt="" /></p>
<p>从字节码中可以看出，我圈出来的位置发生了 <strong>拆箱操作</strong> 。</p>
<blockquote>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
</blockquote>
<p>详细解释下就是：<code>flag ? 0 : i</code> 这行代码中，0 是基本数据类型 int，返回数据的时候 i 会被强制拆箱成 int 类型，由于 i 的值是 null，因此就抛出了 NPE 异常。</p>
<div><pre><code><span>Integer</span> i <span>=</span> <span>null</span><span>;</span>
<span>Boolean</span> flag <span>=</span> <span>false</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>flag <span>?</span> <span>0</span> <span>:</span> i<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果，我们把代码中 <code>flag</code> 变量的值修改为 true 的话，就不会存在 NPE 问题了，因为会直接返回 0，不会进行拆箱操作。</p>
<h3 id="使用-idea-插件-jclasslib-推荐"> 使用 IDEA 插件 jclasslib(推荐)</h3>
<p>相比于 IDEA 自带的查看类字节的功能，我更推荐 <code>jclasslib</code> 这个插件，非常棒！</p>
<p><strong>使用 <code>jclasslib</code> 不光可以直观地查看某个类对应的字节码文件，还可以查看类的基本信息、常量池、接口、属性、函数等信息。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-10/image-20201012145646086.png" alt="" /></p>
<p>我们直接在 IDEA 的插件市场即可找到这个插件。我这里已经安装好了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-10-12/image-20201012145900911.png" alt="" /></p>
<p>安装完成之后，重启 IDEA。点击<code>View -&gt; Show Bytecode With jclasslib</code> 即可通过<code>jclasslib</code> 查看某个类对应的字节码文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/计算机专业学习指南/image-20201012150252106.png" alt="使用IDEA插件jclasslib查看类的字节码" /></p>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/image-20201013084919965.png" type="image/png"/>
    </item>
    <item>
      <title>Maven Helper：解决 Maven 依赖冲突问题</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/maven-helper/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/maven-helper/</guid>
      <source url="https://javaguide.cn/rss.xml">Maven Helper：解决 Maven 依赖冲突问题</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>Maven Helper</strong> 主要用来分析 Maven 项目的相关依赖，可以帮助我们解决 Maven 依赖冲突问题。</p>
<p><img src="./pictures/maver-helper.png" alt="" /></p>
<p><strong>何为依赖冲突？</strong></p>
<p>说白了就是你的项目使用的 2 个 jar 包引用了同一个依赖 h，并且 h 的版本还不一样,这个时候你的项目就存在两个不同版本的 h。这时 Maven 会依据依赖路径最短优先原则，来决定使用哪个版本的 Jar 包，而另一个无用的 Jar 包则未被使用，这就是所谓的依赖冲突。</p>
<p>大部分情况下，依赖冲突可能并不会对系统造成什么异常，因为 Maven 始终选择了一个 Jar 包来使用。但是，不排除在某些特定条件下，会出现类似找不到类的异常，所以，只要存在依赖冲突，在我看来，最好还是解决掉，不要给系统留下隐患。</p>
]]></content:encoded>
    </item>
    <item>
      <title>其他</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/others/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/others/</guid>
      <source url="https://javaguide.cn/rss.xml">其他</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<ol>
<li><strong>leetcode editor</strong> :提供在线 Leetcode 刷题功能，比较方便我们刷题，不过我试用之后发现有一些小 bug，个人感觉还是直接在网站找题目刷来的痛快一些。</li>
<li><strong>​A Search with Github</strong> ：直接通过 Github搜索相关代码。</li>
<li><strong>stackoverflow</strong> : 选中相关内容后单击右键即可快速跳转到 stackoverflow 。</li>
<li><strong>CodeStream</strong> ：让code review变得更加容易。</li>
<li><strong>Code screenshots</strong> ：代码片段保存为图片。</li>
<li><strong>GitToolBox</strong> :Git工具箱</li>
<li><strong>OK,​ Gradle!</strong> ：搜索Java库用于Gradle项目</li>
<li><strong>Java Stream Debugger</strong> : Java8 Stream调试器</li>
<li><strong>EasyCode</strong> : Easycode 可以直接对数据的表生成entity、controller、service、dao、mapper无需任何编码，简单而强大。更多内容可以查看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486205&amp;idx=1&amp;sn=0ff2f87f0d82a1bd9c0c44328ef69435&amp;chksm=cea24536f9d5cc20c6cc7669f0d4167d747fe8b8c05a64546c0162d694aa96044a2862e24b57&amp;token=1862674725&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">《懒人 IDEA 插件插件:EasyCode 一键帮你生成所需代码~》</a></li>
<li><strong>JFormDesigner</strong> ：Swing GUI 在线编辑器。</li>
<li><strong>VisualVM Launcher</strong> ： Java性能分析神器。</li>
<li>......</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>RestfulToolkit：RESTful Web 服务辅助开发工具</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/rest-devlop/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/rest-devlop/</guid>
      <source url="https://javaguide.cn/rss.xml">RestfulToolkit：RESTful Web 服务辅助开发工具</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>开始推荐这个 IDEA 插件之前，我觉得有必要花一小会时间简单聊聊 <strong>REST</strong> 这个我们经常打交道的概念。</p>
<h2 id="rest-相关概念解读"> REST 相关概念解读</h2>
<h3 id="何为-rest"> 何为 REST？</h3>
<p>REST 即 <strong>REpresentational State Transfer</strong> 的缩写。这个词组的翻译过来就是&quot;<strong>表现层状态转化</strong>&quot;。</p>
<p>这样理解起来甚是晦涩，实际上 REST 的全称是 <strong>Resource Representational State Transfer</strong> ，直白地翻译过来就是 <strong>“资源”在网络传输中以某种“表现形式”进行“状态转移”</strong> 。</p>
<p><strong>有没有感觉很难理解？</strong></p>
<p>没关系，看了我对 REST 涉及到的一些概念的解读之后你没准就能理解了！</p>
<ul>
<li><strong>资源（Resource）</strong> ：我们可以把真实的对象数据称为资源。一个资源既可以是一个集合，也可以是单个个体。比如我们的班级 classes 是代表一个集合形式的资源，而特定的 class 代表单个个体资源。每一种资源都有特定的 URI（统一资源定位符）与之对应，如果我们需要获取这个资源，访问这个 URI 就可以了，比如获取特定的班级：<code>/class/12</code>。另外，资源也可以包含子资源，比如 <code>/classes/classId/teachers</code>：列出某个指定班级的所有老师的信息</li>
<li><strong>表现形式（Representational）</strong>：&quot;资源&quot;是一种信息实体，它可以有多种外在表现形式。我们把&quot;资源&quot;具体呈现出来的形式比如 json，xml，image,txt 等等叫做它的&quot;表现层/表现形式&quot;。</li>
<li><strong>状态转移（State Transfer）</strong> ：大家第一眼看到这个词语一定会很懵逼？内心 BB：这尼玛是啥啊？ <strong>大白话来说 REST 中的状态转移更多地描述的服务器端资源的状态，比如你通过增删改查（通过 HTTP 动词实现）引起资源状态的改变。</strong> （HTTP 协议是一个无状态的，所有的资源状态都保存在服务器端）</li>
</ul>
<h3 id="何为-restful-架构"> 何为 RESTful 架构？</h3>
<p>满足 REST 风格的架构设计就可以称为 RESTful 架构：</p>
<ol>
<li>每一个 URI 代表一种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现形式比如 json，xml，image,txt 等等；</li>
<li>客户端通过特定的 HTTP 动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;。</li>
</ol>
<h3 id="何为-restful-web-服务"> 何为 RESTful Web 服务？</h3>
<p>基于 REST 架构的 Web 服务就被称为 RESTful Web 服务。</p>
<h2 id="restful-web-服务辅助开发工具"> RESTful Web 服务辅助开发工具</h2>
<h3 id="安装"> 安装</h3>
<p>这个插件的名字叫做 “<strong>RestfulToolkit</strong>” 。我们直接在 IDEA 的插件市场即可找到这个插件。如下图所示。</p>
<blockquote>
<p>如果你因为网络问题没办法使用 IDEA 自带的插件市场的话，也可以通过<a href="https://plugins.jetbrains.com/idea" target="_blank" rel="noopener noreferrer">IDEA 插件市场的官网</a>手动下载安装。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41a9bfa18920403ba4db83e324f8621e~tplv-k3u1fbpfcp-zoom-1.image" alt="" /></p>
<h3 id="简单使用"> 简单使用</h3>
<h4 id="url-跳转到对应方法"> URL 跳转到对应方法</h4>
<p>根据 URL 直接跳转到对应的方法定义 (Windows: <code>ctrl+\</code> or <code>ctrl+alt+n</code> Mac:<code>command+\</code> or <code>command+alt+n</code> )并且提供了一个服务的树形可视化显示窗口。 如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c26ea05ad472488fbf9eb21627964bee~tplv-k3u1fbpfcp-zoom-1.image" alt="" /></p>
<h4 id="作为-http-请求工具"> 作为 HTTP 请求工具</h4>
<p>这个插件还可以作为一个简单的 http 请求工具来使用。如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/RestfulToolkit2.png" alt="" /></p>
<h4 id="复制生成-url、复制方法参数"> 复制生成 URL、复制方法参数...</h4>
<p>这个插件还提供了生成 URL、查询参数、请求体（RequestBody）等功能。</p>
<p>举个例子。我们选中 <code>Controller</code> 中的某个请求对应的方法右击，你会发现多了几个可选项。当你选择<code>Generate &amp; Copy Full URL</code>的话，就可以把整个请求的路径直接复制下来。eg：<code>http://localhost:9333/api/users?pageNum=1&amp;pageSize=1</code> 。</p>
<p><img src="./pictures/RestfulToolkit3.png" alt="" /></p>
<h4 id="将-java-类转换为对应的-json-格式"> 将 Java 类转换为对应的 JSON 格式</h4>
<p>这个插件还为 Java 类上添加了 <strong>Convert to JSON</strong> 功能 。</p>
<p>我们选中的某个类对应的方法然后右击，你会发现多了几个可选项。</p>
<p><img src="./pictures/RestfulToolkit4.png" alt="" /></p>
<p>当我们选择<code>Convert to JSON</code>的话，你会得到如下 json 类型的数据：</p>
<div><pre><code><span>{</span>
  <span>"username"</span><span>:</span> <span>"demoData"</span><span>,</span>
  <span>"password"</span><span>:</span> <span>"demoData"</span><span>,</span>
  <span>"rememberMe"</span><span>:</span> <span>true</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="后记"> 后记</h2>
<p>RESTFulToolkit 原作者不更新了，IDEA.201 及以上版本不再适配。</p>
<p>因此，国内就有一个大佬参考 RESTFulToolkit 开发了一款类似的插件——RestfulTool（功能较少一些，不过够用了）。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210830112030237.png" alt="" /></p>
]]></content:encoded>
      <enclosure url="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41a9bfa18920403ba4db83e324f8621e~tplv-k3u1fbpfcp-zoom-1.image" type="image/"/>
    </item>
    <item>
      <title>Save Actions：优化文件保存</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/save-actions/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/save-actions/</guid>
      <source url="https://javaguide.cn/rss.xml">Save Actions：优化文件保存</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>真必备插件！可以帮助我们在保存文件的时候：</p>
<ol>
<li>优化导入；</li>
<li>格式化代码；</li>
<li>执行一些quick fix</li>
<li>......</li>
</ol>
<p>这个插件是支持可配置的，我的配置如下：</p>
<p><img src="./pictures/save-actions/save-actions.png" alt="" /></p>
<p>实际使用效果如下：</p>
<p><img src="./pictures/save-actions/save-actions2.gif" alt="" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>SequenceDiagram：一键可以生成时序图</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/sequence-diagram/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/sequence-diagram/</guid>
      <source url="https://javaguide.cn/rss.xml">SequenceDiagram：一键可以生成时序图</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>在平时的学习/工作中，我们会经常面临如下场景：</p>
<ol>
<li>阅读别人的代码</li>
<li>阅读框架源码</li>
<li>阅读自己很久之前写的代码。</li>
</ol>
<p>千万不要觉得工作就是单纯写代码，实际工作中，你会发现你的大部分时间实际都花在了阅读和理解已有代码上。</p>
<p>为了能够更快更清晰地搞清对象之间的调用关系，我经常需要用到序列图。手动画序列图还是很麻烦费时间的，不过 IDEA 提供了一个叫做<strong>SequenceDiagram</strong> 的插件帮助我们解决这个问题。通过 SequenceDiagram 这个插件，我们一键可以生成时序图。</p>
<h2 id="何为序列图"> 何为序列图？</h2>
<p>网上对于序列图的定义有很多，我觉得都不太好理解，太抽象了。最神奇的是，大部分文章对于序列图的定义竟然都是一模一样，看来大家是充分发挥了写代码的“精髓”啊！</p>
<p>我还是简单说一说我的理解吧！不过，说实话，我自己对于 Sequence Diagram 也不是很明朗。下面的描述如有问题和需要完善的地方，还请指出。</p>
<blockquote>
<p><strong>序列图</strong>（Sequence Diagram），亦称为<strong>循序图</strong>，是一种<a href="https://zh.m.wikipedia.org/wiki/UML" target="_blank" rel="noopener noreferrer">UML</a>行为图。表示系统执行某个方法/操作（如登录操作）时，对象之间的顺序调用关系。</p>
<p>这个顺序调用关系可以这样理解：你需要执行系统中某个对象 a 提供的方法/操作 login（登录），但是这个对象又依赖了对象 b 提供的方法 getUser(获取用户)。因此，这里就有了 a -&gt; b 调用关系之说。</p>
</blockquote>
<p>再举两个例子来说一下！</p>
<p>下图是微信支付的业务流程时序图。这个图描述了微信支付相关角色（顾客，商家...）在微信支付场景下，基础支付和支付的的顺序调用关系。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3a48c8d17aea2064ff11b6d3fd1fb2cb.png" alt="" /></p>
<p>下图是我写的一个 HTTP 框架中的执行某个方法的序列图。这个图描述了我们在调用 <code>InterceptorFactory</code>类的 <code>loadInterceptors()</code> 方法的时候，所涉及到的类之间的调用关系。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70.png" alt="" /></p>
<p>另外，国内一般更喜欢称呼序列图为&quot;时序图&quot;。</p>
<ul>
<li>如果你按照纯翻译的角度来说， sequence 这个单词并无&quot;时间&quot;的意思，只有序列，顺序等意思，因此也有人说“时序图”的说法是不准确的。</li>
<li>如果从定义角度来说，时序图这个描述是没问题的。因为 Sequence Diagram 中每条消息的触发时机确实是按照时间顺序执行的。</li>
</ul>
<p>我觉得称呼 Sequence Diagram 为时序图或者序列图都是没问题的，不用太纠结。</p>
<h2 id="哪些场景下需要查看类的时序图"> 哪些场景下需要查看类的时序图?</h2>
<p>我们在很多场景下都需要时序图，比如说：</p>
<ol>
<li><strong>阅读源码</strong> ：阅读源码的时候，你可能需要查看调用目标方法涉及的相关类的调用关系。特别是在代码的调用层级比较多的时候，对于我们理解源码非常有用。（<em>题外话：实际工作中，大部分时间实际我们都花在了阅读理解已有代码上。</em>）</li>
<li><strong>技术文档编写</strong> ：我们在写项目介绍文档的时候，为了让别人更容易理解你的代码，你需要根据核心方法为相关的类生成时序图来展示他们之间的调用关系。</li>
<li><strong>梳理业务流程</strong> ：当我们的系统业务流程比较复杂的时候，我们可以通过序列图将系统中涉及的重要的角色和对象的之间关系可视化出来。</li>
<li>......</li>
</ol>
<h2 id="如何使用-idea-根据类中方法生成时序图"> 如何使用 IDEA 根据类中方法生成时序图？</h2>
<p><strong>通过 SequenceDiagram 这个插件，我们一键可以生成时序图。</strong></p>
<p>并且，你还可以：</p>
<ol>
<li>点击时序图中的类/方法即可跳转到对应的地方。</li>
<li>从时序图中删除对应的类或者方法。</li>
<li>将生成的时序图导出为 PNG 图片格式。</li>
</ol>
<h3 id="安装"> 安装</h3>
<p>我们直接在 IDEA 的插件市场即可找到这个插件。我这里已经安装好了。</p>
<blockquote>
<p>如果你因为网络问题没办法使用 IDEA 自带的插件市场的话，也可以通过<a href="https://plugins.jetbrains.com/idea" target="_blank" rel="noopener noreferrer">IDEA 插件市场的官网</a>手动下载安装。</p>
</blockquote>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021165654262.png" alt="" /></p>
<h3 id="简单使用"> 简单使用</h3>
<ol>
<li>选中方法名（注意不要选类名），然后点击鼠标右键，选择 <strong>Sequence Diagram</strong> 选项即可！</li>
</ol>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021170110697-20211010211819042.png" alt="" /></p>
<ol start="2">
<li>配置生成的序列图的一些基本的参数比如调用深度之后，我们点击 ok 即可！</li>
</ol>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/c5040f1105c762ddf8689892913bc02d-20211010211823985.png" alt="" /></p>
<p>你还可以通过生成的时序图来定位到相关的代码，这对于我们阅读源码的时候尤其有帮助！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021171623809-20211010211828759.png" alt="" /></p>
<p>时序图生成完成之后，你还可以选择将其导出为图片。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021170228723-20211010211832965.png" alt="" /></p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/img_convert/3a48c8d17aea2064ff11b6d3fd1fb2cb.png" type="image/png"/>
    </item>
    <item>
      <title>IDEA 快捷键相关插件</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/shortcut-key/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/shortcut-key/</guid>
      <source url="https://javaguide.cn/rss.xml">IDEA 快捷键相关插件</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>相信我！下面这两个一定是IDEA必备的插件。</p>
<h2 id="key-promoter-x-快捷键提示"> Key Promoter X:快捷键提示</h2>
<p>这个插件的功能主要是<strong>在你本可以使用快捷键操作的地方提醒你用快捷键操作。</strong></p>
<p>举个例子。我直接点击tab栏下的菜单打开 Version Control(版本控制) 的话，这个插件就会提示你可以用快捷键 <code>command+9</code>或者<code>shift+command+9</code>打开。如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/Key-Promoter-X1.png" alt="" /></p>
<p>除了这个很棒的功能之外，这个插件还有一个功能我觉得非常棒。</p>
<p>它可以展示出哪些快捷键你忘记使用的次数最多！这样的话，你可以给予你忘记次数最多的那些快捷键更多的关注。</p>
<p>我忘记最多的快捷键是debug的时候经常使用的 F8（Step Over）。如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/Key-Promoter-X2.png" alt="" /></p>
<p>关于快捷键，很多人不愿意去记，觉得单纯靠鼠标就完全够了。</p>
<p>让我来说的话！我觉得如果你偶尔使用一两次 IDEA 的话，你完全没有必要纠结快捷键。</p>
<p>但是，如果 IDEA 是你开发的主力，你经常需要使用的话，相信我，掌握常用的一些快捷键真的很重要！</p>
<p>不说多的，<strong>熟练掌握IDEA的一些最常见的快捷键，你的工作效率至少提升 30 %。</strong></p>
<p><strong>除了工作效率的提升之外，使用快捷键会让我们显得更加专业。</strong></p>
<p>你在使用快捷键进行操作的时候，是很帅，很酷啊！但是，当你用 IDEA 给别人演示一些操作的时候，你使用了快捷键的话，别人可能根本不知道你进行了什么快捷键操作。</p>
<p><strong>怎么解决这个问题呢？</strong></p>
<p>很简单！这个时候就轮到 <strong>Presentation Assistant</strong> 这个插件上场了！</p>
<h2 id="presentation-assistant-快捷键展示"> Presentation Assistant:快捷键展示</h2>
<p>安装这个插件之后，你使用的快捷键操作都会被可视化地展示出来，非常适合自己在录制视频或者给别人展示代码的时候使用。</p>
<p>举个例子。我使用快捷键 <code>command+9</code>打开 Version Control ，使用了这个插件之后的效果如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/Presentation-Assistant.gif" alt="" /></p>
<p>从上图可以很清晰地看到，IDEA 的底部中间的位置将我刚刚所使用的快捷键给展示了出来。</p>
<p>并且，<strong>这个插件会展示出 Mac 和 Win/Linux 两种不同的版本的快捷键。</strong></p>
<p>因此，不论你的操作系统是 Mac 还是 Win/Linux ，这款插件都能满足你的需求。</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/Key-Promoter-X1.png" type="image/png"/>
    </item>
    <item>
      <title>Translation：翻译</title>
      <link>https://javaguide.cn/idea-tutorial/idea-plugins/translation/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-plugins/translation/</guid>
      <source url="https://javaguide.cn/rss.xml">Translation：翻译</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>有了这个插件之后，你再也不用在编码的时候打开浏览器查找某个单词怎么拼写、某句英文注释什么意思了。</p>
<p>并且，这个插件支持多种翻译源：</p>
<ol>
<li>Google 翻译</li>
<li>Youdao 翻译</li>
<li>Baidu 翻译</li>
</ol>
<p>除了翻译功能之外还提供了语音朗读、单词本等实用功能。这个插件的Github地址是：<a href="https://github.com/YiiGuxing/TranslationPlugin" target="_blank" rel="noopener noreferrer">https://github.com/YiiGuxing/TranslationPlugin</a> （貌似是国人开发的，很赞）。</p>
<p><strong>使用方法很简单！选中你要翻译的单词或者句子，使用快捷键 <code>command+ctrl+u(mac)</code> / <code>shift+ctrl+y(win/linux)</code></strong> （如果你忘记了快捷的话，鼠标右键操作即可！）</p>
<p><img src="./pictures/translation/translation1.jpg" alt="" /></p>
<p><strong>如果需要快速打开翻译框，使用快捷键<code>command+ctrl+i(mac)</code>/<code>ctrl + shift + o(win/linux)</code></strong></p>
<p><img src="./pictures/translation/translation2.png" alt="" /></p>
<p>如果你需要将某个重要的单词添加到生词本的话，只需要点击单词旁边的收藏按钮即可！</p>
]]></content:encoded>
    </item>
    <item>
      <title>IDEA 插件开发入门</title>
      <link>https://javaguide.cn/idea-tutorial/idea-tips/idea-plug-in-development-intro/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-tips/idea-plug-in-development-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">IDEA 插件开发入门</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="idea-插件开发入门"> IDEA 插件开发入门</h1>
<p>我这个人没事就喜欢推荐一些好用的 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319419426898329600&amp;__biz=Mzg2OTA0Njk0OA==#wechat_redirect" target="_blank" rel="noopener noreferrer">IDEA 插件</a>给大家。这些插件极大程度上提高了我们的生产效率以及编码舒适度。</p>
<p><strong>不知道大家有没有想过自己开发一款 IDEA 插件呢？</strong></p>
<p>我自己想过，但是没去尝试过。刚好有一位读者想让我写一篇入门 IDEA 开发的文章，所以，我在周末就花了一会时间简单了解一下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201118071711216.png" alt="" /></p>
<p>不过，<strong>这篇文章只是简单带各位小伙伴入门一下 IDEA 插件开发</strong>，个人精力有限，暂时不会深入探讨太多。如果你已经有 IDEA 插件开发的相关经验的话，这篇文章就可以不用看了，因为会浪费你 3 分钟的时间。</p>
<p>好的废话不多说！咱们直接开始!</p>
<h2 id="_01-新建一个基于-gradle-的插件项目"> 01 新建一个基于 Gradle 的插件项目</h2>
<p>这里我们基于 Gradle 进行插件开发，这也是 IntelliJ 官方的推荐的插件开发解决方案。</p>
<p><strong>第一步，选择 Gradle 项目类型并勾选上相应的依赖。</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/1.png" alt="选择 Gradle 项目类型并勾选上相应的依赖" /></p>
<p><strong>第二步，填写项目相关的属性比如 GroupId、ArtifactId。</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/2.png" alt="填写项目相关的属性" /></p>
<p><strong>第三步，静静等待项目下载相关依赖。</strong></p>
<p>第一次创建 IDEA 插件项目的话，这一步会比较慢。因为要下载 IDEA 插件开发所需的 SDK 。</p>
<h2 id="_02-插件项目结构概览"> 02 插件项目结构概览</h2>
<p>新建完成的项目结构如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/插件项目结构概览.png" alt="插件项目结构概览" /></p>
<p>这里需要额外注意的是下面这两个配置文件。</p>
<p><strong><code>plugin.xml</code> ：插件的核心配置文件。通过它可以配置插件名称、插件介绍、插件作者信息、Action 等信息。</strong></p>
<div><pre><code><span><span><span>&lt;</span>idea-plugin</span><span>></span></span>
    <span><span><span>&lt;</span>id</span><span>></span></span>github.javaguide.my-first-idea-plugin<span><span><span>&lt;/</span>id</span><span>></span></span>
    <span>&lt;!--插件的名称--></span>
    <span><span><span>&lt;</span>name</span><span>></span></span>Beauty<span><span><span>&lt;/</span>name</span><span>></span></span>
    <span>&lt;!--插件的作者相关信息--></span>
    <span><span><span>&lt;</span>vendor</span> <span>email</span><span><span>=</span><span>"</span>koushuangbwcx@163.com<span>"</span></span> <span>url</span><span><span>=</span><span>"</span>https://github.com/Snailclimb<span>"</span></span><span>></span></span>JavaGuide<span><span><span>&lt;/</span>vendor</span><span>></span></span>
    <span>&lt;!--插件的介绍--></span>
    <span><span><span>&lt;</span>description</span><span>></span></span><span>&lt;![CDATA[
     Guide哥代码开发的第一款IDEA插件&lt;br>
    &lt;em>这尼玛是什么垃圾插件！！！&lt;/em>
    ]]]]]]><![CDATA[><![CDATA[></span><span><span><span>&lt;/</span>description</span><span>></span></span>

    <span>&lt;!-- please see https://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/plugin_compatibility.html
         on how to target different products --></span>
    <span><span><span>&lt;</span>depends</span><span>></span></span>com.intellij.modules.platform<span><span><span>&lt;/</span>depends</span><span>></span></span>

    <span><span><span>&lt;</span>extensions</span> <span>defaultExtensionNs</span><span><span>=</span><span>"</span>com.intellij<span>"</span></span><span>></span></span>
        <span>&lt;!-- Add your extensions here --></span>
    <span><span><span>&lt;/</span>extensions</span><span>></span></span>

    <span><span><span>&lt;</span>actions</span><span>></span></span>
        <span>&lt;!-- Add your actions here --></span>
    <span><span><span>&lt;/</span>actions</span><span>></span></span>
<span><span><span>&lt;/</span>idea-plugin</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong><code>build.gradle</code> ：项目依赖配置文件。通过它可以配置项目第三方依赖、插件版本、插件版本更新记录等信息。</strong></p>
<div><pre><code>plugins <span>{</span>
    id <span>'java'</span>
    id <span>'org.jetbrains.intellij'</span> version <span>'0.6.3'</span>
<span>}</span>

group <span>'github.javaguide'</span>
<span>// 当前插件版本</span>
version <span>'1.0-SNAPSHOT'</span>

repositories <span>{</span>
    <span>mavenCentral</span><span>(</span><span>)</span>
<span>}</span>

<span>// 项目依赖</span>
dependencies <span>{</span>
    testCompile group<span>:</span> <span>'junit'</span><span>,</span> name<span>:</span> <span>'junit'</span><span>,</span> version<span>:</span> <span>'4.12'</span>
<span>}</span>

<span>// See https://github.com/JetBrains/gradle-intellij-plugin/</span>
<span>// 当前开发该插件的 IDEA 版本</span>
intellij <span>{</span>
    version <span>'2020.1.2'</span>
<span>}</span>
patchPluginXml <span>{</span>
    <span>// 版本更新记录</span>
    changeNotes <span>"""
      Add change notes here.&lt;br>
      &lt;em>most HTML tags may be used&lt;/em>"""</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>没有开发过 IDEA 插件的小伙伴直接看这两个配置文件内容可能会有点蒙。所以，我专门找了一个 IDEA 插件市场提供的现成插件来说明一下。小伙伴们对照下面这张图来看下面的配置文件内容就非常非常清晰了。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/iShot2020-11-13 16.15.53.png" alt="插件信息" /></p>
<p>这就非常贴心了！如果这都不能让你点赞，我要这文章有何用!</p>
<p><img src="http://wx1.sinaimg.cn/large/006BkP2Hly1fsxxff7zd9g304g0480td.gif" alt="" /></p>
<h2 id="_03-手动创建-action"> 03 手动创建 Action</h2>
<p>我们可以把 Action 看作是 IDEA 提高的事件响应处理器，通过 Action 我们可以自定义一些事件处理逻辑/动作。比如说你点击某个菜单的时候，我们进行一个展示对话框的操作。</p>
<p><strong>第一步，右键<code>java</code>目录并选择 new 一个 Action</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/新建action (1).png" alt="" /></p>
<p><strong>第二步，配置 Action 相关信息比如展示名称。</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/配置动作属性 (1).png" alt="配置动作属性 (1)" /></p>
<p>创建完成之后，我们的 <code>plugin.xml</code> 的 <code>&lt;actions&gt;</code>节点下会自动生成我们刚刚创建的 Action 信息：</p>
<div><pre><code><span><span><span>&lt;</span>actions</span><span>></span></span>
    <span>&lt;!-- Add your actions here --></span>
    <span><span><span>&lt;</span>action</span> <span>id</span><span><span>=</span><span>"</span>test.hello<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>HelloAction<span>"</span></span> <span>text</span><span><span>=</span><span>"</span>Hello<span>"</span></span> <span>description</span><span><span>=</span><span>"</span>IDEA插件入门<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>add-to-group</span> <span>group-id</span><span><span>=</span><span>"</span>ToolsMenu<span>"</span></span> <span>anchor</span><span><span>=</span><span>"</span>first<span>"</span></span><span>/></span></span>
    <span><span><span>&lt;/</span>action</span><span>></span></span>
<span><span><span>&lt;/</span>actions</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>并且 <code>java</code> 目录下为生成一个叫做 <code>HelloAction</code> 的类。并且，这个类继承了 <code>AnAction</code> ，并覆盖了 <code>actionPerformed()</code> 方法。这个 <code>actionPerformed</code> 方法就好比 JS 中的 <code>onClick</code> 方法，会在你点击的时候被触发对应的动作。</p>
<p>我简单对<code>actionPerformed</code> 方法进行了修改，添加了一行代码。这行代码很简单，就是显示 1 个对话框并展示一些信息。</p>
<div><pre><code><span>public</span> <span>class</span> <span>HelloAction</span> <span>extends</span> <span>AnAction</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>actionPerformed</span><span>(</span><span>AnActionEvent</span> e<span>)</span> <span>{</span>
        <span>//显示对话框并展示对应的信息</span>
        <span>Messages</span><span>.</span><span>showInfoMessage</span><span>(</span><span>"素材不够，插件来凑！"</span><span>,</span> <span>"Hello"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>另外，我们上面也说了，每个动作都会归属到一个 Group 中，这个 Group 可以简单看作 IDEA 中已经存在的菜单。</p>
<p>举个例子。我上面创建的 Action 的所属 Group 是 <strong>ToolsMenu(Tools)</strong> 。这样的话，我们创建的 Action 所在的位置就在 Tools 这个菜单下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201113192255689.png" alt="" /></p>
<p>再举个例子。加入我上面创建的 Action 所属的 Group 是<strong>MainMenu</strong> （IDEA 最上方的主菜单栏）下的 <strong>FileMenu(File)</strong> 的话。</p>
<div><pre><code><span><span><span>&lt;</span>actions</span><span>></span></span>
    <span>&lt;!-- Add your actions here --></span>
    <span><span><span>&lt;</span>action</span> <span>id</span><span><span>=</span><span>"</span>test.hello<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>HelloAction<span>"</span></span> <span>text</span><span><span>=</span><span>"</span>Hello<span>"</span></span> <span>description</span><span><span>=</span><span>"</span>IDEA插件入门<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>add-to-group</span> <span>group-id</span><span><span>=</span><span>"</span>FileMenu<span>"</span></span> <span>anchor</span><span><span>=</span><span>"</span>first<span>"</span></span><span>/></span></span>
    <span><span><span>&lt;/</span>action</span><span>></span></span>
<span><span><span>&lt;/</span>actions</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们创建的 Action 所在的位置就在 File 这个菜单下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201113201634643.png" alt="" /></p>
<h2 id="_04-验收成果"> 04 验收成果</h2>
<p>点击 <code>Gradle -&gt; runIde</code> 就会启动一个默认了这个插件的 IDEA。然后，你可以在这个 IDEA 上实际使用这个插件了。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201118075912490.png" alt="点击 runIde 就会启动一个默认了这个插件的 IDEA" /></p>
<p>效果如下：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201118080358764.png" alt="点击 runIde 就会启动一个默认了这个插件的 IDEA" /></p>
<p>我们点击自定义的 Hello Action 的话就会弹出一个对话框并展示出我们自定义的信息。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/IDEA插件HelloWorld.png" alt="IDEA插件HelloWorld" /></p>
<h2 id="_05-完善一下"> 05 完善一下</h2>
<p>想要弄点界面花里胡哨一下， 我们还可以通过 Swing 来写一个界面。</p>
<p>这里我们简单实现一个聊天机器人。代码的话，我是直接参考的我大二刚学 Java 那会写的一个小项目（<em>当时写的代码实在太烂了！就很菜！</em>）。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201114100213337.png" alt="" /></p>
<p>首先，你需要在<a href="http://www.tuling123.com/" title="图灵机器人官网" target="_blank" rel="noopener noreferrer">图灵机器人官网</a>申请一个机器人。（<em>其他机器人也一样，感觉这个图灵机器人没有原来好用了，并且免费调用次数也不多</em>）</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201118075453172.png" alt="" /></p>
<p>然后，简单写一个方法来请求调用机器人。由于代码比较简单，我这里就不放出来了，大家简单看一下效果就好。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201118075803163.png" alt="" /></p>
<h2 id="_06-深入学习"> 06 深入学习</h2>
<p>如果你想要深入学习的 IDEA 插件的话，可以看一下官网文档：<a href="https://jetbrains.org/intellij/sdk/docs/basics/basics.html" title="https://jetbrains.org/intellij/sdk/docs/basics/basics.html " target="_blank" rel="noopener noreferrer">https://jetbrains.org/intellij/sdk/docs/basics/basics.html </a> 。</p>
<p>这方面的资料还是比较少的。除了官方文档的话，你还可以简单看看下面这几篇文章：</p>
<ul>
<li><a href="https://developer.aliyun.com/article/777850?spm=a2c6h.12873581.0.dArticle777850.118d6446r096V4&amp;groupCode=alitech" title="8 条经验轻松上手 IDEA 插件开发" target="_blank" rel="noopener noreferrer">8 条经验轻松上手 IDEA 插件开发</a></li>
<li><a href="https://blog.xiaohansong.com/idea-plugin-development.html" title="IDEA 插件开发入门教程" target="_blank" rel="noopener noreferrer">IDEA 插件开发入门教程</a></li>
</ul>
<h2 id="_07-后记"> 07 后记</h2>
<p>我们开发 IDEA 插件主要是为了让 IDEA 更加好用，比如有些框架使用之后可以减少重复代码的编写、有些主题类型的插件可以让你的 IDEA 更好看。</p>
<p>我这篇文章的这个案例说实话只是为了让大家简单入门一下 IDEA 开发，没有任何实际应用意义。<strong>如果你想要开发一个不错的 IDEA 插件的话，还要充分发挥想象，利用 IDEA 插件平台的能力。</strong></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201118071711216.png" type="image/png"/>
    </item>
    <item>
      <title>IDEA 重构入门</title>
      <link>https://javaguide.cn/idea-tutorial/idea-tips/idea-refractor-intro/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-tips/idea-refractor-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">IDEA 重构入门</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="idea-重构入门"> IDEA 重构入门</h1>
<p>我们在使用 IDEA 进行重构之前，先介绍一个方便我们进行重构的快捷键：<code>ctrl+t(mac)/ctrl+shift+alt+t</code>（如果忘记快捷键的话，鼠标右键也能找到重构选项），使用这个快捷键可以快速调出常用重构的选项，如下图所示：</p>
<p><img src="./pictures/refractor-help.png" alt="" /></p>
<h3 id="重命名-rename"> 重命名(rename)</h3>
<p>快捷键：<strong>Shift + F6(mac) / Shift + F6(windows/Linux)：</strong> 对类、变量或者方法名重命名。</p>
<p><img src="./pictures/rename.gif" alt="重命名" /></p>
<h3 id="提取相关重构手段"> 提取相关重构手段</h3>
<p>这部分的快捷键实际很好记忆，我是这样记忆的:</p>
<p>前面两个键位是  <code>command + option(mac) / ctrl + alt (Windows/Linux)</code> 是固定的，只有后面一个键位会变比如Extract constant (提取变量)就是 c（constant）、Extract variable (提取变量)就是 v(variable)。</p>
<h4 id="提取常量-extract-constant"> 提取常量(extract constant)</h4>
<ol>
<li><strong>使用场景</strong> ：提取未经过定义就直接出现的常量。提取常量使得你的编码更易读，避免硬编码。</li>
<li><strong>快捷键：</strong>  <code>command + option+ c(mac)/ ctrl + alt + c(Windows/Linux)</code></li>
</ol>
<p><strong>示例：</strong></p>
<p><img src="./pictures/exact/extract-constant.gif" alt="" /></p>
<h4 id="提取参数-exact-parameter"> 提取参数(exact parameter﻿)</h4>
<ol>
<li><strong>使用场景</strong> ：提取参数到方法中。</li>
<li><strong>快捷键：</strong>  <code>command + option+ p(mac)/ ctrl + alt + p(Windows/Linux)</code></li>
</ol>
<p><img src="./pictures/exact/exact-parameter.gif" alt="" /></p>
<h4 id="提取变量-exact-variable"> 提取变量(exact variable)</h4>
<ol>
<li><strong>使用场景</strong> ：提取多次出现的表达式。</li>
<li><strong>快捷键：</strong> <code>command + option+ v(mac) / ctrl + alt + v(Windows/Linux)</code></li>
</ol>
<p><strong>示例：</strong></p>
<p><img src="./pictures/exact/exact-variable.gif" alt="" /></p>
<h4 id="提取属性-exact-field"> 提取属性(exact field)</h4>
<ol>
<li><strong>使用场景</strong> ：把当前表达式提取成为类的一个属性。</li>
<li><strong>快捷键：</strong> <code>command + option+ f(mac) / ctrl + alt + f(Windows/Linux)</code></li>
</ol>
<p><strong>示例：</strong></p>
<p><img src="./pictures/exact/exact-field.gif" alt="" /></p>
<p><strong>示例：</strong></p>
<p><img src="./pictures/exact/exact-variable.gif" alt="" /></p>
<h4 id="提取方法-exact-method"> 提取方法(exact method)</h4>
<ol>
<li><strong>使用场景</strong> ：1个或者多个表达式可以提取为一个方法。 提取方法也能使得你的编码更易读，更加语义化。</li>
<li><strong>快捷键：</strong>  <code>command + option+ m(mac)/ ctrl + alt + m(Windows/Linux)</code></li>
</ol>
<p><strong>示例：</strong></p>
<p><img src="./pictures/exact/exact-method.gif" alt="" /></p>
<h4 id="提取接口-exact-interface"> 提取接口(exact interface)</h4>
<ol>
<li><strong>使用场景</strong> ：想要把一个类中的1个或多个方法提取到一个接口中的时候。</li>
<li><strong>快捷键：</strong>  <code>command + option+ m(mac)/ ctrl + alt + m(Windows/Linux)</code></li>
</ol>
<p><strong>示例：</strong></p>
<p><img src="./pictures/exact/exact-interface.gif" alt="" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>IDEA源码阅读技巧</title>
      <link>https://javaguide.cn/idea-tutorial/idea-tips/idea-source-code-reading-skills/</link>
      <guid>https://javaguide.cn/idea-tutorial/idea-tips/idea-source-code-reading-skills/</guid>
      <source url="https://javaguide.cn/rss.xml">IDEA源码阅读技巧</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="idea源码阅读技巧"> IDEA源码阅读技巧</h1>
<p>项目有个新来了一个小伙伴，他看我查看项目源代码的时候，各种骚操作“花里胡哨”的。于是他向我请教，想让我分享一下我平时使用 IDEA 看源码的小技巧。</p>
<h2 id="基本操作"> 基本操作</h2>
<p>这一部分的内容主要是一些我平时看源码的时候常用的快捷键/小技巧！非常好用！</p>
<p>掌握这些快捷键/小技巧，看源码的效率提升一个等级！</p>
<h3 id="查看当前类的层次结构"> 查看当前类的层次结构</h3>
<table>
<thead>
<tr>
<th>使用频率</th>
<th>相关快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>⭐⭐⭐⭐⭐</td>
<td><code>Ctrl + H</code></td>
</tr>
</tbody>
</table>
<p>平时，我们阅读源码的时候，经常需要查看类的层次结构。就比如我们遇到抽象类或者接口的时候，经常需要查看其被哪些类实现。</p>
<p>拿 Spring 源码为例，<code>BeanDefinition</code> 是一个关于 Bean 属性/定义的接口。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>BeanDefinition</span> <span>extends</span> <span>AttributeAccessor</span><span>,</span> <span>BeanMetadataElement</span> <span>{</span>
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果我们需要查看 <code>BeanDefinition</code> 被哪些类实现的话，只需要把鼠标移动到 <code>BeanDefinition</code> 类名上，然后使用快捷键 <code>Ctrl + H</code> 即可。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135533686.png" alt="" /></p>
<p>同理，如果你想查看接口 <code>BeanDefinition</code> 继承的接口 <code>AttributeAccessor</code> 被哪些类实现的话，只需要把鼠标移动到 <code>AttributeAccessor</code> 类名上，然后使用快捷键 <code>Ctrl + H</code> 即可。</p>
<h3 id="查看类结构"> 查看类结构</h3>
<table>
<thead>
<tr>
<th>使用频率</th>
<th>相关快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>⭐⭐⭐⭐</td>
<td><code>Alt + 7</code>(Win) / <code>Command +7</code> （Mac）</td>
</tr>
</tbody>
</table>
<p>类结构可以让我们快速了解到当前类的方法、变量/常量，非常使用！</p>
<p>我们在对应的类的任意位置使用快捷键 <code>Alt + 7</code>(Win) / <code>Command +7</code> （Mac）即可。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135552183.png" alt="" /></p>
<h3 id="快速检索类"> 快速检索类</h3>
<table>
<thead>
<tr>
<th>使用频率</th>
<th>相关快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>⭐⭐⭐⭐⭐</td>
<td><code>Ctrl + N</code> (Win) / <code>Command + O</code> （Mac）</td>
</tr>
</tbody>
</table>
<p>使用快捷键 <code>Ctrl + N</code> (Win) / <code>Command + O</code> （Mac）可以快速检索类/文件。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135629367.png" alt="" /></p>
<h3 id="关键字检索"> 关键字检索</h3>
<table>
<thead>
<tr>
<th>使用频率</th>
<th>相关快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>⭐⭐⭐⭐⭐</td>
<td>见下文</td>
</tr>
</tbody>
</table>
<ul>
<li>当前文件下检索 ： <code>Ctrl + F</code> (Win) / <code>Command + F</code> （Mac）</li>
<li>全局的文本检索 : <code>Ctrl + Shift + F</code> (Win) / <code>Command + Shift + F</code> （Mac）</li>
</ul>
<h3 id="查看方法-类的实现类"> 查看方法/类的实现类</h3>
<table>
<thead>
<tr>
<th>使用频率</th>
<th>相关快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>⭐⭐⭐⭐</td>
<td><code>Ctrl + Alt + B</code> (Win) / <code>Command + Alt + B</code> (Mac)</td>
</tr>
</tbody>
</table>
<p>如果我们想直接跳转到某个方法/类的实现类，直接在方法名或者类名上使用快捷键 <code>Ctrl + Alt + B/鼠标左键</code> (Win) / <code>Command + Alt + B/鼠标左键</code> (Mac) 即可。</p>
<p>如果对应的方法/类只有一个实现类的话，会直接跳转到对应的实现类。</p>
<p>比如 <code>BeanDefinition</code> 接口的 <code>getBeanClassName()</code> 方法只被 <code>AbstractBeanDefinition</code> 抽象类实现，我们对这个方法使用快捷键就可以直接跳转到 <code>AbstractBeanDefinition</code> 抽象类中对应的实现方法。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>BeanDefinition</span> <span>extends</span> <span>AttributeAccessor</span><span>,</span> <span>BeanMetadataElement</span> <span>{</span>
  <span>@Nullable</span>
	<span>String</span> <span>getBeanClassName</span><span>(</span><span>)</span><span>;</span>
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果对应的方法/类有多个实现类的话，IDEA 会弹出一个选择框让你选择。</p>
<p>比如 <code>BeanDefinition</code> 接口的 <code>getParentName()</code> 方法就有多个不同的实现。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135703164.png" alt="" /></p>
<h3 id="查看方法被使用的情况"> 查看方法被使用的情况</h3>
<table>
<thead>
<tr>
<th>使用频率</th>
<th>相关快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>⭐⭐⭐⭐</td>
<td><code>Alt + F7</code></td>
</tr>
</tbody>
</table>
<p>我们可以通过直接在方法名上使用快捷键 <code>Alt + F7</code> 来查看这个方法在哪些地方被调用过。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135712962.png" alt="" /></p>
<h3 id="查看最近使用的文件"> 查看最近使用的文件</h3>
<table>
<thead>
<tr>
<th>使用频率</th>
<th>相关快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>⭐⭐⭐⭐⭐</td>
<td><code>Ctrl + E</code>(Win) / <code>Command +E</code> （Mac）</td>
</tr>
</tbody>
</table>
<p>你可以通过快捷键 <code>Ctrl + E</code>(Win) / <code>Command +E</code> （Mac）来显示 IDEA 最近使用的一些文件。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135733816.png" alt="" /></p>
<h3 id="查看图表形式的类继承链"> 查看图表形式的类继承链</h3>
<table>
<thead>
<tr>
<th>使用频率</th>
<th>相关快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>⭐⭐⭐⭐</td>
<td>相关快捷键较多，不建议记</td>
</tr>
</tbody>
</table>
<p>点击类名 <strong>右键</strong> ，选择 <strong>Shw Diagrams</strong> 即可查看图表形式的类继承链。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135745518.png" alt="" /></p>
<p>你还可以对图表进行一些操作。比如，你可以点击图表中具体的类 <strong>右键</strong>，然后选择显示它的实现类或者父类。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135757163.png" alt="" /></p>
<p>再比如你还可以选择是否显示类中的属性、方法、内部类等等信息。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135902827.png" alt="" /></p>
<p>如果你想跳转到对应类的源码的话，直接点击图表中具体的类 <strong>右键</strong> ，然后选择 <strong>Jump to Source</strong> 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135807668.png" alt="" /></p>
<h2 id="插件推荐"> 插件推荐</h2>
<h3 id="一键生成方法的序列图"> 一键生成方法的序列图</h3>
<p><strong>序列图</strong>（Sequence Diagram），亦称为<strong>循序图</strong>，是一种 UML 行为图。表示系统执行某个方法/操作（如登录操作）时，对象之间的顺序调用关系。</p>
<p>这个顺序调用关系可以这样理解：你需要执行系统中某个对象 a 提供的方法/操作 login（登录），但是这个对象又依赖了对象 b 提供的方法 getUser(获取用户)。因此，这里就有了 a -&gt; b 调用关系之说。</p>
<p>我们可以通过 <strong>SequenceDiagram</strong> 这个插件一键生成方法的序列图。</p>
<blockquote>
<p>如果你因为网络问题没办法使用 IDEA 自带的插件市场的话，也可以通过 IDEA 插件市场的官网手动下载安装。</p>
</blockquote>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/2021052218304014.png" alt="" /></p>
<p><strong>如何使用呢？</strong></p>
<p>1、选中方法名（注意不要选类名），然后点击鼠标右键，选择 <strong>Sequence Diagram</strong> 选项即可！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021170110697.png" alt="" /></p>
<p>2、配置生成的序列图的一些基本的参数比如调用深度之后，我们点击 ok 即可！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/c5040f1105c762ddf8689892913bc02d.png" alt="" /></p>
<p>3、你还可以通过生成的时序图来定位到相关的代码，这对于我们阅读源码的时候尤其有帮助！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021171623809.png" alt="" /></p>
<p>4、时序图生成完成之后，你还可以选择将其导出为图片。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021170228723.png" alt="" /></p>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/SG1twZczqdup_EQAOmNERg" target="_blank" rel="noopener noreferrer">《安利一个 IDEA 骚操作:一键生成方法的序列图》</a> 。</p>
<h3 id="项目代码统计"> 项目代码统计</h3>
<p>为了快速分析项目情况，我们可以对项目的 <strong>代码的总行数、单个文件的代码行数、注释行数等信息进行统计。</strong></p>
<p><strong>Statistic</strong> 这个插件来帮助我们实现这一需求。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210522183550110.png" alt="" /></p>
<p>有了这个插件之后你可以非常直观地看到你的项目中所有类型的文件的信息比如数量、大小等等，可以帮助你更好地了解你们的项目。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210522183616310.png" alt="" /></p>
<p>你还可以使用它看所有类的总行数、有效代码行数、注释行数、以及有效代码比重等等这些东西。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210522183630459.png" alt="" /></p>
<p>如果，你担心插件过多影响 IDEA 速度的话，可以只在有代码统计需求的时候开启这个插件，其他时间禁用它就完事了！</p>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/fVEeMW6elhu79I-rTZB40A" target="_blank" rel="noopener noreferrer">快速识别烂项目！试试这款项目代码统计 IDEA 插件</a></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135533686.png" type="image/png"/>
    </item>
    <item>
      <title>IntelliJ IDEA 使用指南 | 必备插件推荐 | 插件开发入门 | 重构小技巧 | 源码阅读技巧</title>
      <link>https://javaguide.cn/idea-tutorial/</link>
      <guid>https://javaguide.cn/idea-tutorial/</guid>
      <source url="https://javaguide.cn/rss.xml">IntelliJ IDEA 使用指南 | 必备插件推荐 | 插件开发入门 | 重构小技巧 | 源码阅读技巧</source>
      <category>IDEA指南</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="intellij-idea-使用指南-必备插件推荐-插件开发入门-重构小技巧-源码阅读技巧"> IntelliJ IDEA 使用指南 | 必备插件推荐 | 插件开发入门 | 重构小技巧 | 源码阅读技巧</h1>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/2a2423cd-68bc-4c39-ae8f-1ba9915c5404.png" alt="" /></p>
<p>在这里，我会分享一下自己使用 IDEA 的一些经验，希望对大家有帮助（欢迎 star）！</p>
<ul>
<li>Github 地址：<a href="https://github.com/CodingDocs/awesome-idea-tutorial" target="_blank" rel="noopener noreferrer">https://github.com/CodingDocs/awesome-idea-tutorial</a></li>
<li>码云地址：<a href="https://gitee.com/SnailClimb/awesome-idea-tutorial" target="_blank" rel="noopener noreferrer">https://gitee.com/SnailClimb/awesome-idea-tutorial</a> （Github 无法访问或者访问速度比较慢的小伙伴可以看码云上的对应内容）</li>
</ul>
<p>大学的时候，我一直在用 Eclipse ，说实话用习惯了，占内存也比较小，最主要的是还免费使用。我当时一直没有换 IntelliJ IDEA（后面会简称为 IDEA） 的很大一部分原因是切换到 IDEA 需要很长时间去适应，有点跳出舒适区的感觉。</p>
<p>不过，说实话，我现在用 IDEA 这么久了，还是感觉很香的！俗话说：<strong>工欲善其事，必先利其器 ，就我个人而言 IDEA 是最适合 Java 开发者的 IDE 。</strong> 如果你没有用过的 IDEA 就随便评判两者的话，我建议你不妨挑出自己的舒适区，尝试着去使用一段时间。<strong>如果你觉得 Eclipse 更适合你的话，我觉得也没忙病，萝卜白菜各有所爱，我们也要尊重别人的想法 💡。</strong></p>
<p>IDEA 是 JetBrains 在 2001 年发布的，主要用来支持 Java 编程，不过也支持 Kotlin（由 JetBrains 开发），Groovy，Clojure，Scala 等编程语言。</p>
<p>JetBrains 真的是很厉害的一家公司，这家公司推出的很多 IDE 基本都是工程师编程首选比如 PyCharm、WebStorm 等等。这家公司做出来的东西为什么好？我觉得主要就一个词总结：<strong>智能</strong> （ IntelliJ-&gt;intelligent)</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/cover.png" alt="Intelligent Agents Lab" /></p>
<p>下面 Guide 会简单对比一下它们，方便大家更好地去了解这个 IDE。</p>
<h3 id="易用程度"> 易用程度</h3>
<h4 id="idea-提供了更多人性化的功能"> IDEA 提供了更多人性化的功能</h4>
<p>个人感觉 IDEA 更加易用，因为 IDEA 内置了太多人性的话的功能比如对 Git 功能的支持、代码检查等等。</p>
<p>如下图示，这个是 IDEA 自带的版本控制功能，非常好用，清晰地展示了提交记录，便于查阅别人的提交以及项目组进行 Code Review。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/0538df6c-4043-4894-8b75-9bee97fec64a.png" alt="版本控制" /></p>
<h4 id="idea-智能上下文提示"> IDEA 智能上下文提示</h4>
<p>另外，<strong>IDEA 比 Eclipse 更好的一点是它的智能代码提示，这个确实好用，而且还是根据你当前上下文来提示提示的（基于快速索引技术）。</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/8173c155-2b90-41c0-9f2d-76270262f06d.png" alt="" /></p>
<h4 id="使用-idea-更加智能的进行重构"> 使用 IDEA 更加智能的进行重构</h4>
<p>IDEA 对重构的支持更加友好以及安全，你可以更加方便地去进行重构比如使用快捷键提取方法、抽取变量等等。</p>
<p>下图对应地地址在这里：<a href="https://www.jetbrains.com/help/idea/refactoring-source-code.html" target="_blank" rel="noopener noreferrer">https://www.jetbrains.com/help/idea/refactoring-source-code.html</a> 。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/bf928840-043e-4607-a0fe-f57133458fa0.png" alt="" /></p>
<h3 id="是否免费"> 是否免费</h3>
<p>IDEA 社区版和 Eclipse IDE 均可免费下载和使用，不过 IDEA 还提供了一个功能更多地称为 Ultimate Edition（最终版本）的版本，不过作为 Java 初学者来说 IntelliJ IDEA 社区版就完全够用了。</p>
<p>IDEA 的付费商业版本和免费版本的主要区别如下图所示，可以看出商业版的 IDEA 提供了更多功能的支持比如帮你找到你的项目中找到重复的代码块、提供数据库管理工具等等。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/81e432ec-79d0-465c-811f-7bf706eab6b7.png" alt="" /></p>
<h3 id="系统占用和内存管理"> 系统占用和内存管理</h3>
<p>不得不承认， IDEA 的系统占用更大，平稳运行至少需要 4g 以上的闲置内存。而 Eclipse 只需要 1g 的内存就组足够平稳运行了（项目过大的情况可能需要更多地运行内存支持）。</p>
<p>另外，内存管理方面的话，Eclipse 做的也更好，之前我的电脑是 8 g 内存，不过，它足以流畅运行 Eclipse 。我现在的电脑是 16 g 内存，某些时候运行 IDEA 甚至会比较卡顿。</p>
<p><strong>如果你的电脑真的没办法支持 IDEA 运行的话，我的建议是：“你要换电脑了”。</strong></p>
<h3 id="插件"> 插件</h3>
<p>相比于 Eclipse 来说，IDEA 里面有太多太多宝藏插件了，真的非常棒 👍！</p>
<blockquote>
<p>最近我也在整理一些使用 IDEA 开发必备的插件，可能只需要 30s 就能收走你们的再看。下一篇文章我就会分享到，大家期待一波吧！</p>
</blockquote>
<p>很多插件都会优先支持 IDEA，毕竟 IDEA 的使用占比率还是比较大的。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/1156a113-4370-4e8d-bd81-f95732a8cda6.png" alt="" /></p>
<h3 id="受欢迎程度"> 受欢迎程度</h3>
<p>就现在来看，IDEA 的使用占比和受欢迎程度比 Eclipse 更高，并且大有远超之势。</p>
<p>下图是国外的一个网站的一个统计报告！</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/b4639707-ad60-4aae-8ee8-35408939b413.png" alt="" /></p>
<p>最后再分享一下国外一个网站关于 “ Java 编程最好的 IDE 是哪一个？”的数据，可以看出 IDEA 还是略胜一筹的。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/dfa0db1b-66c9-41bc-91ce-880094e6c9fc.png" alt="" /></p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/2a2423cd-68bc-4c39-ae8f-1ba9915c5404.png" type="image/png"/>
    </item>
    <item>
      <title>BigDecimal解决浮点数运算精度丢失问题</title>
      <link>https://javaguide.cn/java/basis/bigdecimal/</link>
      <guid>https://javaguide.cn/java/basis/bigdecimal/</guid>
      <source url="https://javaguide.cn/rss.xml">BigDecimal解决浮点数运算精度丢失问题</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 <code>BigDecimal</code> 来进行浮点数的运算”。</p>
<p>这篇文章，我就简单解释一下浮点数运算出现精度丢失的原因以及 <code>BigDecimal</code> 的常见用法，希望对大家有帮助！</p>
<h2 id="bigdecimal-介绍"> BigDecimal 介绍</h2>
<p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<p>纳尼，浮点数的运算竟然还会有精度丢失的风险吗？确实会！</p>
<p>示例代码：</p>
<div><pre><code><span>float</span> a <span>=</span> <span>2.0f</span> <span>-</span> <span>1.9f</span><span>;</span>
<span>float</span> b <span>=</span> <span>1.8f</span> <span>-</span> <span>1.7f</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span><span>// 0.100000024</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b<span>)</span><span>;</span><span>// 0.099999905</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> b<span>)</span><span>;</span><span>// false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>为什么浮点数 <code>float</code> 或 <code>double</code> 运算的时候会有精度丢失的风险呢？</strong></p>
<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<p>就比如说十进制下的 0.2 就没办法精确转换成二进制小数：</p>
<div><pre><code><span>// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span>
<span>// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span>
<span>0.2</span> <span>*</span> <span>2</span> <span>=</span> <span>0.4</span> <span>-></span> <span>0</span>
<span>0.4</span> <span>*</span> <span>2</span> <span>=</span> <span>0.8</span> <span>-></span> <span>0</span>
<span>0.8</span> <span>*</span> <span>2</span> <span>=</span> <span>1.6</span> <span>-></span> <span>1</span>
<span>0.6</span> <span>*</span> <span>2</span> <span>=</span> <span>1.2</span> <span>-></span> <span>1</span>
<span>0.2</span> <span>*</span> <span>2</span> <span>=</span> <span>0.4</span> <span>-></span> <span>0</span>（发生循环）
<span>.</span><span>.</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>关于浮点数的更多内容，建议看一下<a href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/" target="_blank" rel="noopener noreferrer">计算机系统基础（四）浮点数</a>这篇文章。</p>
<h2 id="bigdecimal-的用处"> BigDecimal 的用处</h2>
<p>《阿里巴巴 Java 开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211213101646884.png" alt="" /></p>
<p>具体原因我们在上面已经详细介绍了，这里就不多提了，我们下面直接上实例：</p>
<div><pre><code><span>float</span> a <span>=</span> <span>1.0f</span> <span>-</span> <span>0.9f</span><span>;</span>
<span>float</span> b <span>=</span> <span>0.9f</span> <span>-</span> <span>0.8f</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span><span>// 0.100000024</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b<span>)</span><span>;</span><span>// 0.099999964</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> b<span>)</span><span>;</span><span>// false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>从输出结果就可以看出发生精度丢失的问题。</p>
<p>想要解决这个问题也很简单，直接使用 <code>BigDecimal</code> 来定义浮点数的值，再进行浮点数的运算操作即可。</p>
<div><pre><code><span>BigDecimal</span> a <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"1.0"</span><span>)</span><span>;</span>
<span>BigDecimal</span> b <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"0.9"</span><span>)</span><span>;</span>
<span>BigDecimal</span> c <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"0.8"</span><span>)</span><span>;</span>

<span>BigDecimal</span> x <span>=</span> a<span>.</span><span>subtract</span><span>(</span>b<span>)</span><span>;</span>
<span>BigDecimal</span> y <span>=</span> b<span>.</span><span>subtract</span><span>(</span>c<span>)</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>)</span><span>;</span> <span>/* 0.1 */</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>y<span>)</span><span>;</span> <span>/* 0.1 */</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Objects</span><span>.</span><span>equals</span><span>(</span>x<span>,</span> y<span>)</span><span>)</span><span>;</span> <span>/* true */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="bigdecimal-常见方法"> BigDecimal 常见方法</h2>
<h3 id="加减乘除"> 加减乘除</h3>
<p><code>add</code> 方法用于将两个 <code>BigDecimal</code> 对象相加，<code>subtract</code> 方法用于将两个 <code>BigDecimal</code> 对象相减。<code>multiply</code> 方法用于将两个 <code>BigDecimal</code> 对象相乘，<code>divide</code> 方法用于将两个 <code>BigDecimal</code> 对象相除。</p>
<div><pre><code><span>BigDecimal</span> a <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"1.0"</span><span>)</span><span>;</span>
<span>BigDecimal</span> b <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"0.9"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>add</span><span>(</span>b<span>)</span><span>)</span><span>;</span><span>// 1.9</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>subtract</span><span>(</span>b<span>)</span><span>)</span><span>;</span><span>// 0.1</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>multiply</span><span>(</span>b<span>)</span><span>)</span><span>;</span><span>// 0.90</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>divide</span><span>(</span>b<span>)</span><span>)</span><span>;</span><span>// 无法除尽，抛出 ArithmeticException 异常</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>divide</span><span>(</span>b<span>,</span> <span>2</span><span>,</span> <span>RoundingMode</span><span>.</span>HALF_UP<span>)</span><span>)</span><span>;</span><span>// 1.11</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这里需要注意的是，在我们使用 <code>divide</code> 方法的时候尽量使用 3 个参数版本，并且<code>RoundingMode</code> 不要选择 <code>UNNECESSARY</code>，否则很可能会遇到 <code>ArithmeticException</code>（无法除尽出现无限循环小数的时候），其中 <code>scale</code> 表示要保留几位小数，<code>roundingMode</code> 代表保留规则。</p>
<div><pre><code><span>public</span> <span>BigDecimal</span> <span>divide</span><span>(</span><span>BigDecimal</span> divisor<span>,</span> <span>int</span> scale<span>,</span> <span>RoundingMode</span> roundingMode<span>)</span> <span>{</span>
    <span>return</span> <span>divide</span><span>(</span>divisor<span>,</span> scale<span>,</span> roundingMode<span>.</span>oldMode<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>保留规则非常多，这里列举几种:</p>
<div><pre><code><span>public</span> <span>enum</span> <span>RoundingMode</span> <span>{</span>
   <span>// 2.5 -> 3 , 1.6 -> 2</span>
   <span>// -1.6 -> -2 , -2.5 -> -3</span>
			 <span>UP</span><span>(</span><span>BigDecimal</span><span>.</span>ROUND_UP<span>)</span><span>,</span>
   <span>// 2.5 -> 2 , 1.6 -> 1</span>
   <span>// -1.6 -> -1 , -2.5 -> -2</span>
			 <span>DOWN</span><span>(</span><span>BigDecimal</span><span>.</span>ROUND_DOWN<span>)</span><span>,</span>
			 <span>// 2.5 -> 3 , 1.6 -> 2</span>
   <span>// -1.6 -> -1 , -2.5 -> -2</span>
			 <span>CEILING</span><span>(</span><span>BigDecimal</span><span>.</span>ROUND_CEILING<span>)</span><span>,</span>
			 <span>// 2.5 -> 2 , 1.6 -> 1</span>
   <span>// -1.6 -> -2 , -2.5 -> -3</span>
			 <span>FLOOR</span><span>(</span><span>BigDecimal</span><span>.</span>ROUND_FLOOR<span>)</span><span>,</span>
   	<span>// 2.5 -> 3 , 1.6 -> 2</span>
   <span>// -1.6 -> -2 , -2.5 -> -3</span>
			 <span>HALF_UP</span><span>(</span><span>BigDecimal</span><span>.</span>ROUND_HALF_UP<span>)</span><span>,</span>
   <span>//......</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="大小比较"> 大小比较</h3>
<p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1 表示 <code>a</code> 大于 <code>b</code>。</p>
<div><pre><code><span>BigDecimal</span> a <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"1.0"</span><span>)</span><span>;</span>
<span>BigDecimal</span> b <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"0.9"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>compareTo</span><span>(</span>b<span>)</span><span>)</span><span>;</span><span>// 1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="保留几位小数"> 保留几位小数</h3>
<p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA 会提示。</p>
<div><pre><code><span>BigDecimal</span> m <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"1.255433"</span><span>)</span><span>;</span>
<span>BigDecimal</span> n <span>=</span> m<span>.</span><span>setScale</span><span>(</span><span>3</span><span>,</span><span>RoundingMode</span><span>.</span>HALF_DOWN<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>n<span>)</span><span>;</span><span>// 1.255</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="bigdecimal-的使用注意事项"> BigDecimal 的使用注意事项</h2>
<p>注意：我们在使用 <code>BigDecimal</code> 时，为了防止精度丢失，推荐使用它的<code>BigDecimal(String val)</code>构造方法或者 <code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象。</p>
<p>《阿里巴巴 Java 开发手册》对这部分内容也有提到，如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211213102222601.png" alt="" /></p>
<h2 id="bigdecimal-工具类分享"> BigDecimal 工具类分享</h2>
<p>网上有一个使用人数比较多的 <code>BigDecimal</code> 工具类，提供了多个静态方法来简化 <code>BigDecimal</code> 的操作。</p>
<p>我对其进行了简单改进，分享一下源码：</p>
<div><pre><code><span>import</span> <span>java<span>.</span>math<span>.</span></span><span>BigDecimal</span><span>;</span>
<span>import</span> <span>java<span>.</span>math<span>.</span></span><span>RoundingMode</span><span>;</span>

<span>/**
 * 简化BigDecimal计算的小工具类
 */</span>
<span>public</span> <span>class</span> <span>BigDecimalUtil</span> <span>{</span>

    <span>/**
     * 默认除法运算精度
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEF_DIV_SCALE <span>=</span> <span>10</span><span>;</span>

    <span>private</span> <span>BigDecimalUtil</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>/**
     * 提供精确的加法运算。
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */</span>
    <span>public</span> <span>static</span> <span>double</span> <span>add</span><span>(</span><span>double</span> v1<span>,</span> <span>double</span> v2<span>)</span> <span>{</span>
        <span>BigDecimal</span> b1 <span>=</span> <span>BigDecimal</span><span>.</span><span>valueOf</span><span>(</span>v1<span>)</span><span>;</span>
        <span>BigDecimal</span> b2 <span>=</span> <span>BigDecimal</span><span>.</span><span>valueOf</span><span>(</span>v2<span>)</span><span>;</span>
        <span>return</span> b1<span>.</span><span>add</span><span>(</span>b2<span>)</span><span>.</span><span>doubleValue</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 提供精确的减法运算。
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */</span>
    <span>public</span> <span>static</span> <span>double</span> <span>subtract</span><span>(</span><span>double</span> v1<span>,</span> <span>double</span> v2<span>)</span> <span>{</span>
        <span>BigDecimal</span> b1 <span>=</span> <span>BigDecimal</span><span>.</span><span>valueOf</span><span>(</span>v1<span>)</span><span>;</span>
        <span>BigDecimal</span> b2 <span>=</span> <span>BigDecimal</span><span>.</span><span>valueOf</span><span>(</span>v2<span>)</span><span>;</span>
        <span>return</span> b1<span>.</span><span>subtract</span><span>(</span>b2<span>)</span><span>.</span><span>doubleValue</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 提供精确的乘法运算。
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */</span>
    <span>public</span> <span>static</span> <span>double</span> <span>multiply</span><span>(</span><span>double</span> v1<span>,</span> <span>double</span> v2<span>)</span> <span>{</span>
        <span>BigDecimal</span> b1 <span>=</span> <span>BigDecimal</span><span>.</span><span>valueOf</span><span>(</span>v1<span>)</span><span>;</span>
        <span>BigDecimal</span> b2 <span>=</span> <span>BigDecimal</span><span>.</span><span>valueOf</span><span>(</span>v2<span>)</span><span>;</span>
        <span>return</span> b1<span>.</span><span>multiply</span><span>(</span>b2<span>)</span><span>.</span><span>doubleValue</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍五入。
     *
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */</span>
    <span>public</span> <span>static</span> <span>double</span> <span>divide</span><span>(</span><span>double</span> v1<span>,</span> <span>double</span> v2<span>)</span> <span>{</span>
        <span>return</span> <span>divide</span><span>(</span>v1<span>,</span> v2<span>,</span> DEF_DIV_SCALE<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入。
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */</span>
    <span>public</span> <span>static</span> <span>double</span> <span>divide</span><span>(</span><span>double</span> v1<span>,</span> <span>double</span> v2<span>,</span> <span>int</span> scale<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>scale <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span>
                    <span>"The scale must be a positive integer or zero"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>BigDecimal</span> b1 <span>=</span> <span>BigDecimal</span><span>.</span><span>valueOf</span><span>(</span>v1<span>)</span><span>;</span>
        <span>BigDecimal</span> b2 <span>=</span> <span>BigDecimal</span><span>.</span><span>valueOf</span><span>(</span>v2<span>)</span><span>;</span>
        <span>return</span> b1<span>.</span><span>divide</span><span>(</span>b2<span>,</span> scale<span>,</span> <span>RoundingMode</span><span>.</span>HALF_UP<span>)</span><span>.</span><span>doubleValue</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 提供精确的小数位四舍五入处理。
     *
     * @param v     需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */</span>
    <span>public</span> <span>static</span> <span>double</span> <span>round</span><span>(</span><span>double</span> v<span>,</span> <span>int</span> scale<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>scale <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span>
                    <span>"The scale must be a positive integer or zero"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>BigDecimal</span> b <span>=</span> <span>BigDecimal</span><span>.</span><span>valueOf</span><span>(</span>v<span>)</span><span>;</span>
        <span>BigDecimal</span> one <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"1"</span><span>)</span><span>;</span>
        <span>return</span> b<span>.</span><span>divide</span><span>(</span>one<span>,</span> scale<span>,</span> <span>RoundingMode</span><span>.</span>HALF_UP<span>)</span><span>.</span><span>doubleValue</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 提供精确的类型转换(Float)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */</span>
    <span>public</span> <span>static</span> <span>float</span> <span>convertToFloat</span><span>(</span><span>double</span> v<span>)</span> <span>{</span>
        <span>BigDecimal</span> b <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span>v<span>)</span><span>;</span>
        <span>return</span> b<span>.</span><span>floatValue</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 提供精确的类型转换(Int)不进行四舍五入
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */</span>
    <span>public</span> <span>static</span> <span>int</span> <span>convertsToInt</span><span>(</span><span>double</span> v<span>)</span> <span>{</span>
        <span>BigDecimal</span> b <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span>v<span>)</span><span>;</span>
        <span>return</span> b<span>.</span><span>intValue</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 提供精确的类型转换(Long)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */</span>
    <span>public</span> <span>static</span> <span>long</span> <span>convertsToLong</span><span>(</span><span>double</span> v<span>)</span> <span>{</span>
        <span>BigDecimal</span> b <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span>v<span>)</span><span>;</span>
        <span>return</span> b<span>.</span><span>longValue</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回两个数中大的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中大的一个值
     */</span>
    <span>public</span> <span>static</span> <span>double</span> <span>returnMax</span><span>(</span><span>double</span> v1<span>,</span> <span>double</span> v2<span>)</span> <span>{</span>
        <span>BigDecimal</span> b1 <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span>v1<span>)</span><span>;</span>
        <span>BigDecimal</span> b2 <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span>v2<span>)</span><span>;</span>
        <span>return</span> b1<span>.</span><span>max</span><span>(</span>b2<span>)</span><span>.</span><span>doubleValue</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回两个数中小的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中小的一个值
     */</span>
    <span>public</span> <span>static</span> <span>double</span> <span>returnMin</span><span>(</span><span>double</span> v1<span>,</span> <span>double</span> v2<span>)</span> <span>{</span>
        <span>BigDecimal</span> b1 <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span>v1<span>)</span><span>;</span>
        <span>BigDecimal</span> b2 <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span>v2<span>)</span><span>;</span>
        <span>return</span> b1<span>.</span><span>min</span><span>(</span>b2<span>)</span><span>.</span><span>doubleValue</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 精确对比两个数字
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1
     */</span>
    <span>public</span> <span>static</span> <span>int</span> <span>compareTo</span><span>(</span><span>double</span> v1<span>,</span> <span>double</span> v2<span>)</span> <span>{</span>
        <span>BigDecimal</span> b1 <span>=</span> <span>BigDecimal</span><span>.</span><span>valueOf</span><span>(</span>v1<span>)</span><span>;</span>
        <span>BigDecimal</span> b2 <span>=</span> <span>BigDecimal</span><span>.</span><span>valueOf</span><span>(</span>v2<span>)</span><span>;</span>
        <span>return</span> b1<span>.</span><span>compareTo</span><span>(</span>b2<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br></div></div><h2 id="总结"> 总结</h2>
<p>浮点数没有办法用二进制精确表示，因此存在精度丢失的风险。</p>
<p>不过，Java 提供了<code>BigDecimal</code> 来操作浮点数。<code>BigDecimal</code> 的实现利用到了 <code>BigInteger</code> （用来操作大整数）, 所不同的是 <code>BigDecimal</code> 加入了小数位的概念。</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211213101646884.png" type="image/png"/>
    </item>
    <item>
      <title>IO模型详解</title>
      <link>https://javaguide.cn/java/basis/io%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</link>
      <guid>https://javaguide.cn/java/basis/io%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</guid>
      <source url="https://javaguide.cn/rss.xml">IO模型详解</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>IO 模型这块确实挺难理解的，需要太多计算机底层知识。写这篇文章用了挺久，就非常希望能把我所知道的讲出来吧!希望朋友们能有收获！为了写这篇文章，还翻看了一下《UNIX 网络编程》这本书，太难了，我滴乖乖！心痛~</p>
<p><em>个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！</em></p>
<h2 id="前言"> 前言</h2>
<p>I/O 一直是很多小伙伴难以理解的一个知识点，这篇文章我会将我所理解的 I/O 讲给你听，希望可以对你有所帮助。</p>
<h2 id="i-o"> I/O</h2>
<h3 id="何为-i-o"> 何为 I/O?</h3>
<p>I/O（<strong>I</strong>nput/<strong>O</strong>utpu） 即<strong>输入／输出</strong> 。</p>
<p><strong>我们先从计算机结构的角度来解读一下 I/O。</strong></p>
<p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p>
<p><img src="https://img-blog.csdnimg.cn/20190624122126398.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="冯诺依曼体系结构" /></p>
<p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</p>
<p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p>
<p><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p>
<p><strong>我们再先从应用程序的角度来解读一下 I/O。</strong></p>
<p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p>
<p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p>
<p>并且，用户空间的程序不能直接访问内核空间。</p>
<p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p>
<p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p>
<p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p>
<p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p>
<p>当应用程序发起 I/O 调用后，会经历两个步骤：</p>
<ol>
<li>内核等待 I/O 设备准备好数据</li>
<li>内核将数据从内核空间拷贝到用户空间。</li>
</ol>
<h3 id="有哪些常见的-io-模型"> 有哪些常见的 IO 模型?</h3>
<p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p>
<p>这也是我们经常提到的 5 种 IO 模型。</p>
<h2 id="java-中-3-种常见-io-模型"> Java 中 3 种常见 IO 模型</h2>
<h3 id="bio-blocking-i-o"> BIO (Blocking I/O)</h3>
<p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>
<p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》" /></p>
<p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<h3 id="nio-non-blocking-new-i-o"> NIO (Non-blocking/New I/O)</h3>
<p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>
<p>跟着我的思路往下看看，相信你会得到答案！</p>
<p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》" /></p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p>
<blockquote>
<p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持</p>
<ul>
<li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li>
<li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li>
</ul>
</blockquote>
<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>
<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f483f2437ce4ecdb180134270a00144~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<h3 id="aio-asynchronous-i-o"> AIO (Asynchronous I/O)</h3>
<p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>
<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p>
<p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2020/33b193457c928ae02217480f994814b6.png" alt="" /></p>
<h2 id="参考"> 参考</h2>
<ul>
<li>《深入拆解 Tomcat &amp; Jetty》</li>
<li>如何完成一次 IO：<a href="https://llc687.top/post/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E4%B8%80%E6%AC%A1-io/" target="_blank" rel="noopener noreferrer">https://llc687.top/post/如何完成一次-io/</a></li>
<li>程序员应该这样理解 IO：<a href="https://www.jianshu.com/p/fa7bdc4f3de7" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/fa7bdc4f3de7</a></li>
<li>10 分钟看懂， Java NIO 底层原理：https://www.cnblogs.com/crazymakercircle/p/10225159.html</li>
<li>IO 模型知多少 | 理论篇：https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html</li>
<li>《UNIX 网络编程 卷 1；套接字联网 API 》6.2 节 IO 模型</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/20190624122126398.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" type="image/"/>
    </item>
    <item>
      <title>final,static,this,super 关键字总结</title>
      <link>https://javaguide.cn/java/basis/java-keyword-summary/</link>
      <guid>https://javaguide.cn/java/basis/java-keyword-summary/</guid>
      <source url="https://javaguide.cn/rss.xml">final,static,this,super 关键字总结</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="final-static-this-super-关键字总结"> final,static,this,super 关键字总结</h1>
<h2 id="final-关键字"> final 关键字</h2>
<p><strong>final 关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：</strong></p>
<ol>
<li>
<p>final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；</p>
</li>
<li>
<p>final 修饰的方法不能被重写；</p>
</li>
<li>
<p>final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</p>
</li>
</ol>
<p>说明：使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</p>
<h2 id="static-关键字"> static 关键字</h2>
<p><strong>static 关键字主要有以下四种使用场景：</strong></p>
<ol>
<li><strong>修饰成员变量和成员方法:</strong> 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：<code>类名.静态变量名</code> <code>类名.静态方法名()</code></li>
<li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li>
<li><strong>静态内部类（static 修饰类的话只能修饰内部类）：</strong> 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。</li>
<li><strong>静态导包(用来导入类中的静态资源，1.5 之后的新特性):</strong> 格式为：<code>import static</code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li>
</ol>
<h2 id="this-关键字"> this 关键字</h2>
<p>this 关键字用于引用类的当前实例。 例如：</p>
<div><pre><code><span>class</span> <span>Manager</span> <span>{</span>
    <span>Employees</span><span>[</span><span>]</span> employees<span>;</span>
    <span>void</span> <span>manageEmployees</span><span>(</span><span>)</span> <span>{</span>
        <span>int</span> totalEmp <span>=</span> <span>this</span><span>.</span>employees<span>.</span>length<span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Total employees: "</span> <span>+</span> totalEmp<span>)</span><span>;</span>
        <span>this</span><span>.</span><span>report</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>void</span> <span>report</span><span>(</span><span>)</span> <span>{</span> <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在上面的示例中，this 关键字用于两个地方：</p>
<ul>
<li>this.employees.length：访问类 Manager 的当前实例的变量。</li>
<li>this.report（）：调用类 Manager 的当前实例的方法。</li>
</ul>
<p>此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。</p>
<h2 id="super-关键字"> super 关键字</h2>
<p>super 关键字用于从子类访问父类的变量和方法。 例如：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Super</span> <span>{</span>
    <span>protected</span> <span>int</span> number<span>;</span>
    <span>protected</span> <span>showNumber</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"number = "</span> <span>+</span> number<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>public</span> <span>class</span> <span>Sub</span> <span>extends</span> <span>Super</span> <span>{</span>
    <span>void</span> <span>bar</span><span>(</span><span>)</span> <span>{</span>
        <span>super</span><span>.</span>number <span>=</span> <span>10</span><span>;</span>
        <span>super</span><span>.</span><span>showNumber</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>在上面的例子中，Sub 类访问父类成员变量 number 并调用其父类 Super 的 <code>showNumber（）</code> 方法。</p>
<p><strong>使用 this 和 super 要注意的问题：</strong></p>
<ul>
<li>在构造器中使用 <code>super()</code> 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</li>
<li>this、super 不能用在 static 方法中。</li>
</ul>
<p><strong>简单解释一下：</strong></p>
<p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， <strong>this 和 super 是属于对象范畴的东西，而静态方法是属于类范畴的东西</strong>。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li>https://www.codejava.net/java-core/the-java-language/java-keywords</li>
<li>https://blog.csdn.net/u013393958/article/details/79881037</li>
</ul>
<h1 id="static-关键字详解"> static 关键字详解</h1>
<h2 id="static-关键字主要有以下四种使用场景"> static 关键字主要有以下四种使用场景</h2>
<ol>
<li>修饰成员变量和成员方法</li>
<li>静态代码块</li>
<li>修饰类(只能修饰内部类)</li>
<li>静态导包(用来导入类中的静态资源，1.5 之后的新特性)</li>
</ol>
<h3 id="修饰成员变量和成员方法-常用"> 修饰成员变量和成员方法(常用)</h3>
<p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</p>
<p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p>
<p>HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p>
<p>调用格式：</p>
<ul>
<li><code>类名.静态变量名</code></li>
<li><code>类名.静态方法名()</code></li>
</ul>
<p>如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。</p>
<p>测试方法：</p>
<div><pre><code><span>public</span> <span>class</span> <span>StaticBean</span> <span>{</span>
    <span>String</span> name<span>;</span>
    <span>//静态变量</span>
    <span>static</span> <span>int</span> age<span>;</span>
    <span>public</span> <span>StaticBean</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    <span>//静态方法</span>
    <span>static</span> <span>void</span> <span>sayHello</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello i am java"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"StaticBean{"</span><span>+</span>
                <span>"name="</span> <span>+</span> name <span>+</span> <span>",age="</span> <span>+</span> age <span>+</span>
                <span>"}"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>StaticDemo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>StaticBean</span> staticBean <span>=</span> <span>new</span> <span>StaticBean</span><span>(</span><span>"1"</span><span>)</span><span>;</span>
        <span>StaticBean</span> staticBean2 <span>=</span> <span>new</span> <span>StaticBean</span><span>(</span><span>"2"</span><span>)</span><span>;</span>
        <span>StaticBean</span> staticBean3 <span>=</span> <span>new</span> <span>StaticBean</span><span>(</span><span>"3"</span><span>)</span><span>;</span>
        <span>StaticBean</span> staticBean4 <span>=</span> <span>new</span> <span>StaticBean</span><span>(</span><span>"4"</span><span>)</span><span>;</span>
        <span>StaticBean</span><span>.</span>age <span>=</span> <span>33</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>staticBean <span>+</span> <span>" "</span> <span>+</span> staticBean2 <span>+</span> <span>" "</span> <span>+</span> staticBean3 <span>+</span> <span>" "</span> <span>+</span> staticBean4<span>)</span><span>;</span>
        <span>//StaticBean{name=1,age=33} StaticBean{name=2,age=33} StaticBean{name=3,age=33} StaticBean{name=4,age=33}</span>
        <span>StaticBean</span><span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span><span>//Hello i am java</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="静态代码块"> 静态代码块</h3>
<p>静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块 —&gt; 非静态代码块 —&gt; 构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</p>
<p>静态代码块的格式是</p>
<div><pre><code>static {
语句体;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM 加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM 将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-14/88531075.jpg" alt="" /></p>
<p>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问.</p>
<h3 id="静态内部类"> 静态内部类</h3>
<p>静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：</p>
<ol>
<li>它的创建是不需要依赖外围类的创建。</li>
<li>它不能使用任何外围类的非 static 成员变量和方法。</li>
</ol>
<p>Example（静态内部类实现单例模式）</p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>
    <span>//声明为 private 避免调用默认构造方法创建对象</span>
    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>
   <span>// 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问</span>
    <span>private</span> <span>static</span> <span>class</span> <span>SingletonHolder</span> <span>{</span>
        <span>private</span> <span>static</span> <span>final</span> <span>Singleton</span> INSTANCE <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>static</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>SingletonHolder</span><span>.</span>INSTANCE<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code>方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p>
<p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p>
<h3 id="静态导包"> 静态导包</h3>
<p>格式为：import static</p>
<p>这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法</p>
<div><pre><code> <span>//将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用</span>
 <span>//如果只想导入单一某个静态方法，只需要将*换成对应的方法名即可</span>
<span>import</span> <span>static</span> <span>java<span>.</span>lang<span>.</span></span><span>Math</span><span>.</span>*<span>;</span><span>//换成import static java.lang.Math.max;具有一样的效果</span>
<span>public</span> <span>class</span> <span>Demo</span> <span>{</span>
  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span> max <span>=</span> <span>max</span><span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>max<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="补充内容"> 补充内容</h2>
<h3 id="静态方法与非静态方法"> 静态方法与非静态方法</h3>
<p>静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。</p>
<p>Example</p>
<div><pre><code><span>class</span> <span>Foo</span> <span>{</span>
    <span>int</span> i<span>;</span>
    <span>public</span> <span>Foo</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
       <span>this</span><span>.</span>i <span>=</span> i<span>;</span>
    <span>}</span>
    <span>public</span> <span>static</span> <span>String</span> <span>method1</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>"An example string that doesn't depend on i (an instance variable)"</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>int</span> <span>method2</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>this</span><span>.</span>i <span>+</span> <span>1</span><span>;</span>  <span>//Depends on i</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>你可以像这样调用静态方法：<code>Foo.method1()</code>。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行</p>
<div><pre><code><span>Foo</span> bar <span>=</span> <span>new</span> <span>Foo</span><span>(</span><span>1</span><span>)</span><span>;</span>
bar<span>.</span><span>method2</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>总结：</p>
<ul>
<li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li>
</ul>
<h3 id="static-静态代码块与-非静态代码块-构造代码块"> <code>static{}</code>静态代码块与<code>{}</code>非静态代码块(构造代码块)</h3>
<p>相同点： 都是在 JVM 加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些 static 变量进行赋值。</p>
<p>不同点： 静态代码块在非静态代码块之前执行(静态代码块 -&gt; 非静态代码块 -&gt; 构造方法)。静态代码块只在第一次 new 执行一次，之后不再执行，而非静态代码块在每 new 一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。</p>
<blockquote>
<p><strong>🐛 修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/677" target="_blank" rel="noopener noreferrer">issue #677</a>）</strong> ：静态代码块可能在第一次 new 对象的时候执行，但不一定只在第一次 new 的时候执行。比如通过 <code>Class.forName(&quot;ClassDemo&quot;)</code>创建 Class 对象的时候也会执行，即 new 或者 <code>Class.forName(&quot;ClassDemo&quot;)</code> 都会执行静态代码块。
一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：<code>Arrays</code> 类，<code>Character</code> 类，<code>String</code> 类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的.</p>
</blockquote>
<p>Example：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>public</span> <span>Test</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"默认构造方法！--"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//非静态代码块</span>
    <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"非静态代码块！--"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//静态代码块</span>
    <span>static</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"静态代码块！--"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>private</span> <span>static</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"静态方法中的内容! --"</span><span>)</span><span>;</span>
        <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"静态方法中的代码块！--"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Test</span> test <span>=</span> <span>new</span> <span>Test</span><span>(</span><span>)</span><span>;</span>
        <span>Test</span><span>.</span><span>test</span><span>(</span><span>)</span><span>;</span><span>//静态代码块！--静态方法中的内容! --静态方法中的代码块！--</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>上述代码输出：</p>
<div><pre><code>静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！--
</code></pre>
<div><span>1</span><br></div></div><p>当只执行 <code>Test.test();</code> 时输出：</p>
<div><pre><code>静态代码块！--静态方法中的内容! --静态方法中的代码块！--
</code></pre>
<div><span>1</span><br></div></div><p>当只执行 <code>Test test = new Test();</code> 时输出：</p>
<div><pre><code>静态代码块！--非静态代码块！--默认构造方法！--
</code></pre>
<div><span>1</span><br></div></div><p>非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。</p>
<h3 id="参考-2"> 参考</h3>
<ul>
<li>https://blog.csdn.net/chen13579867831/article/details/78995480</li>
<li>https://www.cnblogs.com/chenssy/p/3388487.html</li>
<li>https://www.cnblogs.com/Qian123/p/5713440.html</li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-14/88531075.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>为什么 Java 中只有值传递？</title>
      <link>https://javaguide.cn/java/basis/why-there-only-value-passing-in-java/</link>
      <guid>https://javaguide.cn/java/basis/why-there-only-value-passing-in-java/</guid>
      <source url="https://javaguide.cn/rss.xml">为什么 Java 中只有值传递？</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="为什么-java-中只有值传递"> 为什么 Java 中只有值传递？</h1>
<p>开始之前，我们先来搞懂下面这两个概念：</p>
<ul>
<li>形参&amp;实参</li>
<li>值传递&amp;引用传递</li>
</ul>
<h2 id="形参-实参"> 形参&amp;实参</h2>
<p>方法的定义可能会用到 <strong>参数</strong>（有参的方法），参数在程序语言中分为：</p>
<ul>
<li><strong>实参（实际参数）</strong> ：用于传递给函数/方法的参数，必须有确定的值。</li>
<li><strong>形参（形式参数）</strong> ：用于定义函数/方法，接收实参，不需要有确定的值。</li>
</ul>
<div><pre><code><span>String</span> hello <span>=</span> <span>"Hello!"</span><span>;</span>
<span>// hello 为实参</span>
<span>sayHello</span><span>(</span>hello<span>)</span><span>;</span>
<span>// str 为形参</span>
<span>void</span> <span>sayHello</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="值传递-引用传递"> 值传递&amp;引用传递</h2>
<p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p>
<ul>
<li><strong>值传递</strong> ：方法接收的是实参值的拷贝，会创建副本。</li>
<li><strong>引用传递</strong> ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>
</ul>
<p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。</p>
<h2 id="为什么-java-只有值传递"> 为什么 Java 只有值传递？</h2>
<p><strong>为什么说 Java 只有值传递呢？</strong> 不需要太多废话，我通过 3 个例子来给大家证明。</p>
<h3 id="案例1-传递基本类型参数"> 案例1：传递基本类型参数</h3>
<p>代码：</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
    <span>int</span> num2 <span>=</span> <span>20</span><span>;</span>
    <span>swap</span><span>(</span>num1<span>,</span> num2<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num1<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num2 = "</span> <span>+</span> num2<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
    <span>int</span> temp <span>=</span> a<span>;</span>
    a <span>=</span> b<span>;</span>
    b <span>=</span> temp<span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a = "</span> <span>+</span> a<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"b = "</span> <span>+</span> b<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>输出：</p>
<div><pre><code>a = 20
b = 10
num1 = 10
num2 = 20
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>解析：</p>
<p>在 <code>swap()</code>  方法中，<code>a</code>、<code>b</code> 的值进行交换，并不会影响到 <code>num1</code>、<code>num2</code>。因为，<code>a</code>、<code>b</code> 的值，只是从 <code>num1</code>、<code>num2</code> 的复制过来的。也就是说，a、b 相当于 <code>num1</code>、<code>num2</code> 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p><img src="./images/java-value-passing-01.png" alt="基本数据类型参数" /></p>
<p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例2。</p>
<h3 id="案例2-传递引用类型参数1"> 案例2：传递引用类型参数1</h3>
<p>代码：</p>
<div><pre><code>	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
      <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span> <span>}</span><span>;</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
      <span>change</span><span>(</span>arr<span>)</span><span>;</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
	<span>}</span>

	<span>public</span> <span>static</span> <span>void</span> <span>change</span><span>(</span><span>int</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
      <span>// 将数组的第一个元素变为0</span>
      array<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
	<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>输出：</p>
<div><pre><code>1
0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>解析：</p>
<p><img src="./images/java-value-passing-02.png" alt="引用数据类型参数1" /></p>
<p>看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。</p>
<p>实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！</p>
<p>也就是说 <code>change</code> 方法的参数拷贝的是  <code>arr</code> （实参）的地址，因此，它和 <code>arr</code> 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。</p>
<p>为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！</p>
<h3 id="案例3-传递引用类型参数2"> 案例3 ：传递引用类型参数2</h3>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
   <span>// 省略构造函数、Getter&amp;Setter方法</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>Person</span> xiaoZhang <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"小张"</span><span>)</span><span>;</span>
    <span>Person</span> xiaoLi <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"小李"</span><span>)</span><span>;</span>
    <span>swap</span><span>(</span>xiaoZhang<span>,</span> xiaoLi<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"xiaoZhang:"</span> <span>+</span> xiaoZhang<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"xiaoLi:"</span> <span>+</span> xiaoLi<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>Person</span> person1<span>,</span> <span>Person</span> person2<span>)</span> <span>{</span>
    <span>Person</span> temp <span>=</span> person1<span>;</span>
    person1 <span>=</span> person2<span>;</span>
    person2 <span>=</span> temp<span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"person1:"</span> <span>+</span> person1<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"person2:"</span> <span>+</span> person2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>输出:</p>
<div><pre><code>person1:小李
person2:小张
xiaoZhang:小张
xiaoLi:小李
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>解析：</p>
<p>怎么回事？？？两个引用类型的形参互换并没有影响实参啊！</p>
<p><code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址。因此， <code>person1</code> 和 <code>person2</code> 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p>
<p><img src="./images/java-value-passing-03.png" alt="引用数据类型参数2" /></p>
<h2 id="总结"> 总结</h2>
<p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>
</ul>
<h2 id="参考"> 参考</h2>
<ul>
<li>《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节</li>
<li><a href="https://www.zhihu.com/question/31203609/answer/576030121" target="_blank" rel="noopener noreferrer">Java 到底是值传递还是引用传递？ - Hollis的回答 - 知乎</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>代理详解！静态代理+JDK/CGLIB 动态代理实战</title>
      <link>https://javaguide.cn/java/basis/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</link>
      <guid>https://javaguide.cn/java/basis/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</guid>
      <source url="https://javaguide.cn/rss.xml">代理详解！静态代理+JDK/CGLIB 动态代理实战</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1-代理模式"> 1. 代理模式</h2>
<p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p>举个例子：你找了小红来帮你问话，小红就可以看作是代理你的代理对象，代理的行为（方法）是问话。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/1*DjWCgTFm-xqbhbNQVsaWQw.png" alt="Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium" /></p>
<p style="text-align:right;font-size:13px;color:gray">https://medium.com/@mithunsasidharan/understanding-the-proxy-design-pattern-5e63fe38052a</p>
<p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。</p>
<h2 id="_2-静态代理"> 2. 静态代理</h2>
<p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（<em>后面会具体演示代码</em>），非常不灵活（<em>比如接口一旦新增加方法，目标对象和代理对象都要进行修改</em>）且麻烦(<em>需要对每个目标类都单独写一个代理类</em>)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>下面通过代码展示！</p>
<p><strong>1.定义发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>interface</span> <span>SmsService</span> <span>{</span>
    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.实现发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"send message:"</span> <span>+</span> message<span>)</span><span>;</span>
        <span>return</span> message<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SmsProxy</span> <span>implements</span> <span>SmsService</span> <span>{</span>

    <span>private</span> <span>final</span> <span>SmsService</span> smsService<span>;</span>

    <span>public</span> <span>SmsProxy</span><span>(</span><span>SmsService</span> smsService<span>)</span> <span>{</span>
        <span>this</span><span>.</span>smsService <span>=</span> smsService<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>//调用方法之前，我们可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method send()"</span><span>)</span><span>;</span>
        smsService<span>.</span><span>send</span><span>(</span>message<span>)</span><span>;</span>
        <span>//调用方法之后，我们同样可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method send()"</span><span>)</span><span>;</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>4.实际使用</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SmsService</span> smsService <span>=</span> <span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>;</span>
        <span>SmsProxy</span> smsProxy <span>=</span> <span>new</span> <span>SmsProxy</span><span>(</span>smsService<span>)</span><span>;</span>
        smsProxy<span>.</span><span>send</span><span>(</span><span>"java"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>
<div><pre><code>before method send<span>(</span><span>)</span>
send message:java
after method send<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p>
<h2 id="_3-动态代理"> 3. 动态代理</h2>
<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。</p>
<p><strong>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<p><a href="https://github.com/Snailclimb/guide-rpc-framework" target="_blank" rel="noopener noreferrer">guide-rpc-framework</a> 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。</p>
<p>另外，虽然 <a href="https://github.com/Snailclimb/guide-rpc-framework" target="_blank" rel="noopener noreferrer">guide-rpc-framework</a> 没有用到 <strong>CGLIB 动态代理</strong> ，我们这里还是简单介绍一下其使用以及和<strong>JDK 动态代理</strong>的对比。</p>
<h3 id="_3-1-jdk-动态代理机制"> 3.1. JDK 动态代理机制</h3>
<h4 id="_3-1-1-介绍"> 3.1.1. 介绍</h4>
<p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<div><pre><code>    <span>public</span> <span>static</span> <span>Object</span> <span>newProxyInstance</span><span>(</span><span>ClassLoader</span> loader<span>,</span>
                                          <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> interfaces<span>,</span>
                                          <span>InvocationHandler</span> h<span>)</span>
        <span>throws</span> <span>IllegalArgumentException</span>
    <span>{</span>
        <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>InvocationHandler</span> <span>{</span>

    <span>/**
     * 当你使用代理对象调用方法的时候实际会调用到这个方法
     */</span>
    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span>
        <span>throws</span> <span>Throwable</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li><strong>proxy</strong> :动态生成的代理类</li>
<li><strong>method</strong> : 与代理类对象调用的方法相对应</li>
<li><strong>args</strong> : 当前 method 方法的参数</li>
</ol>
<p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
<h4 id="_3-1-2-jdk-动态代理类使用步骤"> 3.1.2. JDK 动态代理类使用步骤</h4>
<ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ol>
<h4 id="_3-1-3-代码示例"> 3.1.3. 代码示例</h4>
<p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p>
<p><strong>1.定义发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>interface</span> <span>SmsService</span> <span>{</span>
    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.实现发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"send message:"</span> <span>+</span> message<span>)</span><span>;</span>
        <span>return</span> message<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.定义一个 JDK 动态代理类</strong></p>
<div><pre><code><span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationHandler</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationTargetException</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>/**
 * @author shuang.kou
 * @createTime 2020年05月11日 11:23:00
 */</span>
<span>public</span> <span>class</span> <span>DebugInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>
    <span>/**
     * 代理类中的真实对象
     */</span>
    <span>private</span> <span>final</span> <span>Object</span> target<span>;</span>

    <span>public</span> <span>DebugInvocationHandler</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
        <span>this</span><span>.</span>target <span>=</span> target<span>;</span>
    <span>}</span>


    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InvocationTargetException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>
        <span>//调用方法之前，我们可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>
        <span>//调用方法之后，我们同样可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> result<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4.获取代理对象的工厂类</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>JdkProxyFactory</span> <span>{</span>
    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
        <span>return</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>
                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span> <span>// 目标类的类加载</span>
                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>,</span>  <span>// 代理需要实现的接口，可指定多个</span>
                <span>new</span> <span>DebugInvocationHandler</span><span>(</span>target<span>)</span>   <span>// 代理对象对应的自定义 InvocationHandler</span>
        <span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>
<p><strong>5.实际使用</strong></p>
<div><pre><code><span>SmsService</span> smsService <span>=</span> <span>(</span><span>SmsService</span><span>)</span> <span>JdkProxyFactory</span><span>.</span><span>getProxy</span><span>(</span><span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>)</span><span>;</span>
smsService<span>.</span><span>send</span><span>(</span><span>"java"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>
<div><pre><code>before method send
send message:java
after method send
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_3-2-cglib-动态代理机制"> 3.2. CGLIB 动态代理机制</h3>
<h4 id="_3-2-1-介绍"> 3.2.1. 介绍</h4>
<p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p>
<p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p>
<p><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener noreferrer">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm" target="_blank" rel="noopener noreferrer">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener noreferrer">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p>
<p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>MethodInterceptor</span>
<span>extends</span> <span>Callback</span><span>{</span>
    <span>// 拦截被代理类中的方法</span>
    <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Object</span> obj<span>,</span> <span><span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span>
                               <span>MethodProxy</span> proxy<span>)</span> <span>throws</span> <span>Throwable</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol>
<li><strong>obj</strong> :被代理的对象（需要增强的对象）</li>
<li><strong>method</strong> :被拦截的方法（需要增强的方法）</li>
<li><strong>args</strong> :方法入参</li>
<li><strong>proxy</strong> :用于调用原始方法</li>
</ol>
<p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
<h4 id="_3-2-2-cglib-动态代理类使用步骤"> 3.2.2. CGLIB 动态代理类使用步骤</h4>
<ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h4 id="_3-2-3-代码示例"> 3.2.3. 代码示例</h4>
<p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener noreferrer">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
  <span><span><span>&lt;</span>groupId</span><span>></span></span>cglib<span><span><span>&lt;/</span>groupId</span><span>></span></span>
  <span><span><span>&lt;</span>artifactId</span><span>></span></span>cglib<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
  <span><span><span>&lt;</span>version</span><span>></span></span>3.3.0<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<div><pre><code><span>package</span> <span>github<span>.</span>javaguide<span>.</span>dynamicProxy<span>.</span>cglibDynamicProxy</span><span>;</span>

<span>public</span> <span>class</span> <span>AliSmsService</span> <span>{</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"send message:"</span> <span>+</span> message<span>)</span><span>;</span>
        <span>return</span> message<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p>
<div><pre><code><span>import</span> <span>net<span>.</span>sf<span>.</span>cglib<span>.</span>proxy<span>.</span></span><span>MethodInterceptor</span><span>;</span>
<span>import</span> <span>net<span>.</span>sf<span>.</span>cglib<span>.</span>proxy<span>.</span></span><span>MethodProxy</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>/**
 * 自定义MethodInterceptor
 */</span>
<span>public</span> <span>class</span> <span>DebugMethodInterceptor</span> <span>implements</span> <span>MethodInterceptor</span> <span>{</span>


    <span>/**
     * @param o           代理对象（增强的对象）
     * @param method      被拦截的方法（需要增强的方法）
     * @param args        方法入参
     * @param methodProxy 用于调用原始方法
     */</span>
    <span>@Override</span>
    <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Object</span> o<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span> <span>MethodProxy</span> methodProxy<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>
        <span>//调用方法之前，我们可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Object</span> object <span>=</span> methodProxy<span>.</span><span>invokeSuper</span><span>(</span>o<span>,</span> args<span>)</span><span>;</span>
        <span>//调用方法之后，我们同样可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> object<span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><strong>3.获取代理类</strong></p>
<div><pre><code><span>import</span> <span>net<span>.</span>sf<span>.</span>cglib<span>.</span>proxy<span>.</span></span><span>Enhancer</span><span>;</span>

<span>public</span> <span>class</span> <span>CglibProxyFactory</span> <span>{</span>

    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz<span>)</span> <span>{</span>
        <span>// 创建动态代理增强类</span>
        <span>Enhancer</span> enhancer <span>=</span> <span>new</span> <span>Enhancer</span><span>(</span><span>)</span><span>;</span>
        <span>// 设置类加载器</span>
        enhancer<span>.</span><span>setClassLoader</span><span>(</span>clazz<span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 设置被代理类</span>
        enhancer<span>.</span><span>setSuperclass</span><span>(</span>clazz<span>)</span><span>;</span>
        <span>// 设置方法拦截器</span>
        enhancer<span>.</span><span>setCallback</span><span>(</span><span>new</span> <span>DebugMethodInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 创建代理类</span>
        <span>return</span> enhancer<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>4.实际使用</strong></p>
<div><pre><code><span>AliSmsService</span> aliSmsService <span>=</span> <span>(</span><span>AliSmsService</span><span>)</span> <span>CglibProxyFactory</span><span>.</span><span>getProxy</span><span>(</span><span>AliSmsService</span><span>.</span><span>class</span><span>)</span><span>;</span>
aliSmsService<span>.</span><span>send</span><span>(</span><span>"java"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>
<div><pre><code>before method send
send message:java
after method send
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_3-3-jdk-动态代理和-cglib-动态代理对比"> 3.3. JDK 动态代理和 CGLIB 动态代理对比</h3>
<ol>
<li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h2 id="_4-静态代理和动态代理的对比"> 4. 静态代理和动态代理的对比</h2>
<ol>
<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
<h2 id="_5-总结"> 5. 总结</h2>
<p>这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。</p>
<p>文中涉及到的所有源码，你可以在这里找到：<a href="https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy" target="_blank" rel="noopener noreferrer">https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy</a> 。</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/1*DjWCgTFm-xqbhbNQVsaWQw.png" type="image/png"/>
    </item>
    <item>
      <title>反射机制详解！</title>
      <link>https://javaguide.cn/java/basis/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</link>
      <guid>https://javaguide.cn/java/basis/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</guid>
      <source url="https://javaguide.cn/rss.xml">反射机制详解！</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="何为反射"> 何为反射？</h2>
<p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。</p>
<p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p>
<p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<h2 id="反射的应用场景了解么"> 反射的应用场景了解么？</h2>
<p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。</p>
<p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<div><pre><code><span>public</span> <span>class</span> <span>DebugInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>
    <span>/**
     * 代理类中的真实对象
     */</span>
    <span>private</span> <span>final</span> <span>Object</span> target<span>;</span>

    <span>public</span> <span>DebugInvocationHandler</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
        <span>this</span><span>.</span>target <span>=</span> target<span>;</span>
    <span>}</span>


    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InvocationTargetException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> result<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h2 id="谈谈反射机制的优缺点"> 谈谈反射机制的优缺点</h2>
<p><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</p>
<p><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：<a href="https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow" target="_blank" rel="noopener noreferrer">Java Reflection: Why is it so slow?</a></p>
<h2 id="反射实战"> 反射实战</h2>
<h3 id="获取-class-对象的四种方式"> 获取 Class 对象的四种方式</h3>
<p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p>
<p><strong>1.知道具体类的情况下可以使用：</strong></p>
<div><pre><code><span>Class</span> alunbarClass <span>=</span> <span>TargetObject</span><span>.</span><span>class</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p>
<p><strong>2.通过 <code>Class.forName()</code>传入类的路径获取：</strong></p>
<div><pre><code><span>Class</span> alunbarClass1 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>3.通过对象实例<code>instance.getClass()</code>获取：</strong></p>
<div><pre><code><span>TargetObject</span> o <span>=</span> <span>new</span> <span>TargetObject</span><span>(</span><span>)</span><span>;</span>
<span>Class</span> alunbarClass2 <span>=</span> o<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>4.通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p>
<div><pre><code><span>Class</span> clazz <span>=</span> <span>ClassLoader</span><span>.</span><span>loadClass</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行</p>
<h3 id="反射的一些基本操作"> 反射的一些基本操作</h3>
<p>1.创建一个我们要使用反射操作的类 <code>TargetObject</code>。</p>
<div><pre><code><span>package</span> <span>cn<span>.</span>javaguide</span><span>;</span>

<span>public</span> <span>class</span> <span>TargetObject</span> <span>{</span>
    <span>private</span> <span>String</span> value<span>;</span>

    <span>public</span> <span>TargetObject</span><span>(</span><span>)</span> <span>{</span>
        value <span>=</span> <span>"JavaGuide"</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>publicMethod</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"I love "</span> <span>+</span> s<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>privateMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"value is "</span> <span>+</span> value<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>2.使用反射操作这个类的方法以及参数</p>
<div><pre><code><span>package</span> <span>cn<span>.</span>javaguide</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Field</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationTargetException</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>ClassNotFoundException</span><span>,</span> <span>NoSuchMethodException</span><span>,</span> <span>IllegalAccessException</span><span>,</span> <span>InstantiationException</span><span>,</span> <span>InvocationTargetException</span><span>,</span> <span>NoSuchFieldException</span> <span>{</span>
        <span>/**
         * 获取TargetObject类的Class对象并且创建TargetObject类实例
         */</span>
        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> tagetClass <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
        <span>TargetObject</span> targetObject <span>=</span> <span>(</span><span>TargetObject</span><span>)</span> tagetClass<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
        <span>/**
         * 获取所有类中所有定义的方法
         */</span>
        <span>Method</span><span>[</span><span>]</span> methods <span>=</span> tagetClass<span>.</span><span>getDeclaredMethods</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Method</span> method <span>:</span> methods<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>/**
         * 获取指定方法并调用
         */</span>
        <span>Method</span> publicMethod <span>=</span> tagetClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"publicMethod"</span><span>,</span>
                <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>

        publicMethod<span>.</span><span>invoke</span><span>(</span>targetObject<span>,</span> <span>"JavaGuide"</span><span>)</span><span>;</span>
        <span>/**
         * 获取指定参数并对参数进行修改
         */</span>
        <span>Field</span> field <span>=</span> tagetClass<span>.</span><span>getDeclaredField</span><span>(</span><span>"value"</span><span>)</span><span>;</span>
        <span>//为了对类中的参数进行修改我们取消安全检查</span>
        field<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
        field<span>.</span><span>set</span><span>(</span>targetObject<span>,</span> <span>"JavaGuide"</span><span>)</span><span>;</span>
        <span>/**
         * 调用 private 方法
         */</span>
        <span>Method</span> privateMethod <span>=</span> tagetClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"privateMethod"</span><span>)</span><span>;</span>
        <span>//为了调用private方法我们取消安全检查</span>
        privateMethod<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
        privateMethod<span>.</span><span>invoke</span><span>(</span>targetObject<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>输出内容：</p>
<div><pre><code>publicMethod
privateMethod
I love JavaGuide
value is JavaGuide
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>注意</strong> : 有读者提到上面代码运行会抛出 <code>ClassNotFoundException</code> 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 <code>TargetObject</code> 所在的包 。</p>
<div><pre><code><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> tagetClass <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Java基础知识&amp;面试题总结</title>
      <link>https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">Java基础知识&amp;面试题总结</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="基础概念与常识"> 基础概念与常识</h2>
<h3 id="java-语言有哪些特点"> Java 语言有哪些特点?</h3>
<ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<blockquote>
<p><strong>🐛 修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/544" target="_blank" rel="noopener noreferrer">issue#544</a>）</strong> ：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread</p>
</blockquote>
<p>🌈 拓展一下：</p>
<p>“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，Java 强大的生态才是！</p>
<h3 id="jvm-vs-jdk-vs-jre"> JVM vs JDK vs JRE</h3>
<h4 id="jvm"> JVM</h4>
<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p>
<p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比：<a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines" target="_blank" rel="noopener noreferrer">Comparison of Java virtual machines</a> ，感兴趣的可以去看看。并且，你可以在 <a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener noreferrer">Java SE Specifications</a> 上找到各个版本的 JDK 对应的 JVM 规范。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/Java-SE-Specifications.png" alt="" /></p>
<h4 id="jdk-和-jre"> JDK 和 JRE</h4>
<p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h3 id="什么是字节码-采用字节码的好处是什么"> 什么是字节码?采用字节码的好处是什么?</h3>
<p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p><strong>Java 程序从源代码到运行的过程如下图所示：</strong></p>
<p><img src="./images/java程序转变为机器代码的过程.png" alt="Java程序转变为机器代码的过程" /></p>
<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
<blockquote>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
</blockquote>
<h3 id="为什么说-java-语言-编译与解释并存"> 为什么说 Java 语言“编译与解释并存”？</h3>
<p>其实这个问题我们讲字节码的时候已经提到过，因为比较重要，所以我们这里再提一下。</p>
<p>我们可以将高级编程语言按照程序的执行方式分为两种：</p>
<ul>
<li><strong>编译型</strong> ：<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener noreferrer">编译型语言</a> 会通过<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8" target="_blank" rel="noopener noreferrer">编译器</a>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>
<li><strong>解释型</strong> ：<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener noreferrer">解释型语言</a>会通过<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8" target="_blank" rel="noopener noreferrer">解释器</a>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>
</ul>
<p><img src="./images/编译型语言和解释型语言.png" alt="编译型语言和解释型语言" /></p>
<p>根据维基百科介绍：</p>
<blockquote>
<p>为了改善编译语言的效率而发展出的<a href="https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF" target="_blank" rel="noopener noreferrer">即时编译</a>技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81" target="_blank" rel="noopener noreferrer">字节码</a>。到执行期时，再将字节码直译，之后执行。<a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener noreferrer">Java</a>与<a href="https://zh.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener noreferrer">LLVM</a>是这种技术的代表产物。</p>
<p>相关阅读：<a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html" target="_blank" rel="noopener noreferrer">基本功 | Java 即时编译器原理解析及实践</a></p>
</blockquote>
<p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p>
<p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h3 id="oracle-jdk-vs-openjdk"> Oracle JDK vs OpenJDK</h3>
<p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle JDK 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p>
<p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p>
<p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p><strong>总结：</strong></p>
<ol>
<li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：<a href="https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence" target="_blank" rel="noopener noreferrer">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence</a> 。</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li>
<li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>
</ol>
<p>🌈 拓展一下：</p>
<ul>
<li>BCL 协议（Oracle Binary Code License Agreement）： 可以使用 JDK（支持商用），但是不能进行修改。</li>
<li>OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/20210425151835918.png" alt="" /></p>
<p>相关阅读 👍：<a href="https://www.baeldung.com/oracle-jdk-vs-openjdk" target="_blank" rel="noopener noreferrer">《Differences Between Oracle JDK and OpenJDK》</a></p>
<h3 id="java-和-c-的区别"> Java 和 C++的区别?</h3>
<p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！</p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>
<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>
<li>......</li>
</ul>
<h2 id="基本语法"> 基本语法</h2>
<h3 id="字符型常量和字符串常量的区别"> 字符型常量和字符串常量的区别?</h3>
<ol>
<li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符</li>
<li><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： <code>char</code> 在 Java 中占两个字节</strong>),</li>
</ol>
<blockquote>
<p>java 编程思想第四版：2.2.2 节
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg" alt="" /></p>
</blockquote>
<h3 id="可变长参数"> 可变长参数</h3>
<p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 <code>printVariable</code> 方法就可以接受 0 个或者多个参数。</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>method1</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span> <span>{</span>
   <span>//......</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>method2</span><span>(</span><span>String</span> arg1<span>,</span> <span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span> <span>{</span>
   <span>//......</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p>
<p>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p>
<p>我们通过下面这个例子来证明一下。</p>
<div><pre><code><span>/**
 * 微信搜 JavaGuide 回复"面试突击"即可免费领取个人原创的 Java 面试手册
 *
 * @author Guide哥
 * @date 2021/12/13 16:52
 **/</span>
<span>public</span> <span>class</span> <span>VariableLengthArgument</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>printVariable</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>String</span> s <span>:</span> args<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>printVariable</span><span>(</span><span>String</span> arg1<span>,</span> <span>String</span> arg2<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arg1 <span>+</span> arg2<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>printVariable</span><span>(</span><span>"a"</span><span>,</span> <span>"b"</span><span>)</span><span>;</span>
        <span>printVariable</span><span>(</span><span>"a"</span><span>,</span> <span>"b"</span><span>,</span> <span>"c"</span><span>,</span> <span>"d"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>输出：</p>
<div><pre><code>ab
a
b
c
d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 <code>class</code>文件就可以看出来了。</p>
<div><pre><code><span>public</span> <span>class</span> <span>VariableLengthArgument</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>printVariable</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span> <span>{</span>
        <span>String</span><span>[</span><span>]</span> var1 <span>=</span> args<span>;</span>
        <span>int</span> var2 <span>=</span> args<span>.</span>length<span>;</span>

        <span>for</span><span>(</span><span>int</span> var3 <span>=</span> <span>0</span><span>;</span> var3 <span>&lt;</span> var2<span>;</span> <span>++</span>var3<span>)</span> <span>{</span>
            <span>String</span> s <span>=</span> var1<span>[</span>var3<span>]</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s<span>)</span><span>;</span>
        <span>}</span>

    <span>}</span>
    <span>// ......</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="注释"> 注释</h3>
<p>Java 中的注释有三种：</p>
<ol>
<li>
<p>单行注释</p>
</li>
<li>
<p>多行注释</p>
</li>
<li>
<p>文档注释。</p>
</li>
</ol>
<p>在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。</p>
<p>《Clean Code》这本书明确指出：</p>
<blockquote>
<p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p>
<p><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong></p>
<p>举个例子：</p>
<p>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可</p>
<div><pre><code><span>// check to see if the employee is eligible for full benefits</span>
<span>if</span> <span>(</span><span>(</span>employee<span>.</span>flags <span>&amp;</span> HOURLY_FLAG<span>)</span> <span>&amp;&amp;</span> <span>(</span>employee<span>.</span>age <span>></span> <span>65</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>应替换为</p>
<div><pre><code><span>if</span> <span>(</span>employee<span>.</span><span>isEligibleForFullBenefits</span><span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<h3 id="标识符和关键字的区别是什么"> 标识符和关键字的区别是什么？</h3>
<p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。</p>
<h3 id="java-中有哪些常见的关键字"> Java 中有哪些常见的关键字？</h3>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">访问控制</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">类，方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>short</td>
<td>null</td>
<td>true</td>
<td>false</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="自增自减运算符"> 自增自减运算符</h3>
<p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（--）。</p>
<p>++ 和 -- 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 <code>b = ++a</code> 时，先自增（自己增加 1），再赋值（赋值给 b）；当 <code>b = a++</code> 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。</p>
<h3 id="continue、break-和-return-的区别是什么"> continue、break 和 return 的区别是什么？</h3>
<p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p>
<ol>
<li><code>continue</code> ：指跳出当前的这一次循环，继续下一次循环。</li>
<li><code>break</code> ：指跳出整个循环体，继续执行循环下面的语句。</li>
</ol>
<p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p>
<ol>
<li><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</li>
</ol>
<h3 id="方法"> 方法</h3>
<h4 id="什么是方法的返回值-方法有哪几种类型"> 什么是方法的返回值?方法有哪几种类型？</h4>
<p><strong>方法的返回值</strong> 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</p>
<p>我们可以按照方法的返回值和参数类型将方法分为下面这几种：</p>
<p><strong>1.无参数无返回值的方法</strong></p>
<div><pre><code><span>public</span> <span>void</span> <span>f1</span><span>(</span><span>)</span> <span>{</span>
    <span>//......</span>
<span>}</span>
<span>// 下面这个方法也没有返回值，虽然用到了 return</span>
<span>public</span> <span>void</span> <span>f</span><span>(</span><span>int</span> a<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>.</span><span>.</span><span>.</span><span>)</span> <span>{</span>
        <span>// 表示结束方法的执行,下方的输出语句不会执行</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>2.有参数无返回值的方法</strong></p>
<div><pre><code><span>public</span> <span>void</span> <span>f2</span><span>(</span><span>Parameter</span> <span>1</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>,</span> <span>Parameter</span> n<span>)</span> <span>{</span>
    <span>//......</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>3.有返回值无参数的方法</strong></p>
<div><pre><code><span>public</span> <span>int</span> <span>f3</span><span>(</span><span>)</span> <span>{</span>
    <span>//......</span>
    <span>return</span> x<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>4.有返回值有参数的方法</strong></p>
<div><pre><code><span>public</span> <span>int</span> <span>f4</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
    <span>return</span> a <span>*</span> b<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="静态方法为什么不能调用非静态成员"> 静态方法为什么不能调用非静态成员?</h4>
<p>这个需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h4 id="静态方法和实例方法有何不同"> 静态方法和实例方法有何不同？</h4>
<p><strong>1、调用方式</strong></p>
<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p>
<p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p>
<p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>
      <span>//......</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>staicMethod</span><span>(</span><span>)</span><span>{</span>
      <span>//......</span>
    <span>}</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Person</span> person <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
        <span>// 调用实例方法</span>
        person<span>.</span><span>method</span><span>(</span><span>)</span><span>;</span>
        <span>// 调用静态方法</span>
        <span>Person</span><span>.</span><span>staicMethod</span><span>(</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong>2、访问类成员是否存在限制</strong></p>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
<h4 id="重载和重写的区别"> 重载和重写的区别</h4>
<blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</blockquote>
<p><strong>重载</strong></p>
<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>下面是《Java 核心技术》对重载这个概念的介绍：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktopjava核心技术-重载.jpg" alt="" /></p>
<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<p><strong>重写</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">区别点</th>
<th style="text-align:left">重载方法</th>
<th style="text-align:left">重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">发生范围</td>
<td style="text-align:left">同一个类</td>
<td style="text-align:left">子类</td>
</tr>
<tr>
<td style="text-align:left">参数列表</td>
<td style="text-align:left">必须修改</td>
<td style="text-align:left">一定不能修改</td>
</tr>
<tr>
<td style="text-align:left">返回类型</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td style="text-align:left">异常</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td style="text-align:left">访问修饰符</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td style="text-align:left">发生阶段</td>
<td style="text-align:left">编译期</td>
<td style="text-align:left">运行期</td>
</tr>
</tbody>
</table>
<p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》，<a href="https://github.com/Snailclimb/JavaGuide/issues/892" target="_blank" rel="noopener noreferrer">issue#892</a> ）：</p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p>⭐️ 关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Hero</span> <span>{</span>
    <span>public</span> <span>String</span> <span>name</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"超级英雄"</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>public</span> <span>class</span> <span>SuperMan</span> <span>extends</span> <span>Hero</span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>name</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"超人"</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>Hero</span> <span>hero</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>Hero</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>SuperSuperMan</span> <span>extends</span> <span>SuperMan</span> <span>{</span>
    <span>public</span> <span>String</span> <span>name</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"超级超级英雄"</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>SuperMan</span> <span>hero</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>SuperMan</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="泛型"> 泛型</h3>
<h4 id="java-泛型了解么-什么是类型擦除-介绍一下常用的通配符"> Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</h4>
<p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

list<span>.</span><span>add</span><span>(</span><span>12</span><span>)</span><span>;</span>
<span>//这里直接添加会报错</span>
list<span>.</span><span>add</span><span>(</span><span>"a"</span><span>)</span><span>;</span>
<span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>List</span><span>></span></span> clazz <span>=</span> list<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
<span>Method</span> add <span>=</span> clazz<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"add"</span><span>,</span> <span>Object</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>//但是通过反射添加是可以的</span>
<span>//这就说明在运行期间所有的泛型信息都会被擦掉</span>
add<span>.</span><span>invoke</span><span>(</span>list<span>,</span> <span>"kl"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>list<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>泛型一般有三种使用方式: 泛型类、泛型接口、泛型方法。</p>
<p><strong>1.泛型类</strong>：</p>
<div><pre><code><span>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span>
<span>//在实例化泛型类时，必须指定T的具体类型</span>
<span>public</span> <span>class</span> <span>Generic</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>
    <span>private</span> <span>T</span> key<span>;</span>
    <span>public</span> <span>Generic</span><span>(</span><span>T</span> key<span>)</span> <span>{</span>
        <span>this</span><span>.</span>key <span>=</span> key<span>;</span>
    <span>}</span>
    <span>public</span> <span>T</span> <span>getKey</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> key<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如何实例化泛型类：</p>
<div><pre><code><span>Generic</span><span><span>&lt;</span><span>Integer</span><span>></span></span> genericInteger <span>=</span> <span>new</span> <span>Generic</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>123456</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>2.泛型接口</strong> ：</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Generator</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>
    <span>public</span> <span>T</span> <span>method</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>实现泛型接口，不指定类型：</p>
<div><pre><code><span>class</span> <span>GeneratorImpl</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>implements</span> <span>Generator</span><span><span>&lt;</span><span>T</span><span>></span></span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>T</span> <span>method</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>实现泛型接口，指定类型：</p>
<div><pre><code><span>class</span> <span>GeneratorImpl</span> <span>implements</span> <span>Generator</span><span><span>&lt;</span><span>String</span><span>></span></span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>method</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"hello"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.泛型方法</strong> ：</p>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>void</span> <span>printArray</span><span>(</span><span>E</span><span>[</span><span>]</span> inputArray<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>E</span> element <span>:</span> inputArray<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>"%s "</span><span>,</span> element<span>)</span><span>;</span>
    <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>使用：</p>
<div><pre><code><span>// 创建不同类型数组： Integer, Double 和 Character</span>
<span>Integer</span><span>[</span><span>]</span> intArray <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span> <span>}</span><span>;</span>
<span>String</span><span>[</span><span>]</span> stringArray <span>=</span> <span>{</span> <span>"Hello"</span><span>,</span> <span>"World"</span> <span>}</span><span>;</span>
<span>printArray</span><span>(</span>intArray<span>)</span><span>;</span>
<span>printArray</span><span>(</span>stringArray<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="常用的通配符有哪些"> 常用的通配符有哪些？</h4>
<p><strong>常用的通配符为： T，E，K，V，？</strong></p>
<ul>
<li>？ 表示不确定的 Java 类型</li>
<li>T (type) 表示具体的一个 Java 类型</li>
<li>K V (key value) 分别代表 Java 键值中的 Key Value</li>
<li>E (element) 代表 Element</li>
</ul>
<h4 id="你的项目中哪里用到了泛型"> 你的项目中哪里用到了泛型？</h4>
<ul>
<li>可用于定义通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li>
<li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</li>
<li>用于构建集合工具类。参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法</li>
<li>......</li>
</ul>
<h3 id="和-equals-的区别"> == 和 equals() 的区别</h3>
<p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong><code>equals()</code></strong> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<p><code>Object</code> 类 <code>equals()</code> 方法：</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>
     <span>return</span> <span>(</span><span>this</span> <span>==</span> obj<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有覆盖 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类覆盖了 <code>equals()</code>方法</strong> ：一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p>举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 <code>==</code> 换成 <code>equals()</code> ）：</p>
<div><pre><code><span>String</span> a <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"ab"</span><span>)</span><span>;</span> <span>// a 为一个引用</span>
<span>String</span> b <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"ab"</span><span>)</span><span>;</span> <span>// b为另一个引用,对象的内容一样</span>
<span>String</span> aa <span>=</span> <span>"ab"</span><span>;</span> <span>// 放在常量池中</span>
<span>String</span> bb <span>=</span> <span>"ab"</span><span>;</span> <span>// 从常量池中查找</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>aa <span>==</span> bb<span>)</span><span>;</span><span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> b<span>)</span><span>;</span><span>// false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>equals</span><span>(</span>b<span>)</span><span>)</span><span>;</span><span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>42</span> <span>==</span> <span>42.0</span><span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<p><code>String</code>类<code>equals()</code>方法：</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> anObject<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span> <span>==</span> anObject<span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>anObject <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>
        <span>String</span> anotherString <span>=</span> <span>(</span><span>String</span><span>)</span>anObject<span>;</span>
        <span>int</span> n <span>=</span> value<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>n <span>==</span> anotherString<span>.</span>value<span>.</span>length<span>)</span> <span>{</span>
            <span>char</span> v1<span>[</span><span>]</span> <span>=</span> value<span>;</span>
            <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span>value<span>;</span>
            <span>int</span> i <span>=</span> <span>0</span><span>;</span>
            <span>while</span> <span>(</span>n<span>--</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span>
                    <span>return</span> <span>false</span><span>;</span>
                i<span>++</span><span>;</span>
            <span>}</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="hashcode-与-equals"> hashCode() 与 equals()</h3>
<p>面试官可能会问你：“你重写过 <code>hashCode()</code> 和 <code>equals()</code>么?为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？”</p>
<p>一个非常基础的问题，面试中的重中之重，然而，很多求职者还是会达不到点子上去。</p>
<h4 id="hashcode-有什么用"> hashCode() 有什么用？</h4>
<p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>
<div><pre><code><span>public</span> <span>native</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>
<h4 id="为什么要有-hashcode"> 为什么要有 hashCode？</h4>
<p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode</code>？</p>
<p>下面这段内容摘自我的 Java 启蒙书《Head First Java》:</p>
<blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
</blockquote>
<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HastSet</code>的过程）！</p>
<p>我们在前面也提到了添加元素进<code>HastSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p>
<p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p>
<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结下来就是 ：</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<p>相信大家看了我前面对 <code>hashCode()</code> 和 <code>equals()</code> 的介绍之后，下面这个问题已经难不倒你们了。</p>
<h4 id="为什么重写-equals-时必须重写-hashcode-方法"> 为什么重写 equals() 时必须重写 hashCode() 方法？</h4>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p><strong>思考</strong> ：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p>
<p><strong>总结</strong> ：</p>
<ul>
<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li>
</ul>
<p>更多关于 <code>hashCode()</code> 和 <code>equals()</code> 的内容可以查看：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener noreferrer">Java hashCode() 和 equals()的若干问题解答</a></p>
<h2 id="基本数据类型"> 基本数据类型</h2>
<h3 id="java-中的几种基本数据类型是什么-各自占用多少字节呢-对应的包装类型是什么"> Java 中的几种基本数据类型是什么？各自占用多少字节呢？对应的包装类型是什么？</h3>
<p>Java 中有 8 种基本数据类型，分别为：</p>
<ol>
<li>6 种数字类型 ：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code></li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code>。</li>
</ol>
<p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">基本类型</th>
<th style="text-align:left">位数</th>
<th style="text-align:left">字节</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>int</code></td>
<td style="text-align:left">32</td>
<td style="text-align:left">4</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left"><code>short</code></td>
<td style="text-align:left">16</td>
<td style="text-align:left">2</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left"><code>long</code></td>
<td style="text-align:left">64</td>
<td style="text-align:left">8</td>
<td style="text-align:left">0L</td>
</tr>
<tr>
<td style="text-align:left"><code>byte</code></td>
<td style="text-align:left">8</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left"><code>char</code></td>
<td style="text-align:left">16</td>
<td style="text-align:left">2</td>
<td style="text-align:left">'u0000'</td>
</tr>
<tr>
<td style="text-align:left"><code>float</code></td>
<td style="text-align:left">32</td>
<td style="text-align:left">4</td>
<td style="text-align:left">0f</td>
</tr>
<tr>
<td style="text-align:left"><code>double</code></td>
<td style="text-align:left">64</td>
<td style="text-align:left">8</td>
<td style="text-align:left">0d</td>
</tr>
<tr>
<td style="text-align:left"><code>boolean</code></td>
<td style="text-align:left">1</td>
<td style="text-align:left"></td>
<td style="text-align:left">false</td>
</tr>
</tbody>
</table>
<p>另外，对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>
<p><strong>注意：</strong></p>
<ol>
<li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li>
<li><code>char a = 'h'</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li>
</ol>
<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>
<p>包装类型不赋值就是 <code>Null</code> ，而基本类型有默认值且不是 <code>Null</code>。</p>
<p>另外，这个问题建议还可以先从 JVM 层面来分析。</p>
<p>基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。</p>
<blockquote>
<p>《深入理解 Java 虚拟机》 ：局部变量表主要存放了编译期可知的基本数据类型 <strong>（boolean、byte、char、short、int、float、long、double）</strong>、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
</blockquote>
<h3 id="包装类型的常量池技术了解么"> 包装类型的常量池技术了解么？</h3>
<p>Java 基本类型的包装类的大部分都实现了常量池技术。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p><strong>Integer 缓存源码：</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>i <span>>=</span> <span>IntegerCache</span><span>.</span>low <span>&amp;&amp;</span> i <span>&lt;=</span> <span>IntegerCache</span><span>.</span>high<span>)</span>
        <span>return</span> <span>IntegerCache</span><span>.</span>cache<span>[</span>i <span>+</span> <span>(</span><span>-</span><span>IntegerCache</span><span>.</span>low<span>)</span><span>]</span><span>;</span>
    <span>return</span> <span>new</span> <span>Integer</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
<span>private</span> <span>static</span> <span>class</span> <span>IntegerCache</span> <span>{</span>
    <span>static</span> <span>final</span> <span>int</span> low <span>=</span> <span>-</span><span>128</span><span>;</span>
    <span>static</span> <span>final</span> <span>int</span> high<span>;</span>
    <span>static</span> <span>{</span>
        <span>// high value may be configured by property</span>
        <span>int</span> h <span>=</span> <span>127</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong><code>Character</code> 缓存源码:</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>Character</span> <span>valueOf</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>c <span>&lt;=</span> <span>127</span><span>)</span> <span>{</span> <span>// must cache</span>
      <span>return</span> <span>CharacterCache</span><span>.</span>cache<span>[</span><span>(</span><span>int</span><span>)</span>c<span>]</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>new</span> <span>Character</span><span>(</span>c<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>static</span> <span>class</span> <span>CharacterCache</span> <span>{</span>
    <span>private</span> <span>CharacterCache</span><span>(</span><span>)</span><span>{</span><span>}</span>
    <span>static</span> <span>final</span> <span>Character</span> cache<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>Character</span><span>[</span><span>127</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>static</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cache<span>.</span>length<span>;</span> i<span>++</span><span>)</span>
            cache<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Character</span><span>(</span><span>(</span><span>char</span><span>)</span>i<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong><code>Boolean</code> 缓存源码：</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>Boolean</span> <span>valueOf</span><span>(</span><span>boolean</span> b<span>)</span> <span>{</span>
    <span>return</span> <span>(</span>b <span>?</span> TRUE <span>:</span> FALSE<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
<div><pre><code><span>Integer</span> i1 <span>=</span> <span>33</span><span>;</span>
<span>Integer</span> i2 <span>=</span> <span>33</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1 <span>==</span> i2<span>)</span><span>;</span><span>// 输出 true</span>

<span>Float</span> i11 <span>=</span> <span>333f</span><span>;</span>
<span>Float</span> i22 <span>=</span> <span>333f</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i11 <span>==</span> i22<span>)</span><span>;</span><span>// 输出 false</span>

<span>Double</span> i3 <span>=</span> <span>1.2</span><span>;</span>
<span>Double</span> i4 <span>=</span> <span>1.2</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i3 <span>==</span> i4<span>)</span><span>;</span><span>// 输出 false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>下面我们来看一下问题。下面的代码的输出结果是 <code>true</code> 还是 <code>flase</code> 呢？</p>
<div><pre><code><span>Integer</span> i1 <span>=</span> <span>40</span><span>;</span>
<span>Integer</span> i2 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1<span>==</span>i2<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是常量池中的对象。而<code>Integer i1 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code> 。你答对了吗？</p>
<p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20210422164544846.png" alt="" /></p>
<h3 id="自动装箱与拆箱了解吗-原理是什么"> 自动装箱与拆箱了解吗？原理是什么？</h3>
<p><strong>什么是自动拆装箱？</strong></p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>举例：</p>
<div><pre><code><span>Integer</span> i <span>=</span> <span>10</span><span>;</span>  <span>//装箱</span>
<span>int</span> n <span>=</span> i<span>;</span>   <span>//拆箱</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面这两行代码对应的字节码为：</p>
<div><pre><code>   L1

    LINENUMBER <span>8</span> L1

    ALOAD <span>0</span>

    BIPUSH <span>10</span>

    INVOKESTATIC java<span>/</span>lang<span>/</span><span>Integer</span><span>.</span>valueOf <span>(</span><span>I</span><span>)</span><span>Ljava</span><span>/</span>lang<span>/</span><span>Integer</span><span>;</span>

    PUTFIELD <span>AutoBoxTest</span><span>.</span>i <span>:</span> <span>Ljava</span><span>/</span>lang<span>/</span><span>Integer</span><span>;</span>

   L2

    LINENUMBER <span>9</span> L2

    ALOAD <span>0</span>

    ALOAD <span>0</span>

    GETFIELD <span>AutoBoxTest</span><span>.</span>i <span>:</span> <span>Ljava</span><span>/</span>lang<span>/</span><span>Integer</span><span>;</span>

    INVOKEVIRTUAL java<span>/</span>lang<span>/</span><span>Integer</span><span>.</span>intValue <span>(</span><span>)</span><span>I</span>

    PUTFIELD <span>AutoBoxTest</span><span>.</span>n <span>:</span> <span>I</span>

    RETURN
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<div><pre><code><span>private</span> <span>static</span> <span>long</span> <span>sum</span><span>(</span><span>)</span> <span>{</span>
    <span>// 应该使用 long 而不是 Long</span>
    <span>Long</span> sum <span>=</span> <span>0L</span><span>;</span>
    <span>for</span> <span>(</span><span>long</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span> i<span>++</span><span>)</span>
        sum <span>+=</span> i<span>;</span>
    <span>return</span> sum<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="java-面向对象"> Java 面向对象</h2>
<h3 id="面向对象和面向过程的区别"> 面向对象和面向过程的区别</h3>
<ul>
<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
<p>参见 issue : <a href="https://github.com/Snailclimb/JavaGuide/issues/431" target="_blank" rel="noopener noreferrer">面向过程 ：面向过程性能比面向对象高？？</a></p>
<blockquote>
<p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p>
<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p>
</blockquote>
<h3 id="成员变量与局部变量的区别有哪些"> 成员变量与局部变量的区别有哪些？</h3>
<ol>
<li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li>
<li>从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
<h3 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"> 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3>
<p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h3 id="对象的相等与指向他们的引用相等-两者有什么不同"> 对象的相等与指向他们的引用相等,两者有什么不同?</h3>
<p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h3 id="一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗-为什么"> 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h3>
<p>构造方法主要作用是完成对类对象的初始化工作。</p>
<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
<h3 id="构造方法有哪些特点-是否可被-override"> 构造方法有哪些特点？是否可被 override?</h3>
<p>特点：</p>
<ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="面向对象三大特征"> 面向对象三大特征</h3>
<h4 id="封装"> 封装</h4>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Student</span> <span>{</span>
    <span>private</span> <span>int</span> id<span>;</span><span>//id属性私有化</span>
    <span>private</span> <span>String</span> name<span>;</span><span>//name属性私有化</span>

    <span>//获取id的方法</span>
    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> id<span>;</span>
    <span>}</span>

    <span>//设置id的方法</span>
    <span>public</span> <span>void</span> <span>setId</span><span>(</span><span>int</span> id<span>)</span> <span>{</span>
        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>
    <span>}</span>

    <span>//获取name的方法</span>
    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>//设置name的方法</span>
    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h4 id="继承"> 继承</h4>
<p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态"> 多态</h4>
<p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h3 id="string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的"> String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h3>
<p><strong>可变性</strong></p>
<p>简单的来说：<code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，<s>所以<code>String</code> 对象是不可变的。</s></p>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>String</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span>
	<span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>🐛 修正 ： 我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<p>相关阅读：<a href="https://www.zhihu.com/question/20618891/answer/114125846" target="_blank" rel="noopener noreferrer">如何理解 String 类型值的不可变？ - 知乎提问</a></p>
<p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675" target="_blank" rel="noopener noreferrer">issue 675</a>）：在 Java 9 之后，String 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p>
</blockquote>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<div><pre><code><span>abstract</span> <span>class</span> <span>AbstractStringBuilder</span> <span>implements</span> <span>Appendable</span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>char</span><span>[</span><span>]</span> value<span>;</span>
    <span>public</span> <span>AbstractStringBuilder</span> <span>append</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>str <span>==</span> <span>null</span><span>)</span>
            <span>return</span> <span>appendNull</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> len<span>)</span><span>;</span>
        str<span>.</span><span>getChars</span><span>(</span><span>0</span><span>,</span> len<span>,</span> value<span>,</span> count<span>)</span><span>;</span>
        count <span>+=</span> len<span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>
  	<span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h3 id="object-类的常见方法总结"> Object 类的常见方法总结</h3>
<p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<div><pre><code><span>public</span> <span>final</span> <span>native</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getClass</span><span>(</span><span>)</span><span>//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span>

<span>public</span> <span>native</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span>
<span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span><span>//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span>

<span>protected</span> <span>native</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span><span>//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span>

<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span><span>//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span>

<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notify</span><span>(</span><span>)</span><span>//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span>

<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notifyAll</span><span>(</span><span>)</span><span>//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span>

<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>)</span> <span>throws</span> <span>InterruptedException</span><span>//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span>

<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>,</span> <span>int</span> nanos<span>)</span> <span>throws</span> <span>InterruptedException</span><span>//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span>

<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span><span>//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span>

<span>protected</span> <span>void</span> <span>finalize</span><span>(</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span> <span>}</span><span>//实例被垃圾回收器回收的时候触发的操作</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="深拷贝和浅拷贝区别了解吗-什么是引用拷贝"> 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3>
<p>关于深拷贝和浅拷贝区别，我这里先给结论：</p>
<ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
</ul>
<p>上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！</p>
<p><strong>浅拷贝</strong></p>
<p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p>
<p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Address</span> <span>implements</span> <span>Cloneable</span><span>{</span>
    <span>private</span> <span>final</span> <span>String</span> name<span>;</span>
    <span>// 省略构造函数、Getter&amp;Setter方法</span>
    <span>@Override</span>
    <span>public</span> <span>Address</span> <span>clone</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>return</span> <span>(</span><span>Address</span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>CloneNotSupportedException</span> e<span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>AssertionError</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Person</span> <span>implements</span> <span>Cloneable</span> <span>{</span>
    <span>private</span> <span>Address</span> address<span>;</span>
    <span>// 省略构造函数、Getter&amp;Setter方法</span>
    <span>@Override</span>
    <span>public</span> <span>Person</span> <span>clone</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>Person</span> person <span>=</span> <span>(</span><span>Person</span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
            <span>return</span> person<span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>CloneNotSupportedException</span> e<span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>AssertionError</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>测试 ：</p>
<div><pre><code><span>Person</span> person1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>new</span> <span>Address</span><span>(</span><span>"武汉"</span><span>)</span><span>)</span><span>;</span>
<span>Person</span> person1Copy <span>=</span> person1<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
<span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>person1<span>.</span><span>getAddress</span><span>(</span><span>)</span> <span>==</span> person1Copy<span>.</span><span>getAddress</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>
<p><strong>深拷贝</strong></p>
<p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p>
<div><pre><code><span>@Override</span>
<span>public</span> <span>Person</span> <span>clone</span><span>(</span><span>)</span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>Person</span> person <span>=</span> <span>(</span><span>Person</span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
        person<span>.</span><span>setAddress</span><span>(</span>person<span>.</span><span>getAddress</span><span>(</span><span>)</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> person<span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>CloneNotSupportedException</span> e<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>AssertionError</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>测试 ：</p>
<div><pre><code><span>Person</span> person1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>new</span> <span>Address</span><span>(</span><span>"武汉"</span><span>)</span><span>)</span><span>;</span>
<span>Person</span> person1Copy <span>=</span> person1<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
<span>// false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>person1<span>.</span><span>getAddress</span><span>(</span><span>)</span> <span>==</span> person1Copy<span>.</span><span>getAddress</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>从输出结构就可以看出，虽然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>
<p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>
<p>我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：</p>
<p><img src="./images/shallow&deep-copy.png" alt="" /></p>
<h2 id="反射"> 反射</h2>
<h3 id="何为反射"> 何为反射？</h3>
<p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。</p>
<p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p>
<p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<h3 id="反射机制优缺点"> 反射机制优缺点</h3>
<ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。<a href="https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow" target="_blank" rel="noopener noreferrer">Java Reflection: Why is it so slow?</a></li>
</ul>
<h3 id="反射的应用场景"> 反射的应用场景</h3>
<p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。</p>
<p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<div><pre><code><span>public</span> <span>class</span> <span>DebugInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>
    <span>/**
     * 代理类中的真实对象
     */</span>
    <span>private</span> <span>final</span> <span>Object</span> target<span>;</span>

    <span>public</span> <span>DebugInvocationHandler</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
        <span>this</span><span>.</span>target <span>=</span> target<span>;</span>
    <span>}</span>


    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InvocationTargetException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> result<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h2 id="注解"> 注解</h2>
<p><code>Annontation</code> （注解） 是Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>METHOD<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>SOURCE<span>)</span>
<span>public</span> <span>@interface</span> <span>Override</span> <span>{</span>

<span>}</span>

<span>public</span> <span>interface</span> <span>Override</span> <span>extends</span> <span>Annotation</span><span>{</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul>
<p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p>
<h2 id="异常"> 异常</h2>
<h3 id="java-异常类层次结构图"> Java 异常类层次结构图</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java异常类层次结构图.png" alt="" /></p>
<p style="font-size:13px;text-align:right">图片来自：https://simplesnippets.tech/exception-handling-in-java-part-1/</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java异常类层次结构图2.png" alt="" /></p>
<p style="font-size:13px;text-align:right">图片来自：https://chercher.tech/java-programming/exceptions-java</p>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>
<p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<p><strong>受检查异常</strong></p>
<p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/check-exception.png" alt="check-exception" /></p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>...。</p>
<p><strong>不受检查异常</strong></p>
<p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPointerException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p>
<h3 id="throwable-类常用方法"> Throwable 类常用方法</h3>
<ul>
<li><strong><code>public String getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public String toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public String getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="try-catch-finally"> try-catch-finally</h3>
<ul>
<li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
</ul>
<p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ol>
<li>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190" target="_blank" rel="noopener noreferrer">https://github.com/Snailclimb/JavaGuide/issues/190</a>。</p>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>public</span> <span>static</span> <span>int</span> <span>f</span><span>(</span><span>int</span> value<span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>return</span> value <span>*</span> value<span>;</span>
        <span>}</span> <span>finally</span> <span>{</span>
            <span>if</span> <span>(</span>value <span>==</span> <span>2</span><span>)</span> <span>{</span>
                <span>return</span> <span>0</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<h3 id="使用-try-with-resources-来代替try-catch-finally"> 使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></h3>
<ol>
<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>
<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<p>《Effecitve Java》中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>
</blockquote>
<p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>
<div><pre><code><span>//读取文本文件的内容</span>
<span>Scanner</span> scanner <span>=</span> <span>null</span><span>;</span>
<span>try</span> <span>{</span>
    scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>"D://read.txt"</span><span>)</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span>scanner<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>scanner<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> e<span>)</span> <span>{</span>
    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>}</span> <span>finally</span> <span>{</span>
    <span>if</span> <span>(</span>scanner <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        scanner<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<div><pre><code><span>try</span> <span>(</span><span>Scanner</span> scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>"test.txt"</span><span>)</span><span>)</span><span>)</span> <span>{</span>
    <span>while</span> <span>(</span>scanner<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>scanner<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> fnfe<span>)</span> <span>{</span>
    fnfe<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>
<div><pre><code><span>try</span> <span>(</span><span>BufferedInputStream</span> bin <span>=</span> <span>new</span> <span>BufferedInputStream</span><span>(</span><span>new</span> <span>FileInputStream</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>"test.txt"</span><span>)</span><span>)</span><span>)</span><span>;</span>
             <span>BufferedOutputStream</span> bout <span>=</span> <span>new</span> <span>BufferedOutputStream</span><span>(</span><span>new</span> <span>FileOutputStream</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>"out.txt"</span><span>)</span><span>)</span><span>)</span><span>)</span> <span>{</span>
            <span>int</span> b<span>;</span>
            <span>while</span> <span>(</span><span>(</span>b <span>=</span> bin<span>.</span><span>read</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
                bout<span>.</span><span>write</span><span>(</span>b<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="i-o-流"> I/O 流</h2>
<h3 id="什么是序列化-什么是反序列化"> 什么是序列化?什么是反序列化?</h3>
<p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>
<p>简单来说：</p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>
<p>维基百科是如是介绍序列化的：</p>
<blockquote>
<p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p>
</blockquote>
<p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/a478c74d-2c48-40ae-9374-87aacf05188c.png" alt="" /></p>
<p style="text-align:right;font-size:13px;color:gray">https://www.corejavaguru.com/java/serialization/interview-questions-1</p>
<h3 id="java-序列化中如果有些字段不想进行序列化-怎么办"> Java 序列化中如果有些字段不想进行序列化，怎么办？</h3>
<p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p>
<p>关于 <code>transient</code> 还有几点注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
<h3 id="获取用键盘输入常用的两种方法"> 获取用键盘输入常用的两种方法</h3>
<p>方法 1：通过 <code>Scanner</code></p>
<div><pre><code><span>Scanner</span> input <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
<span>String</span> s  <span>=</span> input<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>;</span>
input<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>方法 2：通过 <code>BufferedReader</code></p>
<div><pre><code><span>BufferedReader</span> input <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span><span>new</span> <span>InputStreamReader</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>)</span><span>;</span>
<span>String</span> s <span>=</span> input<span>.</span><span>readLine</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="java-中-io-流分为几种"> Java 中 IO 流分为几种?</h3>
<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>按操作方式分类结构图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-操作方式分类.png" alt="IO-操作方式分类" /></p>
<p>按操作对象分类结构图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-操作对象分类.png" alt="IO-操作对象分类" /></p>
<h3 id="既然有了字节流-为什么还要有字符流"> 既然有了字节流,为什么还要有字符流?</h3>
<p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li>https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre</li>
<li>https://www.educba.com/oracle-vs-openjdk/</li>
<li>https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/Java-SE-Specifications.png" type="image/png"/>
    </item>
    <item>
      <title>ConcurrentHashMap源码&amp;底层数据结构分析</title>
      <link>https://javaguide.cn/java/collection/concurrent-hash-map-source-code/</link>
      <guid>https://javaguide.cn/java/collection/concurrent-hash-map-source-code/</guid>
      <source url="https://javaguide.cn/rss.xml">ConcurrentHashMap源码&amp;底层数据结构分析</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文来自公众号：末读代码的投稿，原文地址：https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw  。</p>
</blockquote>
<p>上一篇文章介绍了 HashMap 源码，反响不错，也有很多同学发表了自己的观点，这次又来了，这次是 <code>ConcurrentHashMap</code> 了，作为线程安全的HashMap ，它的使用频率也是很高。那么它的存储结构和实现原理是怎么样的呢？</p>
<h2 id="_1-concurrenthashmap-1-7"> 1. ConcurrentHashMap 1.7</h2>
<h3 id="_1-存储结构"> 1. 存储结构</h3>
<blockquote>
<p>下图存在一个笔误 Segmeng -&gt; Segment</p>
</blockquote>
<p><img src="./images/image-20200405151029416.png" alt="Java 7 ConcurrentHashMap 存储结构" /></p>
<p>Java 7 中 <code>ConcurrentHashMap</code> 的存储结构如上图，<code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code>  组合，而每一个 <code>Segment</code> 是一个类似于 HashMap 的结构，所以每一个 <code>HashMap</code> 的内部可以进行扩容。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> 默认支持最多 16 个线程并发。</p>
<h3 id="_2-初始化"> 2. 初始化</h3>
<p>通过 ConcurrentHashMap 的无参构造探寻 ConcurrentHashMap 的初始化流程。</p>
<div><pre><code>    <span>/**
     * Creates a new, empty map with a default initial capacity (16),
     * load factor (0.75) and concurrencyLevel (16).
     */</span>
    <span>public</span> <span>ConcurrentHashMap</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>(</span>DEFAULT_INITIAL_CAPACITY<span>,</span> DEFAULT_LOAD_FACTOR<span>,</span> DEFAULT_CONCURRENCY_LEVEL<span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。</p>
<div><pre><code>    <span>/**
     * 默认初始化容量
     */</span>
    <span>static</span> <span>final</span> <span>int</span> DEFAULT_INITIAL_CAPACITY <span>=</span> <span>16</span><span>;</span>

    <span>/**
     * 默认负载因子
     */</span>
    <span>static</span> <span>final</span> <span>float</span> DEFAULT_LOAD_FACTOR <span>=</span> <span>0.75f</span><span>;</span>

    <span>/**
     * 默认并发级别
     */</span>
    <span>static</span> <span>final</span> <span>int</span> DEFAULT_CONCURRENCY_LEVEL <span>=</span> <span>16</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>接着看下这个有参构造函数的内部实现逻辑。</p>
<div><pre><code><span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
<span>public</span> <span>ConcurrentHashMap</span><span>(</span><span>int</span> initialCapacity<span>,</span><span>float</span> loadFactor<span>,</span> <span>int</span> concurrencyLevel<span>)</span> <span>{</span>
    <span>// 参数校验</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span>loadFactor <span>></span> <span>0</span><span>)</span> <span>||</span> initialCapacity <span>&lt;</span> <span>0</span> <span>||</span> concurrencyLevel <span>&lt;=</span> <span>0</span><span>)</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>
    <span>// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span>
    <span>if</span> <span>(</span>concurrencyLevel <span>></span> MAX_SEGMENTS<span>)</span>
        concurrencyLevel <span>=</span> MAX_SEGMENTS<span>;</span>
    <span>// Find power-of-two sizes best matching arguments</span>
    <span>// 2的多少次方</span>
    <span>int</span> sshift <span>=</span> <span>0</span><span>;</span>
    <span>int</span> ssize <span>=</span> <span>1</span><span>;</span>
    <span>// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span>
    <span>while</span> <span>(</span>ssize <span>&lt;</span> concurrencyLevel<span>)</span> <span>{</span>
        <span>++</span>sshift<span>;</span>
        ssize <span>&lt;&lt;=</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>// 记录段偏移量</span>
    <span>this</span><span>.</span>segmentShift <span>=</span> <span>32</span> <span>-</span> sshift<span>;</span>
    <span>// 记录段掩码</span>
    <span>this</span><span>.</span>segmentMask <span>=</span> ssize <span>-</span> <span>1</span><span>;</span>
    <span>// 设置容量</span>
    <span>if</span> <span>(</span>initialCapacity <span>></span> MAXIMUM_CAPACITY<span>)</span>
        initialCapacity <span>=</span> MAXIMUM_CAPACITY<span>;</span>
    <span>// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span>
    <span>int</span> c <span>=</span> initialCapacity <span>/</span> ssize<span>;</span>
    <span>if</span> <span>(</span>c <span>*</span> ssize <span>&lt;</span> initialCapacity<span>)</span>
        <span>++</span>c<span>;</span>
    <span>int</span> cap <span>=</span> MIN_SEGMENT_TABLE_CAPACITY<span>;</span>
    <span>//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span>
    <span>while</span> <span>(</span>cap <span>&lt;</span> c<span>)</span>
        cap <span>&lt;&lt;=</span> <span>1</span><span>;</span>
    <span>// create segments and segments[0]</span>
    <span>// 创建 Segment 数组，设置 segments[0]</span>
    <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> s0 <span>=</span> <span>new</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>loadFactor<span>,</span> <span>(</span><span>int</span><span>)</span><span>(</span>cap <span>*</span> loadFactor<span>)</span><span>,</span>
                         <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>HashEntry</span><span>[</span>cap<span>]</span><span>)</span><span>;</span>
    <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> ss <span>=</span> <span>(</span><span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Segment</span><span>[</span>ssize<span>]</span><span>;</span>
    UNSAFE<span>.</span><span>putOrderedObject</span><span>(</span>ss<span>,</span> SBASE<span>,</span> s0<span>)</span><span>;</span> <span>// ordered write of segments[0]</span>
    <span>this</span><span>.</span>segments <span>=</span> ss<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。</p>
<ol>
<li>必要参数校验。</li>
<li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></li>
<li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li>
<li>记录 segmentShift 偏移量，这个值为【容量 =  2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li>
<li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15.</li>
<li><strong>初始化 segments[0]</strong>，<strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75=1.5</strong>，插入第二个值时才会进行扩容。</li>
</ol>
<h3 id="_3-put"> 3. put</h3>
<p>接着上面的初始化参数继续查看 put 方法源码。</p>
<div><pre><code><span>/**
 * Maps the specified key to the specified value in this table.
 * Neither the key nor the value can be null.
 *
 * &lt;p> The value can be retrieved by calling the &lt;tt>get&lt;/tt> method
 * with a key that is equal to the original key.
 *
 * @param key key with which the specified value is to be associated
 * @param value value to be associated with the specified key
 * @return the previous value associated with &lt;tt>key&lt;/tt>, or
 *         &lt;tt>null&lt;/tt> if there was no mapping for &lt;tt>key&lt;/tt>
 * @throws NullPointerException if the specified key or value is null
 */</span>
<span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>
    <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> s<span>;</span>
    <span>if</span> <span>(</span>value <span>==</span> <span>null</span><span>)</span>
        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> hash <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span>
    <span>// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span>
    <span>// 其实也就是把高4位与segmentMask（1111）做与运算</span>
    <span>int</span> j <span>=</span> <span>(</span>hash <span>>>></span> segmentShift<span>)</span> <span>&amp;</span> segmentMask<span>;</span>
    <span>if</span> <span>(</span><span>(</span>s <span>=</span> <span>(</span><span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>UNSAFE<span>.</span>getObject          <span>// nonvolatile; recheck</span>
         <span>(</span>segments<span>,</span> <span>(</span>j <span>&lt;&lt;</span> SSHIFT<span>)</span> <span>+</span> SBASE<span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>//  in ensureSegment</span>
        <span>// 如果查找到的 Segment 为空，初始化</span>
        s <span>=</span> <span>ensureSegment</span><span>(</span>j<span>)</span><span>;</span>
    <span>return</span> s<span>.</span><span>put</span><span>(</span>key<span>,</span> hash<span>,</span> value<span>,</span> <span>false</span><span>)</span><span>;</span>
<span>}</span>

<span>/**
 * Returns the segment for the given index, creating it and
 * recording in segment table (via CAS) if not already present.
 *
 * @param k the index
 * @return the segment
 */</span>
<span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
<span>private</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>ensureSegment</span><span>(</span><span>int</span> k<span>)</span> <span>{</span>
    <span>final</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> ss <span>=</span> <span>this</span><span>.</span>segments<span>;</span>
    <span>long</span> u <span>=</span> <span>(</span>k <span>&lt;&lt;</span> SSHIFT<span>)</span> <span>+</span> SBASE<span>;</span> <span>// raw offset</span>
    <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> seg<span>;</span>
    <span>// 判断 u 位置的 Segment 是否为null</span>
    <span>if</span> <span>(</span><span>(</span>seg <span>=</span> <span>(</span><span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>UNSAFE<span>.</span><span>getObjectVolatile</span><span>(</span>ss<span>,</span> u<span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> proto <span>=</span> ss<span>[</span><span>0</span><span>]</span><span>;</span> <span>// use segment 0 as prototype</span>
        <span>// 获取0号 segment 里的 HashEntry&lt;K,V> 初始化长度</span>
        <span>int</span> cap <span>=</span> proto<span>.</span>table<span>.</span>length<span>;</span>
        <span>// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span>
        <span>float</span> lf <span>=</span> proto<span>.</span>loadFactor<span>;</span>
        <span>// 计算扩容阀值</span>
        <span>int</span> threshold <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>cap <span>*</span> lf<span>)</span><span>;</span>
        <span>// 创建一个 cap 容量的 HashEntry 数组</span>
        <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab <span>=</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>HashEntry</span><span>[</span>cap<span>]</span><span>;</span>
        <span>if</span> <span>(</span><span>(</span>seg <span>=</span> <span>(</span><span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>UNSAFE<span>.</span><span>getObjectVolatile</span><span>(</span>ss<span>,</span> u<span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// recheck</span>
            <span>// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span>
            <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> s <span>=</span> <span>new</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>lf<span>,</span> threshold<span>,</span> tab<span>)</span><span>;</span>
            <span>// 自旋检查 u 位置的 Segment 是否为null</span>
            <span>while</span> <span>(</span><span>(</span>seg <span>=</span> <span>(</span><span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>UNSAFE<span>.</span><span>getObjectVolatile</span><span>(</span>ss<span>,</span> u<span>)</span><span>)</span>
                   <span>==</span> <span>null</span><span>)</span> <span>{</span>
                <span>// 使用CAS 赋值，只会成功一次</span>
                <span>if</span> <span>(</span>UNSAFE<span>.</span><span>compareAndSwapObject</span><span>(</span>ss<span>,</span> u<span>,</span> <span>null</span><span>,</span> seg <span>=</span> s<span>)</span><span>)</span>
                    <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> seg<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><p>上面的源码分析了 ConcurrentHashMap 在 put 一个数据时的处理流程，下面梳理下具体流程。</p>
<ol>
<li>
<p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p>
</li>
<li>
<p>如果指定位置的 Segment 为空，则初始化这个 Segment.</p>
<p><strong>初始化 Segment 流程：</strong></p>
<ol>
<li>检查计算得到的位置的 Segment 是否为null.</li>
<li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li>
<li>再次检查计算得到的指定位置的 Segment 是否为null.</li>
<li>使用创建的 HashEntry 数组初始化这个 Segment.</li>
<li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li>
</ol>
</li>
<li>
<p>Segment.put 插入 key,value 值。</p>
</li>
</ol>
<p>上面探究了获取 Segment 段和初始化 Segment 段的操作。最后一行的 Segment 的 put 方法还没有查看，继续分析。</p>
<div><pre><code><span>final</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>int</span> hash<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>)</span> <span>{</span>
    <span>// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span>
    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> node <span>=</span> <span>tryLock</span><span>(</span><span>)</span> <span>?</span> <span>null</span> <span>:</span> <span>scanAndLockForPut</span><span>(</span>key<span>,</span> hash<span>,</span> value<span>)</span><span>;</span>
    <span>V</span> oldValue<span>;</span>
    <span>try</span> <span>{</span>
        <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span>
        <span>// 计算要put的数据位置</span>
        <span>int</span> index <span>=</span> <span>(</span>tab<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>;</span>
        <span>// CAS 获取 index 坐标的值</span>
        <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> first <span>=</span> <span>entryAt</span><span>(</span>tab<span>,</span> index<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> first<span>;</span><span>;</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                <span>// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span>
                <span>K</span> k<span>;</span>
                <span>if</span> <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span>
                    <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span> <span>{</span>
                    oldValue <span>=</span> e<span>.</span>value<span>;</span>
                    <span>if</span> <span>(</span><span>!</span>onlyIfAbsent<span>)</span> <span>{</span>
                        e<span>.</span>value <span>=</span> value<span>;</span>
                        <span>++</span>modCount<span>;</span>
                    <span>}</span>
                    <span>break</span><span>;</span>
                <span>}</span>
                e <span>=</span> e<span>.</span>next<span>;</span>
            <span>}</span>
            <span>else</span> <span>{</span>
                <span>// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span>
                <span>if</span> <span>(</span>node <span>!=</span> <span>null</span><span>)</span>
                    node<span>.</span><span>setNext</span><span>(</span>first<span>)</span><span>;</span>
                <span>else</span>
                    node <span>=</span> <span>new</span> <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> first<span>)</span><span>;</span>
                <span>int</span> c <span>=</span> count <span>+</span> <span>1</span><span>;</span>
                <span>// 容量大于扩容阀值，小于最大容量，进行扩容</span>
                <span>if</span> <span>(</span>c <span>></span> threshold <span>&amp;&amp;</span> tab<span>.</span>length <span>&lt;</span> MAXIMUM_CAPACITY<span>)</span>
                    <span>rehash</span><span>(</span>node<span>)</span><span>;</span>
                <span>else</span>
                    <span>// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span>
                    <span>setEntryAt</span><span>(</span>tab<span>,</span> index<span>,</span> node<span>)</span><span>;</span>
                <span>++</span>modCount<span>;</span>
                count <span>=</span> c<span>;</span>
                oldValue <span>=</span> <span>null</span><span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span> <span>finally</span> <span>{</span>
        <span>unlock</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> oldValue<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p>
<ol>
<li>
<p>tryLock() 获取锁，获取不到使用  <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p>
</li>
<li>
<p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</p>
</li>
<li>
<p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p>
<p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p>
<ol>
<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
<li>直接头插法插入。</li>
</ol>
<p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p>
<ol>
<li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li>
<li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。
<ol>
<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
<li>直接链表头插法插入。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p>
</li>
</ol>
<p>这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。</p>
<div><pre><code><span>private</span> <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>scanAndLockForPut</span><span>(</span><span>K</span> key<span>,</span> <span>int</span> hash<span>,</span> <span>V</span> value<span>)</span> <span>{</span>
    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> first <span>=</span> <span>entryForHash</span><span>(</span><span>this</span><span>,</span> hash<span>)</span><span>;</span>
    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> first<span>;</span>
    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> node <span>=</span> <span>null</span><span>;</span>
    <span>int</span> retries <span>=</span> <span>-</span><span>1</span><span>;</span> <span>// negative while locating node</span>
    <span>// 自旋获取锁</span>
    <span>while</span> <span>(</span><span>!</span><span>tryLock</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> f<span>;</span> <span>// to recheck first below</span>
        <span>if</span> <span>(</span>retries <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>e <span>==</span> <span>null</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>// speculatively create node</span>
                    node <span>=</span> <span>new</span> <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
                retries <span>=</span> <span>0</span><span>;</span>
            <span>}</span>
            <span>else</span> <span>if</span> <span>(</span>key<span>.</span><span>equals</span><span>(</span>e<span>.</span>key<span>)</span><span>)</span>
                retries <span>=</span> <span>0</span><span>;</span>
            <span>else</span>
                e <span>=</span> e<span>.</span>next<span>;</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span><span>++</span>retries <span>></span> MAX_SCAN_RETRIES<span>)</span> <span>{</span>
            <span>// 自旋达到指定次数后，阻塞等到只到获取到锁</span>
            <span>lock</span><span>(</span><span>)</span><span>;</span>
            <span>break</span><span>;</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span><span>(</span>retries <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span>
                 <span>(</span>f <span>=</span> <span>entryForHash</span><span>(</span><span>this</span><span>,</span> hash<span>)</span><span>)</span> <span>!=</span> first<span>)</span> <span>{</span>
            e <span>=</span> first <span>=</span> f<span>;</span> <span>// re-traverse if entry changed</span>
            retries <span>=</span> <span>-</span><span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> node<span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id="_4-扩容-rehash"> 4. 扩容 rehash</h3>
<p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p>
<div><pre><code><span>private</span> <span>void</span> <span>rehash</span><span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> node<span>)</span> <span>{</span>
    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> oldTable <span>=</span> table<span>;</span>
    <span>// 老容量</span>
    <span>int</span> oldCapacity <span>=</span> oldTable<span>.</span>length<span>;</span>
    <span>// 新容量，扩大两倍</span>
    <span>int</span> newCapacity <span>=</span> oldCapacity <span>&lt;&lt;</span> <span>1</span><span>;</span>
    <span>// 新的扩容阀值 </span>
    threshold <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>newCapacity <span>*</span> loadFactor<span>)</span><span>;</span>
    <span>// 创建新的数组</span>
    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> newTable <span>=</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span> <span>new</span> <span>HashEntry</span><span>[</span>newCapacity<span>]</span><span>;</span>
    <span>// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span>
    <span>int</span> sizeMask <span>=</span> newCapacity <span>-</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> oldCapacity <span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>// 遍历老数组</span>
        <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> oldTable<span>[</span>i<span>]</span><span>;</span>
        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next <span>=</span> e<span>.</span>next<span>;</span>
            <span>// 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span>
            <span>int</span> idx <span>=</span> e<span>.</span>hash <span>&amp;</span> sizeMask<span>;</span>
            <span>if</span> <span>(</span>next <span>==</span> <span>null</span><span>)</span>   <span>//  Single node on list</span>
                <span>// 如果当前位置还不是链表，只是一个元素，直接赋值</span>
                newTable<span>[</span>idx<span>]</span> <span>=</span> e<span>;</span>
            <span>else</span> <span>{</span> <span>// Reuse consecutive sequence at same slot</span>
                <span>// 如果是链表了</span>
                <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> lastRun <span>=</span> e<span>;</span>
                <span>int</span> lastIdx <span>=</span> idx<span>;</span>
                <span>// 新的位置只可能是不便或者是老的位置+老的容量。</span>
                <span>// 遍历结束后，lastRun 后面的元素位置都是相同的</span>
                <span>for</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> last <span>=</span> next<span>;</span> last <span>!=</span> <span>null</span><span>;</span> last <span>=</span> last<span>.</span>next<span>)</span> <span>{</span>
                    <span>int</span> k <span>=</span> last<span>.</span>hash <span>&amp;</span> sizeMask<span>;</span>
                    <span>if</span> <span>(</span>k <span>!=</span> lastIdx<span>)</span> <span>{</span>
                        lastIdx <span>=</span> k<span>;</span>
                        lastRun <span>=</span> last<span>;</span>
                    <span>}</span>
                <span>}</span>
                <span>// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span>
                newTable<span>[</span>lastIdx<span>]</span> <span>=</span> lastRun<span>;</span>
                <span>// Clone remaining nodes</span>
                <span>for</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p <span>=</span> e<span>;</span> p <span>!=</span> lastRun<span>;</span> p <span>=</span> p<span>.</span>next<span>)</span> <span>{</span>
                    <span>// 遍历剩余元素，头插法到指定 k 位置。</span>
                    <span>V</span> v <span>=</span> p<span>.</span>value<span>;</span>
                    <span>int</span> h <span>=</span> p<span>.</span>hash<span>;</span>
                    <span>int</span> k <span>=</span> h <span>&amp;</span> sizeMask<span>;</span>
                    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> n <span>=</span> newTable<span>[</span>k<span>]</span><span>;</span>
                    newTable<span>[</span>k<span>]</span> <span>=</span> <span>new</span> <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>h<span>,</span> p<span>.</span>key<span>,</span> v<span>,</span> n<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>// 头插法插入新的节点</span>
    <span>int</span> nodeIndex <span>=</span> node<span>.</span>hash <span>&amp;</span> sizeMask<span>;</span> <span>// add the new node</span>
    node<span>.</span><span>setNext</span><span>(</span>newTable<span>[</span>nodeIndex<span>]</span><span>)</span><span>;</span>
    newTable<span>[</span>nodeIndex<span>]</span> <span>=</span> node<span>;</span>
    table <span>=</span> newTable<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><p>有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。</p>
<h3 id="_5-get"> 5. get</h3>
<p>到这里就很简单了，get 方法只需要两步即可。</p>
<ol>
<li>计算得到 key 的存放位置。</li>
<li>遍历指定位置查找相同 key 的 value 值。</li>
</ol>
<div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
    <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> s<span>;</span> <span>// manually integrate access methods to reduce overhead</span>
    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span>
    <span>int</span> h <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span>
    <span>long</span> u <span>=</span> <span>(</span><span>(</span><span>(</span>h <span>>>></span> segmentShift<span>)</span> <span>&amp;</span> segmentMask<span>)</span> <span>&lt;&lt;</span> SSHIFT<span>)</span> <span>+</span> SBASE<span>;</span>
    <span>// 计算得到 key 的存放位置</span>
    <span>if</span> <span>(</span><span>(</span>s <span>=</span> <span>(</span><span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>UNSAFE<span>.</span><span>getObjectVolatile</span><span>(</span>segments<span>,</span> u<span>)</span><span>)</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span>
        <span>(</span>tab <span>=</span> s<span>.</span>table<span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span> UNSAFE<span>.</span>getObjectVolatile
                 <span>(</span>tab<span>,</span> <span>(</span><span>(</span><span>long</span><span>)</span><span>(</span><span>(</span><span>(</span>tab<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> h<span>)</span><span>)</span> <span>&lt;&lt;</span> TSHIFT<span>)</span> <span>+</span> TBASE<span>)</span><span>;</span>
             e <span>!=</span> <span>null</span><span>;</span> e <span>=</span> e<span>.</span>next<span>)</span> <span>{</span>
            <span>// 如果是链表，遍历查找到相同 key 的 value。</span>
            <span>K</span> k<span>;</span>
            <span>if</span> <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>e<span>.</span>hash <span>==</span> h <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span>
                <span>return</span> e<span>.</span>value<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="_2-concurrenthashmap-1-8"> 2. ConcurrentHashMap 1.8</h2>
<h3 id="_1-存储结构-2"> 1. 存储结构</h3>
<p><img src="./images/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）" /></p>
<p>可以发现 Java8 的 ConcurrentHashMap  相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<h3 id="_2-初始化-inittable"> 2. 初始化 initTable</h3>
<div><pre><code><span>/**
 * Initializes table, using the size recorded in sizeCtl.
 */</span>
<span>private</span> <span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> <span>initTable</span><span>(</span><span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>int</span> sc<span>;</span>
    <span>while</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> tab<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        ／／　如果 sizeCtl <span>&lt;</span> <span>0</span> <span>,</span>说明另外的线程执行CAS 成功，正在进行初始化。
        <span>if</span> <span>(</span><span>(</span>sc <span>=</span> sizeCtl<span>)</span> <span>&lt;</span> <span>0</span><span>)</span>
            <span>// 让出 CPU 使用权</span>
            <span>Thread</span><span>.</span><span>yield</span><span>(</span><span>)</span><span>;</span> <span>// lost initialization race; just spin</span>
        <span>else</span> <span>if</span> <span>(</span><span>U</span><span>.</span><span>compareAndSwapInt</span><span>(</span><span>this</span><span>,</span> SIZECTL<span>,</span> sc<span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> tab<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
                    <span>int</span> n <span>=</span> <span>(</span>sc <span>></span> <span>0</span><span>)</span> <span>?</span> sc <span>:</span> DEFAULT_CAPACITY<span>;</span>
                    <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> nt <span>=</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Node</span><span><span>&lt;</span><span>?</span><span>,</span><span>?</span><span>></span></span><span>[</span>n<span>]</span><span>;</span>
                    table <span>=</span> tab <span>=</span> nt<span>;</span>
                    sc <span>=</span> n <span>-</span> <span>(</span>n <span>>>></span> <span>2</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span> <span>finally</span> <span>{</span>
                sizeCtl <span>=</span> sc<span>;</span>
            <span>}</span>
            <span>break</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> tab<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>从源码中可以发现 ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p>
<ol>
<li>-1  说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table　已经初始化。</li>
</ol>
<h3 id="_3-put-2"> 3. put</h3>
<p>直接过一遍 put 源码。</p>
<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>
    <span>return</span> <span>putVal</span><span>(</span>key<span>,</span> value<span>,</span> <span>false</span><span>)</span><span>;</span>
<span>}</span>

<span>/** Implementation for put and putIfAbsent */</span>
<span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>)</span> <span>{</span>
    <span>// key 和 value 不能为空</span>
    <span>if</span> <span>(</span>key <span>==</span> <span>null</span> <span>||</span> value <span>==</span> <span>null</span><span>)</span> <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> hash <span>=</span> <span>spread</span><span>(</span>key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>int</span> binCount <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span><span>;</span><span>)</span> <span>{</span>
        <span>// f = 目标位置元素</span>
        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> f<span>;</span> <span>int</span> n<span>,</span> i<span>,</span> fh<span>;</span><span>// fh 后面存放目标位置的元素 hash 值</span>
        <span>if</span> <span>(</span>tab <span>==</span> <span>null</span> <span>||</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>==</span> <span>0</span><span>)</span>
            <span>// 数组桶为空，初始化数组桶（自旋+CAS)</span>
            tab <span>=</span> <span>initTable</span><span>(</span><span>)</span><span>;</span>
        <span>else</span> <span>if</span> <span>(</span><span>(</span>f <span>=</span> <span>tabAt</span><span>(</span>tab<span>,</span> i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span>
            <span>if</span> <span>(</span><span>casTabAt</span><span>(</span>tab<span>,</span> i<span>,</span> <span>null</span><span>,</span><span>new</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>)</span><span>)</span>
                <span>break</span><span>;</span>  <span>// no lock when adding to empty bin</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span><span>(</span>fh <span>=</span> f<span>.</span>hash<span>)</span> <span>==</span> MOVED<span>)</span>
            tab <span>=</span> <span>helpTransfer</span><span>(</span>tab<span>,</span> f<span>)</span><span>;</span>
        <span>else</span> <span>{</span>
            <span>V</span> oldVal <span>=</span> <span>null</span><span>;</span>
            <span>// 使用 synchronized 加锁加入节点</span>
            <span>synchronized</span> <span>(</span>f<span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>tabAt</span><span>(</span>tab<span>,</span> i<span>)</span> <span>==</span> f<span>)</span> <span>{</span>
                    <span>// 说明是链表</span>
                    <span>if</span> <span>(</span>fh <span>>=</span> <span>0</span><span>)</span> <span>{</span>
                        binCount <span>=</span> <span>1</span><span>;</span>
                        <span>// 循环加入新的或者覆盖节点</span>
                        <span>for</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> f<span>;</span><span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>
                            <span>K</span> ek<span>;</span>
                            <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
                                <span>(</span><span>(</span>ek <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span>
                                 <span>(</span>ek <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>ek<span>)</span><span>)</span><span>)</span><span>)</span> <span>{</span>
                                oldVal <span>=</span> e<span>.</span>val<span>;</span>
                                <span>if</span> <span>(</span><span>!</span>onlyIfAbsent<span>)</span>
                                    e<span>.</span>val <span>=</span> value<span>;</span>
                                <span>break</span><span>;</span>
                            <span>}</span>
                            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> pred <span>=</span> e<span>;</span>
                            <span>if</span> <span>(</span><span>(</span>e <span>=</span> e<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
                                pred<span>.</span>next <span>=</span> <span>new</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span>
                                                          value<span>,</span> <span>null</span><span>)</span><span>;</span>
                                <span>break</span><span>;</span>
                            <span>}</span>
                        <span>}</span>
                    <span>}</span>
                    <span>else</span> <span>if</span> <span>(</span>f <span>instanceof</span> <span>TreeBin</span><span>)</span> <span>{</span>
                        <span>// 红黑树</span>
                        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>;</span>
                        binCount <span>=</span> <span>2</span><span>;</span>
                        <span>if</span> <span>(</span><span>(</span>p <span>=</span> <span>(</span><span>(</span><span>TreeBin</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>f<span>)</span><span>.</span><span>putTreeVal</span><span>(</span>hash<span>,</span> key<span>,</span>
                                                       value<span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                            oldVal <span>=</span> p<span>.</span>val<span>;</span>
                            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent<span>)</span>
                                p<span>.</span>val <span>=</span> value<span>;</span>
                        <span>}</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
            <span>if</span> <span>(</span>binCount <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>binCount <span>>=</span> TREEIFY_THRESHOLD<span>)</span>
                    <span>treeifyBin</span><span>(</span>tab<span>,</span> i<span>)</span><span>;</span>
                <span>if</span> <span>(</span>oldVal <span>!=</span> <span>null</span><span>)</span>
                    <span>return</span> oldVal<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>addCount</span><span>(</span><span>1L</span><span>,</span> binCount<span>)</span><span>;</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><ol>
<li>
<p>根据 key 计算出 hashcode 。</p>
</li>
<li>
<p>判断是否需要进行初始化。</p>
</li>
<li>
<p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p>
</li>
<li>
<p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p>
</li>
<li>
<p>如果都不满足，则利用 synchronized 锁写入数据。</p>
</li>
<li>
<p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在treeifyBin中会首先判断当前数组长度≥64时才会将链表转换为红黑树。</p>
</li>
</ol>
<h3 id="_4-get"> 4. get</h3>
<p>get 流程比较简单，直接过一遍源码。</p>
<div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>,</span> p<span>;</span> <span>int</span> n<span>,</span> eh<span>;</span> <span>K</span> ek<span>;</span>
    <span>// key 所在的 hash 位置</span>
    <span>int</span> h <span>=</span> <span>spread</span><span>(</span>key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>></span> <span>0</span> <span>&amp;&amp;</span>
        <span>(</span>e <span>=</span> <span>tabAt</span><span>(</span>tab<span>,</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> h<span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 如果指定位置元素存在，头结点hash值相同</span>
        <span>if</span> <span>(</span><span>(</span>eh <span>=</span> e<span>.</span>hash<span>)</span> <span>==</span> h<span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>(</span>ek <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>ek <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>ek<span>)</span><span>)</span><span>)</span>
                <span>// key hash 值相等，key值相同，直接返回元素 value</span>
                <span>return</span> e<span>.</span>val<span>;</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span>eh <span>&lt;</span> <span>0</span><span>)</span>
            <span>// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span>
            <span>return</span> <span>(</span>p <span>=</span> e<span>.</span><span>find</span><span>(</span>h<span>,</span> key<span>)</span><span>)</span> <span>!=</span> <span>null</span> <span>?</span> p<span>.</span>val <span>:</span> <span>null</span><span>;</span>
        <span>while</span> <span>(</span><span>(</span>e <span>=</span> e<span>.</span>next<span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 是链表，遍历查找</span>
            <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> h <span>&amp;&amp;</span>
                <span>(</span><span>(</span>ek <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>ek <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>ek<span>)</span><span>)</span><span>)</span><span>)</span>
                <span>return</span> e<span>.</span>val<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>总结一下 get 过程：</p>
<ol>
<li>根据 hash 值计算位置。</li>
<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li>
<li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li>
<li>如果是链表，遍历查找之。</li>
</ol>
<p>总结：</p>
<p>总的来说 ConcurrentHashMap 在 Java8 中相对于 Java7 来说变化还是挺大的，</p>
<h2 id="_3-总结"> 3.  总结</h2>
<p>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p>
<p>Java8 中的 ConcurrentHashMap  使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了  <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>
<p>有些同学可能对 Synchronized 的性能存在疑问，其实 Synchronized 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 Synchronized 的<strong>锁升级</strong>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>ArrayList源码&amp;扩容机制分析</title>
      <link>https://javaguide.cn/java/collection/arraylist-source-code/</link>
      <guid>https://javaguide.cn/java/collection/arraylist-source-code/</guid>
      <source url="https://javaguide.cn/rss.xml">ArrayList源码&amp;扩容机制分析</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1-arraylist-简介"> 1. ArrayList 简介</h2>
<p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>
<p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p>
<div><pre><code>
<span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>
        <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>{</span>

  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li>
<li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li>
</ul>
<h3 id="_1-1-arraylist-和-vector-的区别"> 1.1. Arraylist 和 Vector 的区别?</h3>
<ol>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[ ]</code>存储，线程安全的。</li>
</ol>
<h3 id="_1-2-arraylist-与-linkedlist-区别"> 1.2. Arraylist 与 LinkedList 区别?</h3>
<ol>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h2 id="_2-arraylist-核心源码解读"> 2. ArrayList 核心源码解读</h2>
<div><pre><code><span>package</span> <span>java<span>.</span>util</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>Consumer</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>Predicate</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>UnaryOperator</span><span>;</span>


<span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>
        <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span>
<span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>8683452581122892189L</span><span>;</span>

    <span>/**
     * 默认初始容量大小
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>

    <span>/**
     * 空数组（用于空实例）。
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>

     <span>//用于默认大小空实例的共享空数组实例。</span>
      <span>//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>

    <span>/**
     * 保存ArrayList数据的数组
     */</span>
    <span>transient</span> <span>Object</span><span>[</span><span>]</span> elementData<span>;</span> <span>// non-private to simplify nested class access</span>

    <span>/**
     * ArrayList 所包含的元素个数
     */</span>
    <span>private</span> <span>int</span> size<span>;</span>

    <span>/**
     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>//如果传入的参数大于0，创建initialCapacity大小的数组</span>
            <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>//如果传入的参数等于0，创建空数组</span>
            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>//其他情况，抛出异常</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal Capacity: "</span><span>+</span>
                                               initialCapacity<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     *默认无参构造函数
     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>
    <span>}</span>

    <span>/**
     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>//将指定集合转换为数组</span>
        elementData <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
        <span>//如果elementData数组的长度不为0</span>
        <span>if</span> <span>(</span><span>(</span>size <span>=</span> elementData<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            <span>// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span>
            <span>if</span> <span>(</span>elementData<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>!=</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span>
                <span>//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span>
                elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// 其他情况，用空数组代替</span>
            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。
     */</span>
    <span>public</span> <span>void</span> <span>trimToSize</span><span>(</span><span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>
        <span>if</span> <span>(</span>size <span>&lt;</span> elementData<span>.</span>length<span>)</span> <span>{</span>
            elementData <span>=</span> <span>(</span>size <span>==</span> <span>0</span><span>)</span>
              <span>?</span> EMPTY_ELEMENTDATA
              <span>:</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>//下面是ArrayList的扩容机制</span>
<span>//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span>
<span>//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span>
    <span>/**
     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量
     * @param   minCapacity   所需的最小容量
     */</span>
    <span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span>
        <span>int</span> minExpand <span>=</span> <span>(</span>elementData <span>!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span>
            <span>// any size if not default element table</span>
            <span>?</span> <span>0</span>
            <span>// larger than default for default empty table. It's already</span>
            <span>// supposed to be at default size.</span>
            <span>:</span> DEFAULT_CAPACITY<span>;</span>
        <span>//如果最小容量大于已有的最大容量</span>
        <span>if</span> <span>(</span>minCapacity <span>></span> minExpand<span>)</span> <span>{</span>
            <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
   <span>//1.得到最小扩容量</span>
   <span>//2.通过最小容量扩容</span>
    <span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>
              <span>// 获取“默认的容量”和“传入参数”两者之间的最大值</span>
            minCapacity <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>
        <span>}</span>

        <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
    <span>}</span>
  <span>//判断是否需要扩容</span>
    <span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>

        <span>// overflow-conscious code</span>
        <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>
            <span>//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>
            <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 要分配的最大数组大小
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ARRAY_SIZE <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>

    <span>/**
     * ArrayList扩容的核心方法。
     */</span>
    <span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>// oldCapacity为旧容量，newCapacity为新容量</span>
        <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>
        <span>//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>
        <span>//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>
        <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>
        <span>//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>
        <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>
            newCapacity <span>=</span> minCapacity<span>;</span>
        <span>//再检查新容量是否超出了ArrayList所定义的最大容量，</span>
        <span>//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>
        <span>//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span>
        <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>
            newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
        <span>// minCapacity is usually close to size, so this is a win:</span>
        elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>
    <span>}</span>
    <span>//比较minCapacity和 MAX_ARRAY_SIZE</span>
    <span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>
            <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span>
            <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>
            MAX_ARRAY_SIZE<span>;</span>
    <span>}</span>

    <span>/**
     *返回此列表中的元素数。
     */</span>
    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> size<span>;</span>
    <span>}</span>

    <span>/**
     * 如果此列表不包含元素，则返回 true 。
     */</span>
    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
        <span>//注意=和==的区别</span>
        <span>return</span> size <span>==</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 如果此列表包含指定的元素，则返回true 。
     */</span>
    <span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span>
        <span>return</span> <span>indexOf</span><span>(</span>o<span>)</span> <span>>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1
     */</span>
    <span>public</span> <span>int</span> <span>indexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
                <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>
                    <span>return</span> i<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
                <span>//equals()方法比较</span>
                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>
                    <span>return</span> i<span>;</span>
        <span>}</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.
     */</span>
    <span>public</span> <span>int</span> <span>lastIndexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> size<span>-</span><span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span>
                <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>
                    <span>return</span> i<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> size<span>-</span><span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span>
                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>
                    <span>return</span> i<span>;</span>
        <span>}</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）
     */</span>
    <span>public</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>ArrayList</span><span><span>&lt;</span><span>?</span><span>></span></span> v <span>=</span> <span>(</span><span>ArrayList</span><span><span>&lt;</span><span>?</span><span>></span></span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
            <span>//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span>
            v<span>.</span>elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>
            v<span>.</span>modCount <span>=</span> <span>0</span><span>;</span>
            <span>return</span> v<span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>CloneNotSupportedException</span> e<span>)</span> <span>{</span>
            <span>// 这不应该发生，因为我们是可以克隆的</span>
            <span>throw</span> <span>new</span> <span>InternalError</span><span>(</span>e<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。
     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。
     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。
     */</span>
    <span>public</span> <span>Object</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;
     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。
     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。
     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。
     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）
     */</span>
    <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
    <span>public</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>T</span><span>[</span><span>]</span> a<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>a<span>.</span>length <span>&lt;</span> size<span>)</span>
            <span>// 新建一个运行时类型的数组，但是ArrayList数组的内容</span>
            <span>return</span> <span>(</span><span>T</span><span>[</span><span>]</span><span>)</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> a<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>//调用System提供的arraycopy()方法实现数组之间的复制</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> <span>0</span><span>,</span> a<span>,</span> <span>0</span><span>,</span> size<span>)</span><span>;</span>
        <span>if</span> <span>(</span>a<span>.</span>length <span>></span> size<span>)</span>
            a<span>[</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span>
        <span>return</span> a<span>;</span>
    <span>}</span>

    <span>// Positional Access Operations</span>

    <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
    <span>E</span> <span>elementData</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> <span>(</span><span>E</span><span>)</span> elementData<span>[</span>index<span>]</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回此列表中指定位置的元素。
     */</span>
    <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>

        <span>return</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 用指定的元素替换此列表中指定位置的元素。
     */</span>
    <span>public</span> <span>E</span> <span>set</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
        <span>//对index进行界限检查</span>
        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>

        <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>
        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>
        <span>//返回原来在这个位置的元素</span>
        <span>return</span> oldValue<span>;</span>
    <span>}</span>

    <span>/**
     * 将指定的元素追加到此列表的末尾。
     */</span>
    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>
        <span>//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>
        elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * 在此列表中的指定位置插入指定的元素。
     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
     */</span>
    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>

        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>
        <span>//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span>
                         size <span>-</span> index<span>)</span><span>;</span>
        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>
        size<span>++</span><span>;</span>
    <span>}</span>

    <span>/**
     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。
     */</span>
    <span>public</span> <span>E</span> <span>remove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>

        modCount<span>++</span><span>;</span>
        <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>

        <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>
        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>
            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span>
                             numMoved<span>)</span><span>;</span>
        elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>
      <span>//从列表中删除的元素</span>
        <span>return</span> oldValue<span>;</span>
    <span>}</span>

    <span>/**
     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。
     *返回true，如果此列表包含指定的元素
     */</span>
    <span>public</span> <span>boolean</span> <span>remove</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>
                <span>if</span> <span>(</span>elementData<span>[</span>index<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>
                    <span>return</span> <span>true</span><span>;</span>
                <span>}</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>
                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>index<span>]</span><span>)</span><span>)</span> <span>{</span>
                    <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>
                    <span>return</span> <span>true</span><span>;</span>
                <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

    <span>/*
     * Private remove method that skips bounds checking and does not
     * return the value removed.
     */</span>
    <span>private</span> <span>void</span> <span>fastRemove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>
        <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>
        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>
            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span>
                             numMoved<span>)</span><span>;</span>
        elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>
    <span>}</span>

    <span>/**
     * 从列表中删除所有元素。
     */</span>
    <span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>

        <span>// 把数组中所有的元素的值设为null</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
            elementData<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>

        size <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。
     */</span>
    <span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span>  <span>// Increments modCount</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> size<span>,</span> numNew<span>)</span><span>;</span>
        size <span>+=</span> numNew<span>;</span>
        <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。
     */</span>
    <span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>int</span> index<span>,</span> <span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>

        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span>  <span>// Increments modCount</span>

        <span>int</span> numMoved <span>=</span> size <span>-</span> index<span>;</span>
        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>
            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> numNew<span>,</span>
                             numMoved<span>)</span><span>;</span>

        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> index<span>,</span> numNew<span>)</span><span>;</span>
        size <span>+=</span> numNew<span>;</span>
        <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。
     *将任何后续元素移动到左侧（减少其索引）。
     */</span>
    <span>protected</span> <span>void</span> <span>removeRange</span><span>(</span><span>int</span> fromIndex<span>,</span> <span>int</span> toIndex<span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>
        <span>int</span> numMoved <span>=</span> size <span>-</span> toIndex<span>;</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> toIndex<span>,</span> elementData<span>,</span> fromIndex<span>,</span>
                         numMoved<span>)</span><span>;</span>

        <span>// clear to let GC do its work</span>
        <span>int</span> newSize <span>=</span> size <span>-</span> <span>(</span>toIndex<span>-</span>fromIndex<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> newSize<span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            elementData<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>
        <span>}</span>
        size <span>=</span> newSize<span>;</span>
    <span>}</span>

    <span>/**
     * 检查给定的索引是否在范围内。
     */</span>
    <span>private</span> <span>void</span> <span>rangeCheck</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>index <span>>=</span> size<span>)</span>
            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * add和addAll使用的rangeCheck的一个版本
     */</span>
    <span>private</span> <span>void</span> <span>rangeCheckForAdd</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>index <span>></span> size <span>||</span> index <span>&lt;</span> <span>0</span><span>)</span>
            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回IndexOutOfBoundsException细节信息
     */</span>
    <span>private</span> <span>String</span> <span>outOfBoundsMsg</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> <span>"Index: "</span><span>+</span>index<span>+</span><span>", Size: "</span><span>+</span>size<span>;</span>
    <span>}</span>

    <span>/**
     * 从此列表中删除指定集合中包含的所有元素。
     */</span>
    <span>public</span> <span>boolean</span> <span>removeAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>c<span>)</span><span>;</span>
        <span>//如果此列表被修改则返回true</span>
        <span>return</span> <span>batchRemove</span><span>(</span>c<span>,</span> <span>false</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 仅保留此列表中包含在指定集合中的元素。
     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。
     */</span>
    <span>public</span> <span>boolean</span> <span>retainAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>c<span>)</span><span>;</span>
        <span>return</span> <span>batchRemove</span><span>(</span>c<span>,</span> <span>true</span><span>)</span><span>;</span>
    <span>}</span>


    <span>/**
     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。
     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。
     *返回的列表迭代器是fail-fast 。
     */</span>
    <span>public</span> <span>ListIterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>listIterator</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>index <span>&lt;</span> <span>0</span> <span>||</span> index <span>></span> size<span>)</span>
            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>"Index: "</span><span>+</span>index<span>)</span><span>;</span>
        <span>return</span> <span>new</span> <span>ListItr</span><span>(</span>index<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     *返回列表中的列表迭代器（按适当的顺序）。
     *返回的列表迭代器是fail-fast 。
     */</span>
    <span>public</span> <span>ListIterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>listIterator</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ListItr</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     *以正确的顺序返回该列表中的元素的迭代器。
     *返回的迭代器是fail-fast 。
     */</span>
    <span>public</span> <span>Iterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>iterator</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>Itr</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br><span>314</span><br><span>315</span><br><span>316</span><br><span>317</span><br><span>318</span><br><span>319</span><br><span>320</span><br><span>321</span><br><span>322</span><br><span>323</span><br><span>324</span><br><span>325</span><br><span>326</span><br><span>327</span><br><span>328</span><br><span>329</span><br><span>330</span><br><span>331</span><br><span>332</span><br><span>333</span><br><span>334</span><br><span>335</span><br><span>336</span><br><span>337</span><br><span>338</span><br><span>339</span><br><span>340</span><br><span>341</span><br><span>342</span><br><span>343</span><br><span>344</span><br><span>345</span><br><span>346</span><br><span>347</span><br><span>348</span><br><span>349</span><br><span>350</span><br><span>351</span><br><span>352</span><br><span>353</span><br><span>354</span><br><span>355</span><br><span>356</span><br><span>357</span><br><span>358</span><br><span>359</span><br><span>360</span><br><span>361</span><br><span>362</span><br><span>363</span><br><span>364</span><br><span>365</span><br><span>366</span><br><span>367</span><br><span>368</span><br><span>369</span><br><span>370</span><br><span>371</span><br><span>372</span><br><span>373</span><br><span>374</span><br><span>375</span><br><span>376</span><br><span>377</span><br><span>378</span><br><span>379</span><br><span>380</span><br><span>381</span><br><span>382</span><br><span>383</span><br><span>384</span><br><span>385</span><br><span>386</span><br><span>387</span><br><span>388</span><br><span>389</span><br><span>390</span><br><span>391</span><br><span>392</span><br><span>393</span><br><span>394</span><br><span>395</span><br><span>396</span><br><span>397</span><br><span>398</span><br><span>399</span><br><span>400</span><br><span>401</span><br><span>402</span><br><span>403</span><br><span>404</span><br><span>405</span><br><span>406</span><br><span>407</span><br><span>408</span><br><span>409</span><br><span>410</span><br><span>411</span><br><span>412</span><br><span>413</span><br><span>414</span><br><span>415</span><br><span>416</span><br><span>417</span><br><span>418</span><br><span>419</span><br><span>420</span><br><span>421</span><br><span>422</span><br><span>423</span><br><span>424</span><br><span>425</span><br><span>426</span><br><span>427</span><br><span>428</span><br><span>429</span><br><span>430</span><br><span>431</span><br><span>432</span><br><span>433</span><br><span>434</span><br><span>435</span><br><span>436</span><br><span>437</span><br><span>438</span><br><span>439</span><br><span>440</span><br><span>441</span><br><span>442</span><br><span>443</span><br><span>444</span><br><span>445</span><br><span>446</span><br><span>447</span><br><span>448</span><br><span>449</span><br><span>450</span><br><span>451</span><br><span>452</span><br><span>453</span><br><span>454</span><br><span>455</span><br><span>456</span><br><span>457</span><br><span>458</span><br><span>459</span><br><span>460</span><br><span>461</span><br><span>462</span><br><span>463</span><br><span>464</span><br><span>465</span><br><span>466</span><br><span>467</span><br><span>468</span><br><span>469</span><br><span>470</span><br><span>471</span><br><span>472</span><br><span>473</span><br><span>474</span><br><span>475</span><br><span>476</span><br><span>477</span><br><span>478</span><br><span>479</span><br><span>480</span><br><span>481</span><br><span>482</span><br><span>483</span><br><span>484</span><br><span>485</span><br><span>486</span><br><span>487</span><br><span>488</span><br><span>489</span><br><span>490</span><br><span>491</span><br><span>492</span><br><span>493</span><br><span>494</span><br><span>495</span><br><span>496</span><br><span>497</span><br><span>498</span><br><span>499</span><br><span>500</span><br><span>501</span><br><span>502</span><br><span>503</span><br><span>504</span><br></div></div><h2 id="_3-arraylist-扩容机制分析"> 3. ArrayList 扩容机制分析</h2>
<h3 id="_3-1-先从-arraylist-的构造函数说起"> 3.1. 先从 ArrayList 的构造函数说起</h3>
<p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p>
<div><pre><code>   <span>/**
     * 默认初始容量大小
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>


    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>

    <span>/**
     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>
    <span>}</span>

    <span>/**
     * 带初始容量参数的构造函数。（用户自己指定容量）
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span><span>//初始容量大于0</span>
            <span>//创建initialCapacity大小的数组</span>
            <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span><span>//初始容量等于0</span>
            <span>//创建空数组</span>
            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
        <span>}</span> <span>else</span> <span>{</span><span>//初始容量小于0，抛出异常</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal Capacity: "</span><span>+</span>
                                               initialCapacity<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>


   <span>/**
    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回
    *如果指定的集合为null，throws NullPointerException。
    */</span>
     <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
        elementData <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>(</span>size <span>=</span> elementData<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            <span>// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>
            <span>if</span> <span>(</span>elementData<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>!=</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span>
                elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// replace with empty array.</span>
            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
        <span>}</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p>
<blockquote>
<p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData 。</p>
</blockquote>
<h3 id="_3-2-一步一步分析-arraylist-扩容机制"> 3.2. 一步一步分析 ArrayList 扩容机制</h3>
<p>这里以无参构造函数创建的 ArrayList 为例分析</p>
<h4 id="_3-2-1-先来看-add-方法"> 3.2.1. 先来看 <code>add</code> 方法</h4>
<div><pre><code>    <span>/**
     * 将指定的元素追加到此列表的末尾。
     */</span>
    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
   <span>//添加元素之前，先调用ensureCapacityInternal方法</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>
        <span>//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>
        elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p>
</blockquote>
<h4 id="_3-2-2-再来看看-ensurecapacityinternal-方法"> 3.2.2. 再来看看 <code>ensureCapacityInternal()</code> 方法</h4>
<p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>
<div><pre><code>   <span>//得到最小扩容量</span>
    <span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>
              <span>// 获取默认的容量和传入参数的较大值</span>
            minCapacity <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>
        <span>}</span>

        <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p>
<blockquote>
<p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p>
</blockquote>
<h4 id="_3-2-3-ensureexplicitcapacity-方法"> 3.2.3. <code>ensureExplicitCapacity()</code> 方法</h4>
<p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p>
<div><pre><code>  <span>//判断是否需要扩容</span>
    <span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>

        <span>// overflow-conscious code</span>
        <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>
            <span>//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>
            <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们来仔细分析一下：</p>
<ul>
<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>
<li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>
<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>
</ul>
<p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p>
<h4 id="_3-2-4-grow-方法"> 3.2.4. <code>grow()</code> 方法</h4>
<div><pre><code>    <span>/**
     * 要分配的最大数组大小
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ARRAY_SIZE <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>

    <span>/**
     * ArrayList扩容的核心方法。
     */</span>
    <span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>// oldCapacity为旧容量，newCapacity为新容量</span>
        <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>
        <span>//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>
        <span>//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>
        <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>
        <span>//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>
        <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>
            newCapacity <span>=</span> minCapacity<span>;</span>
       <span>// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span>
       <span>//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span>
        <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>
            newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
        <span>// minCapacity is usually close to size, so this is a win:</span>
        elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p>
<blockquote>
<p>&quot;&gt;&gt;&quot;（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p>
</blockquote>
<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p>
<ul>
<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>
<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>
<li>以此类推······</li>
</ul>
<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>
<ul>
<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>
<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>
<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>
</ul>
<h4 id="_3-2-5-hugecapacity-方法。"> 3.2.5. <code>hugeCapacity()</code> 方法。</h4>
<p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>
<div><pre><code>    <span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>
            <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>
        <span>//对minCapacity和MAX_ARRAY_SIZE进行比较</span>
        <span>//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span>
        <span>//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span>
        <span>//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>
        <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span>
            <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>
            MAX_ARRAY_SIZE<span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="_3-3-system-arraycopy-和-arrays-copyof-方法"> 3.3. <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h3>
<p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>
<h4 id="_3-3-1-system-arraycopy-方法"> 3.3.1. <code>System.arraycopy()</code> 方法</h4>
<p>源码：</p>
<div><pre><code>    <span>// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span>
    <span>/**
    *   复制数组
    * @param src 源数组
    * @param srcPos 源数组中的起始位置
    * @param dest 目标数组
    * @param destPos 目标数组中的起始位置
    * @param length 要复制的数组元素的数量
    */</span>
    <span>public</span> <span>static</span> <span>native</span> <span>void</span> <span>arraycopy</span><span>(</span><span>Object</span> src<span>,</span>  <span>int</span>  srcPos<span>,</span>
                                        <span>Object</span> dest<span>,</span> <span>int</span> destPos<span>,</span>
                                        <span>int</span> length<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>场景：</p>
<div><pre><code>    <span>/**
     * 在此列表中的指定位置插入指定的元素。
     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
     */</span>
    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>

        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>
        <span>//arraycopy()方法实现数组自己复制自己</span>
        <span>//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span> size <span>-</span> index<span>)</span><span>;</span>
        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>
        size<span>++</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>我们写一个简单的方法测试以下：</p>
<div><pre><code><span>public</span> <span>class</span> <span>ArraycopyTest</span> <span>{</span>

	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>// TODO Auto-generated method stub</span>
		<span>int</span><span>[</span><span>]</span> a <span>=</span> <span>new</span> <span>int</span><span>[</span><span>10</span><span>]</span><span>;</span>
		a<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
		a<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
		a<span>[</span><span>2</span><span>]</span> <span>=</span> <span>2</span><span>;</span>
		a<span>[</span><span>3</span><span>]</span> <span>=</span> <span>3</span><span>;</span>
		<span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>2</span><span>,</span> a<span>,</span> <span>3</span><span>,</span> <span>3</span><span>)</span><span>;</span>
		a<span>[</span><span>2</span><span>]</span><span>=</span><span>99</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> a<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>a<span>[</span>i<span>]</span> <span>+</span> <span>" "</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>结果：</p>
<div><pre><code>0 1 99 2 3 0 0 0 0 0
</code></pre>
<div><span>1</span><br></div></div><h4 id="_3-3-2-arrays-copyof-方法"> 3.3.2. <code>Arrays.copyOf()</code>方法</h4>
<p>源码：</p>
<div><pre><code>    <span>public</span> <span>static</span> <span>int</span><span>[</span><span>]</span> <span>copyOf</span><span>(</span><span>int</span><span>[</span><span>]</span> original<span>,</span> <span>int</span> newLength<span>)</span> <span>{</span>
    	<span>// 申请一个新的数组</span>
        <span>int</span><span>[</span><span>]</span> copy <span>=</span> <span>new</span> <span>int</span><span>[</span>newLength<span>]</span><span>;</span>
	<span>// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>original<span>,</span> <span>0</span><span>,</span> copy<span>,</span> <span>0</span><span>,</span>
                         <span>Math</span><span>.</span><span>min</span><span>(</span>original<span>.</span>length<span>,</span> newLength<span>)</span><span>)</span><span>;</span>
        <span>return</span> copy<span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>场景：</p>
<div><pre><code>   <span>/**
     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。
     */</span>
    <span>public</span> <span>Object</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>)</span> <span>{</span>
    <span>//elementData：要复制的数组；size：要复制的长度</span>
        <span>return</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>
<div><pre><code><span>public</span> <span>class</span> <span>ArrayscopyOfTest</span> <span>{</span>

	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>int</span><span>[</span><span>]</span> a <span>=</span> <span>new</span> <span>int</span><span>[</span><span>3</span><span>]</span><span>;</span>
		a<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
		a<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
		a<span>[</span><span>2</span><span>]</span> <span>=</span> <span>2</span><span>;</span>
		<span>int</span><span>[</span><span>]</span> b <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>a<span>,</span> <span>10</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"b.length"</span><span>+</span>b<span>.</span>length<span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>结果：</p>
<div><pre><code>10
</code></pre>
<div><span>1</span><br></div></div><h4 id="_3-3-3-两者联系和区别"> 3.3.3. 两者联系和区别</h4>
<p><strong>联系：</strong></p>
<p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p>
<p><strong>区别：</strong></p>
<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>
<h3 id="_3-4-ensurecapacity方法"> 3.4. <code>ensureCapacity</code>方法</h3>
<p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>
<div><pre><code>    <span>/**
    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。
     *
     * @param   minCapacity   所需的最小容量
     */</span>
    <span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>int</span> minExpand <span>=</span> <span>(</span>elementData <span>!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span>
            <span>// any size if not default element table</span>
            <span>?</span> <span>0</span>
            <span>// larger than default for default empty table. It's already</span>
            <span>// supposed to be at default size.</span>
            <span>:</span> DEFAULT_CAPACITY<span>;</span>

        <span>if</span> <span>(</span>minCapacity <span>></span> minExpand<span>)</span> <span>{</span>
            <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>
<p>我们通过下面的代码实际测试以下这个方法的效果：</p>
<div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>
		<span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>
		<span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
			list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
		<span>}</span>
		<span>long</span> endTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用ensureCapacity方法前："</span><span>+</span><span>(</span>endTime <span>-</span> startTime<span>)</span><span>)</span><span>;</span>

	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>运行结果：</p>
<div><pre><code>使用ensureCapacity方法前：2158
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>
        list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>long</span> startTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        list<span>.</span><span>ensureCapacity</span><span>(</span><span>N</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
        <span>long</span> endTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用ensureCapacity方法后："</span><span>+</span><span>(</span>endTime1 <span>-</span> startTime1<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>运行结果：</p>
<div><pre><code>使用ensureCapacity方法后：1773
</code></pre>
<div><span>1</span><br></div></div><p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>
]]></content:encoded>
    </item>
    <item>
      <title>HashMap源码&amp;底层数据结构分析</title>
      <link>https://javaguide.cn/java/collection/hashmap-source-code/</link>
      <guid>https://javaguide.cn/java/collection/hashmap-source-code/</guid>
      <source url="https://javaguide.cn/rss.xml">HashMap源码&amp;底层数据结构分析</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>感谢 <a href="https://github.com/changfubai" target="_blank" rel="noopener noreferrer">changfubai</a> 对本文的改进做出的贡献！</p>
</blockquote>
<h2 id="hashmap-简介"> HashMap 简介</h2>
<p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p>
<p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p>
<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<h2 id="底层数据结构分析"> 底层数据结构分析</h2>
<h3 id="jdk1-8-之前"> JDK1.8 之前</h3>
<p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p>
<p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<div><pre><code>    <span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
      <span>int</span> h<span>;</span>
      <span>// key.hashCode()：返回散列值也就是hashcode</span>
      <span>// ^ ：按位异或</span>
      <span>// >>>:无符号右移，忽略符号位，空位都以0补齐</span>
      <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>
  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<div><pre><code><span>static</span> <span>int</span> <span>hash</span><span>(</span><span>int</span> h<span>)</span> <span>{</span>
    <span>// This function ensures that hashCodes that differ only by</span>
    <span>// constant multiples at each bit position have a bounded</span>
    <span>// number of collisions (approximately 8 at default load factor).</span>

    h <span>^=</span> <span>(</span>h <span>>>></span> <span>20</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>12</span><span>)</span><span>;</span>
    <span>return</span> h <span>^</span> <span>(</span>h <span>>>></span> <span>7</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>4</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/jdk1.8之前的内部结构.png" alt="jdk1.8之前的内部结构" /></p>
<h3 id="jdk1-8-之后"> JDK1.8 之后</h3>
<p>相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。</p>
<p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。相关源码这里就不贴了，重点关注 <code>treeifyBin()</code>方法即可！</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bba283228693dae74e78da1ef7a9a04c684.png" alt="" /></p>
<p><strong>类的属性：</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>AbstractMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>,</span> <span>Cloneable</span><span>,</span> <span>Serializable</span> <span>{</span>
    <span>// 序列号</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>362498820763181265L</span><span>;</span>
    <span>// 默认的初始容量是16</span>
    <span>static</span> <span>final</span> <span>int</span> DEFAULT_INITIAL_CAPACITY <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>4</span><span>;</span>
    <span>// 最大容量</span>
    <span>static</span> <span>final</span> <span>int</span> MAXIMUM_CAPACITY <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>30</span><span>;</span>
    <span>// 默认的填充因子</span>
    <span>static</span> <span>final</span> <span>float</span> DEFAULT_LOAD_FACTOR <span>=</span> <span>0.75f</span><span>;</span>
    <span>// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>
    <span>static</span> <span>final</span> <span>int</span> TREEIFY_THRESHOLD <span>=</span> <span>8</span><span>;</span>
    <span>// 当桶(bucket)上的结点数小于这个值时树转链表</span>
    <span>static</span> <span>final</span> <span>int</span> UNTREEIFY_THRESHOLD <span>=</span> <span>6</span><span>;</span>
    <span>// 桶中结构转化为红黑树对应的table的最小大小</span>
    <span>static</span> <span>final</span> <span>int</span> MIN_TREEIFY_CAPACITY <span>=</span> <span>64</span><span>;</span>
    <span>// 存储元素的数组，总是2的幂次倍</span>
    <span>transient</span> <span>Node</span><span><span>&lt;</span>k<span>,</span>v<span>></span></span><span>[</span><span>]</span> table<span>;</span>
    <span>// 存放具体元素的集</span>
    <span>transient</span> <span>Set</span><span><span>&lt;</span>map<span>.</span>entry<span>&lt;</span>k<span>,</span>v<span>></span><span>></span></span> entrySet<span>;</span>
    <span>// 存放元素的个数，注意这个不等于数组的长度。</span>
    <span>transient</span> <span>int</span> size<span>;</span>
    <span>// 每次扩容和更改map结构的计数器</span>
    <span>transient</span> <span>int</span> modCount<span>;</span>
    <span>// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>
    <span>int</span> threshold<span>;</span>
    <span>// 加载因子</span>
    <span>final</span> <span>float</span> loadFactor<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><ul>
<li>
<p><strong>loadFactor 加载因子</strong></p>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
</li>
<li>
<p><strong>threshold</strong></p>
<p><strong>threshold = capacity * loadFactor</strong>，<strong>当 Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
</li>
</ul>
<p><strong>Node 节点类源码:</strong></p>
<div><pre><code><span>// 继承自 Map.Entry&lt;K,V></span>
<span>static</span> <span>class</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>
       <span>final</span> <span>int</span> hash<span>;</span><span>// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>
       <span>final</span> <span>K</span> key<span>;</span><span>//键</span>
       <span>V</span> value<span>;</span><span>//值</span>
       <span>// 指向下一个节点</span>
       <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>
       <span>Node</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>)</span> <span>{</span>
            <span>this</span><span>.</span>hash <span>=</span> hash<span>;</span>
            <span>this</span><span>.</span>key <span>=</span> key<span>;</span>
            <span>this</span><span>.</span>value <span>=</span> value<span>;</span>
            <span>this</span><span>.</span>next <span>=</span> next<span>;</span>
        <span>}</span>
        <span>public</span> <span>final</span> <span>K</span> <span>getKey</span><span>(</span><span>)</span>        <span>{</span> <span>return</span> key<span>;</span> <span>}</span>
        <span>public</span> <span>final</span> <span>V</span> <span>getValue</span><span>(</span><span>)</span>      <span>{</span> <span>return</span> value<span>;</span> <span>}</span>
        <span>public</span> <span>final</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span> <span>return</span> key <span>+</span> <span>"="</span> <span>+</span> value<span>;</span> <span>}</span>
        <span>// 重写hashCode()方法</span>
        <span>public</span> <span>final</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>Objects</span><span>.</span><span>hashCode</span><span>(</span>key<span>)</span> <span>^</span> <span>Objects</span><span>.</span><span>hashCode</span><span>(</span>value<span>)</span><span>;</span>
        <span>}</span>

        <span>public</span> <span>final</span> <span>V</span> <span>setValue</span><span>(</span><span>V</span> newValue<span>)</span> <span>{</span>
            <span>V</span> oldValue <span>=</span> value<span>;</span>
            value <span>=</span> newValue<span>;</span>
            <span>return</span> oldValue<span>;</span>
        <span>}</span>
        <span>// 重写 equals() 方法</span>
        <span>public</span> <span>final</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>o <span>==</span> <span>this</span><span>)</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>if</span> <span>(</span>o <span>instanceof</span> <span>Map<span>.</span>Entry</span><span>)</span> <span>{</span>
                <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>?</span><span>,</span><span>?</span><span>></span></span> e <span>=</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>?</span><span>,</span><span>?</span><span>></span></span><span>)</span>o<span>;</span>
                <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>equals</span><span>(</span>key<span>,</span> e<span>.</span><span>getKey</span><span>(</span><span>)</span><span>)</span> <span>&amp;&amp;</span>
                    <span>Objects</span><span>.</span><span>equals</span><span>(</span>value<span>,</span> e<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>)</span>
                    <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p><strong>树节点类源码:</strong></p>
<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>LinkedHashMap<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>
        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> parent<span>;</span>  <span>// 父</span>
        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> left<span>;</span>    <span>// 左</span>
        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> right<span>;</span>   <span>// 右</span>
        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> prev<span>;</span>    <span>// needed to unlink next upon deletion</span>
        <span>boolean</span> red<span>;</span>           <span>// 判断颜色</span>
        <span>TreeNode</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> val<span>,</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>)</span> <span>{</span>
            <span>super</span><span>(</span>hash<span>,</span> key<span>,</span> val<span>,</span> next<span>)</span><span>;</span>
        <span>}</span>
        <span>// 返回根节点</span>
        <span>final</span> <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>root</span><span>(</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> r <span>=</span> <span>this</span><span>,</span> p<span>;</span><span>;</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>(</span>p <span>=</span> r<span>.</span>parent<span>)</span> <span>==</span> <span>null</span><span>)</span>
                    <span>return</span> r<span>;</span>
                r <span>=</span> p<span>;</span>
       <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="hashmap-源码分析"> HashMap 源码分析</h2>
<h3 id="构造方法"> 构造方法</h3>
<p>HashMap 中有四个构造方法，它们分别如下：</p>
<div><pre><code>    <span>// 默认构造函数。</span>
    <span>public</span> <span>HashMap</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>loadFactor <span>=</span> DEFAULT_LOAD_FACTOR<span>;</span> <span>// all   other fields defaulted</span>
     <span>}</span>

     <span>// 包含另一个“Map”的构造函数</span>
     <span>public</span> <span>HashMap</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>)</span> <span>{</span>
         <span>this</span><span>.</span>loadFactor <span>=</span> DEFAULT_LOAD_FACTOR<span>;</span>
         <span>putMapEntries</span><span>(</span>m<span>,</span> <span>false</span><span>)</span><span>;</span><span>//下面会分析到这个方法</span>
     <span>}</span>

     <span>// 指定“容量大小”的构造函数</span>
     <span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
         <span>this</span><span>(</span>initialCapacity<span>,</span> DEFAULT_LOAD_FACTOR<span>)</span><span>;</span>
     <span>}</span>

     <span>// 指定“容量大小”和“加载因子”的构造函数</span>
     <span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>,</span> <span>float</span> loadFactor<span>)</span> <span>{</span>
         <span>if</span> <span>(</span>initialCapacity <span>&lt;</span> <span>0</span><span>)</span>
             <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal initial capacity: "</span> <span>+</span> initialCapacity<span>)</span><span>;</span>
         <span>if</span> <span>(</span>initialCapacity <span>></span> MAXIMUM_CAPACITY<span>)</span>
             initialCapacity <span>=</span> MAXIMUM_CAPACITY<span>;</span>
         <span>if</span> <span>(</span>loadFactor <span>&lt;=</span> <span>0</span> <span>||</span> <span>Float</span><span>.</span><span>isNaN</span><span>(</span>loadFactor<span>)</span><span>)</span>
             <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal load factor: "</span> <span>+</span> loadFactor<span>)</span><span>;</span>
         <span>this</span><span>.</span>loadFactor <span>=</span> loadFactor<span>;</span>
         <span>this</span><span>.</span>threshold <span>=</span> <span>tableSizeFor</span><span>(</span>initialCapacity<span>)</span><span>;</span>
     <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><strong>putMapEntries 方法：</strong></p>
<div><pre><code><span>final</span> <span>void</span> <span>putMapEntries</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>,</span> <span>boolean</span> evict<span>)</span> <span>{</span>
    <span>int</span> s <span>=</span> m<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>s <span>></span> <span>0</span><span>)</span> <span>{</span>
        <span>// 判断table是否已经初始化</span>
        <span>if</span> <span>(</span>table <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// pre-size</span>
            <span>// 未初始化，s为m的实际元素个数</span>
            <span>float</span> ft <span>=</span> <span>(</span><span>(</span><span>float</span><span>)</span>s <span>/</span> loadFactor<span>)</span> <span>+</span> <span>1.0F</span><span>;</span>
            <span>int</span> t <span>=</span> <span>(</span><span>(</span>ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span>MAXIMUM_CAPACITY<span>)</span> <span>?</span>
                    <span>(</span><span>int</span><span>)</span>ft <span>:</span> MAXIMUM_CAPACITY<span>)</span><span>;</span>
            <span>// 计算得到的t大于阈值，则初始化阈值</span>
            <span>if</span> <span>(</span>t <span>></span> threshold<span>)</span>
                threshold <span>=</span> <span>tableSizeFor</span><span>(</span>t<span>)</span><span>;</span>
        <span>}</span>
        <span>// 已初始化，并且m元素个数大于阈值，进行扩容处理</span>
        <span>else</span> <span>if</span> <span>(</span>s <span>></span> threshold<span>)</span>
            <span>resize</span><span>(</span><span>)</span><span>;</span>
        <span>// 将m中的所有元素添加至HashMap中</span>
        <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> e <span>:</span> m<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>K</span> key <span>=</span> e<span>.</span><span>getKey</span><span>(</span><span>)</span><span>;</span>
            <span>V</span> value <span>=</span> e<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>
            <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> evict<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="put-方法"> put 方法</h3>
<p>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p>
<p><strong>对 putVal 方法添加元素的分析如下：</strong></p>
<ol>
<li>如果定位到的数组位置没有元素 就直接插入。</li>
<li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/put方法.png" alt=" " /></p>
<p>说明:上图有两个小问题：</p>
<ul>
<li>直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行（<a href="https://github.com/Snailclimb/JavaGuide/issues/608" target="_blank" rel="noopener noreferrer">issue#608</a>）。</li>
<li>当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。参考 HashMap 的 <code>treeifyBin()</code> 方法（<a href="https://github.com/Snailclimb/JavaGuide/issues/1087" target="_blank" rel="noopener noreferrer">issue#1087</a>）。</li>
</ul>
<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>
    <span>return</span> <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> <span>true</span><span>)</span><span>;</span>
<span>}</span>

<span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>
                   <span>boolean</span> evict<span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>;</span> <span>int</span> n<span>,</span> i<span>;</span>
    <span>// table未初始化或者长度为0，进行扩容</span>
    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>==</span> <span>0</span><span>)</span>
        n <span>=</span> <span>(</span>tab <span>=</span> <span>resize</span><span>(</span><span>)</span><span>)</span><span>.</span>length<span>;</span>
    <span>// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>
    <span>if</span> <span>(</span><span>(</span>p <span>=</span> tab<span>[</span>i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>==</span> <span>null</span><span>)</span>
        tab<span>[</span>i<span>]</span> <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
    <span>// 桶中已经存在元素</span>
    <span>else</span> <span>{</span>
        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span> <span>K</span> k<span>;</span>
        <span>// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>
        <span>if</span> <span>(</span>p<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
            <span>(</span><span>(</span>k <span>=</span> p<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
                <span>// 将第一个元素赋值给e，用e来记录</span>
                e <span>=</span> p<span>;</span>
        <span>// hash值不相等，即key不相等；为红黑树结点</span>
        <span>else</span> <span>if</span> <span>(</span>p <span>instanceof</span> <span>TreeNode</span><span>)</span>
            <span>// 放入树中</span>
            e <span>=</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>p<span>)</span><span>.</span><span>putTreeVal</span><span>(</span><span>this</span><span>,</span> tab<span>,</span> hash<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
        <span>// 为链表结点</span>
        <span>else</span> <span>{</span>
            <span>// 在链表最末插入结点</span>
            <span>for</span> <span>(</span><span>int</span> binCount <span>=</span> <span>0</span><span>;</span> <span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>
                <span>// 到达链表的尾部</span>
                <span>if</span> <span>(</span><span>(</span>e <span>=</span> p<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    <span>// 在尾部插入新结点</span>
                    p<span>.</span>next <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
                    <span>// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span>
                    <span>// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span>
                    <span>// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span>
                    <span>if</span> <span>(</span>binCount <span>>=</span> TREEIFY_THRESHOLD <span>-</span> <span>1</span><span>)</span> <span>// -1 for 1st</span>
                        <span>treeifyBin</span><span>(</span>tab<span>,</span> hash<span>)</span><span>;</span>
                    <span>// 跳出循环</span>
                    <span>break</span><span>;</span>
                <span>}</span>
                <span>// 判断链表中结点的key值与插入的元素的key值是否相等</span>
                <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
                    <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
                    <span>// 相等，跳出循环</span>
                    <span>break</span><span>;</span>
                <span>// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>
                p <span>=</span> e<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>// 表示在桶中找到key值、hash值与插入元素相等的结点</span>
        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 记录e的value</span>
            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>
            <span>// onlyIfAbsent为false或者旧值为null</span>
            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent <span>||</span> oldValue <span>==</span> <span>null</span><span>)</span>
                <span>//用新值替换旧值</span>
                e<span>.</span>value <span>=</span> value<span>;</span>
            <span>// 访问后回调</span>
            <span>afterNodeAccess</span><span>(</span>e<span>)</span><span>;</span>
            <span>// 返回旧值</span>
            <span>return</span> oldValue<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>// 结构性修改</span>
    <span>++</span>modCount<span>;</span>
    <span>// 实际大小大于阈值则扩容</span>
    <span>if</span> <span>(</span><span>++</span>size <span>></span> threshold<span>)</span>
        <span>resize</span><span>(</span><span>)</span><span>;</span>
    <span>// 插入后回调</span>
    <span>afterNodeInsertion</span><span>(</span>evict<span>)</span><span>;</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br></div></div><p><strong>我们再来对比一下 JDK1.7 put 方法的代码</strong></p>
<p><strong>对于 put 方法的分析如下：</strong></p>
<ul>
<li>① 如果定位到的数组位置没有元素 就直接插入。</li>
<li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li>
</ul>
<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span>
    <span>if</span> <span>(</span>table <span>==</span> EMPTY_TABLE<span>)</span> <span>{</span>
    <span>inflateTable</span><span>(</span>threshold<span>)</span><span>;</span>
<span>}</span>
    <span>if</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>putForNullKey</span><span>(</span>value<span>)</span><span>;</span>
    <span>int</span> hash <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span>
    <span>int</span> i <span>=</span> <span>indexFor</span><span>(</span>hash<span>,</span> table<span>.</span>length<span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> table<span>[</span>i<span>]</span><span>;</span> e <span>!=</span> <span>null</span><span>;</span> e <span>=</span> e<span>.</span>next<span>)</span> <span>{</span> <span>// 先遍历</span>
        <span>Object</span> k<span>;</span>
        <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span> <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span> <span>{</span>
            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>
            e<span>.</span>value <span>=</span> value<span>;</span>
            e<span>.</span><span>recordAccess</span><span>(</span><span>this</span><span>)</span><span>;</span>
            <span>return</span> oldValue<span>;</span>
        <span>}</span>
    <span>}</span>

    modCount<span>++</span><span>;</span>
    <span>addEntry</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> i<span>)</span><span>;</span>  <span>// 再插入</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="get-方法"> get 方法</h3>
<div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>
    <span>return</span> <span>(</span>e <span>=</span> <span>getNode</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>)</span><span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> e<span>.</span>value<span>;</span>
<span>}</span>

<span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>getNode</span><span>(</span><span>int</span> hash<span>,</span> <span>Object</span> key<span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> first<span>,</span> e<span>;</span> <span>int</span> n<span>;</span> <span>K</span> k<span>;</span>
    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>></span> <span>0</span> <span>&amp;&amp;</span>
        <span>(</span>first <span>=</span> tab<span>[</span><span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 数组元素相等</span>
        <span>if</span> <span>(</span>first<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span> <span>// always check first node</span>
            <span>(</span><span>(</span>k <span>=</span> first<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
            <span>return</span> first<span>;</span>
        <span>// 桶中不止一个节点</span>
        <span>if</span> <span>(</span><span>(</span>e <span>=</span> first<span>.</span>next<span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 在树中get</span>
            <span>if</span> <span>(</span>first <span>instanceof</span> <span>TreeNode</span><span>)</span>
                <span>return</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>first<span>)</span><span>.</span><span>getTreeNode</span><span>(</span>hash<span>,</span> key<span>)</span><span>;</span>
            <span>// 在链表中get</span>
            <span>do</span> <span>{</span>
                <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
                    <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
                    <span>return</span> e<span>;</span>
            <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> e<span>.</span>next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id="resize-方法"> resize 方法</h3>
<p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p>
<div><pre><code><span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> <span>resize</span><span>(</span><span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> oldTab <span>=</span> table<span>;</span>
    <span>int</span> oldCap <span>=</span> <span>(</span>oldTab <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> oldTab<span>.</span>length<span>;</span>
    <span>int</span> oldThr <span>=</span> threshold<span>;</span>
    <span>int</span> newCap<span>,</span> newThr <span>=</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>oldCap <span>></span> <span>0</span><span>)</span> <span>{</span>
        <span>// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>
        <span>if</span> <span>(</span>oldCap <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>{</span>
            threshold <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
            <span>return</span> oldTab<span>;</span>
        <span>}</span>
        <span>// 没超过最大值，就扩充为原来的2倍</span>
        <span>else</span> <span>if</span> <span>(</span><span>(</span>newCap <span>=</span> oldCap <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span> oldCap <span>>=</span> DEFAULT_INITIAL_CAPACITY<span>)</span>
            newThr <span>=</span> oldThr <span>&lt;&lt;</span> <span>1</span><span>;</span> <span>// double threshold</span>
    <span>}</span>
    <span>else</span> <span>if</span> <span>(</span>oldThr <span>></span> <span>0</span><span>)</span> <span>// initial capacity was placed in threshold</span>
        newCap <span>=</span> oldThr<span>;</span>
    <span>else</span> <span>{</span>
        <span>// signifies using defaults</span>
        newCap <span>=</span> DEFAULT_INITIAL_CAPACITY<span>;</span>
        newThr <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>DEFAULT_LOAD_FACTOR <span>*</span> DEFAULT_INITIAL_CAPACITY<span>)</span><span>;</span>
    <span>}</span>
    <span>// 计算新的resize上限</span>
    <span>if</span> <span>(</span>newThr <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>float</span> ft <span>=</span> <span>(</span><span>float</span><span>)</span>newCap <span>*</span> loadFactor<span>;</span>
        newThr <span>=</span> <span>(</span>newCap <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span> ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span>MAXIMUM_CAPACITY <span>?</span> <span>(</span><span>int</span><span>)</span>ft <span>:</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>
    <span>}</span>
    threshold <span>=</span> newThr<span>;</span>
    <span>@SuppressWarnings</span><span>(</span><span>{</span><span>"rawtypes"</span><span>,</span><span>"unchecked"</span><span>}</span><span>)</span>
        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> newTab <span>=</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Node</span><span>[</span>newCap<span>]</span><span>;</span>
    table <span>=</span> newTab<span>;</span>
    <span>if</span> <span>(</span>oldTab <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 把每个bucket都移动到新的buckets中</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> oldCap<span>;</span> <span>++</span>j<span>)</span> <span>{</span>
            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>
            <span>if</span> <span>(</span><span>(</span>e <span>=</span> oldTab<span>[</span>j<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                oldTab<span>[</span>j<span>]</span> <span>=</span> <span>null</span><span>;</span>
                <span>if</span> <span>(</span>e<span>.</span>next <span>==</span> <span>null</span><span>)</span>
                    newTab<span>[</span>e<span>.</span>hash <span>&amp;</span> <span>(</span>newCap <span>-</span> <span>1</span><span>)</span><span>]</span> <span>=</span> e<span>;</span>
                <span>else</span> <span>if</span> <span>(</span>e <span>instanceof</span> <span>TreeNode</span><span>)</span>
                    <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>e<span>)</span><span>.</span><span>split</span><span>(</span><span>this</span><span>,</span> newTab<span>,</span> j<span>,</span> oldCap<span>)</span><span>;</span>
                <span>else</span> <span>{</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> loHead <span>=</span> <span>null</span><span>,</span> loTail <span>=</span> <span>null</span><span>;</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> hiHead <span>=</span> <span>null</span><span>,</span> hiTail <span>=</span> <span>null</span><span>;</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>
                    <span>do</span> <span>{</span>
                        next <span>=</span> e<span>.</span>next<span>;</span>
                        <span>// 原索引</span>
                        <span>if</span> <span>(</span><span>(</span>e<span>.</span>hash <span>&amp;</span> oldCap<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                            <span>if</span> <span>(</span>loTail <span>==</span> <span>null</span><span>)</span>
                                loHead <span>=</span> e<span>;</span>
                            <span>else</span>
                                loTail<span>.</span>next <span>=</span> e<span>;</span>
                            loTail <span>=</span> e<span>;</span>
                        <span>}</span>
                        <span>// 原索引+oldCap</span>
                        <span>else</span> <span>{</span>
                            <span>if</span> <span>(</span>hiTail <span>==</span> <span>null</span><span>)</span>
                                hiHead <span>=</span> e<span>;</span>
                            <span>else</span>
                                hiTail<span>.</span>next <span>=</span> e<span>;</span>
                            hiTail <span>=</span> e<span>;</span>
                        <span>}</span>
                    <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>
                    <span>// 原索引放到bucket里</span>
                    <span>if</span> <span>(</span>loTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                        loTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>
                        newTab<span>[</span>j<span>]</span> <span>=</span> loHead<span>;</span>
                    <span>}</span>
                    <span>// 原索引+oldCap放到bucket里</span>
                    <span>if</span> <span>(</span>hiTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                        hiTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>
                        newTab<span>[</span>j <span>+</span> oldCap<span>]</span> <span>=</span> hiHead<span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> newTab<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br></div></div><h2 id="hashmap-常用方法测试"> HashMap 常用方法测试</h2>
<div><pre><code><span>package</span> <span>map</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Collection</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>HashMap</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Set</span><span>;</span>

<span>public</span> <span>class</span> <span>HashMapDemo</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>// 键不能重复，值可以重复</span>
        map<span>.</span><span>put</span><span>(</span><span>"san"</span><span>,</span> <span>"张三"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>"si"</span><span>,</span> <span>"李四"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>"wu"</span><span>,</span> <span>"王五"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>"wang"</span><span>,</span> <span>"老王"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>"wang"</span><span>,</span> <span>"老王2"</span><span>)</span><span>;</span><span>// 老王被覆盖</span>
        map<span>.</span><span>put</span><span>(</span><span>"lao"</span><span>,</span> <span>"老王"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-------直接输出hashmap:-------"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>)</span><span>;</span>
        <span>/**
         * 遍历HashMap
         */</span>
        <span>// 1.获取Map中的所有键</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-------foreach获取Map中所有的键:------"</span><span>)</span><span>;</span>
        <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys <span>=</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>String</span> key <span>:</span> keys<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>key<span>+</span><span>"  "</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span><span>//换行</span>
        <span>// 2.获取Map中所有值</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-------foreach获取Map中所有的值:------"</span><span>)</span><span>;</span>
        <span>Collection</span><span><span>&lt;</span><span>String</span><span>></span></span> values <span>=</span> map<span>.</span><span>values</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>String</span> value <span>:</span> values<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>value<span>+</span><span>"  "</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span><span>//换行</span>
        <span>// 3.得到key的值的同时得到key所对应的值</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-------得到key的值的同时得到key所对应的值:-------"</span><span>)</span><span>;</span>
        <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys2 <span>=</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>String</span> key <span>:</span> keys2<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>key <span>+</span> <span>"："</span> <span>+</span> map<span>.</span><span>get</span><span>(</span>key<span>)</span><span>+</span><span>"   "</span><span>)</span><span>;</span>

        <span>}</span>
        <span>/**
         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。
         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。
         */</span>
        <span>// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span>
        <span>// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span>
        <span>// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span>
        <span>// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span>
        <span>Set</span><span><span>&lt;</span><span><span>java<span>.</span>util<span>.</span></span>Map<span>.</span>Entry</span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span><span>></span></span> entrys <span>=</span> map<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span><span>java<span>.</span>util<span>.</span></span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> entry <span>:</span> entrys<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span> <span>+</span> <span>"--"</span> <span>+</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>

        <span>/**
         * HashMap其他常用方法
         */</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after map.size()："</span><span>+</span>map<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after map.isEmpty()："</span><span>+</span>map<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>remove</span><span>(</span><span>"san"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after map.remove()："</span><span>+</span>map<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after map.get(si)："</span><span>+</span>map<span>.</span><span>get</span><span>(</span><span>"si"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after map.containsKey(si)："</span><span>+</span>map<span>.</span><span>containsKey</span><span>(</span><span>"si"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after containsValue(李四)："</span><span>+</span>map<span>.</span><span>containsValue</span><span>(</span><span>"李四"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>replace</span><span>(</span><span>"si"</span><span>,</span> <span>"李四2"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after map.replace(si, 李四2):"</span><span>+</span>map<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div>]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/jdk1.8之前的内部结构.png" type="image/png"/>
    </item>
    <item>
      <title>Java集合使用注意事项总结</title>
      <link>https://javaguide.cn/java/collection/java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <guid>https://javaguide.cn/java/collection/java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <source url="https://javaguide.cn/rss.xml">Java集合使用注意事项总结</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>这篇文章我根据《阿里巴巴 Java 开发手册》总结了关于集合使用常见的注意事项以及其具体原理。</p>
<p>强烈建议小伙伴们多多阅读几遍，避免自己写代码的时候出现这些低级的问题。</p>
<h2 id="集合判空"> 集合判空</h2>
<p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</strong></p>
</blockquote>
<p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 O(1)。</p>
<p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 <code>java.util.concurrent</code> 包下的某些集合（<code>ConcurrentLinkedQueue</code> 、<code>ConcurrentHashMap</code>...）。</p>
<p>下面是 <code>ConcurrentHashMap</code> 的 <code>size()</code> 方法和 <code>isEmpty()</code> 方法的源码。</p>
<div><pre><code><span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
    <span>long</span> n <span>=</span> <span>sumCount</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>(</span>n <span>&lt;</span> <span>0L</span><span>)</span> <span>?</span> <span>0</span> <span>:</span>
            <span>(</span>n <span>></span> <span>(</span><span>long</span><span>)</span><span>Integer</span><span>.</span>MAX_VALUE<span>)</span> <span>?</span> <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>
            <span>(</span><span>int</span><span>)</span>n<span>)</span><span>;</span>
<span>}</span>
<span>final</span> <span>long</span> <span>sumCount</span><span>(</span><span>)</span> <span>{</span>
    <span>CounterCell</span><span>[</span><span>]</span> as <span>=</span> counterCells<span>;</span> <span>CounterCell</span> a<span>;</span>
    <span>long</span> sum <span>=</span> baseCount<span>;</span>
    <span>if</span> <span>(</span>as <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> as<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>(</span>a <span>=</span> as<span>[</span>i<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span>
                sum <span>+=</span> a<span>.</span>value<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> sum<span>;</span>
<span>}</span>
<span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>sumCount</span><span>(</span><span>)</span> <span>&lt;=</span> <span>0L</span><span>;</span> <span>// ignore transient negative values</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="集合转-map"> 集合转 Map</h2>
<p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</strong></p>
</blockquote>
<div><pre><code><span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>String</span> phoneNumber<span>;</span>
     <span>// getters and setters</span>
<span>}</span>

<span>List</span><span><span>&lt;</span><span>Person</span><span>></span></span> bookList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
bookList<span>.</span><span>add</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"jack"</span><span>,</span><span>"18163138123"</span><span>)</span><span>)</span><span>;</span>
bookList<span>.</span><span>add</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"martin"</span><span>,</span><span>null</span><span>)</span><span>)</span><span>;</span>
<span>// 空指针异常</span>
bookList<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toMap</span><span>(</span><span>Person</span><span>::</span><span>getName</span><span>,</span> <span>Person</span><span>::</span><span>getPhoneNumber</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>下面我们来解释一下原因。</p>
<p>首先，我们来看 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法 ，可以看到其内部调用了 <code>Map</code> 接口的 <code>merge()</code> 方法。</p>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>,</span> <span>K</span><span>,</span> <span>U</span><span>,</span> <span>M</span> <span>extends</span> <span>Map</span><span>&lt;</span><span>K</span><span>,</span> <span>U</span><span>></span><span>></span></span>
<span>Collector</span><span><span>&lt;</span><span>T</span><span>,</span> <span>?</span><span>,</span> <span>M</span><span>></span></span> <span>toMap</span><span>(</span><span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>extends</span> <span>K</span><span>></span></span> keyMapper<span>,</span>
                            <span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>extends</span> <span>U</span><span>></span></span> valueMapper<span>,</span>
                            <span>BinaryOperator</span><span><span>&lt;</span><span>U</span><span>></span></span> mergeFunction<span>,</span>
                            <span>Supplier</span><span><span>&lt;</span><span>M</span><span>></span></span> mapSupplier<span>)</span> <span>{</span>
    <span>BiConsumer</span><span><span>&lt;</span><span>M</span><span>,</span> <span>T</span><span>></span></span> accumulator
            <span>=</span> <span>(</span>map<span>,</span> element<span>)</span> <span>-></span> map<span>.</span><span>merge</span><span>(</span>keyMapper<span>.</span><span>apply</span><span>(</span>element<span>)</span><span>,</span>
                                          valueMapper<span>.</span><span>apply</span><span>(</span>element<span>)</span><span>,</span> mergeFunction<span>)</span><span>;</span>
    <span>return</span> <span>new</span> <span>CollectorImpl</span><span><span>&lt;</span><span>></span></span><span>(</span>mapSupplier<span>,</span> accumulator<span>,</span> <span>mapMerger</span><span>(</span>mergeFunction<span>)</span><span>,</span> CH_ID<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>Map</code> 接口的 <code>merge()</code> 方法如下，这个方法是接口中的默认实现。</p>
<blockquote>
<p>如果你还不了解 Java 8 新特性的话，请看这篇文章：<a href="https://mp.weixin.qq.com/s/ojyl7B6PiHaTWADqmUq2rw" target="_blank" rel="noopener noreferrer">《Java8 新特性总结》</a> 。</p>
</blockquote>
<div><pre><code><span>default</span> <span>V</span> <span>merge</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>,</span>
        <span>BiFunction</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>V</span><span>,</span> <span>?</span> <span>super</span> <span>V</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> remappingFunction<span>)</span> <span>{</span>
    <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>remappingFunction<span>)</span><span>;</span>
    <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>value<span>)</span><span>;</span>
    <span>V</span> oldValue <span>=</span> <span>get</span><span>(</span>key<span>)</span><span>;</span>
    <span>V</span> newValue <span>=</span> <span>(</span>oldValue <span>==</span> <span>null</span><span>)</span> <span>?</span> value <span>:</span>
               remappingFunction<span>.</span><span>apply</span><span>(</span>oldValue<span>,</span> value<span>)</span><span>;</span>
    <span>if</span><span>(</span>newValue <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>remove</span><span>(</span>key<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>put</span><span>(</span>key<span>,</span> newValue<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> newValue<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><code>merge()</code> 方法会先调用 <code>Objects.requireNonNull()</code> 方法判断 value 是否为空。</p>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>requireNonNull</span><span>(</span><span>T</span> obj<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>obj <span>==</span> <span>null</span><span>)</span>
        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> obj<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="集合遍历"> 集合遍历</h2>
<p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</strong></p>
</blockquote>
<p>通过反编译你会发现 foreach 语法糖底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法</p>
<p>这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p>
<blockquote>
<p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时候，可能会抛出<code>ConcurrentModificationException</code>。 即使是单线程下也有可能会出现这种情况，上面已经提到过。</p>
</blockquote>
<p>Java8 开始，可以使用 <code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>10</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
    list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
list<span>.</span><span>removeIf</span><span>(</span>filter <span>-></span> filter <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span><span>;</span> <span>/* 删除list中的所有偶数 */</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>list<span>)</span><span>;</span> <span>/* [1, 3, 5, 7, 9] */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>除了上面介绍的直接使用 <code>Iterator</code> 进行遍历操作之外，你还可以：</p>
<ul>
<li>使用普通的 for 循环</li>
<li>使用 fail-safe 的集合类。<code>java.util</code>包下面的所有的集合类都是 fail-fast 的，而<code>java.util.concurrent</code>包下面的所有的类都是 fail-safe 的。</li>
<li>......</li>
</ul>
<h2 id="集合去重"> 集合去重</h2>
<p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>可以利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</strong></p>
</blockquote>
<p>这里我们以 <code>HashSet</code> 和 <code>ArrayList</code> 为例说明。</p>
<div><pre><code><span>// Set 去重代码示例</span>
<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Set</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>removeDuplicateBySet</span><span>(</span><span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> data<span>)</span> <span>{</span>

    <span>if</span> <span>(</span><span>CollectionUtils</span><span>.</span><span>isEmpty</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span>data<span>)</span><span>;</span>
<span>}</span>

<span>// List 去重代码示例</span>
<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>removeDuplicateByList</span><span>(</span><span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> data<span>)</span> <span>{</span>

    <span>if</span> <span>(</span><span>CollectionUtils</span><span>.</span><span>isEmpty</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>}</span>
    <span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> result <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>data<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>T</span> current <span>:</span> data<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>result<span>.</span><span>contains</span><span>(</span>current<span>)</span><span>)</span> <span>{</span>
            result<span>.</span><span>add</span><span>(</span>current<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> result<span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>两者的核心差别在于 <code>contains()</code> 方法的实现。</p>
<p><code>HashSet</code> 的 <code>contains()</code> 方法底部依赖的 <code>HashMap</code> 的 <code>containsKey()</code> 方法，时间复杂度接近于 O（1）（没有出现哈希冲突的时候为 O（1））。</p>
<div><pre><code><span>private</span> <span>transient</span> <span>HashMap</span><span><span>&lt;</span><span>E</span><span>,</span><span>Object</span><span>></span></span> map<span>;</span>
<span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
    <span>return</span> map<span>.</span><span>containsKey</span><span>(</span>o<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>我们有 N 个元素插入进 Set 中，那时间复杂度就接近是 O (n)。</p>
<p><code>ArrayList</code> 的 <code>contains()</code> 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
    <span>return</span> <span>indexOf</span><span>(</span>o<span>)</span> <span>>=</span> <span>0</span><span>;</span>
<span>}</span>
<span>public</span> <span>int</span> <span>indexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
            <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>
                <span>return</span> i<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
            <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>
                <span>return</span> i<span>;</span>
    <span>}</span>
    <span>return</span> <span>-</span><span>1</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>我们的 <code>List</code> 有 N 个元素，那时间复杂度就接近是 O (n^2)。</p>
<h2 id="集合转数组"> 集合转数组</h2>
<p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</strong></p>
</blockquote>
<p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p>
<div><pre><code><span>String</span> <span>[</span><span>]</span> s<span>=</span> <span>new</span> <span>String</span><span>[</span><span>]</span><span>{</span>
    <span>"dog"</span><span>,</span> <span>"lazy"</span><span>,</span> <span>"a"</span><span>,</span> <span>"over"</span><span>,</span> <span>"jumps"</span><span>,</span> <span>"fox"</span><span>,</span> <span>"brown"</span><span>,</span> <span>"quick"</span><span>,</span> <span>"A"</span>
<span>}</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>s<span>)</span><span>;</span>
<span>Collections</span><span>.</span><span>reverse</span><span>(</span>list<span>)</span><span>;</span>
<span>//没有指定类型的话会报错</span>
s<span>=</span>list<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>String</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/" target="_blank" rel="noopener noreferrer">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p>
<h2 id="数组转集合"> 数组转集合</h2>
<p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</strong></p>
</blockquote>
<p>我在之前的一个项目中就遇到一个类似的坑。</p>
<p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 <code>List</code> 集合。</p>
<div><pre><code><span>String</span><span>[</span><span>]</span> myArray <span>=</span> <span>{</span><span>"Apple"</span><span>,</span> <span>"Banana"</span><span>,</span> <span>"Orange"</span><span>}</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> myList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>myArray<span>)</span><span>;</span>
<span>//上面两个语句等价于下面一条语句</span>
<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> myList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>"Apple"</span><span>,</span><span>"Banana"</span><span>,</span> <span>"Orange"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>JDK 源码对于这个方法的说明：</p>
<div><pre><code><span>/**
  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，
  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。
  */</span>
<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>asList</span><span>(</span><span>T</span><span>.</span><span>.</span><span>.</span> a<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>a<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>下面我们来总结一下使用注意事项。</p>
<p><strong>1、<code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</strong></p>
<div><pre><code><span>int</span><span>[</span><span>]</span> myArray <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>;</span>
<span>List</span> myList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>myArray<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myList<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//1</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myList<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span><span>//数组地址值</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myList<span>.</span><span>get</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span><span>//报错：ArrayIndexOutOfBoundsException</span>
<span>int</span><span>[</span><span>]</span> array <span>=</span> <span>(</span><span>int</span><span>[</span><span>]</span><span>)</span> myList<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>array<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span><span>//1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 <code>List</code> 的唯一元素就是这个数组，这也就解释了上面的代码。</p>
<p>我们使用包装类型数组就可以解决这个问题。</p>
<div><pre><code><span>Integer</span><span>[</span><span>]</span> myArray <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>2、使用集合的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p>
<div><pre><code><span>List</span> myList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
myList<span>.</span><span>add</span><span>(</span><span>4</span><span>)</span><span>;</span><span>//运行时报错：UnsupportedOperationException</span>
myList<span>.</span><span>remove</span><span>(</span><span>1</span><span>)</span><span>;</span><span>//运行时报错：UnsupportedOperationException</span>
myList<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span><span>//运行时报错：UnsupportedOperationException</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>
<div><pre><code><span>List</span> myList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myList<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//class java.util.Arrays$ArrayList</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下图是 <code>java.util.Arrays$ArrayList</code> 的简易源码，我们可以看到这个类重写的方法有哪些。</p>
<div><pre><code>  <span>private</span> <span>static</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>
        <span>implements</span> <span>RandomAccess</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span>
    <span>{</span>
        <span>.</span><span>.</span><span>.</span>

        <span>@Override</span>
        <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
          <span>.</span><span>.</span><span>.</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>E</span> <span>set</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
          <span>.</span><span>.</span><span>.</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>int</span> <span>indexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
          <span>.</span><span>.</span><span>.</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
           <span>.</span><span>.</span><span>.</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>void</span> <span>forEach</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>E</span><span>></span></span> action<span>)</span> <span>{</span>
          <span>.</span><span>.</span><span>.</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>void</span> <span>replaceAll</span><span>(</span><span>UnaryOperator</span><span><span>&lt;</span><span>E</span><span>></span></span> operator<span>)</span> <span>{</span>
          <span>.</span><span>.</span><span>.</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>void</span> <span>sort</span><span>(</span><span>Comparator</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
          <span>.</span><span>.</span><span>.</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>我们再看一下<code>java.util.AbstractList</code>的 <code>add/remove/clear</code> 方法就知道为什么会抛出 <code>UnsupportedOperationException</code> 了。</p>
<div><pre><code><span>public</span> <span>E</span> <span>remove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
    <span>add</span><span>(</span><span>size</span><span>(</span><span>)</span><span>,</span> e<span>)</span><span>;</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
<span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>
    <span>removeRange</span><span>(</span><span>0</span><span>,</span> <span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
<span>protected</span> <span>void</span> <span>removeRange</span><span>(</span><span>int</span> fromIndex<span>,</span> <span>int</span> toIndex<span>)</span> <span>{</span>
    <span>ListIterator</span><span><span>&lt;</span><span>E</span><span>></span></span> it <span>=</span> <span>listIterator</span><span>(</span>fromIndex<span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>,</span> n<span>=</span>toIndex<span>-</span>fromIndex<span>;</span> i<span>&lt;</span>n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        it<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
        it<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><strong>那我们如何正确的将数组转换为 <code>ArrayList</code> ?</strong></p>
<p>1、手动实现工具类</p>
<div><pre><code><span>//JDK1.5+</span>
<span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>arrayToList</span><span>(</span><span>final</span> <span>T</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
  <span>final</span> <span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> l <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>T</span><span>></span></span><span>(</span>array<span>.</span>length<span>)</span><span>;</span>

  <span>for</span> <span>(</span><span>final</span> <span>T</span> s <span>:</span> array<span>)</span> <span>{</span>
    l<span>.</span><span>add</span><span>(</span>s<span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> l<span>;</span>
<span>}</span>


<span>Integer</span> <span>[</span><span>]</span> myArray <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span> <span>}</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>arrayToList</span><span>(</span>myArray<span>)</span><span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//class java.util.ArrayList</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>2、最简便的方法</p>
<div><pre><code><span>List</span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>"a"</span><span>,</span> <span>"b"</span><span>,</span> <span>"c"</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>3、使用 Java8 的 <code>Stream</code>(推荐)</p>
<div><pre><code><span>Integer</span> <span>[</span><span>]</span> myArray <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span> <span>}</span><span>;</span>
<span>List</span> myList <span>=</span> <span>Arrays</span><span>.</span><span>stream</span><span>(</span>myArray<span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>//基本类型也可以实现转换（依赖boxed的装箱操作）</span>
<span>int</span> <span>[</span><span>]</span> myArray2 <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span> <span>}</span><span>;</span>
<span>List</span> myList <span>=</span> <span>Arrays</span><span>.</span><span>stream</span><span>(</span>myArray2<span>)</span><span>.</span><span>boxed</span><span>(</span><span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>4、使用 Guava</p>
<p>对于不可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java" target="_blank" rel="noopener noreferrer"><code>ImmutableList</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101" target="_blank" rel="noopener noreferrer"><code>of()</code></a>与<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225" target="_blank" rel="noopener noreferrer"><code>copyOf()</code></a>工厂方法：（参数不能为空）</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> il <span>=</span> <span>ImmutableList</span><span>.</span><span>of</span><span>(</span><span>"string"</span><span>,</span> <span>"elements"</span><span>)</span><span>;</span>  <span>// from varargs</span>
<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> il <span>=</span> <span>ImmutableList</span><span>.</span><span>copyOf</span><span>(</span>aStringArray<span>)</span><span>;</span>      <span>// from array</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>对于可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java" target="_blank" rel="noopener noreferrer"><code>Lists</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87" target="_blank" rel="noopener noreferrer"><code>newArrayList()</code></a>工厂方法：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> l1 <span>=</span> <span>Lists</span><span>.</span><span>newArrayList</span><span>(</span>anotherListOrCollection<span>)</span><span>;</span>    <span>// from collection</span>
<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> l2 <span>=</span> <span>Lists</span><span>.</span><span>newArrayList</span><span>(</span>aStringArray<span>)</span><span>;</span>               <span>// from array</span>
<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> l3 <span>=</span> <span>Lists</span><span>.</span><span>newArrayList</span><span>(</span><span>"or"</span><span>,</span> <span>"string"</span><span>,</span> <span>"elements"</span><span>)</span><span>;</span> <span>// from varargs</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>5、使用 Apache Commons Collections</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>CollectionUtils</span><span>.</span><span>addAll</span><span>(</span>list<span>,</span> str<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>6、 使用 Java9 的 <code>List.of()</code>方法</p>
<div><pre><code><span>Integer</span><span>[</span><span>]</span> array <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span>array<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Java集合框架基础知识&amp;面试题总结</title>
      <link>https://javaguide.cn/java/collection/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&amp;%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/java/collection/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&amp;%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">Java集合框架基础知识&amp;面试题总结</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="java集合框架基础知识-面试题总结"> Java集合框架基础知识&amp;面试题总结</h1>
<h2 id="集合概述"> 集合概述</h2>
<h3 id="java-集合概览"> Java 集合概览</h3>
<p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p>
<p>Java 集合框架如下图所示：</p>
<p><img src="./images/java-collection-hierarchy.png" alt="" /></p>
<p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>, <code>NavigableSet</code>等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p>
<h3 id="说说-list-set-queue-map-四者的区别"> 说说 List, Set, Queue, Map 四者的区别？</h3>
<ul>
<li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，&quot;x&quot; 代表 key，&quot;y&quot; 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h3 id="集合框架底层数据结构总结"> 集合框架底层数据结构总结</h3>
<p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h4 id="list"> List</h4>
<ul>
<li><code>Arraylist</code>： <code>Object[]</code> 数组</li>
<li><code>Vector</code>：<code>Object[]</code> 数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h4 id="set"> Set</h4>
<ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li>
</ul>
<h4 id="queue"> Queue</h4>
<ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li>
<li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h4 id="map"> Map</h4>
<ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener noreferrer">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="如何选用集合"> 如何选用集合?</h3>
<p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p>
<p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p>
<h3 id="为什么要使用集合"> 为什么要使用集合？</h3>
<p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端，
因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p>
<p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。
但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p>
<h2 id="collection-子接口之-list"> Collection 子接口之 List</h2>
<h3 id="arraylist-和-vector-的区别"> Arraylist 和 Vector 的区别?</h3>
<ul>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</li>
</ul>
<h3 id="arraylist-与-linkedlist-区别"> Arraylist 与 LinkedList 区别?</h3>
<ol>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong>
<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li>
</ul>
</li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h4 id="补充内容-双向链表和双向循环链表"> 补充内容:双向链表和双向循环链表</h4>
<p><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>
<blockquote>
<p>另外推荐一篇把双向链表讲清楚的文章：<a href="https://juejin.cn/post/6844903648154271757" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903648154271757</a></p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向链表.png" alt="双向链表" /></p>
<p><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向循环链表.png" alt="双向循环链表" /></p>
<h4 id="补充内容-randomaccess-接口"> 补充内容:RandomAccess 接口</h4>
<div><pre><code><span>public</span> <span>interface</span> <span>RandomAccess</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p>
<p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RamdomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p>
<div><pre><code>    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span>
    <span>int</span> <span>binarySearch</span><span>(</span><span>List</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span><span>></span></span> list<span>,</span> <span>T</span> key<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>list <span>instanceof</span> <span>RandomAccess</span> <span>||</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>&lt;</span>BINARYSEARCH_THRESHOLD<span>)</span>
            <span>return</span> <span>Collections</span><span>.</span><span>indexedBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>
        <span>else</span>
            <span>return</span> <span>Collections</span><span>.</span><span>iteratorBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p>
<h3 id="说一说-arraylist-的扩容机制吧"> 说一说 ArrayList 的扩容机制吧</h3>
<p>详见笔主的这篇文章:<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/arraylist-source-code?id=_2-arraylist-%e6%a0%b8%e5%bf%83%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb" target="_blank" rel="noopener noreferrer">通过源码一步一步分析 ArrayList 扩容机制</a></p>
<h2 id="collection-子接口之-set"> Collection 子接口之 Set</h2>
<h3 id="comparable-和-comparator-的区别"> comparable 和 Comparator 的区别</h3>
<ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p>
<h4 id="comparator-定制排序"> Comparator 定制排序</h4>
<div><pre><code>        <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
        arrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>
        arrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>
        arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>5</span><span>)</span><span>;</span>
        arrayList<span>.</span><span>add</span><span>(</span><span>7</span><span>)</span><span>;</span>
        arrayList<span>.</span><span>add</span><span>(</span><span>4</span><span>)</span><span>;</span>
        arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>9</span><span>)</span><span>;</span>
        arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>7</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"原始数组:"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>
        <span>// void reverse(List list)：反转</span>
        <span>Collections</span><span>.</span><span>reverse</span><span>(</span>arrayList<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Collections.reverse(arrayList):"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>

        <span>// void sort(List list),按自然排序的升序排序</span>
        <span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Collections.sort(arrayList):"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>
        <span>// 定制排序的用法</span>
        <span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>,</span> <span>new</span> <span>Comparator</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span> <span>{</span>

            <span>@Override</span>
            <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>Integer</span> o1<span>,</span> <span>Integer</span> o2<span>)</span> <span>{</span>
                <span>return</span> o2<span>.</span><span>compareTo</span><span>(</span>o1<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"定制排序后："</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>Output:</p>
<div><pre><code>原始数组:
[-1, 3, 3, -5, 7, 4, -9, -7]
Collections.reverse(arrayList):
[-7, -9, 4, 7, -5, 3, 3, -1]
Collections.sort(arrayList):
[-9, -7, -5, -1, 3, 3, 4, 7]
定制排序后：
[7, 4, 3, 3, -1, -5, -7, -9]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="重写-compareto-方法实现按年龄来排序"> 重写 compareTo 方法实现按年龄来排序</h4>
<div><pre><code><span>// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span>
<span>// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span>
<span>// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span>
<span>public</span>  <span>class</span> <span>Person</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Person</span><span>></span></span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>/**
     * T重写compareTo方法实现按年龄来排序
     */</span>
    <span>@Override</span>
    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Person</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>age <span>></span> o<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>age <span>&lt;</span> o<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>-</span><span>1</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span> pdata <span>=</span> <span>new</span> <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"张三"</span><span>,</span> <span>30</span><span>)</span><span>,</span> <span>"zhangsan"</span><span>)</span><span>;</span>
        pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"李四"</span><span>,</span> <span>20</span><span>)</span><span>,</span> <span>"lisi"</span><span>)</span><span>;</span>
        pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"王五"</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>"wangwu"</span><span>)</span><span>;</span>
        pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"小红"</span><span>,</span> <span>5</span><span>)</span><span>,</span> <span>"xiaohong"</span><span>)</span><span>;</span>
        <span>// 得到key的值的同时得到key所对应的值</span>
        <span>Set</span><span><span>&lt;</span><span>Person</span><span>></span></span> keys <span>=</span> pdata<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Person</span> key <span>:</span> keys<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>key<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>+</span> <span>"-"</span> <span>+</span> key<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>Output：</p>
<div><pre><code>5-小红
10-王五
20-李四
30-张三
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="无序性和不可重复性的含义是什么"> 无序性和不可重复性的含义是什么</h3>
<p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
<h3 id="比较-hashset、linkedhashset-和-treeset-三者的异同"> 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3>
<ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h2 id="collection-子接口之-queue"> Collection 子接口之 Queue</h2>
<h3 id="queue-与-deque-的区别"> Queue 与 Deque 的区别</h3>
<p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th><code>Queue</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody>
</table>
<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th><code>Deque</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody>
</table>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<h3 id="arraydeque-与-linkedlist-的区别"> ArrayDeque 与 LinkedList 的区别</h3>
<p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li>
<p><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</p>
</li>
<li>
<p><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</p>
</li>
<li>
<p><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</p>
</li>
<li>
<p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>
</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h3 id="说一说-priorityqueue"> 说一说 PriorityQueue</h3>
<p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p>
<h2 id="map-接口"> Map 接口</h2>
<h3 id="hashmap-和-hashtable-的区别"> HashMap 和 Hashtable 的区别</h3>
<ol>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<p><strong><code>HashMap</code> 中带有初始容量的构造函数：</strong></p>
<div><pre><code>    <span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>,</span> <span>float</span> loadFactor<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>initialCapacity <span>&lt;</span> <span>0</span><span>)</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal initial capacity: "</span> <span>+</span>
                                               initialCapacity<span>)</span><span>;</span>
        <span>if</span> <span>(</span>initialCapacity <span>></span> MAXIMUM_CAPACITY<span>)</span>
            initialCapacity <span>=</span> MAXIMUM_CAPACITY<span>;</span>
        <span>if</span> <span>(</span>loadFactor <span>&lt;=</span> <span>0</span> <span>||</span> <span>Float</span><span>.</span><span>isNaN</span><span>(</span>loadFactor<span>)</span><span>)</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal load factor: "</span> <span>+</span>
                                               loadFactor<span>)</span><span>;</span>
        <span>this</span><span>.</span>loadFactor <span>=</span> loadFactor<span>;</span>
        <span>this</span><span>.</span>threshold <span>=</span> <span>tableSizeFor</span><span>(</span>initialCapacity<span>)</span><span>;</span>
    <span>}</span>
     <span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
        <span>this</span><span>(</span>initialCapacity<span>,</span> DEFAULT_LOAD_FACTOR<span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>下面这个方法保证了 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<div><pre><code>    <span>/**
     * Returns a power of two size for the given target capacity.
     */</span>
    <span>static</span> <span>final</span> <span>int</span> <span>tableSizeFor</span><span>(</span><span>int</span> cap<span>)</span> <span>{</span>
        <span>int</span> n <span>=</span> cap <span>-</span> <span>1</span><span>;</span>
        n <span>|=</span> n <span>>>></span> <span>1</span><span>;</span>
        n <span>|=</span> n <span>>>></span> <span>2</span><span>;</span>
        n <span>|=</span> n <span>>>></span> <span>4</span><span>;</span>
        n <span>|=</span> n <span>>>></span> <span>8</span><span>;</span>
        n <span>|=</span> n <span>>>></span> <span>16</span><span>;</span>
        <span>return</span> <span>(</span>n <span>&lt;</span> <span>0</span><span>)</span> <span>?</span> <span>1</span> <span>:</span> <span>(</span>n <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>?</span> MAXIMUM_CAPACITY <span>:</span> n <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="hashmap-和-hashset-区别"> HashMap 和 HashSet 区别</h3>
<p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>HashMap</code></th>
<th style="text-align:center"><code>HashSet</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">实现了 <code>Map</code> 接口</td>
<td style="text-align:center">实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td style="text-align:center">存储键值对</td>
<td style="text-align:center">仅存储对象</td>
</tr>
<tr>
<td style="text-align:center">调用 <code>put()</code>向 map 中添加元素</td>
<td style="text-align:center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td style="text-align:center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td style="text-align:center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody>
</table>
<h3 id="hashmap-和-treemap-区别"> HashMap 和 TreeMap 区别</h3>
<p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<p><img src="./images/TreeMap继承结构.png" alt="" /></p>
<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p>
<div><pre><code><span>/**
 * @author shuang.kou
 * @createTime 2020年06月15日 17:02:00
 */</span>
<span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>Integer</span> age<span>;</span>

    <span>public</span> <span>Person</span><span>(</span><span>Integer</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>Integer</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>


    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span> treeMap <span>=</span> <span>new</span> <span>TreeMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>new</span> <span>Comparator</span><span><span>&lt;</span><span>Person</span><span>></span></span><span>(</span><span>)</span> <span>{</span>
            <span>@Override</span>
            <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>Person</span> person1<span>,</span> <span>Person</span> person2<span>)</span> <span>{</span>
                <span>int</span> num <span>=</span> person1<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>-</span> person2<span>.</span><span>getAge</span><span>(</span><span>)</span><span>;</span>
                <span>return</span> <span>Integer</span><span>.</span><span>compare</span><span>(</span>num<span>,</span> <span>0</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
        treeMap<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>3</span><span>)</span><span>,</span> <span>"person1"</span><span>)</span><span>;</span>
        treeMap<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>18</span><span>)</span><span>,</span> <span>"person2"</span><span>)</span><span>;</span>
        treeMap<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>35</span><span>)</span><span>,</span> <span>"person3"</span><span>)</span><span>;</span>
        treeMap<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>16</span><span>)</span><span>,</span> <span>"person4"</span><span>)</span><span>;</span>
        treeMap<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span>personStringEntry <span>-></span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>personStringEntry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>输出:</p>
<div><pre><code>person1
person4
person2
person3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可以看出，<code>TreeMap</code> 中的元素已经是按照 <code>Person</code> 的 age 字段的升序来排列了。</p>
<p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：</p>
<div><pre><code><span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span> treeMap <span>=</span> <span>new</span> <span>TreeMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>(</span>person1<span>,</span> person2<span>)</span> <span>-></span> <span>{</span>
  <span>int</span> num <span>=</span> person1<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>-</span> person2<span>.</span><span>getAge</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> <span>Integer</span><span>.</span><span>compare</span><span>(</span>num<span>,</span> <span>0</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h3 id="hashset-如何检查重复"> HashSet 如何检查重复</h3>
<p>以下内容摘自我的 Java 启蒙书《Head first java》第二版：</p>
<p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<p>在openjdk8中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code>HashSet</code>中的源码：</p>
<div><pre><code><span>// Returns: true if this set did not already contain the specified element</span>
<span>// 返回值：当set中没有包含add的元素时返回真</span>
<span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
        <span>return</span> map<span>.</span><span>put</span><span>(</span>e<span>,</span> PRESENT<span>)</span><span>==</span><span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>而在<code>HashMap</code>的<code>putVal()</code>方法中也能看到如下说明：</p>
<div><pre><code><span>// Returns : previous value, or null if none</span>
<span>// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span>
<span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>
                   <span>boolean</span> evict<span>)</span> <span>{</span>
<span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>也就是说，在openjdk8中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p>
<p><strong><code>hashCode()</code>与 <code>equals()</code> 的相关规定：</strong></p>
<ol>
<li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li>
<li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li>
<li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li>
<li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li>
<li><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<p><strong>==与 equals 的区别</strong></p>
<p>对于基本类型来说，== 比较的是值是否相等；</p>
<p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</p>
<p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p>
<h3 id="hashmap-的底层实现"> HashMap 的底层实现</h3>
<h4 id="jdk1-8-之前"> JDK1.8 之前</h4>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<div><pre><code>    <span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
      <span>int</span> h<span>;</span>
      <span>// key.hashCode()：返回散列值也就是hashcode</span>
      <span>// ^ ：按位异或</span>
      <span>// >>>:无符号右移，忽略符号位，空位都以0补齐</span>
      <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>
  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<div><pre><code><span>static</span> <span>int</span> <span>hash</span><span>(</span><span>int</span> h<span>)</span> <span>{</span>
    <span>// This function ensures that hashCodes that differ only by</span>
    <span>// constant multiples at each bit position have a bounded</span>
    <span>// number of collisions (approximately 8 at default load factor).</span>

    h <span>^=</span> <span>(</span>h <span>>>></span> <span>20</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>12</span><span>)</span><span>;</span>
    <span>return</span> h <span>^</span> <span>(</span>h <span>>>></span> <span>7</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>4</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="./images/jdk1.8之前的内部结构-HashMap.png" alt="jdk1.8之前的内部结构-HashMap" /></p>
<h4 id="jdk1-8-之后"> JDK1.8 之后</h4>
<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="./images/jdk1.8之后的内部结构-HashMap.png" alt="jdk1.8之后的内部结构-HashMap" /></p>
<blockquote>
<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
</blockquote>
<h3 id="hashmap-的长度为什么是-2-的幂次方"> HashMap 的长度为什么是 2 的幂次方</h3>
<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<p><strong>这个算法应该如何设计呢？</strong></p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p>
<h3 id="hashmap-多线程操作导致死循环问题"> HashMap 多线程操作导致死循环问题</h3>
<p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener noreferrer">https://coolshell.cn/articles/9606.html</a></p>
<h3 id="hashmap-有哪几种常见的遍历方式"> HashMap 有哪几种常见的遍历方式?</h3>
<p><a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw" target="_blank" rel="noopener noreferrer">HashMap 的 7 种遍历方式与性能分析！</a></p>
<h3 id="concurrenthashmap-和-hashtable-的区别"> ConcurrentHashMap 和 Hashtable 的区别</h3>
<p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<p><strong>两者的对比图：</strong></p>
<p><strong>Hashtable:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HashTable全表锁.png" alt="Hashtable全表锁" /></p>
<p style="text-align:right;font-size:13px;color:gray">https://www.cnblogs.com/chengxiao/p/6842045.html></p>
<p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ConcurrentHashMap分段锁.jpg" alt="JDK1.7的ConcurrentHashMap" /></p>
<p style="text-align:right;font-size:13px;color:gray">https://www.cnblogs.com/chengxiao/p/6842045.html></p>
<p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p>
<p><img src="./images/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）" /></p>
<p>JDK1.8 的 <code>ConcurrentHashMap</code> 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong><code>TreeNode</code></strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<h3 id="concurrenthashmap-线程安全的具体实现方式-底层具体实现"> ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h3>
<h4 id="jdk1-7-上面有示意图"> JDK1.7（上面有示意图）</h4>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<div><pre><code><span>static</span> <span>class</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>ReentrantLock</span> <span>implements</span> <span>Serializable</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>
<h4 id="jdk1-8-上面有示意图"> JDK1.8 （上面有示意图）</h4>
<p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p>
<p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
<h2 id="collections-工具类"> Collections 工具类</h2>
<p>Collections 工具类常用方法:</p>
<ol>
<li>排序</li>
<li>查找,替换操作</li>
<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ol>
<h3 id="排序操作"> 排序操作</h3>
<div><pre><code><span>void</span> <span>reverse</span><span>(</span><span>List</span> list<span>)</span><span>//反转</span>
<span>void</span> <span>shuffle</span><span>(</span><span>List</span> list<span>)</span><span>//随机排序</span>
<span>void</span> <span>sort</span><span>(</span><span>List</span> list<span>)</span><span>//按自然排序的升序排序</span>
<span>void</span> <span>sort</span><span>(</span><span>List</span> list<span>,</span> <span>Comparator</span> c<span>)</span><span>//定制排序，由Comparator控制排序逻辑</span>
<span>void</span> <span>swap</span><span>(</span><span>List</span> list<span>,</span> <span>int</span> i <span>,</span> <span>int</span> j<span>)</span><span>//交换两个索引位置的元素</span>
<span>void</span> <span>rotate</span><span>(</span><span>List</span> list<span>,</span> <span>int</span> distance<span>)</span><span>//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="查找-替换操作"> 查找,替换操作</h3>
<div><pre><code><span>int</span> <span>binarySearch</span><span>(</span><span>List</span> list<span>,</span> <span>Object</span> key<span>)</span><span>//对List进行二分查找，返回索引，注意List必须是有序的</span>
<span>int</span> <span>max</span><span>(</span><span>Collection</span> coll<span>)</span><span>//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span>
<span>int</span> <span>max</span><span>(</span><span>Collection</span> coll<span>,</span> <span>Comparator</span> c<span>)</span><span>//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span>
<span>void</span> <span>fill</span><span>(</span><span>List</span> list<span>,</span> <span>Object</span> obj<span>)</span><span>//用指定的元素代替指定list中的所有元素</span>
<span>int</span> <span>frequency</span><span>(</span><span>Collection</span> c<span>,</span> <span>Object</span> o<span>)</span><span>//统计元素出现次数</span>
<span>int</span> <span>indexOfSubList</span><span>(</span><span>List</span> list<span>,</span> <span>List</span> target<span>)</span><span>//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span>
<span>boolean</span> <span>replaceAll</span><span>(</span><span>List</span> list<span>,</span> <span>Object</span> oldVal<span>,</span> <span>Object</span> newVal<span>)</span><span>//用新元素替换旧元素</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="同步控制"> 同步控制</h3>
<p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p>
<p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p>
<p>方法如下：</p>
<div><pre><code><span>synchronizedCollection</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>T</span><span>></span></span>  c<span>)</span> <span>//返回指定 collection 支持的同步（线程安全的）collection。</span>
<span>synchronizedList</span><span>(</span><span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> list<span>)</span><span>//返回指定列表支持的同步（线程安全的）List。</span>
<span>synchronizedMap</span><span>(</span><span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> m<span>)</span> <span>//返回由指定映射支持的同步（线程安全的）Map。</span>
<span>synchronizedSet</span><span>(</span><span>Set</span><span><span>&lt;</span><span>T</span><span>></span></span> s<span>)</span> <span>//返回指定 set 支持的同步（线程安全的）set。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Atomic 原子类总结</title>
      <link>https://javaguide.cn/java/concurrent/atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/java/concurrent/atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">Atomic 原子类总结</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="atomic-原子类介绍"> Atomic 原子类介绍</h2>
<p>Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p>
<p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下,如下图所示。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JUC原子类概览.png" alt="JUC原子类概览" /></p>
<p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类</p>
<p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean ：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicIntegerArray：整型数组原子类</li>
<li>AtomicLongArray：长整型数组原子类</li>
<li>AtomicReferenceArray ：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，<s>也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</s></li>
<li>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li>AtomicIntegerFieldUpdater:原子更新整型字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li>
</ul>
<blockquote>
<p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/626" target="_blank" rel="noopener noreferrer">issue#626</a>）</strong> : <code>AtomicMarkableReference</code> 不能解决 ABA 问题。</p>
</blockquote>
<div><pre><code>    <span>/**

AtomicMarkableReference是将一个boolean值作是否有更改的标记，本质就是它的版本号只有两个，true和false，

修改的时候在这两个版本号之间来回切换，这样做并不能解决ABA的问题，只是会降低ABA问题发生的几率而已

@author : mazh

@Date : 2020/1/17 14:41
*/</span>

<span>public</span> <span>class</span> <span>SolveABAByAtomicMarkableReference</span> <span>{</span>

       <span>private</span> <span>static</span> <span>AtomicMarkableReference</span> atomicMarkableReference <span>=</span> <span>new</span> <span>AtomicMarkableReference</span><span>(</span><span>100</span><span>,</span> <span>false</span><span>)</span><span>;</span>

        <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

            <span>Thread</span> refT1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
                <span>try</span> <span>{</span>
                    <span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                atomicMarkableReference<span>.</span><span>compareAndSet</span><span>(</span><span>100</span><span>,</span> <span>101</span><span>,</span> atomicMarkableReference<span>.</span><span>isMarked</span><span>(</span><span>)</span><span>,</span> <span>!</span>atomicMarkableReference<span>.</span><span>isMarked</span><span>(</span><span>)</span><span>)</span><span>;</span>
                atomicMarkableReference<span>.</span><span>compareAndSet</span><span>(</span><span>101</span><span>,</span> <span>100</span><span>,</span> atomicMarkableReference<span>.</span><span>isMarked</span><span>(</span><span>)</span><span>,</span> <span>!</span>atomicMarkableReference<span>.</span><span>isMarked</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span><span>)</span><span>;</span>

            <span>Thread</span> refT2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
                <span>boolean</span> marked <span>=</span> atomicMarkableReference<span>.</span><span>isMarked</span><span>(</span><span>)</span><span>;</span>
                <span>try</span> <span>{</span>
                    <span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>sleep</span><span>(</span><span>2</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                <span>boolean</span> c3 <span>=</span> atomicMarkableReference<span>.</span><span>compareAndSet</span><span>(</span><span>100</span><span>,</span> <span>101</span><span>,</span> marked<span>,</span> <span>!</span>marked<span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c3<span>)</span><span>;</span> <span>// 返回true,实际应该返回false</span>
            <span>}</span><span>)</span><span>;</span>

            refT1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
            refT2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p><strong>CAS ABA 问题</strong></p>
<ul>
<li>描述: 第一个线程取到了变量 x 的值 A，然后巴拉巴拉干别的事，总之就是只拿到了变量 x 的值 A。这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为 B，然后巴拉巴拉干别的事，最后又把变量 x 的值变为 A （相当于还原了）。在这之后第一个线程终于进行了变量 x 的操作，但是此时变量 x 的值还是 A，所以 compareAndSet 操作是成功。</li>
<li>例子描述(可能不太合适，但好理解): 年初，现金为零，然后通过正常劳动赚了三百万，之后正常消费了（比如买房子）三百万。年末，虽然现金零收入（可能变成其他形式了），但是赚了钱是事实，还是得交税的！</li>
<li>代码例子（以<code>AtomicInteger</code>为例）</li>
</ul>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>atomic<span>.</span></span><span>AtomicInteger</span><span>;</span>

<span>public</span> <span>class</span> <span>AtomicIntegerDefectDemo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>defectOfABA</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>static</span> <span>void</span> <span>defectOfABA</span><span>(</span><span>)</span> <span>{</span>
        <span>final</span> <span>AtomicInteger</span> atomicInteger <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>1</span><span>)</span><span>;</span>

        <span>Thread</span> coreThread <span>=</span> <span>new</span> <span>Thread</span><span>(</span>
                <span>(</span><span>)</span> <span>-></span> <span>{</span>
                    <span>final</span> <span>int</span> currentValue <span>=</span> atomicInteger<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" ------ currentValue="</span> <span>+</span> currentValue<span>)</span><span>;</span>

                    <span>// 这段目的：模拟处理其他业务花费的时间</span>
                    <span>try</span> <span>{</span>
                        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>300</span><span>)</span><span>;</span>
                    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                    <span>}</span>

                    <span>boolean</span> casResult <span>=</span> atomicInteger<span>.</span><span>compareAndSet</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span>
                            <span>+</span> <span>" ------ currentValue="</span> <span>+</span> currentValue
                            <span>+</span> <span>", finalValue="</span> <span>+</span> atomicInteger<span>.</span><span>get</span><span>(</span><span>)</span>
                            <span>+</span> <span>", compareAndSet Result="</span> <span>+</span> casResult<span>)</span><span>;</span>
                <span>}</span>
        <span>)</span><span>;</span>
        coreThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>

        <span>// 这段目的：为了让 coreThread 线程先跑起来</span>
        <span>try</span> <span>{</span>
            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>100</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

        <span>Thread</span> amateurThread <span>=</span> <span>new</span> <span>Thread</span><span>(</span>
                <span>(</span><span>)</span> <span>-></span> <span>{</span>
                    <span>int</span> currentValue <span>=</span> atomicInteger<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
                    <span>boolean</span> casResult <span>=</span> atomicInteger<span>.</span><span>compareAndSet</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span>
                            <span>+</span> <span>" ------ currentValue="</span> <span>+</span> currentValue
                            <span>+</span> <span>", finalValue="</span> <span>+</span> atomicInteger<span>.</span><span>get</span><span>(</span><span>)</span>
                            <span>+</span> <span>", compareAndSet Result="</span> <span>+</span> casResult<span>)</span><span>;</span>

                    currentValue <span>=</span> atomicInteger<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
                    casResult <span>=</span> atomicInteger<span>.</span><span>compareAndSet</span><span>(</span><span>2</span><span>,</span> <span>1</span><span>)</span><span>;</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span>
                            <span>+</span> <span>" ------ currentValue="</span> <span>+</span> currentValue
                            <span>+</span> <span>", finalValue="</span> <span>+</span> atomicInteger<span>.</span><span>get</span><span>(</span><span>)</span>
                            <span>+</span> <span>", compareAndSet Result="</span> <span>+</span> casResult<span>)</span><span>;</span>
                <span>}</span>
        <span>)</span><span>;</span>
        amateurThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><p>输出内容如下：</p>
<div><pre><code>Thread-0 ------ currentValue=1
Thread-1 ------ currentValue=1, finalValue=2, compareAndSet Result=true
Thread-1 ------ currentValue=2, finalValue=1, compareAndSet Result=true
Thread-0 ------ currentValue=1, finalValue=2, compareAndSet Result=true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>下面我们来详细介绍一下这些原子类。</p>
<h2 id="基本类型原子类"> 基本类型原子类</h2>
<h3 id="基本类型原子类介绍"> 基本类型原子类介绍</h3>
<p>使用原子的方式更新基本类型</p>
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean ：布尔型原子类</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicInteger 为例子来介绍。</p>
<p><strong>AtomicInteger 类常用方法</strong></p>
<div><pre><code><span>public</span> <span>final</span> <span>int</span> <span>get</span><span>(</span><span>)</span> <span>//获取当前的值</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndSet</span><span>(</span><span>int</span> newValue<span>)</span><span>//获取当前的值，并设置新的值</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndIncrement</span><span>(</span><span>)</span><span>//获取当前的值，并自增</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndDecrement</span><span>(</span><span>)</span> <span>//获取当前的值，并自减</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndAdd</span><span>(</span><span>int</span> delta<span>)</span> <span>//获取当前的值，并加上预期的值</span>
<span>boolean</span> <span>compareAndSet</span><span>(</span><span>int</span> expect<span>,</span> <span>int</span> update<span>)</span> <span>//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span>
<span>public</span> <span>final</span> <span>void</span> <span>lazySet</span><span>(</span><span>int</span> newValue<span>)</span><span>//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="atomicinteger-常见方法使用"> AtomicInteger 常见方法使用</h3>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>atomic<span>.</span></span><span>AtomicInteger</span><span>;</span>

<span>public</span> <span>class</span> <span>AtomicIntegerTest</span> <span>{</span>

	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>// TODO Auto-generated method stub</span>
		<span>int</span> temvalue <span>=</span> <span>0</span><span>;</span>
		<span>AtomicInteger</span> i <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>0</span><span>)</span><span>;</span>
		temvalue <span>=</span> i<span>.</span><span>getAndSet</span><span>(</span><span>3</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"temvalue:"</span> <span>+</span> temvalue <span>+</span> <span>";  i:"</span> <span>+</span> i<span>)</span><span>;</span><span>//temvalue:0;  i:3</span>
		temvalue <span>=</span> i<span>.</span><span>getAndIncrement</span><span>(</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"temvalue:"</span> <span>+</span> temvalue <span>+</span> <span>";  i:"</span> <span>+</span> i<span>)</span><span>;</span><span>//temvalue:3;  i:4</span>
		temvalue <span>=</span> i<span>.</span><span>getAndAdd</span><span>(</span><span>5</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"temvalue:"</span> <span>+</span> temvalue <span>+</span> <span>";  i:"</span> <span>+</span> i<span>)</span><span>;</span><span>//temvalue:4;  i:9</span>
	<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="基本数据类型原子类的优势"> 基本数据类型原子类的优势</h3>
<p>通过一个简单例子带大家看一下基本数据类型原子类的优势</p>
<p><strong>① 多线程环境不使用原子类保证线程安全（基本数据类型）</strong></p>
<div><pre><code><span>class</span> <span>Test</span> <span>{</span>
        <span>private</span> <span>volatile</span> <span>int</span> count <span>=</span> <span>0</span><span>;</span>
        <span>//若要线程安全执行执行count++，需要加锁</span>
        <span>public</span> <span>synchronized</span> <span>void</span> <span>increment</span><span>(</span><span>)</span> <span>{</span>
                  count<span>++</span><span>;</span>
        <span>}</span>

        <span>public</span> <span>int</span> <span>getCount</span><span>(</span><span>)</span> <span>{</span>
                  <span>return</span> count<span>;</span>
        <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>② 多线程环境使用原子类保证线程安全（基本数据类型）</strong></p>
<div><pre><code><span>class</span> <span>Test2</span> <span>{</span>
        <span>private</span> <span>AtomicInteger</span> count <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>

        <span>public</span> <span>void</span> <span>increment</span><span>(</span><span>)</span> <span>{</span>
                  count<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
      <span>//使用AtomicInteger之后，不需要加锁，也可以实现线程安全。</span>
       <span>public</span> <span>int</span> <span>getCount</span><span>(</span><span>)</span> <span>{</span>
                <span>return</span> count<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="atomicinteger-线程安全原理简单分析"> AtomicInteger 线程安全原理简单分析</h3>
<p>AtomicInteger 类的部分源码：</p>
<div><pre><code>    <span>// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Unsafe</span> unsafe <span>=</span> <span>Unsafe</span><span>.</span><span>getUnsafe</span><span>(</span><span>)</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> valueOffset<span>;</span>

    <span>static</span> <span>{</span>
        <span>try</span> <span>{</span>
            valueOffset <span>=</span> unsafe<span>.</span>objectFieldOffset
                <span>(</span><span>AtomicInteger</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"value"</span><span>)</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> ex<span>)</span> <span>{</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span>ex<span>)</span><span>;</span> <span>}</span>
    <span>}</span>

    <span>private</span> <span>volatile</span> <span>int</span> value<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h2 id="数组类型原子类"> 数组类型原子类</h2>
<h3 id="数组类型原子类介绍"> 数组类型原子类介绍</h3>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray ：引用类型数组原子类</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例子来介绍。</p>
<p><strong>AtomicIntegerArray 类常用方法</strong></p>
<div><pre><code><span>public</span> <span>final</span> <span>int</span> <span>get</span><span>(</span><span>int</span> i<span>)</span> <span>//获取 index=i 位置元素的值</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndSet</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> newValue<span>)</span><span>//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndIncrement</span><span>(</span><span>int</span> i<span>)</span><span>//获取 index=i 位置元素的值，并让该位置的元素自增</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndDecrement</span><span>(</span><span>int</span> i<span>)</span> <span>//获取 index=i 位置元素的值，并让该位置的元素自减</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndAdd</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> delta<span>)</span> <span>//获取 index=i 位置元素的值，并加上预期的值</span>
<span>boolean</span> <span>compareAndSet</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> expect<span>,</span> <span>int</span> update<span>)</span> <span>//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span>
<span>public</span> <span>final</span> <span>void</span> <span>lazySet</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> newValue<span>)</span><span>//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="atomicintegerarray-常见方法使用"> AtomicIntegerArray 常见方法使用</h3>
<div><pre><code>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>atomic<span>.</span></span><span>AtomicIntegerArray</span><span>;</span>

<span>public</span> <span>class</span> <span>AtomicIntegerArrayTest</span> <span>{</span>

	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>// TODO Auto-generated method stub</span>
		<span>int</span> temvalue <span>=</span> <span>0</span><span>;</span>
		<span>int</span><span>[</span><span>]</span> nums <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span> <span>}</span><span>;</span>
		<span>AtomicIntegerArray</span> i <span>=</span> <span>new</span> <span>AtomicIntegerArray</span><span>(</span>nums<span>)</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> nums<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>.</span><span>get</span><span>(</span>j<span>)</span><span>)</span><span>;</span>
		<span>}</span>
		temvalue <span>=</span> i<span>.</span><span>getAndSet</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"temvalue:"</span> <span>+</span> temvalue <span>+</span> <span>";  i:"</span> <span>+</span> i<span>)</span><span>;</span>
		temvalue <span>=</span> i<span>.</span><span>getAndIncrement</span><span>(</span><span>0</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"temvalue:"</span> <span>+</span> temvalue <span>+</span> <span>";  i:"</span> <span>+</span> i<span>)</span><span>;</span>
		temvalue <span>=</span> i<span>.</span><span>getAndAdd</span><span>(</span><span>0</span><span>,</span> <span>5</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"temvalue:"</span> <span>+</span> temvalue <span>+</span> <span>";  i:"</span> <span>+</span> i<span>)</span><span>;</span>
	<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="引用类型原子类"> 引用类型原子类</h2>
<h3 id="引用类型原子类介绍"> 引用类型原子类介绍</h3>
<p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。</p>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li>AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，<s>也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</s></li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicReference 为例子来介绍。</p>
<h3 id="atomicreference-类使用示例"> AtomicReference 类使用示例</h3>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>atomic<span>.</span></span><span>AtomicReference</span><span>;</span>

<span>public</span> <span>class</span> <span>AtomicReferenceTest</span> <span>{</span>

	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>AtomicReference</span><span><span>&lt;</span><span>Person</span><span>></span></span> ar <span>=</span> <span>new</span> <span>AtomicReference</span><span><span>&lt;</span><span>Person</span><span>></span></span><span>(</span><span>)</span><span>;</span>
		<span>Person</span> person <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"SnailClimb"</span><span>,</span> <span>22</span><span>)</span><span>;</span>
		ar<span>.</span><span>set</span><span>(</span>person<span>)</span><span>;</span>
		<span>Person</span> updatePerson <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"Daisy"</span><span>,</span> <span>20</span><span>)</span><span>;</span>
		ar<span>.</span><span>compareAndSet</span><span>(</span>person<span>,</span> updatePerson<span>)</span><span>;</span>

		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ar<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ar<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>

<span>class</span> <span>Person</span> <span>{</span>
	<span>private</span> <span>String</span> name<span>;</span>
	<span>private</span> <span>int</span> age<span>;</span>

	<span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
		<span>super</span><span>(</span><span>)</span><span>;</span>
		<span>this</span><span>.</span>name <span>=</span> name<span>;</span>
		<span>this</span><span>.</span>age <span>=</span> age<span>;</span>
	<span>}</span>

	<span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
		<span>return</span> name<span>;</span>
	<span>}</span>

	<span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
		<span>this</span><span>.</span>name <span>=</span> name<span>;</span>
	<span>}</span>

	<span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
		<span>return</span> age<span>;</span>
	<span>}</span>

	<span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
		<span>this</span><span>.</span>age <span>=</span> age<span>;</span>
	<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>上述代码首先创建了一个 Person 对象，然后把 Person 对象设置进 AtomicReference 对象中，然后调用 compareAndSet 方法，该方法就是通过 CAS 操作设置 ar。如果 ar 的值为 person 的话，则将其设置为 updatePerson。实现原理与 AtomicInteger 类中的 compareAndSet 方法相同。运行上面的代码后的输出结果如下：</p>
<div><pre><code>Daisy
20
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="atomicstampedreference-类使用示例"> AtomicStampedReference 类使用示例</h3>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>atomic<span>.</span></span><span>AtomicStampedReference</span><span>;</span>

<span>public</span> <span>class</span> <span>AtomicStampedReferenceDemo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 实例化、取当前值和 stamp 值</span>
        <span>final</span> <span>Integer</span> initialRef <span>=</span> <span>0</span><span>,</span> initialStamp <span>=</span> <span>0</span><span>;</span>
        <span>final</span> <span>AtomicStampedReference</span><span><span>&lt;</span><span>Integer</span><span>></span></span> asr <span>=</span> <span>new</span> <span>AtomicStampedReference</span><span><span>&lt;</span><span>></span></span><span>(</span>initialRef<span>,</span> initialStamp<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"currentValue="</span> <span>+</span> asr<span>.</span><span>getReference</span><span>(</span><span>)</span> <span>+</span> <span>", currentStamp="</span> <span>+</span> asr<span>.</span><span>getStamp</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// compare and set</span>
        <span>final</span> <span>Integer</span> newReference <span>=</span> <span>666</span><span>,</span> newStamp <span>=</span> <span>999</span><span>;</span>
        <span>final</span> <span>boolean</span> casResult <span>=</span> asr<span>.</span><span>compareAndSet</span><span>(</span>initialRef<span>,</span> newReference<span>,</span> initialStamp<span>,</span> newStamp<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"currentValue="</span> <span>+</span> asr<span>.</span><span>getReference</span><span>(</span><span>)</span>
                <span>+</span> <span>", currentStamp="</span> <span>+</span> asr<span>.</span><span>getStamp</span><span>(</span><span>)</span>
                <span>+</span> <span>", casResult="</span> <span>+</span> casResult<span>)</span><span>;</span>

        <span>// 获取当前的值和当前的 stamp 值</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>1</span><span>]</span><span>;</span>
        <span>final</span> <span>Integer</span> currentValue <span>=</span> asr<span>.</span><span>get</span><span>(</span>arr<span>)</span><span>;</span>
        <span>final</span> <span>int</span> currentStamp <span>=</span> arr<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"currentValue="</span> <span>+</span> currentValue <span>+</span> <span>", currentStamp="</span> <span>+</span> currentStamp<span>)</span><span>;</span>

        <span>// 单独设置 stamp 值</span>
        <span>final</span> <span>boolean</span> attemptStampResult <span>=</span> asr<span>.</span><span>attemptStamp</span><span>(</span>newReference<span>,</span> <span>88</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"currentValue="</span> <span>+</span> asr<span>.</span><span>getReference</span><span>(</span><span>)</span>
                <span>+</span> <span>", currentStamp="</span> <span>+</span> asr<span>.</span><span>getStamp</span><span>(</span><span>)</span>
                <span>+</span> <span>", attemptStampResult="</span> <span>+</span> attemptStampResult<span>)</span><span>;</span>

        <span>// 重新设置当前值和 stamp 值</span>
        asr<span>.</span><span>set</span><span>(</span>initialRef<span>,</span> initialStamp<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"currentValue="</span> <span>+</span> asr<span>.</span><span>getReference</span><span>(</span><span>)</span> <span>+</span> <span>", currentStamp="</span> <span>+</span> asr<span>.</span><span>getStamp</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span>
        <span>// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span>
        <span>// 但是注释上写着 "May fail spuriously and does not provide ordering guarantees,</span>
        <span>// so is only rarely an appropriate alternative to compareAndSet."</span>
        <span>// todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span>
        <span>final</span> <span>boolean</span> wCasResult <span>=</span> asr<span>.</span><span>weakCompareAndSet</span><span>(</span>initialRef<span>,</span> newReference<span>,</span> initialStamp<span>,</span> newStamp<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"currentValue="</span> <span>+</span> asr<span>.</span><span>getReference</span><span>(</span><span>)</span>
                <span>+</span> <span>", currentStamp="</span> <span>+</span> asr<span>.</span><span>getStamp</span><span>(</span><span>)</span>
                <span>+</span> <span>", wCasResult="</span> <span>+</span> wCasResult<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>输出结果如下：</p>
<div><pre><code>currentValue=0, currentStamp=0
currentValue=666, currentStamp=999, casResult=true
currentValue=666, currentStamp=999
currentValue=666, currentStamp=88, attemptStampResult=true
currentValue=0, currentStamp=0
currentValue=666, currentStamp=999, wCasResult=true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="atomicmarkablereference-类使用示例"> AtomicMarkableReference 类使用示例</h3>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>atomic<span>.</span></span><span>AtomicMarkableReference</span><span>;</span>

<span>public</span> <span>class</span> <span>AtomicMarkableReferenceDemo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 实例化、取当前值和 mark 值</span>
        <span>final</span> <span>Boolean</span> initialRef <span>=</span> <span>null</span><span>,</span> initialMark <span>=</span> <span>false</span><span>;</span>
        <span>final</span> <span>AtomicMarkableReference</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> amr <span>=</span> <span>new</span> <span>AtomicMarkableReference</span><span><span>&lt;</span><span>></span></span><span>(</span>initialRef<span>,</span> initialMark<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"currentValue="</span> <span>+</span> amr<span>.</span><span>getReference</span><span>(</span><span>)</span> <span>+</span> <span>", currentMark="</span> <span>+</span> amr<span>.</span><span>isMarked</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// compare and set</span>
        <span>final</span> <span>Boolean</span> newReference1 <span>=</span> <span>true</span><span>,</span> newMark1 <span>=</span> <span>true</span><span>;</span>
        <span>final</span> <span>boolean</span> casResult <span>=</span> amr<span>.</span><span>compareAndSet</span><span>(</span>initialRef<span>,</span> newReference1<span>,</span> initialMark<span>,</span> newMark1<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"currentValue="</span> <span>+</span> amr<span>.</span><span>getReference</span><span>(</span><span>)</span>
                <span>+</span> <span>", currentMark="</span> <span>+</span> amr<span>.</span><span>isMarked</span><span>(</span><span>)</span>
                <span>+</span> <span>", casResult="</span> <span>+</span> casResult<span>)</span><span>;</span>

        <span>// 获取当前的值和当前的 mark 值</span>
        <span>boolean</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>boolean</span><span>[</span><span>1</span><span>]</span><span>;</span>
        <span>final</span> <span>Boolean</span> currentValue <span>=</span> amr<span>.</span><span>get</span><span>(</span>arr<span>)</span><span>;</span>
        <span>final</span> <span>boolean</span> currentMark <span>=</span> arr<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"currentValue="</span> <span>+</span> currentValue <span>+</span> <span>", currentMark="</span> <span>+</span> currentMark<span>)</span><span>;</span>

        <span>// 单独设置 mark 值</span>
        <span>final</span> <span>boolean</span> attemptMarkResult <span>=</span> amr<span>.</span><span>attemptMark</span><span>(</span>newReference1<span>,</span> <span>false</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"currentValue="</span> <span>+</span> amr<span>.</span><span>getReference</span><span>(</span><span>)</span>
                <span>+</span> <span>", currentMark="</span> <span>+</span> amr<span>.</span><span>isMarked</span><span>(</span><span>)</span>
                <span>+</span> <span>", attemptMarkResult="</span> <span>+</span> attemptMarkResult<span>)</span><span>;</span>

        <span>// 重新设置当前值和 mark 值</span>
        amr<span>.</span><span>set</span><span>(</span>initialRef<span>,</span> initialMark<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"currentValue="</span> <span>+</span> amr<span>.</span><span>getReference</span><span>(</span><span>)</span> <span>+</span> <span>", currentMark="</span> <span>+</span> amr<span>.</span><span>isMarked</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span>
        <span>// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span>
        <span>// 但是注释上写着 "May fail spuriously and does not provide ordering guarantees,</span>
        <span>// so is only rarely an appropriate alternative to compareAndSet."</span>
        <span>// todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span>
        <span>final</span> <span>boolean</span> wCasResult <span>=</span> amr<span>.</span><span>weakCompareAndSet</span><span>(</span>initialRef<span>,</span> newReference1<span>,</span> initialMark<span>,</span> newMark1<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"currentValue="</span> <span>+</span> amr<span>.</span><span>getReference</span><span>(</span><span>)</span>
                <span>+</span> <span>", currentMark="</span> <span>+</span> amr<span>.</span><span>isMarked</span><span>(</span><span>)</span>
                <span>+</span> <span>", wCasResult="</span> <span>+</span> wCasResult<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>输出结果如下：</p>
<div><pre><code>currentValue=null, currentMark=false
currentValue=true, currentMark=true, casResult=true
currentValue=true, currentMark=true
currentValue=true, currentMark=false, attemptMarkResult=true
currentValue=null, currentMark=false
currentValue=true, currentMark=true, wCasResult=true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="对象的属性修改类型原子类"> 对象的属性修改类型原子类</h2>
<h3 id="对象的属性修改类型原子类介绍"> 对象的属性修改类型原子类介绍</h3>
<p>如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</p>
<ul>
<li>AtomicIntegerFieldUpdater:原子更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li>
<li>AtomicReferenceFieldUpdater ：原子更新引用类型里的字段的更新器</li>
</ul>
<p>要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。</p>
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerFieldUpdater</code>为例子来介绍。</p>
<h3 id="atomicintegerfieldupdater-类使用示例"> AtomicIntegerFieldUpdater 类使用示例</h3>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>atomic<span>.</span></span><span>AtomicIntegerFieldUpdater</span><span>;</span>

<span>public</span> <span>class</span> <span>AtomicIntegerFieldUpdaterTest</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>AtomicIntegerFieldUpdater</span><span><span>&lt;</span><span>User</span><span>></span></span> a <span>=</span> <span>AtomicIntegerFieldUpdater</span><span>.</span><span>newUpdater</span><span>(</span><span>User</span><span>.</span><span>class</span><span>,</span> <span>"age"</span><span>)</span><span>;</span>

		<span>User</span> user <span>=</span> <span>new</span> <span>User</span><span>(</span><span>"Java"</span><span>,</span> <span>22</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>getAndIncrement</span><span>(</span>user<span>)</span><span>)</span><span>;</span><span>// 22</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>get</span><span>(</span>user<span>)</span><span>)</span><span>;</span><span>// 23</span>
	<span>}</span>
<span>}</span>

<span>class</span> <span>User</span> <span>{</span>
	<span>private</span> <span>String</span> name<span>;</span>
	<span>public</span> <span>volatile</span> <span>int</span> age<span>;</span>

	<span>public</span> <span>User</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
		<span>super</span><span>(</span><span>)</span><span>;</span>
		<span>this</span><span>.</span>name <span>=</span> name<span>;</span>
		<span>this</span><span>.</span>age <span>=</span> age<span>;</span>
	<span>}</span>

	<span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
		<span>return</span> name<span>;</span>
	<span>}</span>

	<span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
		<span>this</span><span>.</span>name <span>=</span> name<span>;</span>
	<span>}</span>

	<span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
		<span>return</span> age<span>;</span>
	<span>}</span>

	<span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
		<span>this</span><span>.</span>age <span>=</span> age<span>;</span>
	<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>输出结果：</p>
<div><pre><code>22
23
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="reference"> Reference</h2>
<ul>
<li>《Java 并发编程的艺术》</li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JUC原子类概览.png" type="image/png"/>
    </item>
    <item>
      <title>AQS 原理以及 AQS 同步组件总结</title>
      <link>https://javaguide.cn/java/concurrent/aqs%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8Aaqs%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/java/concurrent/aqs%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8Aaqs%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">AQS 原理以及 AQS 同步组件总结</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>开始之前，先来看几道常见的面试题！建议你带着这些问题来看这篇文章：</p>
<ul>
<li>何为 AQS？AQS 原理了解吗？</li>
<li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 了解吗？两者的区别是什么？</li>
<li>用过 <code>Semaphore</code> 吗？应用场景了解吗？</li>
<li>......</li>
</ul>
<h2 id="aqs-简单介绍"> AQS 简单介绍</h2>
<p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java 程序员必备：并发知识系统总结/AQS.png" alt="enter image description here" /></p>
<p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractQueuedSynchronizer</span> <span>extends</span> <span>AbstractOwnableSynchronizer</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>AQS 为构建锁和同步器提供了一些通用功能的是实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code>(jdk1.7) 等等皆是基于 AQS 的。</p>
<h2 id="aqs-原理"> AQS 原理</h2>
<blockquote>
<p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p>
</blockquote>
<p>下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p>
<h3 id="aqs-原理概览"> AQS 原理概览</h3>
<p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>看个 AQS(<code>AbstractQueuedSynchronizer</code>)原理图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java 程序员必备：并发知识系统总结/CLH.png" alt="enter image description here" /></p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<div><pre><code><span>private</span> <span>volatile</span> <span>int</span> state<span>;</span><span>//共享变量，使用volatile修饰保证线程可见性</span>
</code></pre>
<div><span>1</span><br></div></div><p>状态信息通过 <code>protected</code> 类型的<code>getState()</code>，<code>setState()</code>，<code>compareAndSetState()</code> 进行操作</p>
<div><pre><code><span>//返回同步状态的当前值</span>
<span>protected</span> <span>final</span> <span>int</span> <span>getState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> state<span>;</span>
<span>}</span>
 <span>// 设置同步状态的值</span>
<span>protected</span> <span>final</span> <span>void</span> <span>setState</span><span>(</span><span>int</span> newState<span>)</span> <span>{</span>
        state <span>=</span> newState<span>;</span>
<span>}</span>
<span>//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span>
<span>protected</span> <span>final</span> <span>boolean</span> <span>compareAndSetState</span><span>(</span><span>int</span> expect<span>,</span> <span>int</span> update<span>)</span> <span>{</span>
        <span>return</span> unsafe<span>.</span><span>compareAndSwapInt</span><span>(</span><span>this</span><span>,</span> stateOffset<span>,</span> expect<span>,</span> update<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="aqs-对资源的共享方式"> AQS 对资源的共享方式</h3>
<p>AQS 定义两种资源共享方式</p>
<p><strong>1)Exclusive</strong>（独占）</p>
<p>只有一个线程能执行，如 <code>ReentrantLock</code>。又可分为公平锁和非公平锁，<code>ReentrantLock</code> 同时支持两种锁，下面以 <code>ReentrantLock</code> 对这两种锁的定义做介绍：</p>
<ul>
<li><strong>公平锁</strong> ：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li><strong>非公平锁</strong> ：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li>
</ul>
<blockquote>
<p>说明：下面这部分关于 <code>ReentrantLock</code> 源代码内容节选自：https://www.javadoop.com/post/AbstractQueuedSynchronizer-2 ，这是一篇很不错文章，推荐阅读。</p>
</blockquote>
<p><strong>下面来看 <code>ReentrantLock</code> 中相关的源代码：</strong></p>
<p><code>ReentrantLock</code> 默认采用非公平锁，因为考虑获得更好的性能，通过 <code>boolean</code> 来决定是否用公平锁（传入 true 用公平锁）。</p>
<div><pre><code><span>/** Synchronizer providing all implementation mechanics */</span>
<span>private</span> <span>final</span> <span>Sync</span> sync<span>;</span>
<span>public</span> <span>ReentrantLock</span><span>(</span><span>)</span> <span>{</span>
    <span>// 默认非公平锁</span>
    sync <span>=</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>public</span> <span>ReentrantLock</span><span>(</span><span>boolean</span> fair<span>)</span> <span>{</span>
    sync <span>=</span> fair <span>?</span> <span>new</span> <span>FairSync</span><span>(</span><span>)</span> <span>:</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>ReentrantLock</code> 中公平锁的 <code>lock</code> 方法</p>
<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>FairSync</span> <span>extends</span> <span>Sync</span> <span>{</span>
    <span>final</span> <span>void</span> <span>lock</span><span>(</span><span>)</span> <span>{</span>
        <span>acquire</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>// AbstractQueuedSynchronizer.acquire(int arg)</span>
    <span>public</span> <span>final</span> <span>void</span> <span>acquire</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span><span>tryAcquire</span><span>(</span>arg<span>)</span> <span>&amp;&amp;</span>
            <span>acquireQueued</span><span>(</span><span>addWaiter</span><span>(</span><span>Node</span><span>.</span>EXCLUSIVE<span>)</span><span>,</span> arg<span>)</span><span>)</span>
            <span>selfInterrupt</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>protected</span> <span>final</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>int</span> acquires<span>)</span> <span>{</span>
        <span>final</span> <span>Thread</span> current <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> c <span>=</span> <span>getState</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>c <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span>
            <span>if</span> <span>(</span><span>!</span><span>hasQueuedPredecessors</span><span>(</span><span>)</span> <span>&amp;&amp;</span>
                <span>compareAndSetState</span><span>(</span><span>0</span><span>,</span> acquires<span>)</span><span>)</span> <span>{</span>
                <span>setExclusiveOwnerThread</span><span>(</span>current<span>)</span><span>;</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span>current <span>==</span> <span>getExclusiveOwnerThread</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>int</span> nextc <span>=</span> c <span>+</span> acquires<span>;</span>
            <span>if</span> <span>(</span>nextc <span>&lt;</span> <span>0</span><span>)</span>
                <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>"Maximum lock count exceeded"</span><span>)</span><span>;</span>
            <span>setState</span><span>(</span>nextc<span>)</span><span>;</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>非公平锁的 <code>lock</code> 方法：</p>
<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>NonfairSync</span> <span>extends</span> <span>Sync</span> <span>{</span>
    <span>final</span> <span>void</span> <span>lock</span><span>(</span><span>)</span> <span>{</span>
        <span>// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span>
        <span>if</span> <span>(</span><span>compareAndSetState</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>)</span>
            <span>setExclusiveOwnerThread</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>else</span>
            <span>acquire</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>// AbstractQueuedSynchronizer.acquire(int arg)</span>
    <span>public</span> <span>final</span> <span>void</span> <span>acquire</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span><span>tryAcquire</span><span>(</span>arg<span>)</span> <span>&amp;&amp;</span>
            <span>acquireQueued</span><span>(</span><span>addWaiter</span><span>(</span><span>Node</span><span>.</span>EXCLUSIVE<span>)</span><span>,</span> arg<span>)</span><span>)</span>
            <span>selfInterrupt</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>protected</span> <span>final</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>int</span> acquires<span>)</span> <span>{</span>
        <span>return</span> <span>nonfairTryAcquire</span><span>(</span>acquires<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>/**
 * Performs non-fair tryLock.  tryAcquire is implemented in
 * subclasses, but both need nonfair try for trylock method.
 */</span>
<span>final</span> <span>boolean</span> <span>nonfairTryAcquire</span><span>(</span><span>int</span> acquires<span>)</span> <span>{</span>
    <span>final</span> <span>Thread</span> current <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> c <span>=</span> <span>getState</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>c <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>// 这里没有对阻塞队列进行判断</span>
        <span>if</span> <span>(</span><span>compareAndSetState</span><span>(</span><span>0</span><span>,</span> acquires<span>)</span><span>)</span> <span>{</span>
            <span>setExclusiveOwnerThread</span><span>(</span>current<span>)</span><span>;</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>else</span> <span>if</span> <span>(</span>current <span>==</span> <span>getExclusiveOwnerThread</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>int</span> nextc <span>=</span> c <span>+</span> acquires<span>;</span>
        <span>if</span> <span>(</span>nextc <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>
            <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>"Maximum lock count exceeded"</span><span>)</span><span>;</span>
        <span>setState</span><span>(</span>nextc<span>)</span><span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>总结：公平锁和非公平锁只有两处不同：</p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 <code>tryAcquire</code> 方法，在 <code>tryAcquire</code> 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<p><strong>2)Share</strong>（共享）</p>
<p>多个线程可同时执行，如 <code>Semaphore/CountDownLatch</code>。<code>Semaphore</code>、<code>CountDownLatCh</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 我们都会在后面讲到。</p>
<p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p>
<h3 id="aqs-底层使用了模板方法模式"> AQS 底层使用了模板方法模式</h3>
<p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。</p>
<blockquote>
<p>模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。</p>
<p>举个很简单的例子假如我们要去一个地方的步骤是：购票 <code>buyTicket()</code>-&gt;安检 <code>securityCheck()</code>-&gt;乘坐某某工具回家 <code>ride()</code> -&gt;到达目的地 <code>arrive()</code>。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了<code>ride()</code>方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 <code>ride()</code>方法。</p>
</blockquote>
<p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p>
<div><pre><code><span>isHeldExclusively</span><span>(</span><span>)</span><span>//该线程是否正在独占资源。只有用到condition才需要去实现它。</span>
<span>tryAcquire</span><span>(</span><span>int</span><span>)</span><span>//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span>
<span>tryRelease</span><span>(</span><span>int</span><span>)</span><span>//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span>tryAcquireShared</span><span>(</span><span>int</span><span>)</span><span>//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span>
<span>tryReleaseShared</span><span>(</span><span>int</span><span>)</span><span>//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以 <code>ReentrantLock</code> 为例，state 初始化为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code>独占该锁并将 state+1。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p>
<p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，state 也初始化为 N（也可以不初始化为 N，不初始化为 N,state 减到 0 也会从 await()返回）。这 N 个子线程是并行执行的，每个子线程执行完后 <code>countDown()</code> 一次，state 会 CAS(Compare and Swap)减 1。等到 <code>state=0</code>，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p>
<p>所以 <code>CountDownLatch</code> 可以做倒计数器，减到 0 后唤醒的线程可以对线程池进行处理，比如关闭线程池。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>
<ul>
<li><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener noreferrer">Java 并发之 AQS 详解</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/p/7141160.html" target="_blank" rel="noopener noreferrer">Java 并发包基石-AQS 详解</a></li>
</ul>
<h2 id="semaphore-信号量"> Semaphore(信号量)</h2>
<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</p>
<p>示例代码如下：</p>
<div><pre><code><span>/**
 *
 * @author Snailclimb
 * @date 2018年9月30日
 * @Description: 需要一次性拿一个许可的情况
 */</span>
<span>public</span> <span>class</span> <span>SemaphoreExample1</span> <span>{</span>
  <span>// 请求的数量</span>
  <span>private</span> <span>static</span> <span>final</span> <span>int</span> threadCount <span>=</span> <span>550</span><span>;</span>

  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span>
    <span>ExecutorService</span> threadPool <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>300</span><span>)</span><span>;</span>
    <span>// 一次只能允许执行的线程数量。</span>
    <span>final</span> <span>Semaphore</span> semaphore <span>=</span> <span>new</span> <span>Semaphore</span><span>(</span><span>20</span><span>)</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> threadCount<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>final</span> <span>int</span> threadnum <span>=</span> i<span>;</span>
      threadPool<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span><span>// Lambda 表达式的运用</span>
        <span>try</span> <span>{</span>
          semaphore<span>.</span><span>acquire</span><span>(</span><span>)</span><span>;</span><span>// 获取一个许可，所以可运行线程数量为20/1=20</span>
          <span>test</span><span>(</span>threadnum<span>)</span><span>;</span>
          semaphore<span>.</span><span>release</span><span>(</span><span>)</span><span>;</span><span>// 释放一个许可</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
          <span>// TODO Auto-generated catch block</span>
          e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

      <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    threadPool<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"finish"</span><span>)</span><span>;</span>
  <span>}</span>

  <span>public</span> <span>static</span> <span>void</span> <span>test</span><span>(</span><span>int</span> threadnum<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span><span>// 模拟请求的耗时操作</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"threadnum:"</span> <span>+</span> threadnum<span>)</span><span>;</span>
    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span><span>// 模拟请求的耗时操作</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>执行 <code>acquire()</code> 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 <code>release</code> 方法增加一个许可证，这可能会释放一个阻塞的 <code>acquire()</code> 方法。然而，其实并没有实际的许可证这个对象，<code>Semaphore</code> 只是维持了一个可获得许可证的数量。 <code>Semaphore</code> 经常用于限制获取某种资源的线程数量。</p>
<p>当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：</p>
<div><pre><code>semaphore<span>.</span><span>acquire</span><span>(</span><span>5</span><span>)</span><span>;</span><span>// 获取5个许可，所以可运行线程数量为20/5=4</span>
<span>test</span><span>(</span>threadnum<span>)</span><span>;</span>
semaphore<span>.</span><span>release</span><span>(</span><span>5</span><span>)</span><span>;</span><span>// 释放5个许可</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>除了 <code>acquire()</code> 方法之外，另一个比较常用的与之对应的方法是 <code>tryAcquire()</code> 方法，该方法如果获取不到许可就立即返回 false。</p>
<p><code>Semaphore</code> 有两种模式，公平模式和非公平模式。</p>
<ul>
<li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li>
<li><strong>非公平模式：</strong> 抢占式的。</li>
</ul>
<p><code>Semaphore</code> 对应的两个构造方法如下：</p>
<div><pre><code>   <span>public</span> <span>Semaphore</span><span>(</span><span>int</span> <span>permits</span><span>)</span> <span>{</span>
        sync <span>=</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>permits</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>Semaphore</span><span>(</span><span>int</span> <span>permits</span><span>,</span> <span>boolean</span> fair<span>)</span> <span>{</span>
        sync <span>=</span> fair <span>?</span> <span>new</span> <span>FairSync</span><span>(</span><span>permits</span><span>)</span> <span>:</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>permits</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/issues/645" target="_blank" rel="noopener noreferrer">issue645 补充内容</a> ：<code>Semaphore</code> 与 <code>CountDownLatch</code> 一样，也是共享锁的一种实现。它默认构造 AQS 的 state 为 <code>permits</code>。当执行任务的线程数量超出 <code>permits</code>，那么多余的线程将会被放入阻塞队列 Park,并自旋判断 state 是否大于 0。只有当 state 大于 0 的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行 <code>release()</code> 方法，<code>release()</code> 方法使得 state 的变量会加 1，那么自旋的线程便会判断成功。
如此，每次只有最多不超过 <code>permits</code> 数量的线程能自旋成功，便限制了执行任务线程的数量。</p>
<h2 id="countdownlatch-倒计时器"> CountDownLatch （倒计时器）</h2>
<p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。然后，<code>CountDownLatch</code> 会自旋 CAS 判断 <code>state == 0</code>，如果 <code>state == 0</code> 的话，就会释放所有等待的线程，<code>await()</code> 方法之后的语句得到执行。</p>
<h3 id="countdownlatch-的两种典型用法"> CountDownLatch 的两种典型用法</h3>
<p><strong>1、某一线程在开始运行前等待 n 个线程执行完毕。</strong></p>
<p>将 <code>CountDownLatch</code> 的计数器初始化为 n （<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减 1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在 <code>CountDownLatch 上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p>
<p><strong>2、实现多个线程开始执行任务的最大并行性。</strong></p>
<p>注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 （<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，多个线程同时被唤醒。</p>
<h3 id="countdownlatch-的使用示例"> CountDownLatch 的使用示例</h3>
<div><pre><code><span>/**
 *
 * @author SnailClimb
 * @date 2018年10月1日
 * @Description: CountDownLatch 使用方法示例
 */</span>
<span>public</span> <span>class</span> <span>CountDownLatchExample1</span> <span>{</span>
  <span>// 请求的数量</span>
  <span>private</span> <span>static</span> <span>final</span> <span>int</span> threadCount <span>=</span> <span>550</span><span>;</span>

  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span>
    <span>ExecutorService</span> threadPool <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>300</span><span>)</span><span>;</span>
    <span>final</span> <span>CountDownLatch</span> countDownLatch <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span>threadCount<span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> threadCount<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>final</span> <span>int</span> threadnum <span>=</span> i<span>;</span>
      threadPool<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span><span>// Lambda 表达式的运用</span>
        <span>try</span> <span>{</span>
          <span>test</span><span>(</span>threadnum<span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
          <span>// TODO Auto-generated catch block</span>
          e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>finally</span> <span>{</span>
          countDownLatch<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span><span>// 表示一个请求已经被完成</span>
        <span>}</span>

      <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    countDownLatch<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
    threadPool<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"finish"</span><span>)</span><span>;</span>
  <span>}</span>

  <span>public</span> <span>static</span> <span>void</span> <span>test</span><span>(</span><span>int</span> threadnum<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span><span>// 模拟请求的耗时操作</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"threadnum:"</span> <span>+</span> threadnum<span>)</span><span>;</span>
    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span><span>// 模拟请求的耗时操作</span>
  <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>上面的代码中，我们定义了请求的数量为 550，当这 550 个请求被处理完成之后，才会执行<code>System.out.println(&quot;finish&quot;);</code>。</p>
<p>与 <code>CountDownLatch</code> 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p>
<p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 <code>await()</code>方法，恢复执行自己的任务。</p>
<p>再插一嘴：<code>CountDownLatch</code> 的 <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p>
<div><pre><code><span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> threadCount<span>-</span><span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这样就导致 <code>count</code> 的值没办法等于 0，然后就会导致一直等待。</p>
<h3 id="countdownlatch-的不足"> CountDownLatch 的不足</h3>
<p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p>
<h3 id="countdownlatch-相常见面试题"> CountDownLatch 相常见面试题</h3>
<ul>
<li><code>CountDownLatch</code> 怎么用？应用场景是什么？</li>
<li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 的不同之处？</li>
<li><code>CountDownLatch</code> 类中主要的方法？</li>
</ul>
<h2 id="cyclicbarrier-循环栅栏"> CyclicBarrier(循环栅栏)</h2>
<p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p>
<blockquote>
<p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p>
</blockquote>
<p><code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<p><code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</p>
<p>再来看一下它的构造函数：</p>
<div><pre><code><span>public</span> <span>CyclicBarrier</span><span>(</span><span>int</span> parties<span>)</span> <span>{</span>
    <span>this</span><span>(</span>parties<span>,</span> <span>null</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>CyclicBarrier</span><span>(</span><span>int</span> parties<span>,</span> <span>Runnable</span> barrierAction<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>parties <span>&lt;=</span> <span>0</span><span>)</span> <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>
    <span>this</span><span>.</span>parties <span>=</span> parties<span>;</span>
    <span>this</span><span>.</span>count <span>=</span> parties<span>;</span>
    <span>this</span><span>.</span>barrierCommand <span>=</span> barrierAction<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p>
<h3 id="cyclicbarrier-的应用场景"> CyclicBarrier 的应用场景</h3>
<p><code>CyclicBarrier</code> 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p>
<h3 id="cyclicbarrier-的使用示例"> CyclicBarrier 的使用示例</h3>
<p>示例 1：</p>
<div><pre><code><span>/**
 *
 * @author Snailclimb
 * @date 2018年10月1日
 * @Description: 测试 CyclicBarrier 类中带参数的 await() 方法
 */</span>
<span>public</span> <span>class</span> <span>CyclicBarrierExample2</span> <span>{</span>
  <span>// 请求的数量</span>
  <span>private</span> <span>static</span> <span>final</span> <span>int</span> threadCount <span>=</span> <span>550</span><span>;</span>
  <span>// 需要同步的线程数量</span>
  <span>private</span> <span>static</span> <span>final</span> <span>CyclicBarrier</span> cyclicBarrier <span>=</span> <span>new</span> <span>CyclicBarrier</span><span>(</span><span>5</span><span>)</span><span>;</span>

  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>// 创建线程池</span>
    <span>ExecutorService</span> threadPool <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>10</span><span>)</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> threadCount<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>final</span> <span>int</span> threadNum <span>=</span> i<span>;</span>
      <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
      threadPool<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
        <span>try</span> <span>{</span>
          <span>test</span><span>(</span>threadNum<span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
          <span>// TODO Auto-generated catch block</span>
          e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>BrokenBarrierException</span> e<span>)</span> <span>{</span>
          <span>// TODO Auto-generated catch block</span>
          e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
      <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    threadPool<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>public</span> <span>static</span> <span>void</span> <span>test</span><span>(</span><span>int</span> threadnum<span>)</span> <span>throws</span> <span>InterruptedException</span><span>,</span> <span>BrokenBarrierException</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"threadnum:"</span> <span>+</span> threadnum <span>+</span> <span>"is ready"</span><span>)</span><span>;</span>
    <span>try</span> <span>{</span>
      <span>/**等待60秒，保证子线程完全执行结束*/</span>
      cyclicBarrier<span>.</span><span>await</span><span>(</span><span>60</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-----CyclicBarrierException------"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"threadnum:"</span> <span>+</span> threadnum <span>+</span> <span>"is finish"</span><span>)</span><span>;</span>
  <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>运行结果，如下：</p>
<div><pre><code>threadnum:0is ready
threadnum:1is ready
threadnum:2is ready
threadnum:3is ready
threadnum:4is ready
threadnum:4is finish
threadnum:0is finish
threadnum:1is finish
threadnum:2is finish
threadnum:3is finish
threadnum:5is ready
threadnum:6is ready
threadnum:7is ready
threadnum:8is ready
threadnum:9is ready
threadnum:9is finish
threadnum:5is finish
threadnum:8is finish
threadnum:7is finish
threadnum:6is finish
......
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， <code>await()</code> 方法之后的方法才被执行。</p>
<p>另外，<code>CyclicBarrier</code> 还提供一个更高级的构造函数 <code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行 <code>barrierAction</code>，方便处理更复杂的业务场景。示例代码如下：</p>
<div><pre><code><span>/**
 *
 * @author SnailClimb
 * @date 2018年10月1日
 * @Description: 新建 CyclicBarrier 的时候指定一个 Runnable
 */</span>
<span>public</span> <span>class</span> <span>CyclicBarrierExample3</span> <span>{</span>
  <span>// 请求的数量</span>
  <span>private</span> <span>static</span> <span>final</span> <span>int</span> threadCount <span>=</span> <span>550</span><span>;</span>
  <span>// 需要同步的线程数量</span>
  <span>private</span> <span>static</span> <span>final</span> <span>CyclicBarrier</span> cyclicBarrier <span>=</span> <span>new</span> <span>CyclicBarrier</span><span>(</span><span>5</span><span>,</span> <span>(</span><span>)</span> <span>-></span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"------当线程数达到之后，优先执行------"</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>// 创建线程池</span>
    <span>ExecutorService</span> threadPool <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>10</span><span>)</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> threadCount<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>final</span> <span>int</span> threadNum <span>=</span> i<span>;</span>
      <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
      threadPool<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
        <span>try</span> <span>{</span>
          <span>test</span><span>(</span>threadNum<span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
          <span>// TODO Auto-generated catch block</span>
          e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>BrokenBarrierException</span> e<span>)</span> <span>{</span>
          <span>// TODO Auto-generated catch block</span>
          e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
      <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    threadPool<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>public</span> <span>static</span> <span>void</span> <span>test</span><span>(</span><span>int</span> threadnum<span>)</span> <span>throws</span> <span>InterruptedException</span><span>,</span> <span>BrokenBarrierException</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"threadnum:"</span> <span>+</span> threadnum <span>+</span> <span>"is ready"</span><span>)</span><span>;</span>
    cyclicBarrier<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"threadnum:"</span> <span>+</span> threadnum <span>+</span> <span>"is finish"</span><span>)</span><span>;</span>
  <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>运行结果，如下：</p>
<div><pre><code>threadnum:0is ready
threadnum:1is ready
threadnum:2is ready
threadnum:3is ready
threadnum:4is ready
------当线程数达到之后，优先执行------
threadnum:4is finish
threadnum:0is finish
threadnum:2is finish
threadnum:1is finish
threadnum:3is finish
threadnum:5is ready
threadnum:6is ready
threadnum:7is ready
threadnum:8is ready
threadnum:9is ready
------当线程数达到之后，优先执行------
threadnum:9is finish
threadnum:5is finish
threadnum:6is finish
threadnum:8is finish
threadnum:7is finish
......
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="cyclicbarrier-源码分析"> CyclicBarrier 源码分析</h3>
<p>当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是 <code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p>
<div><pre><code><span>public</span> <span>int</span> <span>await</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span><span>,</span> <span>BrokenBarrierException</span> <span>{</span>
  <span>try</span> <span>{</span>
    	<span>return</span> <span>dowait</span><span>(</span><span>false</span><span>,</span> <span>0L</span><span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span><span>TimeoutException</span> toe<span>)</span> <span>{</span>
   	 <span>throw</span> <span>new</span> <span>Error</span><span>(</span>toe<span>)</span><span>;</span> <span>// cannot happen</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>dowait(false, 0L)</code>：</p>
<div><pre><code>    <span>// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span>
    <span>private</span> <span>int</span> count<span>;</span>
    <span>/**
     * Main barrier code, covering the various policies.
     */</span>
    <span>private</span> <span>int</span> <span>dowait</span><span>(</span><span>boolean</span> timed<span>,</span> <span>long</span> nanos<span>)</span>
        <span>throws</span> <span>InterruptedException</span><span>,</span> <span>BrokenBarrierException</span><span>,</span>
               <span>TimeoutException</span> <span>{</span>
        <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>
        <span>// 锁住</span>
        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>final</span> <span>Generation</span> g <span>=</span> generation<span>;</span>

            <span>if</span> <span>(</span>g<span>.</span>broken<span>)</span>
                <span>throw</span> <span>new</span> <span>BrokenBarrierException</span><span>(</span><span>)</span><span>;</span>

            <span>// 如果线程中断了，抛出异常</span>
            <span>if</span> <span>(</span><span>Thread</span><span>.</span><span>interrupted</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                <span>breakBarrier</span><span>(</span><span>)</span><span>;</span>
                <span>throw</span> <span>new</span> <span>InterruptedException</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
            <span>// cout减1</span>
            <span>int</span> index <span>=</span> <span>--</span>count<span>;</span>
            <span>// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span>
            <span>if</span> <span>(</span>index <span>==</span> <span>0</span><span>)</span> <span>{</span>  <span>// tripped</span>
                <span>boolean</span> ranAction <span>=</span> <span>false</span><span>;</span>
                <span>try</span> <span>{</span>
                    <span>final</span> <span>Runnable</span> command <span>=</span> barrierCommand<span>;</span>
                    <span>if</span> <span>(</span>command <span>!=</span> <span>null</span><span>)</span>
                        command<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
                    ranAction <span>=</span> <span>true</span><span>;</span>
                    <span>// 将 count 重置为 parties 属性的初始化值</span>
                    <span>// 唤醒之前等待的线程</span>
                    <span>// 下一波执行开始</span>
                    <span>nextGeneration</span><span>(</span><span>)</span><span>;</span>
                    <span>return</span> <span>0</span><span>;</span>
                <span>}</span> <span>finally</span> <span>{</span>
                    <span>if</span> <span>(</span><span>!</span>ranAction<span>)</span>
                        <span>breakBarrier</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>

            <span>// loop until tripped, broken, interrupted, or timed out</span>
            <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
                <span>try</span> <span>{</span>
                    <span>if</span> <span>(</span><span>!</span>timed<span>)</span>
                        trip<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
                    <span>else</span> <span>if</span> <span>(</span>nanos <span>></span> <span>0L</span><span>)</span>
                        nanos <span>=</span> trip<span>.</span><span>awaitNanos</span><span>(</span>nanos<span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> ie<span>)</span> <span>{</span>
                    <span>if</span> <span>(</span>g <span>==</span> generation <span>&amp;&amp;</span> <span>!</span> g<span>.</span>broken<span>)</span> <span>{</span>
                        <span>breakBarrier</span><span>(</span><span>)</span><span>;</span>
                        <span>throw</span> ie<span>;</span>
                    <span>}</span> <span>else</span> <span>{</span>
                        <span>// We're about to finish waiting even if we had not</span>
                        <span>// been interrupted, so this interrupt is deemed to</span>
                        <span>// "belong" to subsequent execution.</span>
                        <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span>

                <span>if</span> <span>(</span>g<span>.</span>broken<span>)</span>
                    <span>throw</span> <span>new</span> <span>BrokenBarrierException</span><span>(</span><span>)</span><span>;</span>

                <span>if</span> <span>(</span>g <span>!=</span> generation<span>)</span>
                    <span>return</span> index<span>;</span>

                <span>if</span> <span>(</span>timed <span>&amp;&amp;</span> nanos <span>&lt;=</span> <span>0L</span><span>)</span> <span>{</span>
                    <span>breakBarrier</span><span>(</span><span>)</span><span>;</span>
                    <span>throw</span> <span>new</span> <span>TimeoutException</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span> <span>finally</span> <span>{</span>
            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br></div></div><p>总结：<code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>
<h3 id="cyclicbarrier-和-countdownlatch-的区别"> CyclicBarrier 和 CountDownLatch 的区别</h3>
<p>下面这个是国外一个大佬的回答：</p>
<p><code>CountDownLatch</code> 是计数器，只能使用一次，而 <code>CyclicBarrier</code> 的计数器提供 <code>reset</code> 功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从 jdk 作者设计的目的来看，javadoc 是这么描述它们的：</p>
<blockquote>
<p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；)
CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p>
</blockquote>
<p>对于 <code>CountDownLatch</code> 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 <code>CyclicBarrier</code>，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p>
<p><code>CountDownLatch</code> 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 <code>CyclicBarrier</code> 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p>
<h3 id="reentrantlock-和-reentrantreadwritelock"> ReentrantLock 和 ReentrantReadWriteLock</h3>
<p><code>ReentrantLock</code> 和 <code>synchronized</code> 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 <code>ReentrantReadWriteLock</code> 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/AQS.png" type="image/png"/>
    </item>
    <item>
      <title>CompletableFuture入门</title>
      <link>https://javaguide.cn/java/concurrent/completablefuture-intro/</link>
      <guid>https://javaguide.cn/java/concurrent/completablefuture-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">CompletableFuture入门</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>自己在项目中使用 <code>CompletableFuture</code> 比较多，看到很多开源框架中也大量使用到了 <code>CompletableFuture</code> 。</p>
<p>因此，专门写一篇文章来介绍这个 Java 8 才被引入的一个非常有用的用于异步编程的类。</p>
<h2 id="简单介绍"> 简单介绍</h2>
<p><code>CompletableFuture</code> 同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口。</p>
<div><pre><code><span>public</span> <span>class</span> <span>CompletableFuture</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>implements</span> <span>Future</span><span><span>&lt;</span><span>T</span><span>></span></span><span>,</span> <span>CompletionStage</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程的能力。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210902092441434.png" alt="" /></p>
<p><code>Future</code> 接口有 5 个方法：</p>
<ul>
<li><code>boolean cancel(boolean mayInterruptIfRunning)</code> ：尝试取消执行任务。</li>
<li><code>boolean isCancelled()</code> ：判断任务是否被取消。</li>
<li><code>boolean isDone()</code> ： 判断任务是否已经被执行完成。</li>
<li><code>get()</code> ：等待任务执行完成并获取运算结果。</li>
<li><code>get(long timeout, TimeUnit unit)</code> ：多了一个超时时间。</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210902093026059.png" alt="" /></p>
<p><code>CompletionStage&lt;T&gt;</code> 接口中的方法比较多，<code>CompletableFuture</code> 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。</p>
<p>由于方法众多，所以这里不能一一讲解，下文中我会介绍大部分常见方法的使用。</p>
<h2 id="常见操作"> 常见操作</h2>
<h3 id="创建-completablefuture"> 创建 CompletableFuture</h3>
<p>常见的创建 <code>CompletableFuture</code> 对象的方法如下：</p>
<ol>
<li>通过 new 关键字。</li>
<li>基于 <code>CompletableFuture</code> 自带的静态工厂方法：<code>runAsync()</code> 、<code>supplyAsync()</code> 。</li>
</ol>
<h4 id="new-关键字"> new 关键字</h4>
<p>通过 new 关键字创建 <code>CompletableFuture</code> 对象这种使用方式可以看作是将 <code>CompletableFuture</code> 当做 <code>Future</code> 来使用。</p>
<p>我在我的开源项目 <a href="https://github.com/Snailclimb/guide-rpc-framework" target="_blank" rel="noopener noreferrer">guide-rpc-framework</a> 中就是这种方式创建的 <code>CompletableFuture</code> 对象。</p>
<p>下面咱们来看一个简单的案例。</p>
<p>我们通过创建了一个结果值类型为 <code>RpcResponse&lt;Object&gt;</code> 的 <code>CompletableFuture</code>，你可以把 <code>resultFuture</code> 看作是异步运算结果的载体。</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>RpcResponse</span><span>&lt;</span><span>Object</span><span>></span><span>></span></span> resultFuture <span>=</span> <span>new</span> <span>CompletableFuture</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>假设在未来的某个时刻，我们得到了最终的结果。这时，我们可以调用 <code>complete()</code> 方法为其传入结果，这表示 <code>resultFuture</code> 已经被完成了。</p>
<div><pre><code><span>// complete() 方法只能调用一次，后续调用将被忽略。</span>
resultFuture<span>.</span><span>complete</span><span>(</span>rpcResponse<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>你可以通过 <code>isDone()</code> 方法来检查是否已经完成。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>isDone</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> result <span>!=</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>获取异步计算的结果也非常简单，直接调用 <code>get()</code> 方法即可！</p>
<div><pre><code>rpcResponse <span>=</span> completableFuture<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>注意 ： <code>get()</code> 方法并不会阻塞，因为我们已经知道异步运算的结果了。</p>
<p>如果你已经知道计算的结果的话，可以使用静态方法 <code>completedFuture()</code> 来创建 <code>CompletableFuture</code> 。</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>String</span><span>></span></span> future <span>=</span> <span>CompletableFuture</span><span>.</span><span>completedFuture</span><span>(</span><span>"hello!"</span><span>)</span><span>;</span>
<span>assertEquals</span><span>(</span><span>"hello!"</span><span>,</span> future<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>completedFuture()</code> 方法底层调用的是带参数的 new 方法，只不过，这个方法不对外暴露。</p>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>U</span><span>></span></span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>completedFuture</span><span>(</span><span>U</span> value<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span><span>(</span><span>(</span>value <span>==</span> <span>null</span><span>)</span> <span>?</span> NIL <span>:</span> value<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="静态工厂方法"> 静态工厂方法</h4>
<p>这两个方法可以帮助我们封装计算逻辑。</p>
<div><pre><code><span>static</span> <span><span>&lt;</span><span>U</span><span>></span></span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>supplyAsync</span><span>(</span><span>Supplier</span><span><span>&lt;</span><span>U</span><span>></span></span> supplier<span>)</span><span>;</span>
<span>// 使用自定义线程池(推荐)</span>
<span>static</span> <span><span>&lt;</span><span>U</span><span>></span></span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>supplyAsync</span><span>(</span><span>Supplier</span><span><span>&lt;</span><span>U</span><span>></span></span> supplier<span>,</span> <span>Executor</span> executor<span>)</span><span>;</span>
<span>static</span> <span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> <span>runAsync</span><span>(</span><span>Runnable</span> runnable<span>)</span><span>;</span>
<span>// 使用自定义线程池(推荐)</span>
<span>static</span> <span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> <span>runAsync</span><span>(</span><span>Runnable</span> runnable<span>,</span> <span>Executor</span> executor<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>runAsync()</code> 方法接受的参数是 <code>Runnable</code> ，这是一个函数式接口，不允许返回值。当你需要异步操作且不关心返回结果的时候可以使用 <code>runAsync()</code> 方法。</p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Runnable</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>supplyAsync()</code> 方法接受的参数是 <code>Supplier&lt;U&gt;</code> ，这也是一个函数式接口，<code>U</code> 是返回结果值的类型。</p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Supplier</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>/**
     * Gets a result.
     *
     * @return a result
     */</span>
    <span>T</span> <span>get</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>当你需要异步操作且关心返回结果的时候,可以使用 <code>supplyAsync()</code> 方法。</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> future <span>=</span> <span>CompletableFuture</span><span>.</span><span>runAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"hello!"</span><span>)</span><span>)</span><span>;</span>
future<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span><span>// 输出 "hello!"</span>
<span>CompletableFuture</span><span><span>&lt;</span><span>String</span><span>></span></span> future2 <span>=</span> <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>"hello!"</span><span>)</span><span>;</span>
<span>assertEquals</span><span>(</span><span>"hello!"</span><span>,</span> future2<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="处理异步结算的结果"> 处理异步结算的结果</h3>
<p>当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：</p>
<ul>
<li><code>thenApply()</code></li>
<li><code>thenAccept()</code></li>
<li><code>thenRun()</code></li>
<li><code>whenComplete()</code></li>
</ul>
<p><code>thenApply()</code> 方法接受一个 <code>Function</code> 实例，用它来处理结果。</p>
<div><pre><code><span>// 沿用上一个任务的线程池</span>
<span>public</span> <span><span>&lt;</span><span>U</span><span>></span></span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>thenApply</span><span>(</span>
    <span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span><span>?</span> <span>extends</span> <span>U</span><span>></span></span> fn<span>)</span> <span>{</span>
    <span>return</span> <span>uniApplyStage</span><span>(</span><span>null</span><span>,</span> fn<span>)</span><span>;</span>
<span>}</span>

<span>//使用默认的 ForkJoinPool 线程池（不推荐）</span>
<span>public</span> <span><span>&lt;</span><span>U</span><span>></span></span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>thenApplyAsync</span><span>(</span>
    <span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span><span>?</span> <span>extends</span> <span>U</span><span>></span></span> fn<span>)</span> <span>{</span>
    <span>return</span> <span>uniApplyStage</span><span>(</span><span>defaultExecutor</span><span>(</span><span>)</span><span>,</span> fn<span>)</span><span>;</span>
<span>}</span>
<span>// 使用自定义线程池(推荐)</span>
<span>public</span> <span><span>&lt;</span><span>U</span><span>></span></span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>thenApplyAsync</span><span>(</span>
    <span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span><span>?</span> <span>extends</span> <span>U</span><span>></span></span> fn<span>,</span> <span>Executor</span> executor<span>)</span> <span>{</span>
    <span>return</span> <span>uniApplyStage</span><span>(</span><span>screenExecutor</span><span>(</span>executor<span>)</span><span>,</span> fn<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><code>thenApply()</code> 方法使用示例如下：</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>String</span><span>></span></span> future <span>=</span> <span>CompletableFuture</span><span>.</span><span>completedFuture</span><span>(</span><span>"hello!"</span><span>)</span>
        <span>.</span><span>thenApply</span><span>(</span>s <span>-></span> s <span>+</span> <span>"world!"</span><span>)</span><span>;</span>
<span>assertEquals</span><span>(</span><span>"hello!world!"</span><span>,</span> future<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>// 这次调用将被忽略。</span>
future<span>.</span><span>thenApply</span><span>(</span>s <span>-></span> s <span>+</span> <span>"nice!"</span><span>)</span><span>;</span>
<span>assertEquals</span><span>(</span><span>"hello!world!"</span><span>,</span> future<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>你还可以进行 <strong>流式调用</strong>：</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>String</span><span>></span></span> future <span>=</span> <span>CompletableFuture</span><span>.</span><span>completedFuture</span><span>(</span><span>"hello!"</span><span>)</span>
        <span>.</span><span>thenApply</span><span>(</span>s <span>-></span> s <span>+</span> <span>"world!"</span><span>)</span><span>.</span><span>thenApply</span><span>(</span>s <span>-></span> s <span>+</span> <span>"nice!"</span><span>)</span><span>;</span>
<span>assertEquals</span><span>(</span><span>"hello!world!nice!"</span><span>,</span> future<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>如果你不需要从回调函数中获取返回结果，可以使用 <code>thenAccept()</code> 或者 <code>thenRun()</code>。这两个方法的区别在于 <code>thenRun()</code> 不能访问异步计算的结果。</strong></p>
<p><code>thenAccept()</code> 方法的参数是 <code>Consumer&lt;? super T&gt;</code> 。</p>
<div><pre><code><span>public</span> <span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> <span>thenAccept</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> action<span>)</span> <span>{</span>
    <span>return</span> <span>uniAcceptStage</span><span>(</span><span>null</span><span>,</span> action<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> <span>thenAcceptAsync</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> action<span>)</span> <span>{</span>
    <span>return</span> <span>uniAcceptStage</span><span>(</span><span>defaultExecutor</span><span>(</span><span>)</span><span>,</span> action<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> <span>thenAcceptAsync</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> action<span>,</span>
                                               <span>Executor</span> executor<span>)</span> <span>{</span>
    <span>return</span> <span>uniAcceptStage</span><span>(</span><span>screenExecutor</span><span>(</span>executor<span>)</span><span>,</span> action<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>顾名思义，<code>Consumer</code> 属于消费型接口，它可以接收 1 个输入对象然后进行“消费”。</p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Consumer</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>void</span> <span>accept</span><span>(</span><span>T</span> t<span>)</span><span>;</span>

    <span>default</span> <span>Consumer</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>andThen</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> after<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>after<span>)</span><span>;</span>
        <span>return</span> <span>(</span><span>T</span> t<span>)</span> <span>-></span> <span>{</span> <span>accept</span><span>(</span>t<span>)</span><span>;</span> after<span>.</span><span>accept</span><span>(</span>t<span>)</span><span>;</span> <span>}</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>thenRun()</code> 的方法是的参数是 <code>Runnable</code> 。</p>
<div><pre><code><span>public</span> <span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> <span>thenRun</span><span>(</span><span>Runnable</span> action<span>)</span> <span>{</span>
    <span>return</span> <span>uniRunStage</span><span>(</span><span>null</span><span>,</span> action<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> <span>thenRunAsync</span><span>(</span><span>Runnable</span> action<span>)</span> <span>{</span>
    <span>return</span> <span>uniRunStage</span><span>(</span><span>defaultExecutor</span><span>(</span><span>)</span><span>,</span> action<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> <span>thenRunAsync</span><span>(</span><span>Runnable</span> action<span>,</span>
                                            <span>Executor</span> executor<span>)</span> <span>{</span>
    <span>return</span> <span>uniRunStage</span><span>(</span><span>screenExecutor</span><span>(</span>executor<span>)</span><span>,</span> action<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><code>thenAccept()</code> 和 <code>thenRun()</code> 使用示例如下：</p>
<div><pre><code><span>CompletableFuture</span><span>.</span><span>completedFuture</span><span>(</span><span>"hello!"</span><span>)</span>
        <span>.</span><span>thenApply</span><span>(</span>s <span>-></span> s <span>+</span> <span>"world!"</span><span>)</span><span>.</span><span>thenApply</span><span>(</span>s <span>-></span> s <span>+</span> <span>"nice!"</span><span>)</span><span>.</span><span>thenAccept</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span><span>//hello!world!nice!</span>

<span>CompletableFuture</span><span>.</span><span>completedFuture</span><span>(</span><span>"hello!"</span><span>)</span>
        <span>.</span><span>thenApply</span><span>(</span>s <span>-></span> s <span>+</span> <span>"world!"</span><span>)</span><span>.</span><span>thenApply</span><span>(</span>s <span>-></span> s <span>+</span> <span>"nice!"</span><span>)</span><span>.</span><span>thenRun</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"hello!"</span><span>)</span><span>)</span><span>;</span><span>//hello!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>whenComplete()</code> 的方法的参数是 <code>BiConsumer&lt;? super T, ? super Throwable&gt;</code> 。</p>
<div><pre><code><span>public</span> <span>CompletableFuture</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>whenComplete</span><span>(</span>
    <span>BiConsumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>super</span> <span>Throwable</span><span>></span></span> action<span>)</span> <span>{</span>
    <span>return</span> <span>uniWhenCompleteStage</span><span>(</span><span>null</span><span>,</span> action<span>)</span><span>;</span>
<span>}</span>


<span>public</span> <span>CompletableFuture</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>whenCompleteAsync</span><span>(</span>
    <span>BiConsumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>super</span> <span>Throwable</span><span>></span></span> action<span>)</span> <span>{</span>
    <span>return</span> <span>uniWhenCompleteStage</span><span>(</span><span>defaultExecutor</span><span>(</span><span>)</span><span>,</span> action<span>)</span><span>;</span>
<span>}</span>
<span>// 使用自定义线程池(推荐)</span>
<span>public</span> <span>CompletableFuture</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>whenCompleteAsync</span><span>(</span>
    <span>BiConsumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>super</span> <span>Throwable</span><span>></span></span> action<span>,</span> <span>Executor</span> executor<span>)</span> <span>{</span>
    <span>return</span> <span>uniWhenCompleteStage</span><span>(</span><span>screenExecutor</span><span>(</span>executor<span>)</span><span>,</span> action<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>相对于 <code>Consumer</code> ， <code>BiConsumer</code> 可以接收 2 个输入对象然后进行“消费”。</p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>BiConsumer</span><span><span>&lt;</span><span>T</span><span>,</span> <span>U</span><span>></span></span> <span>{</span>
    <span>void</span> <span>accept</span><span>(</span><span>T</span> t<span>,</span> <span>U</span> u<span>)</span><span>;</span>

    <span>default</span> <span>BiConsumer</span><span><span>&lt;</span><span>T</span><span>,</span> <span>U</span><span>></span></span> <span>andThen</span><span>(</span><span>BiConsumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>super</span> <span>U</span><span>></span></span> after<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>after<span>)</span><span>;</span>

        <span>return</span> <span>(</span>l<span>,</span> r<span>)</span> <span>-></span> <span>{</span>
            <span>accept</span><span>(</span>l<span>,</span> r<span>)</span><span>;</span>
            after<span>.</span><span>accept</span><span>(</span>l<span>,</span> r<span>)</span><span>;</span>
        <span>}</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><code>whenComplete()</code> 使用示例如下：</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>String</span><span>></span></span> future <span>=</span> <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>"hello!"</span><span>)</span>
        <span>.</span><span>whenComplete</span><span>(</span><span>(</span>res<span>,</span> ex<span>)</span> <span>-></span> <span>{</span>
            <span>// res 代表返回的结果</span>
            <span>// ex 的类型为 Throwable ，代表抛出的异常</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>res<span>)</span><span>;</span>
            <span>// 这里没有抛出异常所有为 null</span>
            <span>assertNull</span><span>(</span>ex<span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
<span>assertEquals</span><span>(</span><span>"hello!"</span><span>,</span> future<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="异常处理"> 异常处理</h3>
<p>你可以通过 <code>handle()</code> 方法来处理任务执行过程中可能出现的抛出异常的情况。</p>
<div><pre><code><span>public</span> <span><span>&lt;</span><span>U</span><span>></span></span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>handle</span><span>(</span>
    <span>BiFunction</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>Throwable</span><span>,</span> <span>?</span> <span>extends</span> <span>U</span><span>></span></span> fn<span>)</span> <span>{</span>
    <span>return</span> <span>uniHandleStage</span><span>(</span><span>null</span><span>,</span> fn<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span><span>&lt;</span><span>U</span><span>></span></span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>handleAsync</span><span>(</span>
    <span>BiFunction</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>Throwable</span><span>,</span> <span>?</span> <span>extends</span> <span>U</span><span>></span></span> fn<span>)</span> <span>{</span>
    <span>return</span> <span>uniHandleStage</span><span>(</span><span>defaultExecutor</span><span>(</span><span>)</span><span>,</span> fn<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span><span>&lt;</span><span>U</span><span>></span></span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>handleAsync</span><span>(</span>
    <span>BiFunction</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>Throwable</span><span>,</span> <span>?</span> <span>extends</span> <span>U</span><span>></span></span> fn<span>,</span> <span>Executor</span> executor<span>)</span> <span>{</span>
    <span>return</span> <span>uniHandleStage</span><span>(</span><span>screenExecutor</span><span>(</span>executor<span>)</span><span>,</span> fn<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>示例代码如下：</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>String</span><span>></span></span> future
        <span>=</span> <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
    <span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>"Computation error!"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>"hello!"</span><span>;</span>
<span>}</span><span>)</span><span>.</span><span>handle</span><span>(</span><span>(</span>res<span>,</span> ex<span>)</span> <span>-></span> <span>{</span>
    <span>// res 代表返回的结果</span>
    <span>// ex 的类型为 Throwable ，代表抛出的异常</span>
    <span>return</span> res <span>!=</span> <span>null</span> <span>?</span> res <span>:</span> <span>"world!"</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
<span>assertEquals</span><span>(</span><span>"world!"</span><span>,</span> future<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>你还可以通过 <code>exceptionally()</code> 方法来处理异常情况。</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>String</span><span>></span></span> future
        <span>=</span> <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
    <span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>"Computation error!"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>"hello!"</span><span>;</span>
<span>}</span><span>)</span><span>.</span><span>exceptionally</span><span>(</span>ex <span>-></span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ex<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span><span>// CompletionException</span>
    <span>return</span> <span>"world!"</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
<span>assertEquals</span><span>(</span><span>"world!"</span><span>,</span> future<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果你想让 <code>CompletableFuture</code> 的结果就是异常的话，可以使用 <code>completeExceptionally()</code> 方法为其赋值。</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>String</span><span>></span></span> completableFuture <span>=</span> <span>new</span> <span>CompletableFuture</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>// ...</span>
completableFuture<span>.</span><span>completeExceptionally</span><span>(</span>
  <span>new</span> <span>RuntimeException</span><span>(</span><span>"Calculation failed!"</span><span>)</span><span>)</span><span>;</span>
<span>// ...</span>
completableFuture<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span> <span>// ExecutionException</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="组合-completablefuture"> 组合 CompletableFuture</h3>
<p>你可以使用 <code>thenCompose()</code> 按顺序链接两个 <code>CompletableFuture</code> 对象。</p>
<div><pre><code><span>public</span> <span><span>&lt;</span><span>U</span><span>></span></span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>thenCompose</span><span>(</span>
    <span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>extends</span> <span>CompletionStage</span><span>&lt;</span><span>U</span><span>></span><span>></span></span> fn<span>)</span> <span>{</span>
    <span>return</span> <span>uniComposeStage</span><span>(</span><span>null</span><span>,</span> fn<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span><span>&lt;</span><span>U</span><span>></span></span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>thenComposeAsync</span><span>(</span>
    <span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>extends</span> <span>CompletionStage</span><span>&lt;</span><span>U</span><span>></span><span>></span></span> fn<span>)</span> <span>{</span>
    <span>return</span> <span>uniComposeStage</span><span>(</span><span>defaultExecutor</span><span>(</span><span>)</span><span>,</span> fn<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span><span>&lt;</span><span>U</span><span>></span></span> <span>CompletableFuture</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>thenComposeAsync</span><span>(</span>
    <span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>extends</span> <span>CompletionStage</span><span>&lt;</span><span>U</span><span>></span><span>></span></span> fn<span>,</span>
    <span>Executor</span> executor<span>)</span> <span>{</span>
    <span>return</span> <span>uniComposeStage</span><span>(</span><span>screenExecutor</span><span>(</span>executor<span>)</span><span>,</span> fn<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><code>thenCompose()</code> 方法会使用示例如下：</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>String</span><span>></span></span> future
        <span>=</span> <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>"hello!"</span><span>)</span>
        <span>.</span><span>thenCompose</span><span>(</span>s <span>-></span> <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> s <span>+</span> <span>"world!"</span><span>)</span><span>)</span><span>;</span>
<span>assertEquals</span><span>(</span><span>"hello!world!"</span><span>,</span> future<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在实际开发中，这个方法还是非常有用的。比如说，我们先要获取用户信息然后再用用户信息去做其他事情。</p>
<p>和 <code>thenCompose()</code> 方法类似的还有 <code>thenCombine()</code> 方法， <code>thenCombine()</code> 同样可以组合两个 <code>CompletableFuture</code> 对象。</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>String</span><span>></span></span> completableFuture
        <span>=</span> <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>"hello!"</span><span>)</span>
        <span>.</span><span>thenCombine</span><span>(</span><span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span>
                <span>(</span><span>)</span> <span>-></span> <span>"world!"</span><span>)</span><span>,</span> <span>(</span>s1<span>,</span> s2<span>)</span> <span>-></span> s1 <span>+</span> s2<span>)</span>
        <span>.</span><span>thenCompose</span><span>(</span>s <span>-></span> <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> s <span>+</span> <span>"nice!"</span><span>)</span><span>)</span><span>;</span>
<span>assertEquals</span><span>(</span><span>"hello!world!nice!"</span><span>,</span> completableFuture<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>那 <code>thenCompose()</code> 和 <code>thenCombine()</code> 有什么区别呢？</strong></p>
<ul>
<li><code>thenCompose()</code> 可以两个 <code>CompletableFuture</code> 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。</li>
<li><code>thenCombine()</code> 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。</li>
</ul>
<h3 id="并行运行多个-completablefuture"> 并行运行多个 CompletableFuture</h3>
<p>你可以通过 <code>CompletableFuture</code> 的 <code>allOf()</code>这个静态方法来并行运行多个 <code>CompletableFuture</code> 。</p>
<p>实际项目中，我们经常需要并行运行多个互不相关的任务，这些任务之间没有依赖关系，可以互相独立地运行。</p>
<p>比说我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。像这种情况我们就可以使用并行运行多个 <code>CompletableFuture</code> 来处理。</p>
<p>示例代码如下：</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> task1 <span>=</span>
  <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span><span>-></span><span>{</span>
    <span>//自定义业务操作</span>
  <span>}</span><span>)</span><span>;</span>
<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> task6 <span>=</span>
  <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span><span>-></span><span>{</span>
    <span>//自定义业务操作</span>
  <span>}</span><span>)</span><span>;</span>
<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
 <span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> headerFuture<span>=</span><span>CompletableFuture</span><span>.</span><span>allOf</span><span>(</span>task1<span>,</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>,</span>task6<span>)</span><span>;</span>

  <span>try</span> <span>{</span>
    headerFuture<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> ex<span>)</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
  <span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"all done. "</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>经常和 <code>allOf()</code> 方法拿来对比的是 <code>anyOf()</code> 方法。</p>
<p><strong><code>allOf()</code> 方法会等到所有的 <code>CompletableFuture</code> 都运行完成之后再返回</strong></p>
<div><pre><code><span>Random</span> rand <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>
<span>CompletableFuture</span><span><span>&lt;</span><span>String</span><span>></span></span> future1 <span>=</span> <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span> <span>+</span> rand<span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>)</span><span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"future1 done..."</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>"abc"</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
<span>CompletableFuture</span><span><span>&lt;</span><span>String</span><span>></span></span> future2 <span>=</span> <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span> <span>+</span> rand<span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>)</span><span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"future2 done..."</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>"efg"</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>调用 <code>join()</code> 可以让程序等<code>future1</code> 和 <code>future2</code> 都运行完了之后再继续执行。</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> completableFuture <span>=</span> <span>CompletableFuture</span><span>.</span><span>allOf</span><span>(</span>future1<span>,</span> future2<span>)</span><span>;</span>
completableFuture<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
<span>assertTrue</span><span>(</span>completableFuture<span>.</span><span>isDone</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"all futures done..."</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>输出：</p>
<div><pre><code>future1 done<span>.</span><span>.</span><span>.</span>
future2 done<span>.</span><span>.</span><span>.</span>
all futures done<span>.</span><span>.</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong><code>anyOf()</code> 方法不会等待所有的 <code>CompletableFuture</code> 都运行完成之后再返回，只要有一个执行完成即可！</strong></p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>Object</span><span>></span></span> f <span>=</span> <span>CompletableFuture</span><span>.</span><span>anyOf</span><span>(</span>future1<span>,</span> future2<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>f<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>输出结果可能是：</p>
<div><pre><code>future2 done<span>.</span><span>.</span><span>.</span>
efg
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>也可能是：</p>
<div><pre><code>future1 done...
abc
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="后记"> 后记</h2>
<p>这篇文章只是简单介绍了 <code>CompletableFuture</code> 比较常用的一些 API 。</p>
<p>如果想要深入学习的话，可以多找一些书籍和博客看。</p>
<p>另外，建议G友们可以看看京东的 <a href="https://gitee.com/jd-platform-opensource/asyncTool" target="_blank" rel="noopener noreferrer">asyncTool</a> 这个并发框架，里面大量使用到了  <code>CompletableFuture</code>  。</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210902092441434.png" type="image/png"/>
    </item>
    <item>
      <title>Java 并发常见知识点&amp;面试题总结（基础篇）</title>
      <link>https://javaguide.cn/java/concurrent/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/java/concurrent/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">Java 并发常见知识点&amp;面试题总结（基础篇）</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="什么是线程和进程"> 什么是线程和进程?</h2>
<h3 id="何为进程"> 何为进程?</h3>
<p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
<p>如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/进程示例图片-Windows.png" alt="进程示例图片-Windows" /></p>
<h3 id="何为线程"> 何为线程?</h3>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。</p>
<div><pre><code><span>public</span> <span>class</span> <span>MultiThread</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>// 获取 Java 线程管理 MXBean</span>
	<span>ThreadMXBean</span> threadMXBean <span>=</span> <span>ManagementFactory</span><span>.</span><span>getThreadMXBean</span><span>(</span><span>)</span><span>;</span>
		<span>// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span>
		<span>ThreadInfo</span><span>[</span><span>]</span> threadInfos <span>=</span> threadMXBean<span>.</span><span>dumpAllThreads</span><span>(</span><span>false</span><span>,</span> <span>false</span><span>)</span><span>;</span>
		<span>// 遍历线程信息，仅打印线程 ID 和线程名称信息</span>
		<span>for</span> <span>(</span><span>ThreadInfo</span> threadInfo <span>:</span> threadInfos<span>)</span> <span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"["</span> <span>+</span> threadInfo<span>.</span><span>getThreadId</span><span>(</span><span>)</span> <span>+</span> <span>"] "</span> <span>+</span> threadInfo<span>.</span><span>getThreadName</span><span>(</span><span>)</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p>
<div><pre><code>[5] Attach Listener //添加事件
[4] Signal Dispatcher // 分发处理给 JVM 信号的线程
[3] Finalizer //调用对象 finalize 方法的线程
[2] Reference Handler //清除 reference 线程
[1] main //main 线程,程序入口
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p>
<h2 id="请简要描述线程与进程的关系-区别及优缺点"> 请简要描述线程与进程的关系,区别及优缺点？</h2>
<p><strong>从 JVM 角度说进程和线程之间的关系</strong></p>
<h3 id="图解进程和线程的关系"> 图解进程和线程的关系</h3>
<p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p>
<p><img src="./../jvm/pictures/java内存区域/Java运行时数据区域JDK1.8.png" alt="" /></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的</strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p>
<p>下面是该知识点的扩展内容！</p>
<p>下面来思考这样一个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p>
<h3 id="程序计数器为什么是私有的"> 程序计数器为什么是私有的?</h3>
<p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h3 id="虚拟机栈和本地方法栈为什么是私有的"> 虚拟机栈和本地方法栈为什么是私有的?</h3>
<ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="一句话简单了解堆和方法区"> 一句话简单了解堆和方法区</h3>
<p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h2 id="说说并发与并行的区别"> 说说并发与并行的区别?</h2>
<ul>
<li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li>
<li><strong>并行：</strong> 单位时间内，多个任务同时执行。</li>
</ul>
<h2 id="为什么要使用多线程呢"> 为什么要使用多线程呢?</h2>
<p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</li>
</ul>
<h2 id="使用多线程可能带来什么问题"> 使用多线程可能带来什么问题?</h2>
<p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p>
<h2 id="说说线程的生命周期和状态"> 说说线程的生命周期和状态?</h2>
<p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java线程的状态.png" alt="Java 线程的状态 " /></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java+线程状态变迁.png" alt="Java 线程状态变迁 " /></p>
<blockquote>
<p>订正(来自<a href="https://github.com/Snailclimb/JavaGuide/issues/736" target="_blank" rel="noopener noreferrer">issue736</a>)：原图中 wait 到 runnable 状态的转换中，<code>join</code>实际上是<code>Thread</code>类的方法，但这里写成了<code>Object</code>。</p>
</blockquote>
<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>在操作系统中层面线程有 READY 和 RUNNING 状态，而在 JVM 层面只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinJava.com/" title="HowToDoInJava" target="_blank" rel="noopener noreferrer">HowToDoInJava</a>：<a href="https://howtodoinJava.com/Java/multi-threading/Java-thread-life-cycle-and-thread-states/" title="Java Thread Life Cycle and Thread States" target="_blank" rel="noopener noreferrer">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
<p><strong>为什么 JVM 没有区分这两种状态呢？</strong> （摘自：<a href="https://www.zhihu.com/question/56494969/answer/154053599" target="_blank" rel="noopener noreferrer">java线程运行怎么有第六种状态？ - Dawell的回答</a> ） 现在的<b>时分</b>（time-sharing）<b>多任务</b>（multi-task）操作系统架构通常都是用所谓的“<b>时间分片</b>（time quantum or time slice）”方式进行<b>抢占式</b>（preemptive）轮转调度（round-robin式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png" alt="RUNNABLE-VS-RUNNING" /></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED_WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/UOrXql_LhOD8dhTq_EPI0w" target="_blank" rel="noopener noreferrer">挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误</a> 。</p>
<h2 id="什么是上下文切换"> 什么是上下文切换?</h2>
<p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h2 id="什么是线程死锁-如何避免死锁"> 什么是线程死锁?如何避免死锁?</h2>
<h3 id="认识线程死锁"> 认识线程死锁</h3>
<p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-4/2019-4死锁1.png" alt="线程死锁示意图 " /></p>
<p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>
<div><pre><code><span>public</span> <span>class</span> <span>DeadLockDemo</span> <span>{</span>
    <span>private</span> <span>static</span> <span>Object</span> resource1 <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span><span>//资源 1</span>
    <span>private</span> <span>static</span> <span>Object</span> resource2 <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span><span>//资源 2</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>synchronized</span> <span>(</span>resource1<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"get resource1"</span><span>)</span><span>;</span>
                <span>try</span> <span>{</span>
                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"waiting get resource2"</span><span>)</span><span>;</span>
                <span>synchronized</span> <span>(</span>resource2<span>)</span> <span>{</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"get resource2"</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>,</span> <span>"线程 1"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>

        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>synchronized</span> <span>(</span>resource2<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"get resource2"</span><span>)</span><span>;</span>
                <span>try</span> <span>{</span>
                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"waiting get resource1"</span><span>)</span><span>;</span>
                <span>synchronized</span> <span>(</span>resource1<span>)</span> <span>{</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"get resource1"</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>,</span> <span>"线程 2"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>Output</p>
<div><pre><code>Thread[线程 1,5,main]get resource1
Thread[线程 2,5,main]get resource2
Thread[线程 1,5,main]waiting get resource2
Thread[线程 2,5,main]waiting get resource1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p>
<p>学过操作系统的朋友都知道产生死锁必须具备以下四个条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="如何预防和避免线程死锁"> 如何预防和避免线程死锁?</h3>
<p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<p><strong>安全状态</strong> 指的是系统能够按照某种进程推进顺序（P1、P2、P3.....Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。称&lt;P1、P2、P3.....Pn&gt;序列为安全序列。</p>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>
<div><pre><code>        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>synchronized</span> <span>(</span>resource1<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"get resource1"</span><span>)</span><span>;</span>
                <span>try</span> <span>{</span>
                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"waiting get resource2"</span><span>)</span><span>;</span>
                <span>synchronized</span> <span>(</span>resource2<span>)</span> <span>{</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"get resource2"</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>,</span> <span>"线程 2"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>Output</p>
<div><pre><code>Thread[线程 1,5,main]get resource1
Thread[线程 1,5,main]waiting get resource2
Thread[线程 1,5,main]get resource2
Thread[线程 2,5,main]get resource1
Thread[线程 2,5,main]waiting get resource2
Thread[线程 2,5,main]get resource2

Process finished with exit code 0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>我们分析一下上面的代码为什么避免了死锁的发生?</p>
<p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
<h2 id="说说-sleep-方法和-wait-方法区别和共同点"> 说说 sleep() 方法和 wait() 方法区别和共同点?</h2>
<ul>
<li>两者最主要的区别在于：<strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li>
<li>两者都可以暂停线程的执行。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
</ul>
<h2 id="为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法"> 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2>
<p>这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/进程示例图片-Windows.png" type="image/png"/>
    </item>
    <item>
      <title>Java 并发常见知识点&amp;面试题总结（进阶篇）</title>
      <link>https://javaguide.cn/java/concurrent/java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/java/concurrent/java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">Java 并发常见知识点&amp;面试题总结（进阶篇）</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1-synchronized-关键字"> 1.synchronized 关键字</h2>
<p><img src="./images/interview-questions/synchronized关键字.png" alt="" /></p>
<h3 id="_1-1-说一说自己对于-synchronized-关键字的了解"> 1.1.说一说自己对于 synchronized 关键字的了解</h3>
<p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p>
<p>另外，在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。</p>
<p><strong>为什么呢？</strong></p>
<p>因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<p>所以，你会发现目前的话，不论是各种开源框架还是 JDK 源码都大量使用了 <code>synchronized</code> 关键字。</p>
<h3 id="_1-2-说说自己是怎么使用-synchronized-关键字"> 1.2. 说说自己是怎么使用 synchronized 关键字</h3>
<p><strong>synchronized 关键字最主要的三种使用方式：</strong></p>
<p><strong>1.修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></p>
<div><pre><code><span>synchronized</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>
    <span>//业务代码</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。因为静态成员不属于任何一个实例对象，是类成员（ <em>static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份</em>）。所以，如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</p>
<div><pre><code><span>synchronized</span> <span>static</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>
    <span>//业务代码</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>3.修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></p>
<div><pre><code><span>synchronized</span><span>(</span><span>this</span><span>)</span> <span>{</span>
    <span>//业务代码</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>总结：</strong></p>
<ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁。</li>
<li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁。</li>
<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能！</li>
</ul>
<p>下面我以一个常见的面试题为例讲解一下 <code>synchronized</code> 关键字的具体使用。</p>
<p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p>
<p><strong>双重校验锁实现对象单例（线程安全）</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

    <span>private</span> <span>volatile</span> <span>static</span> <span>Singleton</span> uniqueInstance<span>;</span>

    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span>  <span>static</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
       <span>//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>
        <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>//类对象加锁</span>
            <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> uniqueInstance<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>另外，需要注意 <code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要。</p>
<p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p>
<p>使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h3 id="_1-3-构造方法可以使用-synchronized-关键字修饰么"> 1.3. 构造方法可以使用 synchronized 关键字修饰么？</h3>
<p>先说结论：<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p>
<p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
<h3 id="_1-3-讲一下-synchronized-关键字的底层原理"> 1.3. 讲一下 synchronized 关键字的底层原理</h3>
<p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p>
<h4 id="_1-3-1-synchronized-同步语句块的情况"> 1.3.1. synchronized 同步语句块的情况</h4>
<div><pre><code><span>public</span> <span>class</span> <span>SynchronizedDemo</span> <span>{</span>
    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>
        <span>synchronized</span> <span>(</span><span>this</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"synchronized 代码块"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>通过 JDK 自带的 <code>javap</code> 命令查看 <code>SynchronizedDemo</code> 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized关键字原理.png" alt="synchronized关键字原理" /></p>
<p>从上面我们可以看出：</p>
<p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp" target="_blank" rel="noopener noreferrer">ObjectMonitor</a>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p>在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h4 id="_1-3-2-synchronized-修饰方法的的情况"> 1.3.2. synchronized 修饰方法的的情况</h4>
<div><pre><code><span>public</span> <span>class</span> <span>SynchronizedDemo2</span> <span>{</span>
    <span>public</span> <span>synchronized</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"synchronized 方法"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized关键字原理2.png" alt="synchronized关键字原理" /></p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h4 id="_1-3-3-总结"> 1.3.3.总结</h4>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p>
<p>相关推荐：<a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/" target="_blank" rel="noopener noreferrer">Java锁与线程的那些事 - 有赞技术团队</a> 。</p>
<h3 id="_1-4-说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗"> 1.4. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</h3>
<p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p>关于这几种优化的详细信息可以查看下面这篇文章：<a href="https://www.cnblogs.com/wuqinglong/p/9945618.html" target="_blank" rel="noopener noreferrer">Java6 及以上版本对 synchronized 的优化</a></p>
<h3 id="_1-5-谈谈-synchronized-和-reentrantlock-的区别"> 1.5. 谈谈 synchronized 和 ReentrantLock 的区别</h3>
<h4 id="_1-5-1-两者都是可重入锁"> 1.5.1. 两者都是可重入锁</h4>
<p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<h4 id="_1-5-2-synchronized-依赖于-jvm-而-reentrantlock-依赖于-api"> 1.5.2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h4>
<p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<h4 id="_1-5-3-reentrantlock-比-synchronized-增加了一些高级功能"> 1.5.3.ReentrantLock 比 synchronized 增加了一些高级功能</h4>
<p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
<blockquote>
<p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 Lock 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p>
</blockquote>
<p><strong>如果你想使用上述功能，那么选择 ReentrantLock 是一个不错的选择。性能已不是选择标准</strong></p>
<h2 id="_2-volatile-关键字"> 2. volatile 关键字</h2>
<p>我们先要从 <strong>CPU 缓存模型</strong> 说起！</p>
<h3 id="_2-1-cpu-缓存模型"> 2.1. CPU 缓存模型</h3>
<p><strong>为什么要弄一个 CPU 高速缓存呢？</strong></p>
<p>类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 <strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</strong></p>
<p>我们甚至可以把 <strong>内存可以看作外存的高速缓存</strong>，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。</p>
<p>总结：<strong>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</strong></p>
<p>为了更好地理解，我画了一个简单的 CPU Cache 示意图如下（实际上，现代的 CPU Cache 通常分为三层，分别叫 L1,L2,L3 Cache）:</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/303a300f-70dd-4ee1-9974-3f33affc6574.png" alt="CPU Cache" /></p>
<p><strong>CPU Cache 的工作方式：</strong></p>
<p>先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 <strong>内存缓存不一致性的问题</strong> ！比如我执行一个 i++操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。</p>
<p><strong>CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议或者其他手段来解决。</strong></p>
<h3 id="_2-2-讲一下-jmm-java-内存模型"> 2.2. 讲一下 JMM(Java 内存模型)</h3>
<p>在 JDK1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/0ac7e663-7db8-4b95-8d8e-7d2b179f67e8.png" alt="JMM(Java内存模型)" /></p>
<p>要解决这个问题，就需要把变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p>所以，<strong><code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/d49c5557-140b-4abf-adad-8aac3c9036cf.png" alt="volatile关键字的可见性" /></p>
<h3 id="_2-3-并发编程的三个重要特性"> 2.3. 并发编程的三个重要特性</h3>
<ol>
<li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li>
<li><strong>可见性</strong> ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li>
<li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li>
</ol>
<h3 id="_2-4-说说-synchronized-关键字和-volatile-关键字的区别"> 2.4. 说说 synchronized 关键字和 volatile 关键字的区别</h3>
<p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile</code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li>
<li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li>
<li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
<h2 id="_3-threadlocal"> 3. ThreadLocal</h2>
<h3 id="_3-1-threadlocal-简介"> 3.1. ThreadLocal 简介</h3>
<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK 中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p>
<p>再举个简单的例子：</p>
<p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p>
<h3 id="_3-2-threadlocal-示例"> 3.2. ThreadLocal 示例</h3>
<p>相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。</p>
<div><pre><code><span>import</span> <span>java<span>.</span>text<span>.</span></span><span>SimpleDateFormat</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Random</span><span>;</span>

<span>public</span> <span>class</span> <span>ThreadLocalExample</span> <span>implements</span> <span>Runnable</span><span>{</span>

     <span>// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span>
    <span>private</span> <span>static</span> <span>final</span> <span>ThreadLocal</span><span><span>&lt;</span><span>SimpleDateFormat</span><span>></span></span> formatter <span>=</span> <span>ThreadLocal</span><span>.</span><span>withInitial</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyyMMdd HHmm"</span><span>)</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>ThreadLocalExample</span> obj <span>=</span> <span>new</span> <span>ThreadLocalExample</span><span>(</span><span>)</span><span>;</span>
        <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span> <span>;</span> i<span>&lt;</span><span>10</span><span>;</span> i<span>++</span><span>)</span><span>{</span>
            <span>Thread</span> t <span>=</span> <span>new</span> <span>Thread</span><span>(</span>obj<span>,</span> <span>""</span><span>+</span>i<span>)</span><span>;</span>
            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>new</span> <span>Random</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>)</span><span>)</span><span>;</span>
            t<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Thread Name= "</span><span>+</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>" default Formatter = "</span><span>+</span>formatter<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>toPattern</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>new</span> <span>Random</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>)</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>//formatter pattern is changed here by thread, but it won't reflect to other threads</span>
        formatter<span>.</span><span>set</span><span>(</span><span>new</span> <span>SimpleDateFormat</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Thread Name= "</span><span>+</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>" formatter = "</span><span>+</span>formatter<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>toPattern</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>Output:</p>
<div><pre><code>Thread Name= 0 default Formatter = yyyyMMdd HHmm
Thread Name= 0 formatter = yy-M-d ah:mm
Thread Name= 1 default Formatter = yyyyMMdd HHmm
Thread Name= 2 default Formatter = yyyyMMdd HHmm
Thread Name= 1 formatter = yy-M-d ah:mm
Thread Name= 3 default Formatter = yyyyMMdd HHmm
Thread Name= 2 formatter = yy-M-d ah:mm
Thread Name= 4 default Formatter = yyyyMMdd HHmm
Thread Name= 3 formatter = yy-M-d ah:mm
Thread Name= 4 formatter = yy-M-d ah:mm
Thread Name= 5 default Formatter = yyyyMMdd HHmm
Thread Name= 5 formatter = yy-M-d ah:mm
Thread Name= 6 default Formatter = yyyyMMdd HHmm
Thread Name= 6 formatter = yy-M-d ah:mm
Thread Name= 7 default Formatter = yyyyMMdd HHmm
Thread Name= 7 formatter = yy-M-d ah:mm
Thread Name= 8 default Formatter = yyyyMMdd HHmm
Thread Name= 9 default Formatter = yyyyMMdd HHmm
Thread Name= 8 formatter = yy-M-d ah:mm
Thread Name= 9 formatter = yy-M-d ah:mm
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>从输出中可以看出，Thread-0 已经改变了 formatter 的值，但仍然是 thread-2 默认格式化程序与初始化值相同，其他线程也一样。</p>
<p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA 会提示你转换为 Java8 的格式(IDEA 真的不错！)。因为 ThreadLocal 类在 Java 8 中扩展，使用一个新的方法<code>withInitial()</code>，将 Supplier 功能接口作为参数。</p>
<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>ThreadLocal</span><span><span>&lt;</span><span>SimpleDateFormat</span><span>></span></span> formatter <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>SimpleDateFormat</span><span>></span></span><span>(</span><span>)</span><span>{</span>
    <span>@Override</span>
    <span>protected</span> <span>SimpleDateFormat</span> <span>initialValue</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyyMMdd HHmm"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_3-3-threadlocal-原理"> 3.3. ThreadLocal 原理</h3>
<p>从 <code>Thread</code>类源代码入手。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Thread</span> <span>implements</span> <span>Runnable</span> <span>{</span>
    <span>//......</span>
    <span>//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span>
    <span>ThreadLocal<span>.</span>ThreadLocalMap</span> threadLocals <span>=</span> <span>null</span><span>;</span>

    <span>//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span>
    <span>ThreadLocal<span>.</span>ThreadLocalMap</span> inheritableThreadLocals <span>=</span> <span>null</span><span>;</span>
    <span>//......</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>
<p><code>ThreadLocal</code>类的<code>set()</code>方法</p>
<div><pre><code><span>public</span> <span>void</span> <span>set</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>
    <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>
    <span>ThreadLocalMap</span> map <span>=</span> <span>getMap</span><span>(</span>t<span>)</span><span>;</span>
    <span>if</span> <span>(</span>map <span>!=</span> <span>null</span><span>)</span>
        map<span>.</span><span>set</span><span>(</span><span>this</span><span>,</span> value<span>)</span><span>;</span>
    <span>else</span>
        <span>createMap</span><span>(</span>t<span>,</span> value<span>)</span><span>;</span>
<span>}</span>
<span>ThreadLocalMap</span> <span>getMap</span><span>(</span><span>Thread</span> t<span>)</span> <span>{</span>
    <span>return</span> t<span>.</span>threadLocals<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>
<div><pre><code><span>ThreadLocalMap</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> firstKey<span>,</span> <span>Object</span> firstValue<span>)</span> <span>{</span>
    <span>//......</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code>内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p>
<p><img src="./images/threadlocal数据结构.png" alt="ThreadLocal数据结构" /></p>
<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p>
<p><img src="./images/ThreadLocal内部类.png" alt="ThreadLocal内部类" /></p>
<h3 id="_3-4-threadlocal-内存泄露问题"> 3.4. ThreadLocal 内存泄露问题</h3>
<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<div><pre><code><span>static</span> <span>class</span> <span>Entry</span> <span>extends</span> <span>WeakReference</span><span><span>&lt;</span><span>ThreadLocal</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> <span>{</span>
    <span>/** The value associated with this ThreadLocal. */</span>
    <span>Object</span> value<span>;</span>

    <span>Entry</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k<span>,</span> <span>Object</span> v<span>)</span> <span>{</span>
        <span>super</span><span>(</span>k<span>)</span><span>;</span>
        value <span>=</span> v<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>弱引用介绍：</strong></p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<h2 id="_4-线程池"> 4. 线程池</h2>
<h3 id="_4-1-为什么要用线程池"> 4.1. 为什么要用线程池？</h3>
<blockquote>
<p><strong>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p>
</blockquote>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="_4-2-实现-runnable-接口和-callable-接口的区别"> 4.2. 实现 Runnable 接口和 Callable 接口的区别</h3>
<p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong><code>Runnable</code> 接口</strong> 不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong> 可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong> ，这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现将 <code>Runnable</code> 对象转换成 <code>Callable</code> 对象。（<code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>）。</p>
<p><code>Runnable.java</code></p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Runnable</span> <span>{</span>
   <span>/**
    * 被线程执行，没有返回值也无法抛出异常
    */</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>Callable.java</code></p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Callable</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>
    <span>/**
     * 计算结果，或在无法这样做时抛出异常。
     * @return 计算得出的结果
     * @throws 如果无法计算结果，则抛出异常
     */</span>
    <span>V</span> <span>call</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="_4-3-执行-execute-方法和-submit-方法的区别是什么呢"> 4.3. 执行 execute()方法和 submit()方法的区别是什么呢？</h3>
<ol>
<li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
<p>我们以 <strong><code>AbstractExecutorService</code> 接口</strong> 中的一个 <code>submit</code> 方法为例子来看看源代码：</p>
<div><pre><code><span>public</span> <span>Future</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>submit</span><span>(</span><span>Runnable</span> task<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>task <span>==</span> <span>null</span><span>)</span> <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
    <span>RunnableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> ftask <span>=</span> <span>newTaskFor</span><span>(</span>task<span>,</span> <span>null</span><span>)</span><span>;</span>
    <span>execute</span><span>(</span>ftask<span>)</span><span>;</span>
    <span>return</span> ftask<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p>
<div><pre><code><span>protected</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>RunnableFuture</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>newTaskFor</span><span>(</span><span>Runnable</span> runnable<span>,</span> <span>T</span> value<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>FutureTask</span><span><span>&lt;</span><span>T</span><span>></span></span><span>(</span>runnable<span>,</span> value<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们再来看看<code>execute()</code>方法：</p>
<div><pre><code><span>public</span> <span>void</span> <span>execute</span><span>(</span><span>Runnable</span> command<span>)</span> <span>{</span>
  <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_4-4-如何创建线程池"> 4.4. 如何创建线程池</h3>
<p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
</blockquote>
<p><strong>方式一：通过构造方法实现</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ThreadPoolExecutor构造方法.png" alt="ThreadPoolExecutor构造方法" /></p>
<p><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong></p>
<p>我们可以创建三种类型的 ThreadPoolExecutor：</p>
<ul>
<li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<p>对应 Executors 工具类中的方法如图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Executor框架的工具类.png" alt="Executor框架的工具类" /></p>
<h3 id="_4-5-threadpoolexecutor-类分析"> 4.5 ThreadPoolExecutor 类分析</h3>
<p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p>
<div><pre><code><span>/**
 * 用给定的初始参数创建一个新的ThreadPoolExecutor。
 */</span>
<span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>
                      <span>int</span> maximumPoolSize<span>,</span>
                      <span>long</span> keepAliveTime<span>,</span>
                      <span>TimeUnit</span> unit<span>,</span>
                      <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span>
                      <span>ThreadFactory</span> threadFactory<span>,</span>
                      <span>RejectedExecutionHandler</span> handler<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>corePoolSize <span>&lt;</span> <span>0</span> <span>||</span>
        maximumPoolSize <span>&lt;=</span> <span>0</span> <span>||</span>
        maximumPoolSize <span>&lt;</span> corePoolSize <span>||</span>
        keepAliveTime <span>&lt;</span> <span>0</span><span>)</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>workQueue <span>==</span> <span>null</span> <span>||</span> threadFactory <span>==</span> <span>null</span> <span>||</span> handler <span>==</span> <span>null</span><span>)</span>
        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
    <span>this</span><span>.</span>corePoolSize <span>=</span> corePoolSize<span>;</span>
    <span>this</span><span>.</span>maximumPoolSize <span>=</span> maximumPoolSize<span>;</span>
    <span>this</span><span>.</span>workQueue <span>=</span> workQueue<span>;</span>
    <span>this</span><span>.</span>keepAliveTime <span>=</span> unit<span>.</span><span>toNanos</span><span>(</span>keepAliveTime<span>)</span><span>;</span>
    <span>this</span><span>.</span>threadFactory <span>=</span> threadFactory<span>;</span>
    <span>this</span><span>.</span>handler <span>=</span> handler<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>下面这些对创建 非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。</strong></p>
<h4 id="_4-5-1-threadpoolexecutor构造函数重要参数分析"> 4.5.1 <code>ThreadPoolExecutor</code>构造函数重要参数分析</h4>
<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ol>
<h4 id="_4-5-2-threadpoolexecutor-饱和策略"> 4.5.2 <code>ThreadPoolExecutor</code> 饱和策略</h4>
<p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<p>举个例子： Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p>
<h3 id="_4-6-一个简单的线程池-demo"> 4.6 一个简单的线程池 Demo</h3>
<p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。</p>
<p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p>
<p><code>MyRunnable.java</code></p>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Date</span><span>;</span>

<span>/**
 * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。
 * @author shuang.kou
 */</span>
<span>public</span> <span>class</span> <span>MyRunnable</span> <span>implements</span> <span>Runnable</span> <span>{</span>

    <span>private</span> <span>String</span> command<span>;</span>

    <span>public</span> <span>MyRunnable</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>this</span><span>.</span>command <span>=</span> s<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" Start. Time = "</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>processCommand</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" End. Time = "</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>processCommand</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>command<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p>
<p><code>ThreadPoolExecutorDemo.java</code></p>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>ArrayBlockingQueue</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>ThreadPoolExecutor</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>TimeUnit</span><span>;</span>

<span>public</span> <span>class</span> <span>ThreadPoolExecutorDemo</span> <span>{</span>

    <span>private</span> <span>static</span> <span>final</span> <span>int</span> CORE_POOL_SIZE <span>=</span> <span>5</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_POOL_SIZE <span>=</span> <span>10</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> QUEUE_CAPACITY <span>=</span> <span>100</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Long</span> KEEP_ALIVE_TIME <span>=</span> <span>1L</span><span>;</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>//使用阿里巴巴推荐的创建线程池的方式</span>
        <span>//通过ThreadPoolExecutor构造函数自定义参数创建</span>
        <span>ThreadPoolExecutor</span> executor <span>=</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>
                CORE_POOL_SIZE<span>,</span>
                MAX_POOL_SIZE<span>,</span>
                KEEP_ALIVE_TIME<span>,</span>
                <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>
                <span>new</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>></span></span><span>(</span>QUEUE_CAPACITY<span>)</span><span>,</span>
                <span>new</span> <span>ThreadPoolExecutor<span>.</span>CallerRunsPolicy</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span>
            <span>Runnable</span> worker <span>=</span> <span>new</span> <span>MyRunnable</span><span>(</span><span>""</span> <span>+</span> i<span>)</span><span>;</span>
            <span>//执行Runnable</span>
            executor<span>.</span><span>execute</span><span>(</span>worker<span>)</span><span>;</span>
        <span>}</span>
        <span>//终止线程池</span>
        executor<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span><span>!</span>executor<span>.</span><span>isTerminated</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Finished all threads"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>可以看到我们上面的代码指定了：</p>
<ol>
<li><code>corePoolSize</code>: 核心线程数为 5。</li>
<li><code>maximumPoolSize</code> ：最大线程数 10</li>
<li><code>keepAliveTime</code> : 等待时间为 1L。</li>
<li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>
<li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li>
<li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li>
</ol>
<p><strong>Output：</strong></p>
<div><pre><code>pool-1-thread-3 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-5 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-2 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-1 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-4 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-3 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-4 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-1 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-5 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-1 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-2 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-5 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-4 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-3 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-2 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-1 End. Time = Sun Apr 12 11:14:47 CST 2020
pool-1-thread-4 End. Time = Sun Apr 12 11:14:47 CST 2020
pool-1-thread-5 End. Time = Sun Apr 12 11:14:47 CST 2020
pool-1-thread-3 End. Time = Sun Apr 12 11:14:47 CST 2020
pool-1-thread-2 End. Time = Sun Apr 12 11:14:47 CST 2020

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="_4-7-线程池原理分析"> 4.7 线程池原理分析</h3>
<p>承接 4.6 节，我们通过代码输出结果可以看出：<strong>线程池首先会先执行 5 个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。</strong> 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p>
<p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p>
<p><strong>为了搞懂线程池的原理，我们需要首先分析一下 <code>execute</code>方法。</strong> 在 4.6 节中的 Demo 中我们使用 <code>executor.execute(worker)</code>来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p>
<div><pre><code><span>// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span>
<span>private</span> <span>final</span> <span>AtomicInteger</span> ctl <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>ctlOf</span><span>(</span>RUNNING<span>,</span> <span>0</span><span>)</span><span>)</span><span>;</span>

<span>private</span> <span>static</span> <span>int</span> <span>workerCountOf</span><span>(</span><span>int</span> c<span>)</span> <span>{</span>
    <span>return</span> c <span>&amp;</span> CAPACITY<span>;</span>
<span>}</span>

<span>private</span> <span>final</span> <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>;</span>

<span>public</span> <span>void</span> <span>execute</span><span>(</span><span>Runnable</span> command<span>)</span> <span>{</span>
    <span>// 如果任务为null，则抛出异常。</span>
    <span>if</span> <span>(</span>command <span>==</span> <span>null</span><span>)</span>
        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
    <span>// ctl 中保存的线程池当前的一些状态信息</span>
    <span>int</span> c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>

    <span>//  下面会涉及到 3 步 操作</span>
    <span>// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span>
    <span>// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>
    <span>if</span> <span>(</span><span>workerCountOf</span><span>(</span>c<span>)</span> <span>&lt;</span> corePoolSize<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>addWorker</span><span>(</span>command<span>,</span> <span>true</span><span>)</span><span>)</span>
            <span>return</span><span>;</span>
        c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里</span>
    <span>// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span>
    <span>if</span> <span>(</span><span>isRunning</span><span>(</span>c<span>)</span> <span>&amp;&amp;</span> workQueue<span>.</span><span>offer</span><span>(</span>command<span>)</span><span>)</span> <span>{</span>
        <span>int</span> recheck <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
        <span>// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span>
        <span>if</span> <span>(</span><span>!</span><span>isRunning</span><span>(</span>recheck<span>)</span> <span>&amp;&amp;</span> <span>remove</span><span>(</span>command<span>)</span><span>)</span>
            <span>reject</span><span>(</span>command<span>)</span><span>;</span>
            <span>// 如果当前线程池为空就新创建一个线程并执行。</span>
        <span>else</span> <span>if</span> <span>(</span><span>workerCountOf</span><span>(</span>recheck<span>)</span> <span>==</span> <span>0</span><span>)</span>
            <span>addWorker</span><span>(</span><span>null</span><span>,</span> <span>false</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>
    <span>//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span>
    <span>else</span> <span>if</span> <span>(</span><span>!</span><span>addWorker</span><span>(</span>command<span>,</span> <span>false</span><span>)</span><span>)</span>
        <span>reject</span><span>(</span>command<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。</p>
<p><img src="./images/java线程池学习总结/图解线程池实现原理.png" alt="图解线程池实现原理" /></p>
<p>现在，让我们在回到 4.6 节我们写的 Demo， 现在是不是很容易就可以搞懂它的原理了呢？</p>
<p>没搞懂的话，也没关系，可以看看我的分析：</p>
<blockquote>
<p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的5个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p>
</blockquote>
<h2 id="_5-atomic-原子类"> 5. Atomic 原子类</h2>
<h3 id="_5-1-介绍一下-atomic-原子类"> 5.1. 介绍一下 Atomic 原子类</h3>
<p><code>Atomic</code> 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p>
<p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下,如下图所示。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JUC原子类概览.png" alt="JUC原子类概览" /></p>
<h3 id="_5-2-juc-包中的原子类是哪-4-类"> 5.2. JUC 包中的原子类是哪 4 类?</h3>
<p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整形原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整形字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整形字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li>
</ul>
<h3 id="_5-3-讲讲-atomicinteger-的使用"> 5.3. 讲讲 AtomicInteger 的使用</h3>
<p><strong>AtomicInteger 类常用方法</strong></p>
<div><pre><code><span>public</span> <span>final</span> <span>int</span> <span>get</span><span>(</span><span>)</span> <span>//获取当前的值</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndSet</span><span>(</span><span>int</span> newValue<span>)</span><span>//获取当前的值，并设置新的值</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndIncrement</span><span>(</span><span>)</span><span>//获取当前的值，并自增</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndDecrement</span><span>(</span><span>)</span> <span>//获取当前的值，并自减</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndAdd</span><span>(</span><span>int</span> delta<span>)</span> <span>//获取当前的值，并加上预期的值</span>
<span>boolean</span> <span>compareAndSet</span><span>(</span><span>int</span> expect<span>,</span> <span>int</span> update<span>)</span> <span>//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span>
<span>public</span> <span>final</span> <span>void</span> <span>lazySet</span><span>(</span><span>int</span> newValue<span>)</span><span>//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>AtomicInteger 类的使用示例</strong></p>
<p>使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。</p>
<div><pre><code><span>class</span> <span>AtomicIntegerTest</span> <span>{</span>
    <span>private</span> <span>AtomicInteger</span> count <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>
    <span>//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span>
    <span>public</span> <span>void</span> <span>increment</span><span>(</span><span>)</span> <span>{</span>
        count<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getCount</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> count<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_5-4-能不能给我简单介绍一下-atomicinteger-类的原理"> 5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理</h3>
<p>AtomicInteger 线程安全原理简单分析</p>
<p>AtomicInteger 类的部分源码：</p>
<div><pre><code><span>// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span>
<span>private</span> <span>static</span> <span>final</span> <span>Unsafe</span> unsafe <span>=</span> <span>Unsafe</span><span>.</span><span>getUnsafe</span><span>(</span><span>)</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>long</span> valueOffset<span>;</span>

<span>static</span> <span>{</span>
    <span>try</span> <span>{</span>
        valueOffset <span>=</span> unsafe<span>.</span>objectFieldOffset
            <span>(</span><span>AtomicInteger</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"value"</span><span>)</span><span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> ex<span>)</span> <span>{</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span>ex<span>)</span><span>;</span> <span>}</span>
<span>}</span>

<span>private</span> <span>volatile</span> <span>int</span> value<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<p>关于 Atomic 原子类这部分更多内容可以查看我的这篇文章：并发编程面试必备：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484834&amp;idx=1&amp;sn=7d3835091af8125c13fc6db765f4c5bd&amp;source=41#wechat_redirect" target="_blank" rel="noopener noreferrer">JUC 中的 Atomic 原子类总结</a></p>
<h2 id="_6-aqs"> 6. AQS</h2>
<h3 id="_6-1-aqs-介绍"> 6.1. AQS 介绍</h3>
<p>AQS 的全称为（<code>AbstractQueuedSynchronizer</code>），这个类在<code>java.util.concurrent.locks</code>包下面。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/AQS类.png" alt="AQS类" /></p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h3 id="_6-2-aqs-原理分析"> 6.2. AQS 原理分析</h3>
<p>AQS 原理这部分参考了部分博客，在 5.2 节末尾放了链接。</p>
<blockquote>
<p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参加，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p>
</blockquote>
<p>下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p>
<h4 id="_6-2-1-aqs-原理概览"> 6.2.1. AQS 原理概览</h4>
<p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<blockquote>
<p>CLH(Craig,Landin and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>看个 AQS(AbstractQueuedSynchronizer)原理图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/AQS原理图.png" alt="AQS原理图" /></p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<div><pre><code><span>private</span> <span>volatile</span> <span>int</span> state<span>;</span><span>//共享变量，使用volatile修饰保证线程可见性</span>
</code></pre>
<div><span>1</span><br></div></div><p>状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作</p>
<div><pre><code>
<span>//返回同步状态的当前值</span>
<span>protected</span> <span>final</span> <span>int</span> <span>getState</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> state<span>;</span>
<span>}</span>
<span>//设置同步状态的值</span>
<span>protected</span> <span>final</span> <span>void</span> <span>setState</span><span>(</span><span>int</span> newState<span>)</span> <span>{</span>
    state <span>=</span> newState<span>;</span>
<span>}</span>
<span>//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span>
<span>protected</span> <span>final</span> <span>boolean</span> <span>compareAndSetState</span><span>(</span><span>int</span> expect<span>,</span> <span>int</span> update<span>)</span> <span>{</span>
    <span>return</span> unsafe<span>.</span><span>compareAndSwapInt</span><span>(</span><span>this</span><span>,</span> stateOffset<span>,</span> expect<span>,</span> update<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="_6-2-2-aqs-对资源的共享方式"> 6.2.2. AQS 对资源的共享方式</h4>
<p><strong>AQS 定义两种资源共享方式</strong></p>
<ul>
<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 <code>ReentrantLock</code>。又可分为公平锁和非公平锁：
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><strong>Share</strong>（共享）：多个线程可同时执行，如<code>CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 我们都会在后面讲到。</li>
</ul>
<p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。</p>
<h4 id="_6-2-3-aqs-底层使用了模板方法模式"> 6.2.3. AQS 底层使用了模板方法模式</h4>
<p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p>
<div><pre><code><span>protected</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>int</span><span>)</span><span>//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span>
<span>protected</span> <span>boolean</span> <span>tryRelease</span><span>(</span><span>int</span><span>)</span><span>//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span>protected</span> <span>boolean</span> <span>tryAcquireShared</span><span>(</span><span>int</span><span>)</span><span>//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span>
<span>protected</span> <span>boolean</span> <span>tryReleaseShared</span><span>(</span><span>int</span><span>)</span><span>//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span>protected</span> <span>boolean</span> <span>isHeldExclusively</span><span>(</span><span>)</span><span>//该线程是否正在独占资源。只有用到condition才需要去实现它。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p>
<p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后<code>countDown()</code> 一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>
<ul>
<li>https://www.cnblogs.com/waterystone/p/4920797.html</li>
<li>https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</li>
</ul>
<h3 id="_6-3-aqs-组件总结"> 6.3. AQS 组件总结</h3>
<ul>
<li><strong><code>Semaphore</code>(信号量)-允许多个线程同时访问：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong><code>CountDownLatch</code>（倒计时器）：</strong>  <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。<code>CyclicBarrier</code> 的字面意思是可循环使用（<code>Cyclic</code>）的屏障（<code>Barrier</code>）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h3 id="_6-4-用过-countdownlatch-么-什么场景下用的"> 6.4. 用过 CountDownLatch 么？什么场景下用的？</h3>
<p><code>CountDownLatch</code> 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p>
<p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>
<p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>
<p>伪代码是下面这样的：</p>
<div><pre><code><span>public</span> <span>class</span> <span>CountDownLatchExample1</span> <span>{</span>
    <span>// 处理文件的数量</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> threadCount <span>=</span> <span>6</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span>
        <span>ExecutorService</span> threadPool <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>10</span><span>)</span><span>;</span>
        <span>final</span> <span>CountDownLatch</span> countDownLatch <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span>threadCount<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> threadCount<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>final</span> <span>int</span> threadnum <span>=</span> i<span>;</span>
            threadPool<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
                <span>try</span> <span>{</span>
                    <span>//处理文件的业务操作</span>
                    <span>//......</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span> <span>finally</span> <span>{</span>
                    <span>//表示一个文件已经被完成</span>
                    countDownLatch<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>

            <span>}</span><span>)</span><span>;</span>
        <span>}</span>
        countDownLatch<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
        threadPool<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"finish"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><strong>有没有可以改进的地方呢？</strong></p>
<p>可以使用 <code>CompletableFuture</code> 类来改进！Java8 的 <code>CompletableFuture</code> 提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。</p>
<div><pre><code><span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> task1 <span>=</span>
    <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span><span>-></span><span>{</span>
        <span>//自定义业务操作</span>
    <span>}</span><span>)</span><span>;</span>
<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> task6 <span>=</span>
    <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span><span>-></span><span>{</span>
    <span>//自定义业务操作</span>
    <span>}</span><span>)</span><span>;</span>
<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> headerFuture<span>=</span><span>CompletableFuture</span><span>.</span><span>allOf</span><span>(</span>task1<span>,</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>,</span>task6<span>)</span><span>;</span>

<span>try</span> <span>{</span>
    headerFuture<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span><span>Exception</span> ex<span>)</span> <span>{</span>
    <span>//......</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"all done. "</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>上面的代码还可以接续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑通过循环来添加任务。</p>
<div><pre><code><span>//文件夹位置</span>
<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> filePaths <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span>
<span>// 异步处理所有文件</span>
<span>List</span><span><span>&lt;</span><span>CompletableFuture</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> fileFutures <span>=</span> filePaths<span>.</span><span>stream</span><span>(</span><span>)</span>
    <span>.</span><span>map</span><span>(</span>filePath <span>-></span> <span>doSomeThing</span><span>(</span>filePath<span>)</span><span>)</span>
    <span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>// 将他们合并起来</span>
<span>CompletableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> allFutures <span>=</span> <span>CompletableFuture</span><span>.</span><span>allOf</span><span>(</span>
    fileFutures<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>CompletableFuture</span><span>[</span>fileFutures<span>.</span><span>size</span><span>(</span><span>)</span><span>]</span><span>)</span>
<span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="_7-reference"> 7 Reference</h2>
<ul>
<li>《深入理解 Java 虚拟机》</li>
<li>《实战 Java 高并发程序设计》</li>
<li>《Java 并发编程的艺术》</li>
<li>https://www.cnblogs.com/waterystone/p/4920797.html</li>
<li>https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</li>
<li><a href="https://www.journaldev.com/1076/java-threadlocal-example" target="_blank" rel="noopener noreferrer">https://www.journaldev.com/1076/java-threadlocal-example</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java线程池学习总结</title>
      <link>https://javaguide.cn/java/concurrent/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/java/concurrent/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">Java线程池学习总结</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="一-使用线程池的好处"> 一 使用线程池的好处</h2>
<blockquote>
<p><strong>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p>
</blockquote>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h2 id="二-executor-框架"> 二 Executor 框架</h2>
<h3 id="_2-1-简介"> 2.1 简介</h3>
<p><code>Executor</code> 框架是 Java5 之后引进的，在 Java 5 之后，通过 <code>Executor</code> 来启动线程比使用 <code>Thread</code> 的 <code>start</code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p>
<blockquote>
<p>补充：this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p>
</blockquote>
<p><code>Executor</code> 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，<code>Executor</code> 框架让并发编程变得更加简单。</p>
<h3 id="_2-2-executor-框架结构-主要由三大部分组成"> 2.2 Executor 框架结构(主要由三大部分组成)</h3>
<h4 id="_1-任务-runnable-callable"> 1) 任务(<code>Runnable</code> /<code>Callable</code>)</h4>
<p>执行任务需要实现的 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code>接口</strong>。<strong><code>Runnable</code> 接口</strong>或 <strong><code>Callable</code> 接口</strong> 实现类都可以被 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。</p>
<h4 id="_2-任务的执行-executor"> 2) 任务的执行(<code>Executor</code>)</h4>
<p>如下图所示，包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <code>Executor</code> 接口的 <strong><code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code></strong> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong>ExecutorService 接口</strong>。</p>
<p><strong>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 <code>ThreadPoolExecutor</code> 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。</strong></p>
<blockquote>
<p><strong>注意：</strong> 通过查看 <code>ScheduledThreadPoolExecutor</code> 源代码我们发现 <code>ScheduledThreadPoolExecutor</code> 实际上是继承了 <code>ThreadPoolExecutor</code> 并实现了 ScheduledExecutorService ，而 <code>ScheduledExecutorService</code> 又实现了 <code>ExecutorService</code>，正如我们下面给出的类关系图显示的一样。</p>
</blockquote>
<p><strong><code>ThreadPoolExecutor</code> 类描述:</strong></p>
<div><pre><code><span>//AbstractExecutorService实现了ExecutorService接口</span>
<span>public</span> <span>class</span> <span>ThreadPoolExecutor</span> <span>extends</span> <span>AbstractExecutorService</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong><code>ScheduledThreadPoolExecutor</code> 类描述:</strong></p>
<div><pre><code><span>//ScheduledExecutorService继承ExecutorService接口</span>
<span>public</span> <span>class</span> <span>ScheduledThreadPoolExecutor</span>
        <span>extends</span> <span>ThreadPoolExecutor</span>
        <span>implements</span> <span>ScheduledExecutorService</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="./images/java线程池学习总结/任务的执行相关接口.png" alt="任务的执行相关接口" /></p>
<h4 id="_3-异步计算的结果-future"> 3) 异步计算的结果(<code>Future</code>)</h4>
<p><strong><code>Future</code></strong> 接口以及 <code>Future</code> 接口的实现类 <strong><code>FutureTask</code></strong> 类都可以代表异步计算的结果。</p>
<p>当我们把 <strong><code>Runnable</code>接口</strong> 或 <strong><code>Callable</code> 接口</strong> 的实现类提交给 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。（调用 <code>submit()</code> 方法时会返回一个 <strong><code>FutureTask</code></strong> 对象）</p>
<h3 id="_2-3-executor-框架的使用示意图"> 2.3 Executor 框架的使用示意图</h3>
<p><img src="./images/java线程池学习总结/Executor框架的使用示意图.png" alt="Executor 框架的使用示意图" /></p>
<ol>
<li><strong>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</strong></li>
<li><strong>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行</strong>: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li>
<li><strong>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象</strong>（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li>
<li><strong>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</strong></li>
</ol>
<h2 id="三-重要-threadpoolexecutor-类简单介绍"> 三 (重要)ThreadPoolExecutor 类简单介绍</h2>
<p><strong>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</strong></p>
<h3 id="_3-1-threadpoolexecutor-类分析"> 3.1 ThreadPoolExecutor 类分析</h3>
<p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么）。</p>
<div><pre><code>    <span>/**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */</span>
    <span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span><span>//线程池的核心线程数量</span>
                              <span>int</span> maximumPoolSize<span>,</span><span>//线程池的最大线程数</span>
                              <span>long</span> keepAliveTime<span>,</span><span>//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span>
                              <span>TimeUnit</span> unit<span>,</span><span>//时间单位</span>
                              <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span><span>//任务队列，用来储存等待执行任务的队列</span>
                              <span>ThreadFactory</span> threadFactory<span>,</span><span>//线程工厂，用来创建线程，一般默认即可</span>
                              <span>RejectedExecutionHandler</span> handler<span>//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>
                               <span>)</span> <span>{</span>
        <span>if</span> <span>(</span>corePoolSize <span>&lt;</span> <span>0</span> <span>||</span>
            maximumPoolSize <span>&lt;=</span> <span>0</span> <span>||</span>
            maximumPoolSize <span>&lt;</span> corePoolSize <span>||</span>
            keepAliveTime <span>&lt;</span> <span>0</span><span>)</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>workQueue <span>==</span> <span>null</span> <span>||</span> threadFactory <span>==</span> <span>null</span> <span>||</span> handler <span>==</span> <span>null</span><span>)</span>
            <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>corePoolSize <span>=</span> corePoolSize<span>;</span>
        <span>this</span><span>.</span>maximumPoolSize <span>=</span> maximumPoolSize<span>;</span>
        <span>this</span><span>.</span>workQueue <span>=</span> workQueue<span>;</span>
        <span>this</span><span>.</span>keepAliveTime <span>=</span> unit<span>.</span><span>toNanos</span><span>(</span>keepAliveTime<span>)</span><span>;</span>
        <span>this</span><span>.</span>threadFactory <span>=</span> threadFactory<span>;</span>
        <span>this</span><span>.</span>handler <span>=</span> handler<span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>下面这些对创建非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。</p>
<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ol>
<p>下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《Java 性能调优实战》）：</p>
<p><img src="./images/java线程池学习总结/线程池各个参数之间的关系.png" alt="线程池各个参数的关系" /></p>
<p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong> ：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code></strong> ：不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code></strong> ： 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<p>举个例子：</p>
<blockquote>
<p>Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了。）</p>
</blockquote>
<h3 id="_3-2-推荐使用-threadpoolexecutor-构造函数创建线程池"> 3.2 推荐使用 <code>ThreadPoolExecutor</code> 构造函数创建线程池</h3>
<p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>
<p><strong>为什么呢？</strong></p>
<blockquote>
<p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
</blockquote>
<p>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<blockquote>
<p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
</blockquote>
<p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数实现（推荐）</strong>
<img src="./images/java线程池学习总结/threadpoolexecutor构造函数.png" alt="通过构造方法实现" /></p>
<p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现</strong>
我们可以创建三种类型的 <code>ThreadPoolExecutor</code>：</p>
<ul>
<li><code>FixedThreadPool</code></li>
<li><code>SingleThreadExecutor</code></li>
<li>CachedThreadPool</li>
</ul>
<p>对应 Executors 工具类中的方法如图所示：</p>
<p><img src="./images/java线程池学习总结/Executors工具类.png" alt="通过Executor 框架的工具类Executors来实现" /></p>
<h2 id="四-threadpoolexecutor-使用-原理分析"> 四 ThreadPoolExecutor 使用+原理分析</h2>
<p>我们上面讲解了 <code>Executor</code>框架以及 <code>ThreadPoolExecutor</code> 类，下面让我们实战一下，来通过写一个 <code>ThreadPoolExecutor</code> 的小 Demo 来回顾上面的内容。</p>
<h3 id="_4-1-示例代码-runnable-threadpoolexecutor"> 4.1 示例代码:<code>Runnable</code>+<code>ThreadPoolExecutor</code></h3>
<p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p>
<p><code>MyRunnable.java</code></p>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Date</span><span>;</span>

<span>/**
 * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。
 * @author shuang.kou
 */</span>
<span>public</span> <span>class</span> <span>MyRunnable</span> <span>implements</span> <span>Runnable</span> <span>{</span>

    <span>private</span> <span>String</span> command<span>;</span>

    <span>public</span> <span>MyRunnable</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>this</span><span>.</span>command <span>=</span> s<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" Start. Time = "</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>processCommand</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" End. Time = "</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>processCommand</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>command<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p>
<p><code>ThreadPoolExecutorDemo.java</code></p>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>ArrayBlockingQueue</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>ThreadPoolExecutor</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>TimeUnit</span><span>;</span>

<span>public</span> <span>class</span> <span>ThreadPoolExecutorDemo</span> <span>{</span>

    <span>private</span> <span>static</span> <span>final</span> <span>int</span> CORE_POOL_SIZE <span>=</span> <span>5</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_POOL_SIZE <span>=</span> <span>10</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> QUEUE_CAPACITY <span>=</span> <span>100</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Long</span> KEEP_ALIVE_TIME <span>=</span> <span>1L</span><span>;</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>//使用阿里巴巴推荐的创建线程池的方式</span>
        <span>//通过ThreadPoolExecutor构造函数自定义参数创建</span>
        <span>ThreadPoolExecutor</span> executor <span>=</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>
                CORE_POOL_SIZE<span>,</span>
                MAX_POOL_SIZE<span>,</span>
                KEEP_ALIVE_TIME<span>,</span>
                <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>
                <span>new</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>></span></span><span>(</span>QUEUE_CAPACITY<span>)</span><span>,</span>
                <span>new</span> <span>ThreadPoolExecutor<span>.</span>CallerRunsPolicy</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span>
            <span>Runnable</span> worker <span>=</span> <span>new</span> <span>MyRunnable</span><span>(</span><span>""</span> <span>+</span> i<span>)</span><span>;</span>
            <span>//执行Runnable</span>
            executor<span>.</span><span>execute</span><span>(</span>worker<span>)</span><span>;</span>
        <span>}</span>
        <span>//终止线程池</span>
        executor<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span><span>!</span>executor<span>.</span><span>isTerminated</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Finished all threads"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>可以看到我们上面的代码指定了：</p>
<ol>
<li><code>corePoolSize</code>: 核心线程数为 5。</li>
<li><code>maximumPoolSize</code> ：最大线程数 10</li>
<li><code>keepAliveTime</code> : 等待时间为 1L。</li>
<li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>
<li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li>
<li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li>
</ol>
<p><strong>Output：</strong></p>
<div><pre><code>pool-1-thread-3 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-5 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-2 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-1 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-4 Start. Time = Sun Apr 12 11:14:37 CST 2020
pool-1-thread-3 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-4 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-1 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-5 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-1 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-2 End. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-5 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-4 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-3 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-2 Start. Time = Sun Apr 12 11:14:42 CST 2020
pool-1-thread-1 End. Time = Sun Apr 12 11:14:47 CST 2020
pool-1-thread-4 End. Time = Sun Apr 12 11:14:47 CST 2020
pool-1-thread-5 End. Time = Sun Apr 12 11:14:47 CST 2020
pool-1-thread-3 End. Time = Sun Apr 12 11:14:47 CST 2020
pool-1-thread-2 End. Time = Sun Apr 12 11:14:47 CST 2020

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="_4-2-线程池原理分析"> 4.2 线程池原理分析</h3>
<p>承接 4.1 节，我们通过代码输出结果可以看出：<strong>线程池首先会先执行 5 个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。</strong> 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p>
<p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p>
<p><strong>为了搞懂线程池的原理，我们需要首先分析一下 <code>execute</code>方法。</strong> 在 4.1 节中的 Demo 中我们使用 <code>executor.execute(worker)</code>来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p>
<div><pre><code>   <span>// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span>
   <span>private</span> <span>final</span> <span>AtomicInteger</span> ctl <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>ctlOf</span><span>(</span>RUNNING<span>,</span> <span>0</span><span>)</span><span>)</span><span>;</span>

    <span>private</span> <span>static</span> <span>int</span> <span>workerCountOf</span><span>(</span><span>int</span> c<span>)</span> <span>{</span>
        <span>return</span> c <span>&amp;</span> CAPACITY<span>;</span>
    <span>}</span>
    <span>//任务队列</span>
    <span>private</span> <span>final</span> <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>;</span>

    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>Runnable</span> command<span>)</span> <span>{</span>
        <span>// 如果任务为null，则抛出异常。</span>
        <span>if</span> <span>(</span>command <span>==</span> <span>null</span><span>)</span>
            <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
        <span>// ctl 中保存的线程池当前的一些状态信息</span>
        <span>int</span> c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>

        <span>//  下面会涉及到 3 步 操作</span>
        <span>// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span>
        <span>// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>
        <span>if</span> <span>(</span><span>workerCountOf</span><span>(</span>c<span>)</span> <span>&lt;</span> corePoolSize<span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>addWorker</span><span>(</span>command<span>,</span> <span>true</span><span>)</span><span>)</span>
                <span>return</span><span>;</span>
            c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span>
        <span>// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span>
        <span>if</span> <span>(</span><span>isRunning</span><span>(</span>c<span>)</span> <span>&amp;&amp;</span> workQueue<span>.</span><span>offer</span><span>(</span>command<span>)</span><span>)</span> <span>{</span>
            <span>int</span> recheck <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
            <span>// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span>
            <span>if</span> <span>(</span><span>!</span><span>isRunning</span><span>(</span>recheck<span>)</span> <span>&amp;&amp;</span> <span>remove</span><span>(</span>command<span>)</span><span>)</span>
                <span>reject</span><span>(</span>command<span>)</span><span>;</span>
                <span>// 如果当前线程池为空就新创建一个线程并执行。</span>
            <span>else</span> <span>if</span> <span>(</span><span>workerCountOf</span><span>(</span>recheck<span>)</span> <span>==</span> <span>0</span><span>)</span>
                <span>addWorker</span><span>(</span><span>null</span><span>,</span> <span>false</span><span>)</span><span>;</span>
        <span>}</span>
        <span>//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>
        <span>//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span>
        <span>else</span> <span>if</span> <span>(</span><span>!</span><span>addWorker</span><span>(</span>command<span>,</span> <span>false</span><span>)</span><span>)</span>
            <span>reject</span><span>(</span>command<span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/图解线程池实现原理.png" alt="图解线程池实现原理" /></p>
<p><strong><code>addWorker</code> 这个方法主要用来创建新的工作线程，如果返回 true 说明创建和启动工作线程成功，否则的话返回的就是 false。</strong></p>
<div><pre><code>    <span>// 全局锁，并发操作必备</span>
    <span>private</span> <span>final</span> <span>ReentrantLock</span> mainLock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>
    <span>// 跟踪线程池的最大大小，只有在持有全局锁mainLock的前提下才能访问此集合</span>
    <span>private</span> <span>int</span> largestPoolSize<span>;</span>
    <span>// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span>
    <span>private</span> <span>final</span> <span>HashSet</span><span><span>&lt;</span><span>Worker</span><span>></span></span> workers <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>//获取线程池状态</span>
    <span>private</span> <span>static</span> <span>int</span> <span>runStateOf</span><span>(</span><span>int</span> c<span>)</span>     <span>{</span> <span>return</span> c <span>&amp;</span> <span>~</span>CAPACITY<span>;</span> <span>}</span>
    <span>//判断线程池的状态是否为 Running</span>
    <span>private</span> <span>static</span> <span>boolean</span> <span>isRunning</span><span>(</span><span>int</span> c<span>)</span> <span>{</span>
        <span>return</span> c <span>&lt;</span> SHUTDOWN<span>;</span>
    <span>}</span>


    <span>/**
     * 添加新的工作线程到线程池
     * @param firstTask 要执行
     * @param core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小
     * @return 添加成功就返回true否则返回false
     */</span>
   <span>private</span> <span>boolean</span> <span>addWorker</span><span>(</span><span>Runnable</span> firstTask<span>,</span> <span>boolean</span> core<span>)</span> <span>{</span>
        retry<span>:</span>
        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
            <span>//这两句用来获取线程池的状态</span>
            <span>int</span> c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
            <span>int</span> rs <span>=</span> <span>runStateOf</span><span>(</span>c<span>)</span><span>;</span>

            <span>// Check if queue empty only if necessary.</span>
            <span>if</span> <span>(</span>rs <span>>=</span> SHUTDOWN <span>&amp;&amp;</span>
                <span>!</span> <span>(</span>rs <span>==</span> SHUTDOWN <span>&amp;&amp;</span>
                   firstTask <span>==</span> <span>null</span> <span>&amp;&amp;</span>
                   <span>!</span> workQueue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>)</span>
                <span>return</span> <span>false</span><span>;</span>

            <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
               <span>//获取线程池中线程的数量</span>
                <span>int</span> wc <span>=</span> <span>workerCountOf</span><span>(</span>c<span>)</span><span>;</span>
                <span>// core参数为true的话表明队列也满了，线程池大小变为 maximumPoolSize</span>
                <span>if</span> <span>(</span>wc <span>>=</span> CAPACITY <span>||</span>
                    wc <span>>=</span> <span>(</span>core <span>?</span> corePoolSize <span>:</span> maximumPoolSize<span>)</span><span>)</span>
                    <span>return</span> <span>false</span><span>;</span>
               <span>//原子操作将workcount的数量加1</span>
                <span>if</span> <span>(</span><span>compareAndIncrementWorkerCount</span><span>(</span>c<span>)</span><span>)</span>
                    <span>break</span> retry<span>;</span>
                <span>// 如果线程的状态改变了就再次执行上述操作</span>
                c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
                <span>if</span> <span>(</span><span>runStateOf</span><span>(</span>c<span>)</span> <span>!=</span> rs<span>)</span>
                    <span>continue</span> retry<span>;</span>
                <span>// else CAS failed due to workerCount change; retry inner loop</span>
            <span>}</span>
        <span>}</span>
        <span>// 标记工作线程是否启动成功</span>
        <span>boolean</span> workerStarted <span>=</span> <span>false</span><span>;</span>
        <span>// 标记工作线程是否创建成功</span>
        <span>boolean</span> workerAdded <span>=</span> <span>false</span><span>;</span>
        <span>Worker</span> w <span>=</span> <span>null</span><span>;</span>
        <span>try</span> <span>{</span>

            w <span>=</span> <span>new</span> <span>Worker</span><span>(</span>firstTask<span>)</span><span>;</span>
            <span>final</span> <span>Thread</span> t <span>=</span> w<span>.</span>thread<span>;</span>
            <span>if</span> <span>(</span>t <span>!=</span> <span>null</span><span>)</span> <span>{</span>
              <span>// 加锁</span>
                <span>final</span> <span>ReentrantLock</span> mainLock <span>=</span> <span>this</span><span>.</span>mainLock<span>;</span>
                mainLock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>
                <span>try</span> <span>{</span>
                   <span>//获取线程池状态</span>
                    <span>int</span> rs <span>=</span> <span>runStateOf</span><span>(</span>ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
                   <span>//rs &lt; SHUTDOWN 如果线程池状态依然为RUNNING,并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中</span>
                  <span>//(rs=SHUTDOWN &amp;&amp; firstTask == null)如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker</span>
                   <span>// firstTask == null证明只新建线程而不执行任务</span>
                    <span>if</span> <span>(</span>rs <span>&lt;</span> SHUTDOWN <span>||</span>
                        <span>(</span>rs <span>==</span> SHUTDOWN <span>&amp;&amp;</span> firstTask <span>==</span> <span>null</span><span>)</span><span>)</span> <span>{</span>
                        <span>if</span> <span>(</span>t<span>.</span><span>isAlive</span><span>(</span><span>)</span><span>)</span> <span>// precheck that t is startable</span>
                            <span>throw</span> <span>new</span> <span>IllegalThreadStateException</span><span>(</span><span>)</span><span>;</span>
                        workers<span>.</span><span>add</span><span>(</span>w<span>)</span><span>;</span>
                       <span>//更新当前工作线程的最大容量</span>
                        <span>int</span> s <span>=</span> workers<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
                        <span>if</span> <span>(</span>s <span>></span> largestPoolSize<span>)</span>
                            largestPoolSize <span>=</span> s<span>;</span>
                      <span>// 工作线程是否启动成功</span>
                        workerAdded <span>=</span> <span>true</span><span>;</span>
                    <span>}</span>
                <span>}</span> <span>finally</span> <span>{</span>
                    <span>// 释放锁</span>
                    mainLock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                <span>//// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span>
                <span>if</span> <span>(</span>workerAdded<span>)</span> <span>{</span>
                    t<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
                  <span>/// 标记线程启动成功</span>
                    workerStarted <span>=</span> <span>true</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span> <span>finally</span> <span>{</span>
           <span>// 线程启动失败，需要从工作线程中移除对应的Worker</span>
            <span>if</span> <span>(</span><span>!</span> workerStarted<span>)</span>
                <span>addWorkerFailed</span><span>(</span>w<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> workerStarted<span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br></div></div><p>更多关于线程池源码分析的内容推荐这篇文章：《<a href="http://www.throwable.club/2019/07/15/java-concurrency-thread-pool-executor/" target="_blank" rel="noopener noreferrer">JUC 线程池 ThreadPoolExecutor 源码分析</a>》</p>
<p>现在，让我们在回到 4.1 节我们写的 Demo， 现在应该是不是很容易就可以搞懂它的原理了呢？</p>
<p>没搞懂的话，也没关系，可以看看我的分析：</p>
<blockquote>
<p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p>
</blockquote>
<h3 id="_4-3-几个常见的对比"> 4.3 几个常见的对比</h3>
<h4 id="_4-3-1-runnable-vs-callable"> 4.3.1 <code>Runnable</code> vs <code>Callable</code></h4>
<p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现将 <code>Runnable</code> 对象转换成 <code>Callable</code> 对象。（<code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>）。</p>
<p><code>Runnable.java</code></p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Runnable</span> <span>{</span>
   <span>/**
    * 被线程执行，没有返回值也无法抛出异常
    */</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>Callable.java</code></p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Callable</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>
    <span>/**
     * 计算结果，或在无法这样做时抛出异常。
     * @return 计算得出的结果
     * @throws 如果无法计算结果，则抛出异常
     */</span>
    <span>V</span> <span>call</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="_4-3-2-execute-vs-submit"> 4.3.2 <code>execute()</code> vs <code>submit()</code></h4>
<ul>
<li><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li>
<li><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<p>我们以 <code>AbstractExecutorService</code> 接口中的一个 <code>submit()</code> 方法为例子来看看源代码：</p>
<div><pre><code>    <span>public</span> <span>Future</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>submit</span><span>(</span><span>Runnable</span> task<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>task <span>==</span> <span>null</span><span>)</span> <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
        <span>RunnableFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> ftask <span>=</span> <span>newTaskFor</span><span>(</span>task<span>,</span> <span>null</span><span>)</span><span>;</span>
        <span>execute</span><span>(</span>ftask<span>)</span><span>;</span>
        <span>return</span> ftask<span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p>
<div><pre><code>    <span>protected</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>RunnableFuture</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>newTaskFor</span><span>(</span><span>Runnable</span> runnable<span>,</span> <span>T</span> value<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>FutureTask</span><span><span>&lt;</span><span>T</span><span>></span></span><span>(</span>runnable<span>,</span> value<span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们再来看看<code>execute()</code>方法：</p>
<div><pre><code>    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>Runnable</span> command<span>)</span> <span>{</span>
      <span>.</span><span>.</span><span>.</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="_4-3-3-shutdown-vsshutdownnow"> 4.3.3 <code>shutdown()</code>VS<code>shutdownNow()</code></h4>
<ul>
<li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li>
</ul>
<h4 id="_4-3-2-isterminated-vs-isshutdown"> 4.3.2 <code>isTerminated()</code> VS <code>isShutdown()</code></h4>
<ul>
<li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li>
<li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li>
</ul>
<h3 id="_4-4-加餐-callable-threadpoolexecutor示例代码"> 4.4 加餐:<code>Callable</code>+<code>ThreadPoolExecutor</code>示例代码</h3>
<p><code>MyCallable.java</code></p>
<div><pre><code>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>Callable</span><span>;</span>

<span>public</span> <span>class</span> <span>MyCallable</span> <span>implements</span> <span>Callable</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>call</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
        <span>//返回执行当前 Callable 的线程名字</span>
        <span>return</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>CallableDemo.java</code></p>
<div><pre><code>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Date</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>List</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>ArrayBlockingQueue</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>Callable</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>ExecutionException</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>Future</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>ThreadPoolExecutor</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>TimeUnit</span><span>;</span>

<span>public</span> <span>class</span> <span>CallableDemo</span> <span>{</span>

    <span>private</span> <span>static</span> <span>final</span> <span>int</span> CORE_POOL_SIZE <span>=</span> <span>5</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_POOL_SIZE <span>=</span> <span>10</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> QUEUE_CAPACITY <span>=</span> <span>100</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Long</span> KEEP_ALIVE_TIME <span>=</span> <span>1L</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>//使用阿里巴巴推荐的创建线程池的方式</span>
        <span>//通过ThreadPoolExecutor构造函数自定义参数创建</span>
        <span>ThreadPoolExecutor</span> executor <span>=</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>
                CORE_POOL_SIZE<span>,</span>
                MAX_POOL_SIZE<span>,</span>
                KEEP_ALIVE_TIME<span>,</span>
                <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>
                <span>new</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>></span></span><span>(</span>QUEUE_CAPACITY<span>)</span><span>,</span>
                <span>new</span> <span>ThreadPoolExecutor<span>.</span>CallerRunsPolicy</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>List</span><span><span>&lt;</span><span>Future</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> futureList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>Callable</span><span><span>&lt;</span><span>String</span><span>></span></span> callable <span>=</span> <span>new</span> <span>MyCallable</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>//提交任务到线程池</span>
            <span>Future</span><span><span>&lt;</span><span>String</span><span>></span></span> future <span>=</span> executor<span>.</span><span>submit</span><span>(</span>callable<span>)</span><span>;</span>
            <span>//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span>
            futureList<span>.</span><span>add</span><span>(</span>future<span>)</span><span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>Future</span><span><span>&lt;</span><span>String</span><span>></span></span> fut <span>:</span> futureList<span>)</span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span> <span>+</span> <span>"::"</span> <span>+</span> fut<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> <span>|</span> <span>ExecutionException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>//关闭线程池</span>
        executor<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><p>Output:</p>
<div><pre><code>Wed Nov 13 13:40:41 CST 2019::pool-1-thread-1
Wed Nov 13 13:40:42 CST 2019::pool-1-thread-2
Wed Nov 13 13:40:42 CST 2019::pool-1-thread-3
Wed Nov 13 13:40:42 CST 2019::pool-1-thread-4
Wed Nov 13 13:40:42 CST 2019::pool-1-thread-5
Wed Nov 13 13:40:42 CST 2019::pool-1-thread-3
Wed Nov 13 13:40:43 CST 2019::pool-1-thread-2
Wed Nov 13 13:40:43 CST 2019::pool-1-thread-1
Wed Nov 13 13:40:43 CST 2019::pool-1-thread-4
Wed Nov 13 13:40:43 CST 2019::pool-1-thread-5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="五-几种常见的线程池详解"> 五 几种常见的线程池详解</h2>
<h3 id="_5-1-fixedthreadpool"> 5.1 FixedThreadPool</h3>
<h4 id="_5-1-1-介绍"> 5.1.1 介绍</h4>
<p><code>FixedThreadPool</code> 被称为可重用固定线程数的线程池。通过 Executors 类中的相关源代码来看一下相关实现：</p>
<div><pre><code>   <span>/**
     * 创建一个可重用固定数量线程的线程池
     */</span>
    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newFixedThreadPool</span><span>(</span><span>int</span> nThreads<span>,</span> <span>ThreadFactory</span> threadFactory<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>nThreads<span>,</span> nThreads<span>,</span>
                                      <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>
                                      <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>,</span>
                                      threadFactory<span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>另外还有一个 <code>FixedThreadPool</code> 的实现方法，和上面的类似，所以这里不多做阐述：</p>
<div><pre><code>    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newFixedThreadPool</span><span>(</span><span>int</span> nThreads<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>nThreads<span>,</span> nThreads<span>,</span>
                                      <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>
                                      <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>从上面源代码可以看出新创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 nThreads，这个 nThreads 参数是我们使用的时候自己传递的。</strong></p>
<h4 id="_5-1-2-执行任务过程介绍"> 5.1.2 执行任务过程介绍</h4>
<p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图（该图片来源：《Java 并发编程的艺术》）：</p>
<p><img src="./images/java线程池学习总结/FixedThreadPool.png" alt="FixedThreadPool的execute()方法运行示意图" /></p>
<p><strong>上图说明：</strong></p>
<ol>
<li>如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；</li>
<li>当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</li>
<li>线程池中的线程执行完 手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>
<h4 id="_5-1-3-为什么不推荐使用fixedthreadpool"> 5.1.3 为什么不推荐使用<code>FixedThreadPool</code>？</h4>
<p><strong><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响 ：</strong></p>
<ol>
<li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize；</li>
<li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code>的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值。</li>
<li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li>
<li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li>
</ol>
<h3 id="_5-2-singlethreadexecutor-详解"> 5.2 SingleThreadExecutor 详解</h3>
<h4 id="_5-2-1-介绍"> 5.2.1 介绍</h4>
<p><code>SingleThreadExecutor</code> 是只有一个线程的线程池。下面看看<strong>SingleThreadExecutor 的实现：</strong></p>
<div><pre><code>   <span>/**
     *返回只有一个线程的线程池
     */</span>
    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newSingleThreadExecutor</span><span>(</span><span>ThreadFactory</span> threadFactory<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>FinalizableDelegatedExecutorService</span>
            <span>(</span><span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span>
                                    <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>
                                    <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>,</span>
                                    threadFactory<span>)</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>   <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newSingleThreadExecutor</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>FinalizableDelegatedExecutorService</span>
            <span>(</span><span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span>
                                    <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>
                                    <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>从上面源代码可以看出新创建的 <code>SingleThreadExecutor</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1.其他参数和 <code>FixedThreadPool</code> 相同。</p>
<h4 id="_5-2-2-执行任务过程介绍"> 5.2.2 执行任务过程介绍</h4>
<p><code>SingleThreadExecutor</code> 的运行示意图（该图片来源：《Java 并发编程的艺术》）：
<img src="./images/java线程池学习总结/SingleThreadExecutor.png" alt="SingleThreadExecutor的运行示意图" /></p>
<p><strong>上图说明</strong> :</p>
<ol>
<li>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</li>
<li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></li>
<li>线程执行完当前的任务后，会在循环中反复从<code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>
<h4 id="_5-2-3-为什么不推荐使用singlethreadexecutor"> 5.2.3 为什么不推荐使用<code>SingleThreadExecutor</code>？</h4>
<p><code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 Intger.MAX_VALUE）。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点就是可能会导致 OOM，</p>
<h3 id="_5-3-cachedthreadpool-详解"> 5.3 CachedThreadPool 详解</h3>
<h4 id="_5-3-1-介绍"> 5.3.1 介绍</h4>
<p><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。下面通过源码来看看 <code>CachedThreadPool</code> 的实现：</p>
<div><pre><code>    <span>/**
     * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。
     */</span>
    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newCachedThreadPool</span><span>(</span><span>ThreadFactory</span> threadFactory<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>0</span><span>,</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span>
                                      <span>60L</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>
                                      <span>new</span> <span>SynchronousQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>,</span>
                                      threadFactory<span>)</span><span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newCachedThreadPool</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>0</span><span>,</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span>
                                      <span>60L</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>
                                      <span>new</span> <span>SynchronousQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 <code>Integer.MAX.VALUE</code>，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p>
<h4 id="_5-3-2-执行任务过程介绍"> 5.3.2 执行任务过程介绍</h4>
<p><code>CachedThreadPool</code> 的 <code>execute()</code> 方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：
<img src="./images/java线程池学习总结/CachedThreadPool-execute.png" alt="CachedThreadPool的execute()方法的执行示意图" /></p>
<p><strong>上图说明：</strong></p>
<ol>
<li>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 offer 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成，否则执行下面的步骤 2；</li>
<li>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，execute 方法执行完成；</li>
</ol>
<h4 id="_5-3-3-为什么不推荐使用cachedthreadpool"> 5.3.3 为什么不推荐使用<code>CachedThreadPool</code>？</h4>
<p><code>CachedThreadPool</code>允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</p>
<h2 id="六-scheduledthreadpoolexecutor-详解"> 六 ScheduledThreadPoolExecutor 详解</h2>
<p><strong><code>ScheduledThreadPoolExecutor</code> 主要用来在给定的延迟后运行任务，或者定期执行任务。</strong> 这个在实际项目中基本不会被用到，也不推荐使用，大家只需要简单了解一下它的思想即可。</p>
<h3 id="_6-1-简介"> 6.1 简介</h3>
<p><code>ScheduledThreadPoolExecutor</code> 使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</p>
<p><strong><code>ScheduledThreadPoolExecutor</code> 和 <code>Timer</code> 的比较：</strong></p>
<ul>
<li><code>Timer</code> 对系统时钟的变化敏感，<code>ScheduledThreadPoolExecutor</code>不是；</li>
<li><code>Timer</code> 只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 <code>ScheduledThreadPoolExecutor</code> 可以配置任意数量的线程。 此外，如果你想（通过提供 ThreadFactory），你可以完全控制创建的线程;</li>
<li>在<code>TimerTask</code> 中抛出的运行时异常会杀死一个线程，从而导致 <code>Timer</code> 死机:-( ...即计划任务将不再运行。<code>ScheduledThreadExecutor</code> 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 <code>afterExecute</code> 方法<code>ThreadPoolExecutor</code>）。抛出异常的任务将被取消，但其他任务将继续运行。</li>
</ul>
<p><strong>综上，在 JDK1.5 之后，你没有理由再使用 Timer 进行任务调度了。</strong></p>
<blockquote>
<p>关于定时任务的详细介绍，小伙伴们可以在 JavaGuide 的项目首页搜索“定时任务”找到对应的原创内容。</p>
</blockquote>
<h3 id="_6-2-运行机制"> 6.2 运行机制</h3>
<p><img src="./images/java线程池学习总结/ScheduledThreadPoolExecutor机制.png" alt="ScheduledThreadPoolExecutor运行机制" /></p>
<p><strong><code>ScheduledThreadPoolExecutor</code> 的执行主要分为两大部分：</strong></p>
<ol>
<li>当调用 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>scheduleAtFixedRate()</code></strong> 方法或者 <strong><code>scheduleWithFixedDelay()</code></strong> 方法时，会向 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>DelayQueue</code></strong> 添加一个实现了 <strong><code>RunnableScheduledFuture</code></strong> 接口的 <strong><code>ScheduledFutureTask</code></strong> 。</li>
<li>线程池中的线程从 <code>DelayQueue</code> 中获取 <code>ScheduledFutureTask</code>，然后执行任务。</li>
</ol>
<p><strong><code>ScheduledThreadPoolExecutor</code> 为了实现周期性的执行任务，对 <code>ThreadPoolExecutor</code>做了如下修改：</strong></p>
<ul>
<li>使用 <strong><code>DelayQueue</code></strong> 作为任务队列；</li>
<li>获取任务的方不同</li>
<li>执行周期任务后，增加了额外的处理</li>
</ul>
<h3 id="_6-3-scheduledthreadpoolexecutor-执行周期任务的步骤"> 6.3 ScheduledThreadPoolExecutor 执行周期任务的步骤</h3>
<p><img src="./images/java线程池学习总结/ScheduledThreadPoolExecutor执行周期任务步骤.png" alt="ScheduledThreadPoolExecutor执行周期任务的步骤" /></p>
<ol>
<li>线程 1 从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask（DelayQueue.take()）</code>。到期任务是指 <code>ScheduledFutureTask</code>的 time 大于等于当前系统的时间；</li>
<li>线程 1 执行这个 <code>ScheduledFutureTask</code>；</li>
<li>线程 1 修改 <code>ScheduledFutureTask</code> 的 time 变量为下次将要被执行的时间；</li>
<li>线程 1 把这个修改 time 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中（<code>DelayQueue.add()</code>)。</li>
</ol>
<h2 id="七-线程池大小确定"> 七 线程池大小确定</h2>
<p><strong>线程池数量的确定一直是困扰着程序员的一个难题，大部分程序员在设定线程池大小的时候就是随心而定。</strong></p>
<p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：<strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了<strong>上下文切换</strong>成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p>
<blockquote>
<p>上下文切换：</p>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
</blockquote>
<p><strong>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</strong></p>
<p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p>
<p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<h2 id="八-参考"> 八 参考</h2>
<ul>
<li>《Java 并发编程的艺术》</li>
<li><a href="https://www.journaldev.com/2340/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example" title="Java Scheduler ScheduledExecutorService ScheduledThreadPoolExecutor Example" target="_blank" rel="noopener noreferrer">Java Scheduler ScheduledExecutorService ScheduledThreadPoolExecutor Example</a></li>
<li><a href="https://examples.javacodegeeks.com/core-java/util/concurrent/scheduledthreadpoolexecutor/java-util-concurrent-scheduledthreadpoolexecutor-example/" title="java.util.concurrent.ScheduledThreadPoolExecutor Example" target="_blank" rel="noopener noreferrer">java.util.concurrent.ScheduledThreadPoolExecutor Example</a></li>
<li><a href="https://www.journaldev.com/1069/threadpoolexecutor-java-thread-pool-example-executorservice" title="ThreadPoolExecutor – Java Thread Pool Example" target="_blank" rel="noopener noreferrer">ThreadPoolExecutor – Java Thread Pool Example</a></li>
</ul>
<h2 id="九-其他推荐阅读"> 九 其他推荐阅读</h2>
<ul>
<li><a href="https://www.cnblogs.com/warehouse/p/10720781.html" title="Java并发（三）线程池原理" target="_blank" rel="noopener noreferrer">Java 并发（三）线程池原理</a></li>
<li><a href="https://github.com/crossoverJie/JCSprout/blob/master/MD/ThreadPoolExecutor.md" title="如何优雅的使用和理解线程池" target="_blank" rel="noopener noreferrer">如何优雅的使用和理解线程池</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>从ReentrantLock的实现看AQS的原理及应用</title>
      <link>https://javaguide.cn/java/concurrent/reentrantlock/</link>
      <guid>https://javaguide.cn/java/concurrent/reentrantlock/</guid>
      <source url="https://javaguide.cn/rss.xml">从ReentrantLock的实现看AQS的原理及应用</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文转载自：https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</p>
<p>作者：美团技术团队</p>
</blockquote>
<h2 id="前言"> 前言</h2>
<p>Java 中的大部分同步类（Lock、Semaphore、ReentrantLock 等）都是基于 AbstractQueuedSynchronizer（简称为 AQS）实现的。AQS 是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过 ReentrantLock 的基本特性和 ReentrantLock 与 AQS 的关联，来深入解读 AQS 相关独占锁的知识点，同时采取问答的模式来帮助大家理解 AQS。由于篇幅原因，本篇文章主要阐述 AQS 中独占锁的逻辑和 Sync Queue，不讲述包含共享锁和 Condition Queue 的部分（本篇文章核心为 AQS 原理剖析，只是简单介绍了 ReentrantLock，感兴趣同学可以阅读一下 ReentrantLock 的源码）。</p>
<h2 id="_1-reentrantlock"> 1 ReentrantLock</h2>
<h3 id="_1-1-reentrantlock-特性概览"> 1.1 ReentrantLock 特性概览</h3>
<p>ReentrantLock 意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解 ReentrantLock 的特性，我们先将 ReentrantLock 跟常用的 Synchronized 进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：</p>
<p><img src="https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png" alt="img" /></p>
<p>下面通过伪代码，进行更加直观的比较：</p>
<div><pre><code><span>// **************************Synchronized的使用方式**************************</span>
<span>// 1.用于代码块</span>
<span>synchronized</span> <span>(</span><span>this</span><span>)</span> <span>{</span><span>}</span>
<span>// 2.用于对象</span>
<span>synchronized</span> <span>(</span>object<span>)</span> <span>{</span><span>}</span>
<span>// 3.用于方法</span>
<span>public</span> <span>synchronized</span> <span>void</span> test <span>(</span><span>)</span> <span>{</span><span>}</span>
<span>// 4.可重入</span>
<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
	<span>synchronized</span> <span>(</span><span>this</span><span>)</span> <span>{</span><span>}</span>
<span>}</span>
<span>// **************************ReentrantLock的使用方式**************************</span>
<span>public</span> <span>void</span> test <span>(</span><span>)</span> <span>throw</span> <span>Exception</span> <span>{</span>
	<span>// 1.初始化选择公平锁、非公平锁</span>
	<span>ReentrantLock</span> lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>true</span><span>)</span><span>;</span>
	<span>// 2.可用于代码块</span>
	lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>
	<span>try</span> <span>{</span>
		<span>try</span> <span>{</span>
			<span>// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span>
			<span>if</span><span>(</span>lock<span>.</span><span>tryLock</span><span>(</span><span>100</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>)</span><span>)</span><span>{</span> <span>}</span>
		<span>}</span> <span>finally</span> <span>{</span>
			<span>// 4.手动释放锁</span>
			lock<span>.</span><span>unlock</span><span>(</span><span>)</span>
		<span>}</span>
	<span>}</span> <span>finally</span> <span>{</span>
		lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id="_1-2-reentrantlock-与-aqs-的关联"> 1.2 ReentrantLock 与 AQS 的关联</h3>
<p>通过上文我们已经了解，ReentrantLock 支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651749434&amp;idx=3&amp;sn=5ffa63ad47fe166f2f1a9f604ed10091&amp;chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&amp;scene=38#wechat_redirect" target="_blank" rel="noopener noreferrer">不可不说的 Java“锁”事</a>》），并且 ReentrantLock 的底层就是由 AQS 来实现的。那么 ReentrantLock 是如何通过公平锁和非公平锁与 AQS 关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与 AQS 之间的关系（加锁过程中与 AQS 的关联比较明显，解锁流程后续会介绍）。</p>
<p>非公平锁源码中的加锁流程如下：</p>
<div><pre><code><span>// java.util.concurrent.locks.ReentrantLock#NonfairSync</span>

<span>// 非公平锁</span>
<span>static</span> <span>final</span> <span>class</span> <span>NonfairSync</span> <span>extends</span> <span>Sync</span> <span>{</span>
	<span>.</span><span>.</span><span>.</span>
	<span>final</span> <span>void</span> <span>lock</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>compareAndSetState</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>)</span>
			<span>setExclusiveOwnerThread</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>)</span><span>;</span>
		<span>else</span>
			<span>acquire</span><span>(</span><span>1</span><span>)</span><span>;</span>
		<span>}</span>
  <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>这块代码的含义为：</p>
<ul>
<li>若通过 CAS 设置变量 State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</li>
<li>若通过 CAS 设置变量 State（同步状态）失败，也就是获取锁失败，则进入 Acquire 方法进行后续处理。</li>
</ul>
<p>第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考：</p>
<ul>
<li>某个线程获取锁失败的后续流程是什么呢？有以下两种可能：</li>
</ul>
<p>(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是 AQS 框架的处理流程。</p>
<p>(2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>
<ul>
<li>对于问题 1 的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</li>
<li>处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</li>
<li>如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？</li>
</ul>
<p>带着非公平锁的这些问题，再看下公平锁源码中获锁的方式：</p>
<div><pre><code>// java.util.concurrent.locks.ReentrantLock#FairSync

static final class FairSync extends Sync {
  ...
	final void lock() {
		acquire(1);
	}
  ...
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>看到这块代码，我们可能会存在这种疑问：Lock 函数通过 Acquire 方法进行加锁，但是具体是如何加锁的呢？</p>
<p>结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了 Acquire 方法，而 Acquire 方法是 FairSync 和 UnfairSync 的父类 AQS 中的核心方法。</p>
<p>对于上边提到的问题，其实在 ReentrantLock 类源码中都无法解答，而这些问题的答案，都是位于 Acquire 方法所在的类 AbstractQueuedSynchronizer 中，也就是本文的核心——AQS。下面我们会对 AQS 以及 ReentrantLock 和 AQS 的关联做详细介绍（相关问题答案会在 2.3.5 小节中解答）。</p>
<h2 id="_2-aqs"> 2 AQS</h2>
<p>首先，我们通过下面的架构图来整体了解一下 AQS 框架：</p>
<p><img src="https://p1.meituan.net/travelcube/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="" /></p>
<ul>
<li>上图中有颜色的为 Method，无颜色的为 Attribution。</li>
<li>总的来说，AQS 框架共分为五层，自上而下由浅入深，从 AQS 对外暴露的 API 到底层基础数据。</li>
<li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的 API 进入 AQS 内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li>
</ul>
<p>下面我们会从整体到细节，从流程到方法逐一剖析 AQS 框架，主要分析过程如下：</p>
<p><img src="https://p1.meituan.net/travelcube/d2f7f7fffdc30d85d17b44266c3ab05323338.png" alt="" /></p>
<h3 id="_2-1-原理概览"> 2.1 原理概览</h3>
<p>AQS 核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是 CLH 队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH：Craig、Landin and Hagersten 队列，是单向链表，AQS 中的队列是 CLH 变体的虚拟双向队列（FIFO），AQS 是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p>
<p>主要原理图如下：</p>
<p><img src="https://p0.meituan.net/travelcube/7132e4cef44c26f62835b197b239147b18062.png" alt="" /></p>
<p>AQS 使用一个 Volatile 的 int 类型的成员变量来表示同步状态，通过内置的 FIFO 队列来完成资源获取的排队工作，通过 CAS 完成对 State 值的修改。</p>
<h4 id="_2-1-1-aqs-数据结构"> 2.1.1 AQS 数据结构</h4>
<p>先来看下 AQS 中最基本的数据结构——Node，Node 即为上面 CLH 变体队列中的节点。</p>
<p><img src="https://p1.meituan.net/travelcube/960271cf2b5c8a185eed23e98b72c75538637.png" alt="" /></p>
<p>解释一下几个方法和属性值的含义：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法和属性值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">waitStatus</td>
<td style="text-align:left">当前节点在队列中的状态</td>
</tr>
<tr>
<td style="text-align:left">thread</td>
<td style="text-align:left">表示处于该节点的线程</td>
</tr>
<tr>
<td style="text-align:left">prev</td>
<td style="text-align:left">前驱指针</td>
</tr>
<tr>
<td style="text-align:left">predecessor</td>
<td style="text-align:left">返回前驱节点，没有的话抛出 npe</td>
</tr>
<tr>
<td style="text-align:left">nextWaiter</td>
<td style="text-align:left">指向下一个处于 CONDITION 状态的节点（由于本篇文章不讲述 Condition Queue 队列，这个指针不多介绍）</td>
</tr>
<tr>
<td style="text-align:left">next</td>
<td style="text-align:left">后继指针</td>
</tr>
</tbody>
</table>
<p>线程两种锁的模式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SHARED</td>
<td style="text-align:left">表示线程以共享的模式等待锁</td>
</tr>
<tr>
<td style="text-align:left">EXCLUSIVE</td>
<td style="text-align:left">表示线程正在以独占的方式等待锁</td>
</tr>
</tbody>
</table>
<p>waitStatus 有下面几个枚举值：</p>
<table>
<thead>
<tr>
<th style="text-align:left">枚举</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">当一个 Node 被初始化的时候的默认值</td>
</tr>
<tr>
<td style="text-align:left">CANCELLED</td>
<td style="text-align:left">为 1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td style="text-align:left">CONDITION</td>
<td style="text-align:left">为-2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATE</td>
<td style="text-align:left">为-3，当前线程处在 SHARED 情况下，该字段才会使用</td>
</tr>
<tr>
<td style="text-align:left">SIGNAL</td>
<td style="text-align:left">为-1，表示线程已经准备好了，就等资源释放了</td>
</tr>
</tbody>
</table>
<h4 id="_2-1-2-同步状态-state"> 2.1.2 同步状态 State</h4>
<p>在了解数据结构后，接下来了解一下 AQS 的同步状态——State。AQS 中维护了一个名为 state 的字段，意为同步状态，是由 Volatile 修饰的，用于展示当前临界资源的获锁情况。</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>private</span> <span>volatile</span> <span>int</span> state<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面提供了几个访问这个字段的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">protected final int getState()</td>
<td style="text-align:left">获取 State 的值</td>
</tr>
<tr>
<td style="text-align:left">protected final void setState(int newState)</td>
<td style="text-align:left">设置 State 的值</td>
</tr>
<tr>
<td style="text-align:left">protected final boolean compareAndSetState(int expect, int update)</td>
<td style="text-align:left">使用 CAS 方式更新 State</td>
</tr>
</tbody>
</table>
<p>这几个方法都是 Final 修饰的，说明子类中无法重写它们。我们可以通过修改 State 字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p>
<p><img src="https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png" alt="" /></p>
<p><img src="https://p0.meituan.net/travelcube/3f1e1a44f5b7d77000ba4f9476189b2e32806.png" alt="" /></p>
<p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是 AQS 架构图中的第一层：API 层。</p>
<h2 id="_2-2-aqs-重要方法与-reentrantlock-的关联"> 2.2 AQS 重要方法与 ReentrantLock 的关联</h2>
<p>从架构图中可以得知，AQS 提供了大量用于自定义同步器实现的 Protected 方法。自定义同步器实现的相关方法也只是为了通过修改 State 字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock 需要实现的方法如下，并不是全部）：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">protected boolean isHeldExclusively()</td>
<td style="text-align:left">该线程是否正在独占资源。只有用到 Condition 才需要去实现它。</td>
</tr>
<tr>
<td style="text-align:left">protected boolean tryAcquire(int arg)</td>
<td style="text-align:left">独占方式。arg 为获取锁的次数，尝试获取资源，成功则返回 True，失败则返回 False。</td>
</tr>
<tr>
<td style="text-align:left">protected boolean tryRelease(int arg)</td>
<td style="text-align:left">独占方式。arg 为释放锁的次数，尝试释放资源，成功则返回 True，失败则返回 False。</td>
</tr>
<tr>
<td style="text-align:left">protected int tryAcquireShared(int arg)</td>
<td style="text-align:left">共享方式。arg 为获取锁的次数，尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td>
</tr>
<tr>
<td style="text-align:left">protected boolean tryReleaseShared(int arg)</td>
<td style="text-align:left">共享方式。arg 为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回 True，否则返回 False。</td>
</tr>
</tbody>
</table>
<p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现 tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。ReentrantLock 是独占锁，所以实现了 tryAcquire-tryRelease。</p>
<p>以非公平锁为例，这里主要阐述一下非公平锁与 AQS 之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。</p>
<p><img src="https://p1.meituan.net/travelcube/b8b53a70984668bc68653efe9531573e78636.png" alt="" /></p>
<p>为了帮助大家理解 ReentrantLock 和 AQS 之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。</p>
<p><img src="https://p1.meituan.net/travelcube/7aadb272069d871bdee8bf3a218eed8136919.png" alt="" /></p>
<p>加锁：</p>
<ul>
<li>通过 ReentrantLock 的加锁方法 Lock 进行加锁操作。</li>
<li>会调用到内部类 Sync 的 Lock 方法，由于 Sync#lock 是抽象方法，根据 ReentrantLock 初始化选择的公平锁和非公平锁，执行相关内部类的 Lock 方法，本质上都会执行 AQS 的 Acquire 方法。</li>
<li>AQS 的 Acquire 方法会执行 tryAcquire 方法，但是由于 tryAcquire 需要自定义同步器实现，因此执行了 ReentrantLock 中的 tryAcquire 方法，由于 ReentrantLock 是通过公平锁和非公平锁内部类实现的 tryAcquire 方法，因此会根据锁类型不同，执行不同的 tryAcquire。</li>
<li>tryAcquire 是获取锁逻辑，获取失败后，会执行框架 AQS 的后续逻辑，跟 ReentrantLock 自定义同步器无关。</li>
</ul>
<p>解锁：</p>
<ul>
<li>通过 ReentrantLock 的解锁方法 Unlock 进行解锁。</li>
<li>Unlock 会调用内部类 Sync 的 Release 方法，该方法继承于 AQS。</li>
<li>Release 中会调用 tryRelease 方法，tryRelease 需要自定义同步器实现，tryRelease 只在 ReentrantLock 中的 Sync 实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li>
<li>释放成功后，所有处理由 AQS 框架完成，与自定义同步器无关。</li>
</ul>
<p>通过上面的描述，大概可以总结出 ReentrantLock 加锁解锁时 API 层核心方法的映射关系。</p>
<p><img src="https://p0.meituan.net/travelcube/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png" alt="" /></p>
<h2 id="_2-3-通过-reentrantlock-理解-aqs"> 2.3 通过 ReentrantLock 理解 AQS</h2>
<p>ReentrantLock 中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。</p>
<p>在非公平锁中，有一段这样的代码：</p>
<div><pre><code><span>// java.util.concurrent.locks.ReentrantLock</span>

<span>static</span> <span>final</span> <span>class</span> <span>NonfairSync</span> <span>extends</span> <span>Sync</span> <span>{</span>
	<span>.</span><span>.</span><span>.</span>
	<span>final</span> <span>void</span> <span>lock</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>compareAndSetState</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>)</span>
			<span>setExclusiveOwnerThread</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>)</span><span>;</span>
		<span>else</span>
			<span>acquire</span><span>(</span><span>1</span><span>)</span><span>;</span>
	<span>}</span>
  <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>看一下这个 Acquire 是怎么写的：</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>public</span> <span>final</span> <span>void</span> <span>acquire</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
	<span>if</span> <span>(</span><span>!</span><span>tryAcquire</span><span>(</span>arg<span>)</span> <span>&amp;&amp;</span> <span>acquireQueued</span><span>(</span><span>addWaiter</span><span>(</span><span>Node</span><span>.</span>EXCLUSIVE<span>)</span><span>,</span> arg<span>)</span><span>)</span>
		<span>selfInterrupt</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>再看一下 tryAcquire 方法：</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>protected</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
	<span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可以看出，这里只是 AQS 的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以 ReentrantLock 为例）。如果该方法返回了 True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。</p>
<h3 id="_2-3-1-线程加入等待队列"> 2.3.1 线程加入等待队列</h3>
<h4 id="_2-3-1-1-加入队列的时机"> 2.3.1.1 加入队列的时机</h4>
<p>当执行 Acquire(1)时，会通过 tryAcquire 获取锁。在这种情况下，如果获取锁失败，就会调用 addWaiter 加入到等待队列中去。</p>
<h4 id="_2-3-1-2-如何加入队列"> 2.3.1.2 如何加入队列</h4>
<p>获取锁失败后，会执行 addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>private</span> <span>Node</span> <span>addWaiter</span><span>(</span><span>Node</span> mode<span>)</span> <span>{</span>
	<span>Node</span> node <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>,</span> mode<span>)</span><span>;</span>
	<span>// Try the fast path of enq; backup to full enq on failure</span>
	<span>Node</span> pred <span>=</span> tail<span>;</span>
	<span>if</span> <span>(</span>pred <span>!=</span> <span>null</span><span>)</span> <span>{</span>
		node<span>.</span>prev <span>=</span> pred<span>;</span>
		<span>if</span> <span>(</span><span>compareAndSetTail</span><span>(</span>pred<span>,</span> node<span>)</span><span>)</span> <span>{</span>
			pred<span>.</span>next <span>=</span> node<span>;</span>
			<span>return</span> node<span>;</span>
		<span>}</span>
	<span>}</span>
	<span>enq</span><span>(</span>node<span>)</span><span>;</span>
	<span>return</span> node<span>;</span>
<span>}</span>
<span>private</span> <span>final</span> <span>boolean</span> <span>compareAndSetTail</span><span>(</span><span>Node</span> expect<span>,</span> <span>Node</span> update<span>)</span> <span>{</span>
	<span>return</span> unsafe<span>.</span><span>compareAndSwapObject</span><span>(</span><span>this</span><span>,</span> tailOffset<span>,</span> expect<span>,</span> update<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>主要的流程如下：</p>
<ul>
<li>通过当前的线程和锁模式新建一个节点。</li>
<li>Pred 指针指向尾节点 Tail。</li>
<li>将 New 中 Node 的 Prev 指针指向 Pred。</li>
<li>通过 compareAndSetTail 方法，完成尾节点的设置。这个方法主要是对 tailOffset 和 Expect 进行比较，如果 tailOffset 的 Node 和 Expect 的 Node 地址是相同的，那么设置 Tail 的值为 Update 的值。</li>
</ul>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>static</span> <span>{</span>
	<span>try</span> <span>{</span>
		stateOffset <span>=</span> unsafe<span>.</span><span>objectFieldOffset</span><span>(</span><span>AbstractQueuedSynchronizer</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"state"</span><span>)</span><span>)</span><span>;</span>
		headOffset <span>=</span> unsafe<span>.</span><span>objectFieldOffset</span><span>(</span><span>AbstractQueuedSynchronizer</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"head"</span><span>)</span><span>)</span><span>;</span>
		tailOffset <span>=</span> unsafe<span>.</span><span>objectFieldOffset</span><span>(</span><span>AbstractQueuedSynchronizer</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"tail"</span><span>)</span><span>)</span><span>;</span>
		waitStatusOffset <span>=</span> unsafe<span>.</span><span>objectFieldOffset</span><span>(</span><span>Node</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"waitStatus"</span><span>)</span><span>)</span><span>;</span>
		nextOffset <span>=</span> unsafe<span>.</span><span>objectFieldOffset</span><span>(</span><span>Node</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"next"</span><span>)</span><span>)</span><span>;</span>
	<span>}</span> <span>catch</span> <span>(</span><span>Exception</span> ex<span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>Error</span><span>(</span>ex<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>从 AQS 的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset 指的是 tail 对应的偏移量，所以这个时候会将 new 出来的 Node 置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。</p>
<ul>
<li>如果 Pred 指针是 Null（说明等待队列中没有元素），或者当前 Pred 指针和 Tail 指向的位置不同（说明被别的线程已经修改），就需要看一下 Enq 的方法。</li>
</ul>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>private</span> <span>Node</span> <span>enq</span><span>(</span><span>final</span> <span>Node</span> node<span>)</span> <span>{</span>
	<span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
		<span>Node</span> t <span>=</span> tail<span>;</span>
		<span>if</span> <span>(</span>t <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// Must initialize</span>
			<span>if</span> <span>(</span><span>compareAndSetHead</span><span>(</span><span>new</span> <span>Node</span><span>(</span><span>)</span><span>)</span><span>)</span>
				tail <span>=</span> head<span>;</span>
		<span>}</span> <span>else</span> <span>{</span>
			node<span>.</span>prev <span>=</span> t<span>;</span>
			<span>if</span> <span>(</span><span>compareAndSetTail</span><span>(</span>t<span>,</span> node<span>)</span><span>)</span> <span>{</span>
				t<span>.</span>next <span>=</span> node<span>;</span>
				<span>return</span> t<span>;</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter 就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p>
<p>总结一下，线程获取锁的时候，过程大体如下：</p>
<ol>
<li>当没有线程获取到锁时，线程 1 获取锁成功。</li>
<li>线程 2 申请锁，但是锁被线程 1 占有。</li>
</ol>
<p><img src="https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png" alt="img" /></p>
<ol>
<li>如果再有线程要获取锁，依次在队列中往后排队即可。</li>
</ol>
<p>回到上边的代码，hasQueuedPredecessors 是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回 False，说明当前线程可以争取共享资源；如果返回 True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</p>
<div><pre><code><span>// java.util.concurrent.locks.ReentrantLock</span>

<span>public</span> <span>final</span> <span>boolean</span> <span>hasQueuedPredecessors</span><span>(</span><span>)</span> <span>{</span>
	<span>// The correctness of this depends on head being initialized</span>
	<span>// before tail and on head.next being accurate if the current</span>
	<span>// thread is first in queue.</span>
	<span>Node</span> t <span>=</span> tail<span>;</span> <span>// Read fields in reverse initialization order</span>
	<span>Node</span> h <span>=</span> head<span>;</span>
	<span>Node</span> s<span>;</span>
	<span>return</span> h <span>!=</span> t <span>&amp;&amp;</span> <span>(</span><span>(</span>s <span>=</span> h<span>.</span>next<span>)</span> <span>==</span> <span>null</span> <span>||</span> s<span>.</span>thread <span>!=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>看到这里，我们理解一下 h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</p>
<blockquote>
<p>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当 h != t 时： 如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了 Tail 指向 Head，没有将 Head 指向 Tail，此时队列中有元素，需要返回 True（这块具体见下边代码分析）。 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时 s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果 s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p>
</blockquote>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</span>

<span>if</span> <span>(</span>t <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// Must initialize</span>
	<span>if</span> <span>(</span><span>compareAndSetHead</span><span>(</span><span>new</span> <span>Node</span><span>(</span><span>)</span><span>)</span><span>)</span>
		tail <span>=</span> head<span>;</span>
<span>}</span> <span>else</span> <span>{</span>
	node<span>.</span>prev <span>=</span> t<span>;</span>
	<span>if</span> <span>(</span><span>compareAndSetTail</span><span>(</span>t<span>,</span> node<span>)</span><span>)</span> <span>{</span>
		t<span>.</span>next <span>=</span> node<span>;</span>
		<span>return</span> t<span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>节点入队不是原子操作，所以会出现短暂的 head != tail，此时 Tail 指向最后一个节点，而且 Tail 指向 Head。如果 Head 没有指向 Tail（可见 5、6、7 行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。</p>
<h4 id="_2-3-1-3-等待队列中线程出队列时机"> 2.3.1.3 等待队列中线程出队列时机</h4>
<p>回到最初的源码：</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>public</span> <span>final</span> <span>void</span> <span>acquire</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
	<span>if</span> <span>(</span><span>!</span><span>tryAcquire</span><span>(</span>arg<span>)</span> <span>&amp;&amp;</span> <span>acquireQueued</span><span>(</span><span>addWaiter</span><span>(</span><span>Node</span><span>.</span>EXCLUSIVE<span>)</span><span>,</span> arg<span>)</span><span>)</span>
		<span>selfInterrupt</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上文解释了 addWaiter 方法，这个方法其实就是把对应的线程以 Node 的数据结构形式加入到双端队列里，返回的是一个包含该线程的 Node。而这个 Node 会作为参数，进入到 acquireQueued 方法中。acquireQueued 方法可以对排队中的线程进行“获锁”操作。</p>
<p>总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued 会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p>
<p>下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下 acquireQueued 源码：</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>final</span> <span>boolean</span> <span>acquireQueued</span><span>(</span><span>final</span> <span>Node</span> node<span>,</span> <span>int</span> arg<span>)</span> <span>{</span>
	<span>// 标记是否成功拿到资源</span>
	<span>boolean</span> failed <span>=</span> <span>true</span><span>;</span>
	<span>try</span> <span>{</span>
		<span>// 标记等待过程中是否中断过</span>
		<span>boolean</span> interrupted <span>=</span> <span>false</span><span>;</span>
		<span>// 开始自旋，要么获取锁，要么中断</span>
		<span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
			<span>// 获取当前节点的前驱节点</span>
			<span>final</span> <span>Node</span> p <span>=</span> node<span>.</span><span>predecessor</span><span>(</span><span>)</span><span>;</span>
			<span>// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span>
			<span>if</span> <span>(</span>p <span>==</span> head <span>&amp;&amp;</span> <span>tryAcquire</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>
				<span>// 获取锁成功，头指针移动到当前node</span>
				<span>setHead</span><span>(</span>node<span>)</span><span>;</span>
				p<span>.</span>next <span>=</span> <span>null</span><span>;</span> <span>// help GC</span>
				failed <span>=</span> <span>false</span><span>;</span>
				<span>return</span> interrupted<span>;</span>
			<span>}</span>
			<span>// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span>
			<span>if</span> <span>(</span><span>shouldParkAfterFailedAcquire</span><span>(</span>p<span>,</span> node<span>)</span> <span>&amp;&amp;</span> <span>parkAndCheckInterrupt</span><span>(</span><span>)</span><span>)</span>
				interrupted <span>=</span> <span>true</span><span>;</span>
		<span>}</span>
	<span>}</span> <span>finally</span> <span>{</span>
		<span>if</span> <span>(</span>failed<span>)</span>
			<span>cancelAcquire</span><span>(</span>node<span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>注：setHead 方法是把当前节点置为虚节点，但并没有修改 waitStatus，因为它是一直需要用的数据。</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>private</span> <span>void</span> <span>setHead</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
	head <span>=</span> node<span>;</span>
	node<span>.</span>thread <span>=</span> <span>null</span><span>;</span>
	node<span>.</span>prev <span>=</span> <span>null</span><span>;</span>
<span>}</span>

<span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>// 靠前驱节点判断当前线程是否应该被阻塞</span>
<span>private</span> <span>static</span> <span>boolean</span> <span>shouldParkAfterFailedAcquire</span><span>(</span><span>Node</span> pred<span>,</span> <span>Node</span> node<span>)</span> <span>{</span>
	<span>// 获取头结点的节点状态</span>
	<span>int</span> ws <span>=</span> pred<span>.</span>waitStatus<span>;</span>
	<span>// 说明头结点处于唤醒状态</span>
	<span>if</span> <span>(</span>ws <span>==</span> <span>Node</span><span>.</span>SIGNAL<span>)</span>
		<span>return</span> <span>true</span><span>;</span>
	<span>// 通过枚举值我们知道waitStatus>0是取消状态</span>
	<span>if</span> <span>(</span>ws <span>></span> <span>0</span><span>)</span> <span>{</span>
		<span>do</span> <span>{</span>
			<span>// 循环向前查找取消节点，把取消节点从队列中剔除</span>
			node<span>.</span>prev <span>=</span> pred <span>=</span> pred<span>.</span>prev<span>;</span>
		<span>}</span> <span>while</span> <span>(</span>pred<span>.</span>waitStatus <span>></span> <span>0</span><span>)</span><span>;</span>
		pred<span>.</span>next <span>=</span> node<span>;</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>// 设置前任节点等待状态为SIGNAL</span>
		<span>compareAndSetWaitStatus</span><span>(</span>pred<span>,</span> ws<span>,</span> <span>Node</span><span>.</span>SIGNAL<span>)</span><span>;</span>
	<span>}</span>
	<span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>parkAndCheckInterrupt 主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>private</span> <span>final</span> <span>boolean</span> <span>parkAndCheckInterrupt</span><span>(</span><span>)</span> <span>{</span>
    <span>LockSupport</span><span>.</span><span>park</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>return</span> <span>Thread</span><span>.</span><span>interrupted</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上述方法的流程图如下：</p>
<p><img src="https://p0.meituan.net/travelcube/c124b76dcbefb9bdc778458064703d1135485.png" alt="" /></p>
<p>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致 CPU 资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire 流程）：</p>
<p><img src="https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png" alt="" /></p>
<p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p>
<ul>
<li>shouldParkAfterFailedAcquire 中取消节点是怎么生成的呢？什么时候会把一个节点的 waitStatus 设置为-1？</li>
<li>是在什么时间释放节点通知到被挂起的线程呢？</li>
</ul>
<h3 id="_2-3-2-cancelled-状态节点生成"> 2.3.2 CANCELLED 状态节点生成</h3>
<p>acquireQueued 方法中的 Finally 代码：</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>final</span> <span>boolean</span> <span>acquireQueued</span><span>(</span><span>final</span> <span>Node</span> node<span>,</span> <span>int</span> arg<span>)</span> <span>{</span>
	<span>boolean</span> failed <span>=</span> <span>true</span><span>;</span>
	<span>try</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
		<span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
			<span>final</span> <span>Node</span> p <span>=</span> node<span>.</span><span>predecessor</span><span>(</span><span>)</span><span>;</span>
			<span>if</span> <span>(</span>p <span>==</span> head <span>&amp;&amp;</span> <span>tryAcquire</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>
				<span>.</span><span>.</span><span>.</span>
				failed <span>=</span> <span>false</span><span>;</span>
        <span>.</span><span>.</span><span>.</span>
			<span>}</span>
			<span>.</span><span>.</span><span>.</span>
	<span>}</span> <span>finally</span> <span>{</span>
		<span>if</span> <span>(</span>failed<span>)</span>
			<span>cancelAcquire</span><span>(</span>node<span>)</span><span>;</span>
		<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>通过 cancelAcquire 方法，将 Node 的状态标记为 CANCELLED。接下来，我们逐行来分析这个方法的原理：</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>private</span> <span>void</span> <span>cancelAcquire</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
  <span>// 将无效节点过滤</span>
	<span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span>
		<span>return</span><span>;</span>
  <span>// 设置该节点不关联任何线程，也就是虚节点</span>
	node<span>.</span>thread <span>=</span> <span>null</span><span>;</span>
	<span>Node</span> pred <span>=</span> node<span>.</span>prev<span>;</span>
  <span>// 通过前驱节点，跳过取消状态的node</span>
	<span>while</span> <span>(</span>pred<span>.</span>waitStatus <span>></span> <span>0</span><span>)</span>
		node<span>.</span>prev <span>=</span> pred <span>=</span> pred<span>.</span>prev<span>;</span>
  <span>// 获取过滤后的前驱节点的后继节点</span>
	<span>Node</span> predNext <span>=</span> pred<span>.</span>next<span>;</span>
  <span>// 把当前node的状态设置为CANCELLED</span>
	node<span>.</span>waitStatus <span>=</span> <span>Node</span><span>.</span>CANCELLED<span>;</span>
  <span>// 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点</span>
  <span>// 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null</span>
	<span>if</span> <span>(</span>node <span>==</span> tail <span>&amp;&amp;</span> <span>compareAndSetTail</span><span>(</span>node<span>,</span> pred<span>)</span><span>)</span> <span>{</span>
		<span>compareAndSetNext</span><span>(</span>pred<span>,</span> predNext<span>,</span> <span>null</span><span>)</span><span>;</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>int</span> ws<span>;</span>
    <span>// 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span>
    <span>// 如果1和2中有一个为true，再判断当前节点的线程是否为null</span>
    <span>// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点</span>
		<span>if</span> <span>(</span>pred <span>!=</span> head <span>&amp;&amp;</span> <span>(</span><span>(</span>ws <span>=</span> pred<span>.</span>waitStatus<span>)</span> <span>==</span> <span>Node</span><span>.</span>SIGNAL <span>||</span> <span>(</span>ws <span>&lt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>compareAndSetWaitStatus</span><span>(</span>pred<span>,</span> ws<span>,</span> <span>Node</span><span>.</span>SIGNAL<span>)</span><span>)</span><span>)</span> <span>&amp;&amp;</span> pred<span>.</span>thread <span>!=</span> <span>null</span><span>)</span> <span>{</span>
			<span>Node</span> next <span>=</span> node<span>.</span>next<span>;</span>
			<span>if</span> <span>(</span>next <span>!=</span> <span>null</span> <span>&amp;&amp;</span> next<span>.</span>waitStatus <span>&lt;=</span> <span>0</span><span>)</span>
				<span>compareAndSetNext</span><span>(</span>pred<span>,</span> predNext<span>,</span> next<span>)</span><span>;</span>
		<span>}</span> <span>else</span> <span>{</span>
      <span>// 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span>
			<span>unparkSuccessor</span><span>(</span>node<span>)</span><span>;</span>
		<span>}</span>
		node<span>.</span>next <span>=</span> node<span>;</span> <span>// help GC</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>当前的流程：</p>
<ul>
<li>获取当前节点的前驱节点，如果前驱节点的状态是 CANCELLED，那就一直往前遍历，找到第一个 waitStatus &lt;= 0 的节点，将找到的 Pred 节点和当前 Node 关联，将当前 Node 设置为 CANCELLED。</li>
<li>根据当前节点的位置，考虑以下三种情况：</li>
</ul>
<p>(1) 当前节点是尾节点。</p>
<p>(2) 当前节点是 Head 的后继节点。</p>
<p>(3) 当前节点不是 Head 的后继节点，也不是尾节点。</p>
<p>根据上述第二条，我们来分析每一种情况的流程。</p>
<p>当前节点是尾节点。</p>
<p><img src="https://p1.meituan.net/travelcube/b845211ced57561c24f79d56194949e822049.png" alt="" /></p>
<p>当前节点是 Head 的后继节点。</p>
<p><img src="https://p1.meituan.net/travelcube/ab89bfec875846e5028a4f8fead32b7117975.png" alt="" /></p>
<p>当前节点不是 Head 的后继节点，也不是尾节点。</p>
<p><img src="https://p0.meituan.net/travelcube/45d0d9e4a6897eddadc4397cf53d6cd522452.png" alt="" /></p>
<p>通过上面的流程，我们对于 CANCELLED 节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对 Next 指针进行了操作，而没有对 Prev 指针进行操作呢？什么情况下会对 Prev 指针进行操作？</p>
<blockquote>
<p>执行 cancelAcquire 的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过 Try 代码块中的 shouldParkAfterFailedAcquire 方法了），如果此时修改 Prev 指针，有可能会导致 Prev 指向另一个已经移除队列的 Node，因此这块变化 Prev 指针不安全。 shouldParkAfterFailedAcquire 方法中，会执行下面的代码，其实就是在处理 Prev 指针。shouldParkAfterFailedAcquire 是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更 Prev 指针比较安全。</p>
<div><pre><code><span>do</span> <span>{</span>
	node<span>.</span>prev <span>=</span> pred <span>=</span> pred<span>.</span>prev<span>;</span>
<span>}</span> <span>while</span> <span>(</span>pred<span>.</span>waitStatus <span>></span> <span>0</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></blockquote>
<h3 id="_2-3-3-如何解锁"> 2.3.3 如何解锁</h3>
<p>我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于 ReentrantLock 在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p>
<div><pre><code><span>// java.util.concurrent.locks.ReentrantLock</span>

<span>public</span> <span>void</span> <span>unlock</span><span>(</span><span>)</span> <span>{</span>
	sync<span>.</span><span>release</span><span>(</span><span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可以看到，本质释放锁的地方，是通过框架来完成的。</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>public</span> <span>final</span> <span>boolean</span> <span>release</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
	<span>if</span> <span>(</span><span>tryRelease</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>
		<span>Node</span> h <span>=</span> head<span>;</span>
		<span>if</span> <span>(</span>h <span>!=</span> <span>null</span> <span>&amp;&amp;</span> h<span>.</span>waitStatus <span>!=</span> <span>0</span><span>)</span>
			<span>unparkSuccessor</span><span>(</span>h<span>)</span><span>;</span>
		<span>return</span> <span>true</span><span>;</span>
	<span>}</span>
	<span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>在 ReentrantLock 里面的公平锁和非公平锁的父类 Sync 定义了可重入锁的释放锁机制。</p>
<div><pre><code><span>// java.util.concurrent.locks.ReentrantLock.Sync</span>

<span>// 方法返回当前锁是不是没有被线程持有</span>
<span>protected</span> <span>final</span> <span>boolean</span> <span>tryRelease</span><span>(</span><span>int</span> releases<span>)</span> <span>{</span>
	<span>// 减少可重入次数</span>
	<span>int</span> c <span>=</span> <span>getState</span><span>(</span><span>)</span> <span>-</span> releases<span>;</span>
	<span>// 当前线程不是持有锁的线程，抛出异常</span>
	<span>if</span> <span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>!=</span> <span>getExclusiveOwnerThread</span><span>(</span><span>)</span><span>)</span>
		<span>throw</span> <span>new</span> <span>IllegalMonitorStateException</span><span>(</span><span>)</span><span>;</span>
	<span>boolean</span> free <span>=</span> <span>false</span><span>;</span>
	<span>// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span>
	<span>if</span> <span>(</span>c <span>==</span> <span>0</span><span>)</span> <span>{</span>
		free <span>=</span> <span>true</span><span>;</span>
		<span>setExclusiveOwnerThread</span><span>(</span><span>null</span><span>)</span><span>;</span>
	<span>}</span>
	<span>setState</span><span>(</span>c<span>)</span><span>;</span>
	<span>return</span> free<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>我们来解释下述源码：</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>public</span> <span>final</span> <span>boolean</span> <span>release</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
	<span>// 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有</span>
	<span>if</span> <span>(</span><span>tryRelease</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>
		<span>// 获取头结点</span>
		<span>Node</span> h <span>=</span> head<span>;</span>
		<span>// 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态</span>
		<span>if</span> <span>(</span>h <span>!=</span> <span>null</span> <span>&amp;&amp;</span> h<span>.</span>waitStatus <span>!=</span> <span>0</span><span>)</span>
			<span>unparkSuccessor</span><span>(</span>h<span>)</span><span>;</span>
		<span>return</span> <span>true</span><span>;</span>
	<span>}</span>
	<span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这里的判断条件为什么是 h != null &amp;&amp; h.waitStatus != 0？</p>
<blockquote>
<p>h == null Head 还没初始化。初始情况下，head == null，第一个节点入队，Head 会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现 head == null 的情况。</p>
<p>h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。</p>
<p>h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</p>
</blockquote>
<p>再看一下 unparkSuccessor 方法：</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>private</span> <span>void</span> <span>unparkSuccessor</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
	<span>// 获取头结点waitStatus</span>
	<span>int</span> ws <span>=</span> node<span>.</span>waitStatus<span>;</span>
	<span>if</span> <span>(</span>ws <span>&lt;</span> <span>0</span><span>)</span>
		<span>compareAndSetWaitStatus</span><span>(</span>node<span>,</span> ws<span>,</span> <span>0</span><span>)</span><span>;</span>
	<span>// 获取当前节点的下一个节点</span>
	<span>Node</span> s <span>=</span> node<span>.</span>next<span>;</span>
	<span>// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span>
	<span>if</span> <span>(</span>s <span>==</span> <span>null</span> <span>||</span> s<span>.</span>waitStatus <span>></span> <span>0</span><span>)</span> <span>{</span>
		s <span>=</span> <span>null</span><span>;</span>
		<span>// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span>
		<span>for</span> <span>(</span><span>Node</span> t <span>=</span> tail<span>;</span> t <span>!=</span> <span>null</span> <span>&amp;&amp;</span> t <span>!=</span> node<span>;</span> t <span>=</span> t<span>.</span>prev<span>)</span>
			<span>if</span> <span>(</span>t<span>.</span>waitStatus <span>&lt;=</span> <span>0</span><span>)</span>
				s <span>=</span> t<span>;</span>
	<span>}</span>
	<span>// 如果当前节点的下个节点不为空，而且状态&lt;=0，就把当前节点unpark</span>
	<span>if</span> <span>(</span>s <span>!=</span> <span>null</span><span>)</span>
		<span>LockSupport</span><span>.</span><span>unpark</span><span>(</span>s<span>.</span>thread<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>为什么要从后往前找第一个非 Cancelled 的节点呢？原因如下。</p>
<p>之前的 addWaiter 方法：</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>private</span> <span>Node</span> <span>addWaiter</span><span>(</span><span>Node</span> mode<span>)</span> <span>{</span>
	<span>Node</span> node <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>,</span> mode<span>)</span><span>;</span>
	<span>// Try the fast path of enq; backup to full enq on failure</span>
	<span>Node</span> pred <span>=</span> tail<span>;</span>
	<span>if</span> <span>(</span>pred <span>!=</span> <span>null</span><span>)</span> <span>{</span>
		node<span>.</span>prev <span>=</span> pred<span>;</span>
		<span>if</span> <span>(</span><span>compareAndSetTail</span><span>(</span>pred<span>,</span> node<span>)</span><span>)</span> <span>{</span>
			pred<span>.</span>next <span>=</span> node<span>;</span>
			<span>return</span> node<span>;</span>
		<span>}</span>
	<span>}</span>
	<span>enq</span><span>(</span>node<span>)</span><span>;</span>
	<span>return</span> node<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作 Tail 入队的原子操作，但是此时 pred.next = node;还没执行，如果这个时候执行了 unparkSuccessor 方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生 CANCELLED 状态节点的时候，先断开的是 Next 指针，Prev 指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的 Node。</p>
<p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和 CANCELLED 节点产生过程中断开 Next 指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行 acquireQueued 方法以后，中断如何处理？</p>
<h3 id="_2-3-4-中断恢复后的执行流程"> 2.3.4 中断恢复后的执行流程</h3>
<p>唤醒后，会执行 return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>private</span> <span>final</span> <span>boolean</span> <span>parkAndCheckInterrupt</span><span>(</span><span>)</span> <span>{</span>
	<span>LockSupport</span><span>.</span><span>park</span><span>(</span><span>this</span><span>)</span><span>;</span>
	<span>return</span> <span>Thread</span><span>.</span><span>interrupted</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>再回到 acquireQueued 代码，当 parkAndCheckInterrupt 返回 True 或者 False 的时候，interrupted 的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前 interrupted 返回。</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>final</span> <span>boolean</span> <span>acquireQueued</span><span>(</span><span>final</span> <span>Node</span> node<span>,</span> <span>int</span> arg<span>)</span> <span>{</span>
	<span>boolean</span> failed <span>=</span> <span>true</span><span>;</span>
	<span>try</span> <span>{</span>
		<span>boolean</span> interrupted <span>=</span> <span>false</span><span>;</span>
		<span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
			<span>final</span> <span>Node</span> p <span>=</span> node<span>.</span><span>predecessor</span><span>(</span><span>)</span><span>;</span>
			<span>if</span> <span>(</span>p <span>==</span> head <span>&amp;&amp;</span> <span>tryAcquire</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>
				<span>setHead</span><span>(</span>node<span>)</span><span>;</span>
				p<span>.</span>next <span>=</span> <span>null</span><span>;</span> <span>// help GC</span>
				failed <span>=</span> <span>false</span><span>;</span>
				<span>return</span> interrupted<span>;</span>
			<span>}</span>
			<span>if</span> <span>(</span><span>shouldParkAfterFailedAcquire</span><span>(</span>p<span>,</span> node<span>)</span> <span>&amp;&amp;</span> <span>parkAndCheckInterrupt</span><span>(</span><span>)</span><span>)</span>
				interrupted <span>=</span> <span>true</span><span>;</span>
			<span>}</span>
	<span>}</span> <span>finally</span> <span>{</span>
		<span>if</span> <span>(</span>failed<span>)</span>
			<span>cancelAcquire</span><span>(</span>node<span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>如果 acquireQueued 为 True，就会执行 selfInterrupt 方法。</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>static</span> <span>void</span> <span>selfInterrupt</span><span>(</span><span>)</span> <span>{</span>
	<span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于 Java 提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：</p>
<ol>
<li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过 Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为 False），并记录下来，如果发现该线程被中断过，就再中断一次。</li>
<li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li>
</ol>
<p>这里的处理方式主要是运用线程池中基本运作单元 Worder 中的 runWorker，通过 Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下 ThreadPoolExecutor 源码。</p>
<h3 id="_2-3-5-小结"> 2.3.5 小结</h3>
<p>我们在 1.3 小节中提出了一些问题，现在来回答一下。</p>
<blockquote>
<p>Q：某个线程获取锁失败的后续流程是什么呢？</p>
<p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>
<p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p>
<p>A：是 CLH 变体的 FIFO 双端队列。</p>
<p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p>
<p>A：可以详细看下 2.3.1.3 小节。</p>
<p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p>
<p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见 2.3.2 小节。</p>
<p>Q：Lock 函数通过 Acquire 方法进行加锁，但是具体是如何加锁的呢？</p>
<p>A：AQS 的 Acquire 会调用 tryAcquire 方法，tryAcquire 由各个自定义同步器实现，通过 tryAcquire 完成加锁过程。</p>
</blockquote>
<h2 id="_3-aqs-应用"> 3 AQS 应用</h2>
<h3 id="_3-1-reentrantlock-的可重入应用"> 3.1 ReentrantLock 的可重入应用</h3>
<p>ReentrantLock 的可重入性是 AQS 很好的应用之一，在了解完上述知识点以后，我们很容易得知 ReentrantLock 实现可重入的方法。在 ReentrantLock 里面，不管是公平锁还是非公平锁，都有一段逻辑。</p>
<p>公平锁：</p>
<div><pre><code><span>// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</span>

<span>if</span> <span>(</span>c <span>==</span> <span>0</span><span>)</span> <span>{</span>
	<span>if</span> <span>(</span><span>!</span><span>hasQueuedPredecessors</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>compareAndSetState</span><span>(</span><span>0</span><span>,</span> acquires<span>)</span><span>)</span> <span>{</span>
		<span>setExclusiveOwnerThread</span><span>(</span>current<span>)</span><span>;</span>
		<span>return</span> <span>true</span><span>;</span>
	<span>}</span>
<span>}</span>
<span>else</span> <span>if</span> <span>(</span>current <span>==</span> <span>getExclusiveOwnerThread</span><span>(</span><span>)</span><span>)</span> <span>{</span>
	<span>int</span> nextc <span>=</span> c <span>+</span> acquires<span>;</span>
	<span>if</span> <span>(</span>nextc <span>&lt;</span> <span>0</span><span>)</span>
		<span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>"Maximum lock count exceeded"</span><span>)</span><span>;</span>
	<span>setState</span><span>(</span>nextc<span>)</span><span>;</span>
	<span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>非公平锁：</p>
<div><pre><code><span>// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span>

<span>if</span> <span>(</span>c <span>==</span> <span>0</span><span>)</span> <span>{</span>
	<span>if</span> <span>(</span><span>compareAndSetState</span><span>(</span><span>0</span><span>,</span> acquires<span>)</span><span>)</span><span>{</span>
		<span>setExclusiveOwnerThread</span><span>(</span>current<span>)</span><span>;</span>
		<span>return</span> <span>true</span><span>;</span>
	<span>}</span>
<span>}</span>
<span>else</span> <span>if</span> <span>(</span>current <span>==</span> <span>getExclusiveOwnerThread</span><span>(</span><span>)</span><span>)</span> <span>{</span>
	<span>int</span> nextc <span>=</span> c <span>+</span> acquires<span>;</span>
	<span>if</span> <span>(</span>nextc <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>
		<span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>"Maximum lock count exceeded"</span><span>)</span><span>;</span>
	<span>setState</span><span>(</span>nextc<span>)</span><span>;</span>
	<span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>从上面这两段都可以看到，有一个同步状态 State 来控制整体可重入的情况。State 是 Volatile 修饰的，用于保证一定的可见性和有序性。</p>
<div><pre><code><span>// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>

<span>private</span> <span>volatile</span> <span>int</span> state<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>接下来看 State 这个字段主要的过程：</p>
<ol>
<li>State 初始化的时候为 0，表示没有任何线程持有锁。</li>
<li>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</li>
<li>解锁也是对这个字段-1，一直到 0，此线程对锁释放。</li>
</ol>
<h3 id="_3-2-juc-中的应用场景"> 3.2 JUC 中的应用场景</h3>
<p>除了上边 ReentrantLock 的可重入性的应用，AQS 作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了 JUC 中的几种同步工具，大体介绍一下 AQS 的应用场景：</p>
<table>
<thead>
<tr>
<th style="text-align:left">同步工具</th>
<th style="text-align:left">同步工具与 AQS 的关联</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ReentrantLock</td>
<td style="text-align:left">使用 AQS 保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock 记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td>
</tr>
<tr>
<td style="text-align:left">Semaphore</td>
<td style="text-align:left">使用 AQS 同步状态来保存信号量的当前计数。tryRelease 会增加计数，acquireShared 会减少计数。</td>
</tr>
<tr>
<td style="text-align:left">CountDownLatch</td>
<td style="text-align:left">使用 AQS 同步状态来表示计数。计数为 0 时，所有的 Acquire 操作（CountDownLatch 的 await 方法）才可以通过。</td>
</tr>
<tr>
<td style="text-align:left">ReentrantReadWriteLock</td>
<td style="text-align:left">使用 AQS 同步状态中的 16 位保存写锁持有的次数，剩下的 16 位用于保存读锁的持有次数。</td>
</tr>
<tr>
<td style="text-align:left">ThreadPoolExecutor</td>
<td style="text-align:left">Worker 利用 AQS 同步状态实现对独占线程变量的设置（tryAcquire 和 tryRelease）。</td>
</tr>
</tbody>
</table>
<h3 id="_3-3-自定义同步工具"> 3.3 自定义同步工具</h3>
<p>了解 AQS 基本原理以后，按照上面所说的 AQS 知识点，自己实现一个同步工具。</p>
<div><pre><code><span>public</span> <span>class</span> <span>LeeLock</span>  <span>{</span>

    <span>private</span> <span>static</span> <span>class</span> <span>Sync</span> <span>extends</span> <span>AbstractQueuedSynchronizer</span> <span>{</span>
        <span>@Override</span>
        <span>protected</span> <span>boolean</span> tryAcquire <span>(</span><span>int</span> arg<span>)</span> <span>{</span>
            <span>return</span> <span>compareAndSetState</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>

        <span>@Override</span>
        <span>protected</span> <span>boolean</span> tryRelease <span>(</span><span>int</span> arg<span>)</span> <span>{</span>
            <span>setState</span><span>(</span><span>0</span><span>)</span><span>;</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>

        <span>@Override</span>
        <span>protected</span> <span>boolean</span> isHeldExclusively <span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>getState</span><span>(</span><span>)</span> <span>==</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>private</span> <span>Sync</span> sync <span>=</span> <span>new</span> <span>Sync</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>void</span> lock <span>(</span><span>)</span> <span>{</span>
        sync<span>.</span><span>acquire</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> unlock <span>(</span><span>)</span> <span>{</span>
        sync<span>.</span><span>release</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>通过我们自己定义的 Lock 完成一定的同步功能。</p>
<div><pre><code><span>public</span> <span>class</span> <span>LeeMain</span> <span>{</span>

    <span>static</span> <span>int</span> count <span>=</span> <span>0</span><span>;</span>
    <span>static</span> <span>LeeLock</span> leeLock <span>=</span> <span>new</span> <span>LeeLock</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> main <span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>

        <span>Runnable</span> runnable <span>=</span> <span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>
            <span>@Override</span>
            <span>public</span> <span>void</span> run <span>(</span><span>)</span> <span>{</span>
                <span>try</span> <span>{</span>
                    leeLock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>
                    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                        count<span>++</span><span>;</span>
                    <span>}</span>
                <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span> <span>finally</span> <span>{</span>
                    leeLock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>

            <span>}</span>
        <span>}</span><span>;</span>
        <span>Thread</span> thread1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span>runnable<span>)</span><span>;</span>
        <span>Thread</span> thread2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span>runnable<span>)</span><span>;</span>
        thread1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        thread2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        thread1<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
        thread2<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>count<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>上述代码每次运行结果都会是 20000。通过简单的几行代码就能实现同步功能，这就是 AQS 的强大之处。</p>
<h2 id="总结"> 总结</h2>
<p>我们日常开发中使用并发的场景太多，但是对并发内部的基本框架原理了解的人却不多。由于篇幅原因，本文仅介绍了可重入锁 ReentrantLock 的原理和 AQS 原理，希望能够成为大家了解 AQS 和 ReentrantLock 等同步器的“敲门砖”。</p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li>Lea D. The java. util. concurrent synchronizer framework[J]. Science of Computer Programming, 2005, 58(3): 293-309.</li>
<li>《Java 并发编程实战》</li>
<li><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener noreferrer">不可不说的 Java“锁”事</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png" type="image/png"/>
    </item>
    <item>
      <title>JDK 提供的并发容器总结</title>
      <link>https://javaguide.cn/java/concurrent/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/java/concurrent/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">JDK 提供的并发容器总结</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>JDK 提供的这些容器大部分在 <code>java.util.concurrent</code> 包中。</p>
<ul>
<li><strong><code>ConcurrentHashMap</code></strong> : 线程安全的 <code>HashMap</code></li>
<li><strong><code>CopyOnWriteArrayList</code></strong> : 线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</li>
<li><strong><code>ConcurrentLinkedQueue</code></strong> : 高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li>
<li><strong><code>BlockingQueue</code></strong> : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li>
<li><strong><code>ConcurrentSkipListMap</code></strong> : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</li>
</ul>
<h2 id="concurrenthashmap"> ConcurrentHashMap</h2>
<p>我们知道 <code>HashMap</code> 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 <code>Collections.synchronizedMap()</code> 方法来包装我们的 <code>HashMap</code>。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p>
<p>所以就有了 <code>HashMap</code> 的线程安全版本—— <code>ConcurrentHashMap</code> 的诞生。</p>
<p>在 <code>ConcurrentHashMap</code> 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。</p>
<h2 id="copyonwritearraylist"> CopyOnWriteArrayList</h2>
<h3 id="copyonwritearraylist-简介"> CopyOnWriteArrayList 简介</h3>
<div><pre><code><span>public</span> <span>class</span> <span>CopyOnWriteArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span>
<span>extends</span> <span>Object</span>
<span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span>Serializable</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们应该允许多个线程同时访问 <code>List</code> 的内部数据，毕竟读取操作是安全的。</p>
<p>这和我们之前在多线程章节讲过 <code>ReentrantReadWriteLock</code> 读写锁的思想非常类似，也就是读读共享、写写互斥、读写互斥、写读互斥。JDK 中提供了 <code>CopyOnWriteArrayList</code> 类比相比于在读写锁的思想又更进一步。为了将读取的性能发挥到极致，<code>CopyOnWriteArrayList</code> 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。<strong>那它是怎么做的呢？</strong></p>
<h3 id="copyonwritearraylist-是如何做到的"> CopyOnWriteArrayList 是如何做到的？</h3>
<p><code>CopyOnWriteArrayList</code> 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。</p>
<p>从 <code>CopyOnWriteArrayList</code> 的名字就能看出 <code>CopyOnWriteArrayList</code> 是满足 <code>CopyOnWrite</code> 的。所谓 <code>CopyOnWrite</code> 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。</p>
<h3 id="copyonwritearraylist-读取和写入源码简单分析"> CopyOnWriteArrayList 读取和写入源码简单分析</h3>
<h4 id="copyonwritearraylist-读取操作的实现"> CopyOnWriteArrayList 读取操作的实现</h4>
<p>读取操作没有任何同步控制和锁操作，理由就是内部数组 <code>array</code> 不会发生修改，只会被另外一个 <code>array</code> 替换，因此可以保证数据安全。</p>
<div><pre><code>    <span>/** The array, accessed only via getArray/setArray. */</span>
    <span>private</span> <span>transient</span> <span>volatile</span> <span>Object</span><span>[</span><span>]</span> array<span>;</span>
    <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> <span>get</span><span>(</span><span>getArray</span><span>(</span><span>)</span><span>,</span> index<span>)</span><span>;</span>
    <span>}</span>
    <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
    <span>private</span> <span>E</span> <span>get</span><span>(</span><span>Object</span><span>[</span><span>]</span> a<span>,</span> <span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> <span>(</span><span>E</span><span>)</span> a<span>[</span>index<span>]</span><span>;</span>
    <span>}</span>
    <span>final</span> <span>Object</span><span>[</span><span>]</span> <span>getArray</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> array<span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="_3-3-2-copyonwritearraylist-写入操作的实现"> 3.3.2 CopyOnWriteArrayList 写入操作的实现</h4>
<p><code>CopyOnWriteArrayList</code> 写入操作 <code>add()</code>方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。</p>
<div><pre><code>    <span>/**
     * Appends the specified element to the end of this list.
     *
     * @param e element to be appended to this list
     * @return {@code true} (as specified by {@link Collection#add})
     */</span>
    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
        <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>
        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span><span>//加锁</span>
        <span>try</span> <span>{</span>
            <span>Object</span><span>[</span><span>]</span> elements <span>=</span> <span>getArray</span><span>(</span><span>)</span><span>;</span>
            <span>int</span> len <span>=</span> elements<span>.</span>length<span>;</span>
            <span>Object</span><span>[</span><span>]</span> newElements <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elements<span>,</span> len <span>+</span> <span>1</span><span>)</span><span>;</span><span>//拷贝新数组</span>
            newElements<span>[</span>len<span>]</span> <span>=</span> e<span>;</span>
            <span>setArray</span><span>(</span>newElements<span>)</span><span>;</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span> <span>finally</span> <span>{</span>
            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span><span>//释放锁</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="concurrentlinkedqueue"> ConcurrentLinkedQueue</h2>
<p>Java 提供的线程安全的 <code>Queue</code> 可以分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，其中阻塞队列的典型例子是 <code>BlockingQueue</code>，非阻塞队列的典型例子是 <code>ConcurrentLinkedQueue</code>，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 <strong>阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</strong></p>
<p>从名字可以看出，<code>ConcurrentLinkedQueue</code>这个队列使用链表作为其数据结构．<code>ConcurrentLinkedQueue</code> 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</p>
<p><code>ConcurrentLinkedQueue</code> 内部代码我们就不分析了，大家知道 <code>ConcurrentLinkedQueue</code> 主要使用 CAS 非阻塞算法来实现线程安全就好了。</p>
<p><code>ConcurrentLinkedQueue</code> 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 <code>ConcurrentLinkedQueue</code> 来替代。</p>
<h2 id="blockingqueue"> BlockingQueue</h2>
<h3 id="blockingqueue-简介"> BlockingQueue 简介</h3>
<p>上面我们己经提到了 <code>ConcurrentLinkedQueue</code> 作为高性能的非阻塞队列。下面我们要讲到的是阻塞队列——<code>BlockingQueue</code>。阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p>
<p><code>BlockingQueue</code> 是一个接口，继承自 <code>Queue</code>，所以其实现类也可以作为 <code>Queue</code> 的实现来使用，而 <code>Queue</code> 又继承自 <code>Collection</code> 接口。下面是 <code>BlockingQueue</code> 的相关实现类：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/51622268.jpg" alt="BlockingQueue 的实现类" /></p>
<p>下面主要介绍一下 3 个常见的 <code>BlockingQueue</code> 的实现类：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 、<code>PriorityBlockingQueue</code> 。</p>
<h3 id="arrayblockingqueue"> ArrayBlockingQueue</h3>
<p><code>ArrayBlockingQueue</code> 是 <code>BlockingQueue</code> 接口的有界队列实现类，底层采用数组来实现。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>E</span><span>></span></span>
<span>extends</span> <span>AbstractQueue</span><span><span>&lt;</span><span>E</span><span>></span></span>
<span>implements</span> <span>BlockingQueue</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>Serializable</span><span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>ArrayBlockingQueue</code> 一旦创建，容量不能改变。其并发控制采用可重入锁 <code>ReentrantLock</code> ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p>
<p><code>ArrayBlockingQueue</code> 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 <code>ArrayBlockingQueue</code>。而非公平性则是指访问 <code>ArrayBlockingQueue</code> 的顺序不是遵守严格的时间顺序，有可能存在，当 <code>ArrayBlockingQueue</code> 可以被访问时，长时间阻塞的线程依然无法访问到 <code>ArrayBlockingQueue</code>。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 <code>ArrayBlockingQueue</code>，可采用如下代码：</p>
<div><pre><code><span>private</span> <span>static</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> blockingQueue <span>=</span> <span>new</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>10</span><span>,</span><span>true</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="linkedblockingqueue"> LinkedBlockingQueue</h3>
<p><code>LinkedBlockingQueue</code> 底层基于<strong>单向链表</strong>实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 <code>ArrayBlockingQueue</code> 相比起来具有更高的吞吐量，为了防止 <code>LinkedBlockingQueue</code> 容量迅速增，损耗大量内存。通常在创建 <code>LinkedBlockingQueue</code> 对象时，会指定其大小，如果未指定，容量等于 <code>Integer.MAX_VALUE</code> 。</p>
<p><strong>相关构造方法:</strong></p>
<div><pre><code>    <span>/**
     *某种意义上的无界队列
     * Creates a {@code LinkedBlockingQueue} with a capacity of
     * {@link Integer#MAX_VALUE}.
     */</span>
    <span>public</span> <span>LinkedBlockingQueue</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>(</span><span>Integer</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     *有界队列
     * Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity.
     *
     * @param capacity the capacity of this queue
     * @throws IllegalArgumentException if {@code capacity} is not greater
     *         than zero
     */</span>
    <span>public</span> <span>LinkedBlockingQueue</span><span>(</span><span>int</span> capacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>capacity <span>&lt;=</span> <span>0</span><span>)</span> <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>capacity <span>=</span> capacity<span>;</span>
        last <span>=</span> head <span>=</span> <span>new</span> <span>Node</span><span><span>&lt;</span><span>E</span><span>></span></span><span>(</span><span>null</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="priorityblockingqueue"> PriorityBlockingQueue</h3>
<p><code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化时通过构造器参数 <code>Comparator</code> 来指定排序规则。</p>
<p><code>PriorityBlockingQueue</code> 并发控制采用的是可重入锁 <code>ReentrantLock</code>，队列为无界队列（<code>ArrayBlockingQueue</code> 是有界队列，<code>LinkedBlockingQueue</code> 也可以通过在构造函数中传入 <code>capacity</code> 指定队列最大的容量，但是 <code>PriorityBlockingQueue</code> 只能指定初始的队列大小，后面插入元素的时候，<strong>如果空间不够的话会自动扩容</strong>）。</p>
<p>简单地说，它就是 <code>PriorityQueue</code> 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 <code>ClassCastException</code> 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p>
<p><strong>推荐文章：</strong> <a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener noreferrer">《解读 Java 并发队列 BlockingQueue》</a></p>
<h2 id="concurrentskiplistmap"> ConcurrentSkipListMap</h2>
<p>下面这部分内容参考了极客时间专栏<a href="https://time.geekbang.org/column/intro/126?code=zl3GYeAsRI4rEJIBNu5B/km7LSZsPDlGWQEpAYw5Vu0=&amp;utm_term=SPoster" title="《数据结构与算法之美》" target="_blank" rel="noopener noreferrer">《数据结构与算法之美》</a>以及《实战 Java 高并发程序设计》。</p>
<p>为了引出 <code>ConcurrentSkipListMap</code>，先带着大家简单理解一下跳表。</p>
<p>对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 <strong>O(logn)</strong> 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</p>
<p>跳表的本质是同时维护了多个链表，并且链表是分层的，</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/93666217.jpg" alt="2级索引跳表" /></p>
<p>最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。</p>
<p>跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素 18。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/32005738.jpg" alt="在跳表中查找元素18" /></p>
<p>查找 18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。</p>
<p>从上面很容易看出，<strong>跳表是一种利用空间换时间的算法。</strong></p>
<p>使用跳表实现 <code>Map</code> 和使用哈希算法实现 <code>Map</code> 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是 <code>ConcurrentSkipListMap</code>。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li>《实战 Java 高并发程序设计》</li>
<li>https://javadoop.com/post/java-concurrent-queue</li>
<li>https://juejin.im/post/5aeebd02518825672f19c546</li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/51622268.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>万字解析 ThreadLocal 关键字</title>
      <link>https://javaguide.cn/java/concurrent/threadlocal/</link>
      <guid>https://javaguide.cn/java/concurrent/threadlocal/</guid>
      <source url="https://javaguide.cn/rss.xml">万字解析 ThreadLocal 关键字</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文来自一枝花算不算浪漫投稿， 原文地址：<a href="https://juejin.im/post/5eacc1c75188256d976df748" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5eacc1c75188256d976df748</a>。</p>
</blockquote>
<h3 id="前言"> 前言</h3>
<p><img src="./images/thread-local/1.png" alt="" /></p>
<p><strong>全文共 10000+字，31 张图，这篇文章同样耗费了不少的时间和精力才创作完成，原创不易，请大家点点关注+在看，感谢。</strong></p>
<p>对于<code>ThreadLocal</code>，大家的第一反应可能是很简单呀，线程的变量副本，每个线程隔离。那这里有几个问题大家可以思考一下：</p>
<ul>
<li><code>ThreadLocal</code>的 key 是<strong>弱引用</strong>，那么在 <code>ThreadLocal.get()</code>的时候，发生<strong>GC</strong>之后，key 是否为<strong>null</strong>？</li>
<li><code>ThreadLocal</code>中<code>ThreadLocalMap</code>的<strong>数据结构</strong>？</li>
<li><code>ThreadLocalMap</code>的<strong>Hash 算法</strong>？</li>
<li><code>ThreadLocalMap</code>中<strong>Hash 冲突</strong>如何解决？</li>
<li><code>ThreadLocalMap</code>的<strong>扩容机制</strong>？</li>
<li><code>ThreadLocalMap</code>中<strong>过期 key 的清理机制</strong>？<strong>探测式清理</strong>和<strong>启发式清理</strong>流程？</li>
<li><code>ThreadLocalMap.set()</code>方法实现原理？</li>
<li><code>ThreadLocalMap.get()</code>方法实现原理？</li>
<li>项目中<code>ThreadLocal</code>使用情况？遇到的坑？</li>
<li>......</li>
</ul>
<p>上述的一些问题你是否都已经掌握的很清楚了呢？本文将围绕这些问题使用图文方式来剖析<code>ThreadLocal</code>的<strong>点点滴滴</strong>。</p>
<h3 id="目录"> 目录</h3>
<p><strong>注明：</strong> 本文源码基于<code>JDK 1.8</code></p>
<h3 id="threadlocal代码演示"> <code>ThreadLocal</code>代码演示</h3>
<p>我们先看下<code>ThreadLocal</code>使用示例：</p>
<div><pre><code><span>public</span> <span>class</span> <span>ThreadLocalTest</span> <span>{</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> messages <span>=</span> <span>Lists</span><span>.</span><span>newArrayList</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>final</span> <span>ThreadLocal</span><span><span>&lt;</span><span>ThreadLocalTest</span><span>></span></span> holder <span>=</span> <span>ThreadLocal</span><span>.</span><span>withInitial</span><span>(</span><span>ThreadLocalTest</span><span>::</span><span>new</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>add</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        holder<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span>messages<span>.</span><span>add</span><span>(</span>message<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>clear</span><span>(</span><span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> messages <span>=</span> holder<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span>messages<span>;</span>
        holder<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"size: "</span> <span>+</span> holder<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span>messages<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> messages<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ThreadLocalTest</span><span>.</span><span>add</span><span>(</span><span>"一枝花算不算浪漫"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>holder<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span>messages<span>)</span><span>;</span>
        <span>ThreadLocalTest</span><span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>打印结果：</p>
<div><pre><code><span>[</span>一枝花算不算浪漫<span>]</span>
size<span>:</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>ThreadLocal</code>对象可以提供线程局部变量，每个线程<code>Thread</code>拥有一份自己的<strong>副本变量</strong>，多个线程互不干扰。</p>
<h3 id="threadlocal的数据结构"> <code>ThreadLocal</code>的数据结构</h3>
<p><img src="./images/thread-local/2.png" alt="" /></p>
<p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。</p>
<p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p>
<p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p>
<p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构。</p>
<p>我们还要注意<code>Entry</code>， 它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code> ，继承自<code>WeakReference</code>， 也就是我们常说的弱引用类型。</p>
<h3 id="gc-之后-key-是否为-null"> GC 之后 key 是否为 null？</h3>
<p>回应开头的那个问题， <code>ThreadLocal</code> 的<code>key</code>是弱引用，那么在<code>ThreadLocal.get()</code>的时候，发生<code>GC</code>之后，<code>key</code>是否是<code>null</code>？</p>
<p>为了搞清楚这个问题，我们需要搞清楚<code>Java</code>的<strong>四种引用类型</strong>：</p>
<ul>
<li><strong>强引用</strong>：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候</li>
<li><strong>软引用</strong>：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收</li>
<li><strong>弱引用</strong>：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li>
<li><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知</li>
</ul>
<p>接着再来看下代码，我们使用反射的方式来看看<code>GC</code>后<code>ThreadLocal</code>中的数据情况：(下面代码来源自：https://blog.csdn.net/thewindkee/article/details/103726942 本地运行演示 GC 回收场景)</p>
<div><pre><code><span>public</span> <span>class</span> <span>ThreadLocalDemo</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>NoSuchFieldException</span><span>,</span> <span>IllegalAccessException</span><span>,</span> <span>InterruptedException</span> <span>{</span>
        <span>Thread</span> t <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span><span>-></span><span>test</span><span>(</span><span>"abc"</span><span>,</span><span>false</span><span>)</span><span>)</span><span>;</span>
        t<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        t<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"--gc后--"</span><span>)</span><span>;</span>
        <span>Thread</span> t2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>test</span><span>(</span><span>"def"</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>
        t2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        t2<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>static</span> <span>void</span> <span>test</span><span>(</span><span>String</span> s<span>,</span><span>boolean</span> isGC<span>)</span>  <span>{</span>
        <span>try</span> <span>{</span>
            <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>.</span><span>set</span><span>(</span>s<span>)</span><span>;</span>
            <span>if</span> <span>(</span>isGC<span>)</span> <span>{</span>
                <span>System</span><span>.</span><span>gc</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
            <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>
            <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Thread</span><span>></span></span> clz <span>=</span> t<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
            <span>Field</span> field <span>=</span> clz<span>.</span><span>getDeclaredField</span><span>(</span><span>"threadLocals"</span><span>)</span><span>;</span>
            field<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
            <span>Object</span> <span>ThreadLocalMap</span> <span>=</span> field<span>.</span><span>get</span><span>(</span>t<span>)</span><span>;</span>
            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> tlmClass <span>=</span> <span>ThreadLocalMap</span><span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
            <span>Field</span> tableField <span>=</span> tlmClass<span>.</span><span>getDeclaredField</span><span>(</span><span>"table"</span><span>)</span><span>;</span>
            tableField<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
            <span>Object</span><span>[</span><span>]</span> arr <span>=</span> <span>(</span><span>Object</span><span>[</span><span>]</span><span>)</span> tableField<span>.</span><span>get</span><span>(</span><span>ThreadLocalMap</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>Object</span> o <span>:</span> arr<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>o <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> entryClass <span>=</span> o<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
                    <span>Field</span> valueField <span>=</span> entryClass<span>.</span><span>getDeclaredField</span><span>(</span><span>"value"</span><span>)</span><span>;</span>
                    <span>Field</span> referenceField <span>=</span> entryClass<span>.</span><span>getSuperclass</span><span>(</span><span>)</span><span>.</span><span>getSuperclass</span><span>(</span><span>)</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"referent"</span><span>)</span><span>;</span>
                    valueField<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
                    referenceField<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"弱引用key:%s,值:%s"</span><span>,</span> referenceField<span>.</span><span>get</span><span>(</span>o<span>)</span><span>,</span> valueField<span>.</span><span>get</span><span>(</span>o<span>)</span><span>)</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>结果如下：</p>
<div><pre><code>弱引用key<span>:</span><span><span>java<span>.</span>lang<span>.</span></span>ThreadLocal</span><span>@433619b6</span><span>,</span>值<span>:</span>abc
弱引用key<span>:</span><span><span>java<span>.</span>lang<span>.</span></span>ThreadLocal</span><span>@418a15e3</span><span>,</span>值<span>:</span><span><span>java<span>.</span>lang<span>.</span>ref<span>.</span></span>SoftReference</span><span>@bf97a12</span>
<span>--</span>gc后<span>--</span>
弱引用key<span>:</span><span>null</span><span>,</span>值<span>:</span>def
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="./images/thread-local/3.png" alt="" /></p>
<p>如图所示，因为这里创建的<code>ThreadLocal</code>并没有指向任何值，也就是没有任何引用：</p>
<div><pre><code><span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>.</span><span>set</span><span>(</span>s<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>所以这里在<code>GC</code>之后，<code>key</code>就会被回收，我们看到上面<code>debug</code>中的<code>referent=null</code>, 如果<strong>改动一下代码：</strong></p>
<p><img src="./images/thread-local/4.png" alt="" /></p>
<p>这个问题刚开始看，如果没有过多思考，<strong>弱引用</strong>，还有<strong>垃圾回收</strong>，那么肯定会觉得是<code>null</code>。</p>
<p>其实是不对的，因为题目说的是在做 <code>ThreadLocal.get()</code> 操作，证明其实还是有<strong>强引用</strong>存在的，所以 <code>key</code> 并不为 <code>null</code>，如下图所示，<code>ThreadLocal</code>的<strong>强引用</strong>仍然是存在的。</p>
<p><img src="./images/thread-local/5.png" alt="image.png" /></p>
<p>如果我们的<strong>强引用</strong>不存在的话，那么 <code>key</code> 就会被回收，也就是会出现我们 <code>value</code> 没被回收，<code>key</code> 被回收，导致 <code>value</code> 永远存在，出现内存泄漏。</p>
<h3 id="threadlocal-set-方法源码详解"> <code>ThreadLocal.set()</code>方法源码详解</h3>
<p><img src="./images/thread-local/6.png" alt="" /></p>
<p><code>ThreadLocal</code>中的<code>set</code>方法原理如上图所示，很简单，主要是判断<code>ThreadLocalMap</code>是否存在，然后使用<code>ThreadLocal</code>中的<code>set</code>方法进行数据处理。</p>
<p>代码如下：</p>
<div><pre><code><span>public</span> <span>void</span> <span>set</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>
    <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>
    <span>ThreadLocalMap</span> map <span>=</span> <span>getMap</span><span>(</span>t<span>)</span><span>;</span>
    <span>if</span> <span>(</span>map <span>!=</span> <span>null</span><span>)</span>
        map<span>.</span><span>set</span><span>(</span><span>this</span><span>,</span> value<span>)</span><span>;</span>
    <span>else</span>
        <span>createMap</span><span>(</span>t<span>,</span> value<span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>createMap</span><span>(</span><span>Thread</span> t<span>,</span> <span>T</span> firstValue<span>)</span> <span>{</span>
    t<span>.</span>threadLocals <span>=</span> <span>new</span> <span>ThreadLocalMap</span><span>(</span><span>this</span><span>,</span> firstValue<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>主要的核心逻辑还是在<code>ThreadLocalMap</code>中的，一步步往下看，后面还有更详细的剖析。</p>
<h3 id="threadlocalmap-hash-算法"> <code>ThreadLocalMap</code> Hash 算法</h3>
<p>既然是<code>Map</code>结构，那么<code>ThreadLocalMap</code>当然也要实现自己的<code>hash</code>算法来解决散列表数组冲突问题。</p>
<div><pre><code><span>int</span> i <span>=</span> key<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>len<span>-</span><span>1</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>ThreadLocalMap</code>中<code>hash</code>算法很简单，这里<code>i</code>就是当前 key 在散列表中对应的数组下标位置。</p>
<p>这里最关键的就是<code>threadLocalHashCode</code>值的计算，<code>ThreadLocal</code>中有一个属性为<code>HASH_INCREMENT = 0x61c88647</code></p>
<div><pre><code><span>public</span> <span>class</span> <span>ThreadLocal</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>
    <span>private</span> <span>final</span> <span>int</span> threadLocalHashCode <span>=</span> <span>nextHashCode</span><span>(</span><span>)</span><span>;</span>

    <span>private</span> <span>static</span> <span>AtomicInteger</span> nextHashCode <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>

    <span>private</span> <span>static</span> <span>final</span> <span>int</span> HASH_INCREMENT <span>=</span> <span>0x61c88647</span><span>;</span>

    <span>private</span> <span>static</span> <span>int</span> <span>nextHashCode</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> nextHashCode<span>.</span><span>getAndAdd</span><span>(</span>HASH_INCREMENT<span>)</span><span>;</span>
    <span>}</span>

    <span>static</span> <span>class</span> <span>ThreadLocalMap</span> <span>{</span>
        <span>ThreadLocalMap</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> firstKey<span>,</span> <span>Object</span> firstValue<span>)</span> <span>{</span>
            table <span>=</span> <span>new</span> <span>Entry</span><span>[</span>INITIAL_CAPACITY<span>]</span><span>;</span>
            <span>int</span> i <span>=</span> firstKey<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>INITIAL_CAPACITY <span>-</span> <span>1</span><span>)</span><span>;</span>

            table<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Entry</span><span>(</span>firstKey<span>,</span> firstValue<span>)</span><span>;</span>
            size <span>=</span> <span>1</span><span>;</span>
            <span>setThreshold</span><span>(</span>INITIAL_CAPACITY<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>每当创建一个<code>ThreadLocal</code>对象，这个<code>ThreadLocal.nextHashCode</code> 这个值就会增长 <code>0x61c88647</code> 。</p>
<p>这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p>
<p>我们自己可以尝试下：</p>
<p><img src="./images/thread-local/8.png" alt="" /></p>
<p>可以看到产生的哈希码分布很均匀，这里不去细纠<strong>斐波那契</strong>具体算法，感兴趣的可以自行查阅相关资料。</p>
<h3 id="threadlocalmap-hash-冲突"> <code>ThreadLocalMap</code> Hash 冲突</h3>
<blockquote>
<p><strong>注明：</strong> 下面所有示例图中，<strong>绿色块</strong><code>Entry</code>代表<strong>正常数据</strong>，<strong>灰色块</strong>代表<code>Entry</code>的<code>key</code>值为<code>null</code>，<strong>已被垃圾回收</strong>。<strong>白色块</strong>表示<code>Entry</code>为<code>null</code>。</p>
</blockquote>
<p>虽然<code>ThreadLocalMap</code>中使用了<strong>黄金分割数</strong>来作为<code>hash</code>计算因子，大大减少了<code>Hash</code>冲突的概率，但是仍然会存在冲突。</p>
<p><code>HashMap</code>中解决冲突的方法是在数组上构造一个<strong>链表</strong>结构，冲突的数据挂载到链表上，如果链表长度超过一定数量则会转化成<strong>红黑树</strong>。</p>
<p>而 <code>ThreadLocalMap</code> 中并没有链表结构，所以这里不能使用 <code>HashMap</code> 解决冲突的方式了。</p>
<p><img src="./images/thread-local/7.png" alt="" /></p>
<p>如上图所示，如果我们插入一个<code>value=27</code>的数据，通过 <code>hash</code> 计算后应该落入槽位 4 中，而槽位 4 已经有了 <code>Entry</code> 数据。</p>
<p>此时就会线性向后查找，一直找到 <code>Entry</code> 为 <code>null</code> 的槽位才会停止查找，将当前元素放入此槽位中。当然迭代过程中还有其他的情况，比如遇到了 <code>Entry</code> 不为 <code>null</code> 且 <code>key</code> 值相等的情况，还有 <code>Entry</code> 中的 <code>key</code> 值为 <code>null</code> 的情况等等都会有不同的处理，后面会一一详细讲解。</p>
<p>这里还画了一个<code>Entry</code>中的<code>key</code>为<code>null</code>的数据（<strong>Entry=2 的灰色块数据</strong>），因为<code>key</code>值是<strong>弱引用</strong>类型，所以会有这种数据存在。在<code>set</code>过程中，如果遇到了<code>key</code>过期的<code>Entry</code>数据，实际上是会进行一轮<strong>探测式清理</strong>操作的，具体操作方式后面会讲到。</p>
<h3 id="threadlocalmap-set-详解"> <code>ThreadLocalMap.set()</code>详解</h3>
<h4 id="threadlocalmap-set-原理图解"> <code>ThreadLocalMap.set()</code>原理图解</h4>
<p>看完了<code>ThreadLocal</code> <strong>hash 算法</strong>后，我们再来看<code>set</code>是如何实现的。</p>
<p>往<code>ThreadLocalMap</code>中<code>set</code>数据（<strong>新增</strong>或者<strong>更新</strong>数据）分为好几种情况，针对不同的情况我们画图来说明。</p>
<p><strong>第一种情况：</strong> 通过<code>hash</code>计算后的槽位对应的<code>Entry</code>数据为空：</p>
<p><img src="./images/thread-local/9.png" alt="" /></p>
<p>这里直接将数据放到该槽位即可。</p>
<p><strong>第二种情况：</strong> 槽位数据不为空，<code>key</code>值与当前<code>ThreadLocal</code>通过<code>hash</code>计算获取的<code>key</code>值一致：</p>
<p><img src="./images/thread-local/10.png" alt="" /></p>
<p>这里直接更新该槽位的数据。</p>
<p><strong>第三种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code>Entry</code>为<code>null</code>的槽位之前，没有遇到<code>key</code>过期的<code>Entry</code>：</p>
<p><img src="./images/thread-local/11.png" alt="" /></p>
<p>遍历散列数组，线性往后查找，如果找到<code>Entry</code>为<code>null</code>的槽位，则将数据放入该槽位中，或者往后遍历过程中，遇到了<strong>key 值相等</strong>的数据，直接更新即可。</p>
<p><strong>第四种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code>Entry</code>为<code>null</code>的槽位之前，遇到<code>key</code>过期的<code>Entry</code>，如下图，往后遍历过程中，遇到了<code>index=7</code>的槽位数据<code>Entry</code>的<code>key=null</code>：</p>
<p><img src="./images/thread-local/12.png" alt="" /></p>
<p>散列数组下标为 7 位置对应的<code>Entry</code>数据<code>key</code>为<code>null</code>，表明此数据<code>key</code>值已经被垃圾回收掉了，此时就会执行<code>replaceStaleEntry()</code>方法，该方法含义是<strong>替换过期数据的逻辑</strong>，以<strong>index=7</strong>位起点开始遍历，进行探测式数据清理工作。</p>
<p>初始化探测式清理过期数据扫描的开始位置：<code>slotToExpunge = staleSlot = 7</code></p>
<p>以当前<code>staleSlot</code>开始 向前迭代查找，找其他过期的数据，然后更新过期数据起始扫描下标<code>slotToExpunge</code>。<code>for</code>循环迭代，直到碰到<code>Entry</code>为<code>null</code>结束。</p>
<p>如果找到了过期的数据，继续向前迭代，直到遇到<code>Entry=null</code>的槽位才停止迭代，如下图所示，<strong>slotToExpunge 被更新为 0</strong>：</p>
<p><img src="./images/thread-local/13.png" alt="" /></p>
<p>以当前节点(<code>index=7</code>)向前迭代，检测是否有过期的<code>Entry</code>数据，如果有则更新<code>slotToExpunge</code>值。碰到<code>null</code>则结束探测。以上图为例<code>slotToExpunge</code>被更新为 0。</p>
<p>上面向前迭代的操作是为了更新探测清理过期数据的起始下标<code>slotToExpunge</code>的值，这个值在后面会讲解，它是用来判断当前过期槽位<code>staleSlot</code>之前是否还有过期元素。</p>
<p>接着开始以<code>staleSlot</code>位置(<code>index=7</code>)向后迭代，<strong>如果找到了相同 key 值的 Entry 数据：</strong></p>
<p><img src="./images/thread-local/14.png" alt="" /></p>
<p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>元素，找到后更新<code>Entry</code>的值并交换<code>staleSlot</code>元素的位置(<code>staleSlot</code>位置为过期元素)，更新<code>Entry</code>数据，然后开始进行过期<code>Entry</code>的清理工作，如下图所示：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/view.png" alt="" />向后遍历过程中，如果没有找到相同 key 值的 Entry 数据：</p>
<p><img src="./images/thread-local/15.png" alt="" /></p>
<p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>元素，直到<code>Entry</code>为<code>null</code>则停止寻找。通过上图可知，此时<code>table</code>中没有<code>key</code>值相同的<code>Entry</code>。</p>
<p>创建新的<code>Entry</code>，替换<code>table[stableSlot]</code>位置：</p>
<p><img src="./images/thread-local/16.png" alt="" /></p>
<p>替换完成后也是进行过期元素清理工作，清理工作主要是有两个方法：<code>expungeStaleEntry()</code>和<code>cleanSomeSlots()</code>，具体细节后面会讲到，请继续往后看。</p>
<h4 id="threadlocalmap-set-源码详解"> <code>ThreadLocalMap.set()</code>源码详解</h4>
<p>上面已经用图的方式解析了<code>set()</code>实现的原理，其实已经很清晰了，我们接着再看下源码：</p>
<p><code>java.lang.ThreadLocal</code>.<code>ThreadLocalMap.set()</code>:</p>
<div><pre><code><span>private</span> <span>void</span> <span>set</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> key<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>
    <span>Entry</span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span>
    <span>int</span> len <span>=</span> tab<span>.</span>length<span>;</span>
    <span>int</span> i <span>=</span> key<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>len<span>-</span><span>1</span><span>)</span><span>;</span>

    <span>for</span> <span>(</span><span>Entry</span> e <span>=</span> tab<span>[</span>i<span>]</span><span>;</span>
         e <span>!=</span> <span>null</span><span>;</span>
         e <span>=</span> tab<span>[</span>i <span>=</span> <span>nextIndex</span><span>(</span>i<span>,</span> len<span>)</span><span>]</span><span>)</span> <span>{</span>
        <span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k <span>=</span> e<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span>k <span>==</span> key<span>)</span> <span>{</span>
            e<span>.</span>value <span>=</span> value<span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>k <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>replaceStaleEntry</span><span>(</span>key<span>,</span> value<span>,</span> i<span>)</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
    <span>}</span>

    tab<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Entry</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>
    <span>int</span> sz <span>=</span> <span>++</span>size<span>;</span>
    <span>if</span> <span>(</span><span>!</span><span>cleanSomeSlots</span><span>(</span>i<span>,</span> sz<span>)</span> <span>&amp;&amp;</span> sz <span>>=</span> threshold<span>)</span>
        <span>rehash</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>这里会通过<code>key</code>来计算在散列表中的对应位置，然后以当前<code>key</code>对应的桶的位置向后查找，找到可以使用的桶。</p>
<div><pre><code><span>Entry</span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span>
<span>int</span> len <span>=</span> tab<span>.</span>length<span>;</span>
<span>int</span> i <span>=</span> key<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>len<span>-</span><span>1</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>什么情况下桶才是可以使用的呢？</p>
<ol>
<li><code>k = key</code> 说明是替换操作，可以使用</li>
<li>碰到一个过期的桶，执行替换逻辑，占用过期桶</li>
<li>查找过程中，碰到桶中<code>Entry=null</code>的情况，直接使用</li>
</ol>
<p>接着就是执行<code>for</code>循环遍历，向后查找，我们先看下<code>nextIndex()</code>、<code>prevIndex()</code>方法实现：</p>
<p><img src="./images/thread-local/17.png" alt="" /></p>
<div><pre><code><span>private</span> <span>static</span> <span>int</span> <span>nextIndex</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> len<span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>(</span>i <span>+</span> <span>1</span> <span>&lt;</span> len<span>)</span> <span>?</span> i <span>+</span> <span>1</span> <span>:</span> <span>0</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>static</span> <span>int</span> <span>prevIndex</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> len<span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>(</span>i <span>-</span> <span>1</span> <span>>=</span> <span>0</span><span>)</span> <span>?</span> i <span>-</span> <span>1</span> <span>:</span> len <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>接着看剩下<code>for</code>循环中的逻辑：</p>
<ol>
<li>遍历当前<code>key</code>值对应的桶中<code>Entry</code>数据为空，这说明散列数组这里没有数据冲突，跳出<code>for</code>循环，直接<code>set</code>数据到对应的桶中</li>
<li>如果<code>key</code>值对应的桶中<code>Entry</code>数据不为空<br>
2.1 如果<code>k = key</code>，说明当前<code>set</code>操作是一个替换操作，做替换逻辑，直接返回<br>
2.2 如果<code>key = null</code>，说明当前桶位置的<code>Entry</code>是过期数据，执行<code>replaceStaleEntry()</code>方法(核心方法)，然后返回</li>
<li><code>for</code>循环执行完毕，继续往下执行说明向后迭代的过程中遇到了<code>entry</code>为<code>null</code>的情况<br>
3.1 在<code>Entry</code>为<code>null</code>的桶中创建一个新的<code>Entry</code>对象<br>
3.2 执行<code>++size</code>操作</li>
<li>调用<code>cleanSomeSlots()</code>做一次启发式清理工作，清理散列数组中<code>Entry</code>的<code>key</code>过期的数据<br>
4.1 如果清理工作完成后，未清理到任何数据，且<code>size</code>超过了阈值(数组长度的 2/3)，进行<code>rehash()</code>操作<br>
4.2 <code>rehash()</code>中会先进行一轮探测式清理，清理过期<code>key</code>，清理完成后如果<strong>size &gt;= threshold - threshold / 4</strong>，就会执行真正的扩容逻辑(扩容逻辑往后看)</li>
</ol>
<p>接着重点看下<code>replaceStaleEntry()</code>方法，<code>replaceStaleEntry()</code>方法提供替换过期数据的功能，我们可以对应上面<strong>第四种情况</strong>的原理图来再回顾下，具体代码如下：</p>
<p><code>java.lang.ThreadLocal.ThreadLocalMap.replaceStaleEntry()</code>:</p>
<div><pre><code><span>private</span> <span>void</span> <span>replaceStaleEntry</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> key<span>,</span> <span>Object</span> value<span>,</span>
                                       <span>int</span> staleSlot<span>)</span> <span>{</span>
    <span>Entry</span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span>
    <span>int</span> len <span>=</span> tab<span>.</span>length<span>;</span>
    <span>Entry</span> e<span>;</span>

    <span>int</span> slotToExpunge <span>=</span> staleSlot<span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>prevIndex</span><span>(</span>staleSlot<span>,</span> len<span>)</span><span>;</span>
         <span>(</span>e <span>=</span> tab<span>[</span>i<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>;</span>
         i <span>=</span> <span>prevIndex</span><span>(</span>i<span>,</span> len<span>)</span><span>)</span>

        <span>if</span> <span>(</span>e<span>.</span><span>get</span><span>(</span><span>)</span> <span>==</span> <span>null</span><span>)</span>
            slotToExpunge <span>=</span> i<span>;</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>nextIndex</span><span>(</span>staleSlot<span>,</span> len<span>)</span><span>;</span>
         <span>(</span>e <span>=</span> tab<span>[</span>i<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>;</span>
         i <span>=</span> <span>nextIndex</span><span>(</span>i<span>,</span> len<span>)</span><span>)</span> <span>{</span>

        <span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k <span>=</span> e<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span>k <span>==</span> key<span>)</span> <span>{</span>
            e<span>.</span>value <span>=</span> value<span>;</span>

            tab<span>[</span>i<span>]</span> <span>=</span> tab<span>[</span>staleSlot<span>]</span><span>;</span>
            tab<span>[</span>staleSlot<span>]</span> <span>=</span> e<span>;</span>

            <span>if</span> <span>(</span>slotToExpunge <span>==</span> staleSlot<span>)</span>
                slotToExpunge <span>=</span> i<span>;</span>
            <span>cleanSomeSlots</span><span>(</span><span>expungeStaleEntry</span><span>(</span>slotToExpunge<span>)</span><span>,</span> len<span>)</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>k <span>==</span> <span>null</span> <span>&amp;&amp;</span> slotToExpunge <span>==</span> staleSlot<span>)</span>
            slotToExpunge <span>=</span> i<span>;</span>
    <span>}</span>

    tab<span>[</span>staleSlot<span>]</span><span>.</span>value <span>=</span> <span>null</span><span>;</span>
    tab<span>[</span>staleSlot<span>]</span> <span>=</span> <span>new</span> <span>Entry</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>

    <span>if</span> <span>(</span>slotToExpunge <span>!=</span> staleSlot<span>)</span>
        <span>cleanSomeSlots</span><span>(</span><span>expungeStaleEntry</span><span>(</span>slotToExpunge<span>)</span><span>,</span> len<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p><code>slotToExpunge</code>表示开始探测式清理过期数据的开始下标，默认从当前的<code>staleSlot</code>开始。以当前的<code>staleSlot</code>开始，向前迭代查找，找到没有过期的数据，<code>for</code>循环一直碰到<code>Entry</code>为<code>null</code>才会结束。如果向前找到了过期数据，更新探测清理过期数据的开始下标为 i，即<code>slotToExpunge=i</code></p>
<div><pre><code><span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>prevIndex</span><span>(</span>staleSlot<span>,</span> len<span>)</span><span>;</span>
     <span>(</span>e <span>=</span> tab<span>[</span>i<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>;</span>
     i <span>=</span> <span>prevIndex</span><span>(</span>i<span>,</span> len<span>)</span><span>)</span><span>{</span>

    <span>if</span> <span>(</span>e<span>.</span><span>get</span><span>(</span><span>)</span> <span>==</span> <span>null</span><span>)</span><span>{</span>
        slotToExpunge <span>=</span> i<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>接着开始从<code>staleSlot</code>向后查找，也是碰到<code>Entry</code>为<code>null</code>的桶结束。
如果迭代过程中，<strong>碰到 k == key</strong>，这说明这里是替换逻辑，替换新数据并且交换当前<code>staleSlot</code>位置。如果<code>slotToExpunge == staleSlot</code>，这说明<code>replaceStaleEntry()</code>一开始向前查找过期数据时并未找到过期的<code>Entry</code>数据，接着向后查找过程中也未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的 index，即<code>slotToExpunge = i</code>。最后调用<code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code>进行启发式过期数据清理。</p>
<div><pre><code><span>if</span> <span>(</span>k <span>==</span> key<span>)</span> <span>{</span>
    e<span>.</span>value <span>=</span> value<span>;</span>

    tab<span>[</span>i<span>]</span> <span>=</span> tab<span>[</span>staleSlot<span>]</span><span>;</span>
    tab<span>[</span>staleSlot<span>]</span> <span>=</span> e<span>;</span>

    <span>if</span> <span>(</span>slotToExpunge <span>==</span> staleSlot<span>)</span>
        slotToExpunge <span>=</span> i<span>;</span>

    <span>cleanSomeSlots</span><span>(</span><span>expungeStaleEntry</span><span>(</span>slotToExpunge<span>)</span><span>,</span> len<span>)</span><span>;</span>
    <span>return</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><code>cleanSomeSlots()</code>和<code>expungeStaleEntry()</code>方法后面都会细讲，这两个是和清理相关的方法，一个是过期<code>key</code>相关<code>Entry</code>的启发式清理(<code>Heuristically scan</code>)，另一个是过期<code>key</code>相关<code>Entry</code>的探测式清理。</p>
<p><strong>如果 k != key</strong>则会接着往下走，<code>k == null</code>说明当前遍历的<code>Entry</code>是一个过期数据，<code>slotToExpunge == staleSlot</code>说明，一开始的向前查找数据并未找到过期的<code>Entry</code>。如果条件成立，则更新<code>slotToExpunge</code> 为当前位置，这个前提是前驱节点扫描时未发现过期数据。</p>
<div><pre><code><span>if</span> <span>(</span>k <span>==</span> <span>null</span> <span>&amp;&amp;</span> slotToExpunge <span>==</span> staleSlot<span>)</span>
    slotToExpunge <span>=</span> i<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>往后迭代的过程中如果没有找到<code>k == key</code>的数据，且碰到<code>Entry</code>为<code>null</code>的数据，则结束当前的迭代操作。此时说明这里是一个添加的逻辑，将新的数据添加到<code>table[staleSlot]</code> 对应的<code>slot</code>中。</p>
<div><pre><code>tab<span>[</span>staleSlot<span>]</span><span>.</span>value <span>=</span> <span>null</span><span>;</span>
tab<span>[</span>staleSlot<span>]</span> <span>=</span> <span>new</span> <span>Entry</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>最后判断除了<code>staleSlot</code>以外，还发现了其他过期的<code>slot</code>数据，就要开启清理数据的逻辑：</p>
<div><pre><code><span>if</span> <span>(</span>slotToExpunge <span>!=</span> staleSlot<span>)</span>
    <span>cleanSomeSlots</span><span>(</span><span>expungeStaleEntry</span><span>(</span>slotToExpunge<span>)</span><span>,</span> len<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="threadlocalmap过期-key-的探测式清理流程"> <code>ThreadLocalMap</code>过期 key 的探测式清理流程</h3>
<p>上面我们有提及<code>ThreadLocalMap</code>的两种过期<code>key</code>数据清理方式：<strong>探测式清理</strong>和<strong>启发式清理</strong>。</p>
<p>我们先讲下探测式清理，也就是<code>expungeStaleEntry</code>方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的<code>Entry</code>设置为<code>null</code>，沿途中碰到未过期的数据则将此数据<code>rehash</code>后重新在<code>table</code>数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的<code>Entry=null</code>的桶中，使<code>rehash</code>后的<code>Entry</code>数据距离正确的桶的位置更近一些。操作逻辑如下：</p>
<p><img src="./images/thread-local/18.png" alt="" /></p>
<p>如上图，<code>set(27)</code> 经过 hash 计算后应该落到<code>index=4</code>的桶中，由于<code>index=4</code>桶已经有了数据，所以往后迭代最终数据放入到<code>index=7</code>的桶中，放入后一段时间后<code>index=5</code>中的<code>Entry</code>数据<code>key</code>变为了<code>null</code></p>
<p><img src="./images/thread-local/19.png" alt="" /></p>
<p>如果再有其他数据<code>set</code>到<code>map</code>中，就会触发<strong>探测式清理</strong>操作。</p>
<p>如上图，执行<strong>探测式清理</strong>后，<code>index=5</code>的数据被清理掉，继续往后迭代，到<code>index=7</code>的元素时，经过<code>rehash</code>后发现该元素正确的<code>index=4</code>，而此位置已经有了数据，往后查找离<code>index=4</code>最近的<code>Entry=null</code>的节点(刚被探测式清理掉的数据：<code>index=5</code>)，找到后移动<code>index= 7</code>的数据到<code>index=5</code>中，此时桶的位置离正确的位置<code>index=4</code>更近了。</p>
<p>经过一轮探测式清理后，<code>key</code>过期的数据会被清理掉，没过期的数据经过<code>rehash</code>重定位后所处的桶位置理论上更接近<code>i= key.hashCode &amp; (tab.len - 1)</code>的位置。这种优化会提高整个散列表查询性能。</p>
<p>接着看下<code>expungeStaleEntry()</code>具体流程，我们还是以先原理图后源码讲解的方式来一步步梳理：</p>
<p><img src="./images/thread-local/20.png" alt="" /></p>
<p>我们假设<code>expungeStaleEntry(3)</code> 来调用此方法，如上图所示，我们可以看到<code>ThreadLocalMap</code>中<code>table</code>的数据情况，接着执行清理操作：</p>
<p><img src="./images/thread-local/21.png" alt="" /></p>
<p>第一步是清空当前<code>staleSlot</code>位置的数据，<code>index=3</code>位置的<code>Entry</code>变成了<code>null</code>。然后接着往后探测：</p>
<p><img src="./images/thread-local/22.png" alt="" /></p>
<p>执行完第二步后，index=4 的元素挪到 index=3 的槽位中。</p>
<p>继续往后迭代检查，碰到正常数据，计算该数据位置是否偏移，如果被偏移，则重新计算<code>slot</code>位置，目的是让正常数据尽可能存放在正确位置或离正确位置更近的位置</p>
<p><img src="./images/thread-local/23.png" alt="" /></p>
<p>在往后迭代的过程中碰到空的槽位，终止探测，这样一轮探测式清理工作就完成了，接着我们继续看看具体<strong>实现源代码</strong>：</p>
<div><pre><code><span>private</span> <span>int</span> <span>expungeStaleEntry</span><span>(</span><span>int</span> staleSlot<span>)</span> <span>{</span>
    <span>Entry</span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span>
    <span>int</span> len <span>=</span> tab<span>.</span>length<span>;</span>

    tab<span>[</span>staleSlot<span>]</span><span>.</span>value <span>=</span> <span>null</span><span>;</span>
    tab<span>[</span>staleSlot<span>]</span> <span>=</span> <span>null</span><span>;</span>
    size<span>--</span><span>;</span>

    <span>Entry</span> e<span>;</span>
    <span>int</span> i<span>;</span>
    <span>for</span> <span>(</span>i <span>=</span> <span>nextIndex</span><span>(</span>staleSlot<span>,</span> len<span>)</span><span>;</span>
         <span>(</span>e <span>=</span> tab<span>[</span>i<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>;</span>
         i <span>=</span> <span>nextIndex</span><span>(</span>i<span>,</span> len<span>)</span><span>)</span> <span>{</span>
        <span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k <span>=</span> e<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>k <span>==</span> <span>null</span><span>)</span> <span>{</span>
            e<span>.</span>value <span>=</span> <span>null</span><span>;</span>
            tab<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>
            size<span>--</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>int</span> h <span>=</span> k<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>len <span>-</span> <span>1</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>h <span>!=</span> i<span>)</span> <span>{</span>
                tab<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>

                <span>while</span> <span>(</span>tab<span>[</span>h<span>]</span> <span>!=</span> <span>null</span><span>)</span>
                    h <span>=</span> <span>nextIndex</span><span>(</span>h<span>,</span> len<span>)</span><span>;</span>
                tab<span>[</span>h<span>]</span> <span>=</span> e<span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> i<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>这里我们还是以<code>staleSlot=3</code> 来做示例说明，首先是将<code>tab[staleSlot]</code>槽位的数据清空，然后设置<code>size--</code>
接着以<code>staleSlot</code>位置往后迭代，如果遇到<code>k==null</code>的过期数据，也是清空该槽位数据，然后<code>size--</code></p>
<div><pre><code><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k <span>=</span> e<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>

<span>if</span> <span>(</span>k <span>==</span> <span>null</span><span>)</span> <span>{</span>
    e<span>.</span>value <span>=</span> <span>null</span><span>;</span>
    tab<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>
    size<span>--</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果<code>key</code>没有过期，重新计算当前<code>key</code>的下标位置是不是当前槽位下标位置，如果不是，那么说明产生了<code>hash</code>冲突，此时以新计算出来正确的槽位位置往后迭代，找到最近一个可以存放<code>entry</code>的位置。</p>
<div><pre><code><span>int</span> h <span>=</span> k<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>len <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>if</span> <span>(</span>h <span>!=</span> i<span>)</span> <span>{</span>
    tab<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>

    <span>while</span> <span>(</span>tab<span>[</span>h<span>]</span> <span>!=</span> <span>null</span><span>)</span>
        h <span>=</span> <span>nextIndex</span><span>(</span>h<span>,</span> len<span>)</span><span>;</span>

    tab<span>[</span>h<span>]</span> <span>=</span> e<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这里是处理正常的产生<code>Hash</code>冲突的数据，经过迭代后，有过<code>Hash</code>冲突数据的<code>Entry</code>位置会更靠近正确位置，这样的话，查询的时候 效率才会更高。</p>
<h3 id="threadlocalmap扩容机制"> <code>ThreadLocalMap</code>扩容机制</h3>
<p>在<code>ThreadLocalMap.set()</code>方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中<code>Entry</code>的数量已经达到了列表的扩容阈值<code>(len*2/3)</code>，就开始执行<code>rehash()</code>逻辑：</p>
<div><pre><code><span>if</span> <span>(</span><span>!</span><span>cleanSomeSlots</span><span>(</span>i<span>,</span> sz<span>)</span> <span>&amp;&amp;</span> sz <span>>=</span> threshold<span>)</span>
    <span>rehash</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>接着看下<code>rehash()</code>具体实现：</p>
<div><pre><code><span>private</span> <span>void</span> <span>rehash</span><span>(</span><span>)</span> <span>{</span>
    <span>expungeStaleEntries</span><span>(</span><span>)</span><span>;</span>

    <span>if</span> <span>(</span>size <span>>=</span> threshold <span>-</span> threshold <span>/</span> <span>4</span><span>)</span>
        <span>resize</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>expungeStaleEntries</span><span>(</span><span>)</span> <span>{</span>
    <span>Entry</span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span>
    <span>int</span> len <span>=</span> tab<span>.</span>length<span>;</span>
    <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> len<span>;</span> j<span>++</span><span>)</span> <span>{</span>
        <span>Entry</span> e <span>=</span> tab<span>[</span>j<span>]</span><span>;</span>
        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span> <span>&amp;&amp;</span> e<span>.</span><span>get</span><span>(</span><span>)</span> <span>==</span> <span>null</span><span>)</span>
            <span>expungeStaleEntry</span><span>(</span>j<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>这里首先是会进行探测式清理工作，从<code>table</code>的起始位置往后清理，上面有分析清理的详细流程。清理完成之后，<code>table</code>中可能有一些<code>key</code>为<code>null</code>的<code>Entry</code>数据被清理掉，所以此时通过判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold * 3/4</code> 来决定是否扩容。</p>
<p>我们还记得上面进行<code>rehash()</code>的阈值是<code>size &gt;= threshold</code>，所以当面试官套路我们<code>ThreadLocalMap</code>扩容机制的时候 我们一定要说清楚这两个步骤：</p>
<p><img src="./images/thread-local/24.png" alt="" /></p>
<p>接着看看具体的<code>resize()</code>方法，为了方便演示，我们以<code>oldTab.len=8</code>来举例：</p>
<p><img src="./images/thread-local/25.png" alt="" /></p>
<p>扩容后的<code>tab</code>的大小为<code>oldLen * 2</code>，然后遍历老的散列表，重新计算<code>hash</code>位置，然后放到新的<code>tab</code>数组中，如果出现<code>hash</code>冲突则往后寻找最近的<code>entry</code>为<code>null</code>的槽位，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到新的<code>tab</code>中了。重新计算<code>tab</code>下次扩容的<strong>阈值</strong>，具体代码如下：</p>
<div><pre><code><span>private</span> <span>void</span> <span>resize</span><span>(</span><span>)</span> <span>{</span>
    <span>Entry</span><span>[</span><span>]</span> oldTab <span>=</span> table<span>;</span>
    <span>int</span> oldLen <span>=</span> oldTab<span>.</span>length<span>;</span>
    <span>int</span> newLen <span>=</span> oldLen <span>*</span> <span>2</span><span>;</span>
    <span>Entry</span><span>[</span><span>]</span> newTab <span>=</span> <span>new</span> <span>Entry</span><span>[</span>newLen<span>]</span><span>;</span>
    <span>int</span> count <span>=</span> <span>0</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> oldLen<span>;</span> <span>++</span>j<span>)</span> <span>{</span>
        <span>Entry</span> e <span>=</span> oldTab<span>[</span>j<span>]</span><span>;</span>
        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k <span>=</span> e<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>k <span>==</span> <span>null</span><span>)</span> <span>{</span>
                e<span>.</span>value <span>=</span> <span>null</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>int</span> h <span>=</span> k<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>newLen <span>-</span> <span>1</span><span>)</span><span>;</span>
                <span>while</span> <span>(</span>newTab<span>[</span>h<span>]</span> <span>!=</span> <span>null</span><span>)</span>
                    h <span>=</span> <span>nextIndex</span><span>(</span>h<span>,</span> newLen<span>)</span><span>;</span>
                newTab<span>[</span>h<span>]</span> <span>=</span> e<span>;</span>
                count<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>setThreshold</span><span>(</span>newLen<span>)</span><span>;</span>
    size <span>=</span> count<span>;</span>
    table <span>=</span> newTab<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="threadlocalmap-get-详解"> <code>ThreadLocalMap.get()</code>详解</h3>
<p>上面已经看完了<code>set()</code>方法的源码，其中包括<code>set</code>数据、清理数据、优化数据桶的位置等操作，接着看看<code>get()</code>操作的原理。</p>
<h4 id="threadlocalmap-get-图解"> <code>ThreadLocalMap.get()</code>图解</h4>
<p><strong>第一种情况：</strong> 通过查找<code>key</code>值计算出散列表中<code>slot</code>位置，然后该<code>slot</code>位置中的<code>Entry.key</code>和查找的<code>key</code>一致，则直接返回：</p>
<p><img src="./images/thread-local/26.png" alt="" /></p>
<p><strong>第二种情况：</strong> <code>slot</code>位置中的<code>Entry.key</code>和要查找的<code>key</code>不一致：</p>
<p><img src="./images/thread-local/27.png" alt="" /></p>
<p>我们以<code>get(ThreadLocal1)</code>为例，通过<code>hash</code>计算后，正确的<code>slot</code>位置应该是 4，而<code>index=4</code>的槽位已经有了数据，且<code>key</code>值不等于<code>ThreadLocal1</code>，所以需要继续往后迭代查找。</p>
<p>迭代到<code>index=5</code>的数据时，此时<code>Entry.key=null</code>，触发一次探测式数据回收操作，执行<code>expungeStaleEntry()</code>方法，执行完后，<code>index 5,8</code>的数据都会被回收，而<code>index 6,7</code>的数据都会前移，此时继续往后迭代，到<code>index = 6</code>的时候即找到了<code>key</code>值相等的<code>Entry</code>数据，如下图所示：</p>
<p><img src="./images/thread-local/28.png" alt="" /></p>
<h4 id="threadlocalmap-get-源码详解"> <code>ThreadLocalMap.get()</code>源码详解</h4>
<p><code>java.lang.ThreadLocal.ThreadLocalMap.getEntry()</code>:</p>
<div><pre><code><span>private</span> <span>Entry</span> <span>getEntry</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> key<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> key<span>.</span>threadLocalHashCode <span>&amp;</span> <span>(</span>table<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>Entry</span> e <span>=</span> table<span>[</span>i<span>]</span><span>;</span>
    <span>if</span> <span>(</span>e <span>!=</span> <span>null</span> <span>&amp;&amp;</span> e<span>.</span><span>get</span><span>(</span><span>)</span> <span>==</span> key<span>)</span>
        <span>return</span> e<span>;</span>
    <span>else</span>
        <span>return</span> <span>getEntryAfterMiss</span><span>(</span>key<span>,</span> i<span>,</span> e<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>Entry</span> <span>getEntryAfterMiss</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> key<span>,</span> <span>int</span> i<span>,</span> <span>Entry</span> e<span>)</span> <span>{</span>
    <span>Entry</span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span>
    <span>int</span> len <span>=</span> tab<span>.</span>length<span>;</span>

    <span>while</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k <span>=</span> e<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>k <span>==</span> key<span>)</span>
            <span>return</span> e<span>;</span>
        <span>if</span> <span>(</span>k <span>==</span> <span>null</span><span>)</span>
            <span>expungeStaleEntry</span><span>(</span>i<span>)</span><span>;</span>
        <span>else</span>
            i <span>=</span> <span>nextIndex</span><span>(</span>i<span>,</span> len<span>)</span><span>;</span>
        e <span>=</span> tab<span>[</span>i<span>]</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="threadlocalmap过期-key-的启发式清理流程"> <code>ThreadLocalMap</code>过期 key 的启发式清理流程</h3>
<p>上面多次提及到<code>ThreadLocalMap</code>过期key的两种清理方式：<strong>探测式清理(expungeStaleEntry())</strong>、<strong>启发式清理(cleanSomeSlots())</strong></p>
<p>探测式清理是以当前<code>Entry</code> 往后清理，遇到值为<code>null</code>则结束清理，属于<strong>线性探测清理</strong>。</p>
<p>而启发式清理被作者定义为：<strong>Heuristically scan some cells looking for stale entries</strong>.</p>
<p><img src="./images/thread-local/29.png" alt="" /></p>
<p>具体代码如下：</p>
<div><pre><code><span>private</span> <span>boolean</span> <span>cleanSomeSlots</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
    <span>boolean</span> removed <span>=</span> <span>false</span><span>;</span>
    <span>Entry</span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span>
    <span>int</span> len <span>=</span> tab<span>.</span>length<span>;</span>
    <span>do</span> <span>{</span>
        i <span>=</span> <span>nextIndex</span><span>(</span>i<span>,</span> len<span>)</span><span>;</span>
        <span>Entry</span> e <span>=</span> tab<span>[</span>i<span>]</span><span>;</span>
        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span> <span>&amp;&amp;</span> e<span>.</span><span>get</span><span>(</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            n <span>=</span> len<span>;</span>
            removed <span>=</span> <span>true</span><span>;</span>
            i <span>=</span> <span>expungeStaleEntry</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span> <span>while</span> <span>(</span> <span>(</span>n <span>>>>=</span> <span>1</span><span>)</span> <span>!=</span> <span>0</span><span>)</span><span>;</span>
    <span>return</span> removed<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="inheritablethreadlocal"> <code>InheritableThreadLocal</code></h3>
<p>我们使用<code>ThreadLocal</code>的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。</p>
<p>为了解决这个问题，JDK 中还有一个<code>InheritableThreadLocal</code>类，我们来看一个例子：</p>
<div><pre><code><span>public</span> <span>class</span> <span>InheritableThreadLocalDemo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>ThreadLocal</span> <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> inheritableThreadLocal <span>=</span> <span>new</span> <span>InheritableThreadLocal</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>ThreadLocal</span><span>.</span><span>set</span><span>(</span><span>"父类数据:threadLocal"</span><span>)</span><span>;</span>
        inheritableThreadLocal<span>.</span><span>set</span><span>(</span><span>"父类数据:inheritableThreadLocal"</span><span>)</span><span>;</span>

        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>
            <span>@Override</span>
            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"子线程获取父类ThreadLocal数据："</span> <span>+</span> <span>ThreadLocal</span><span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"子线程获取父类inheritableThreadLocal数据："</span> <span>+</span> inheritableThreadLocal<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>打印结果：</p>
<div><pre><code>子线程获取父类<span>ThreadLocal</span>数据：<span>null</span>
子线程获取父类inheritableThreadLocal数据：父类数据<span>:</span>inheritableThreadLocal
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>实现原理是子线程是通过在父线程中通过调用<code>new Thread()</code>方法来创建子线程，<code>Thread#init</code>方法在<code>Thread</code>的构造方法中被调用。在<code>init</code>方法中拷贝父线程数据到子线程中：</p>
<div><pre><code><span>private</span> <span>void</span> <span>init</span><span>(</span><span>ThreadGroup</span> g<span>,</span> <span>Runnable</span> target<span>,</span> <span>String</span> name<span>,</span>
                      <span>long</span> stackSize<span>,</span> <span>AccessControlContext</span> acc<span>,</span>
                      <span>boolean</span> inheritThreadLocals<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>name <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>"name cannot be null"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span>inheritThreadLocals <span>&amp;&amp;</span> parent<span>.</span>inheritableThreadLocals <span>!=</span> <span>null</span><span>)</span>
        <span>this</span><span>.</span>inheritableThreadLocals <span>=</span>
            <span>ThreadLocal</span><span>.</span><span>createInheritedMap</span><span>(</span>parent<span>.</span>inheritableThreadLocals<span>)</span><span>;</span>
    <span>this</span><span>.</span>stackSize <span>=</span> stackSize<span>;</span>
    tid <span>=</span> <span>nextThreadID</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>但<code>InheritableThreadLocal</code>仍然有缺陷，一般我们做异步化处理都是使用的线程池，而<code>InheritableThreadLocal</code>是在<code>new Thread</code>中的<code>init()</code>方法给赋值的，而线程池是线程复用的逻辑，所以这里会存在问题。</p>
<p>当然，有问题出现就会有解决问题的方案，阿里巴巴开源了一个<code>TransmittableThreadLocal</code>组件就可以解决这个问题，这里就不再延伸，感兴趣的可自行查阅资料。</p>
<h3 id="threadlocal项目中使用实战"> <code>ThreadLocal</code>项目中使用实战</h3>
<h4 id="threadlocal使用场景"> <code>ThreadLocal</code>使用场景</h4>
<p>我们现在项目中日志记录用的是<code>ELK+Logstash</code>，最后在<code>Kibana</code>中进行展示和检索。</p>
<p>现在都是分布式系统统一对外提供服务，项目间调用的关系可以通过 <code>traceId</code> 来关联，但是不同项目之间如何传递 <code>traceId</code> 呢？</p>
<p>这里我们使用 <code>org.slf4j.MDC</code> 来实现此功能，内部就是通过 <code>ThreadLocal</code> 来实现的，具体实现如下：</p>
<p>当前端发送请求到<strong>服务 A</strong>时，<strong>服务 A</strong>会生成一个类似<code>UUID</code>的<code>traceId</code>字符串，将此字符串放入当前线程的<code>ThreadLocal</code>中，在调用<strong>服务 B</strong>的时候，将<code>traceId</code>写入到请求的<code>Header</code>中，<strong>服务 B</strong>在接收请求时会先判断请求的<code>Header</code>中是否有<code>traceId</code>，如果存在则写入自己线程的<code>ThreadLocal</code>中。</p>
<p><img src="./images/thread-local/30.png" alt="" /></p>
<p>图中的<code>requestId</code>即为我们各个系统链路关联的<code>traceId</code>，系统间互相调用，通过这个<code>requestId</code>即可找到对应链路，这里还有会有一些其他场景：</p>
<p><img src="./images/thread-local/31.png" alt="" /></p>
<p>针对于这些场景，我们都可以有相应的解决方案，如下所示</p>
<h4 id="feign-远程调用解决方案"> Feign 远程调用解决方案</h4>
<p><strong>服务发送请求：</strong></p>
<div><pre><code><span>@Component</span>
<span>@Slf4j</span>
<span>public</span> <span>class</span> <span>FeignInvokeInterceptor</span> <span>implements</span> <span>RequestInterceptor</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>apply</span><span>(</span><span>RequestTemplate</span> template<span>)</span> <span>{</span>
        <span>String</span> requestId <span>=</span> MDC<span>.</span><span>get</span><span>(</span><span>"requestId"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>StringUtils</span><span>.</span><span>isNotBlank</span><span>(</span>requestId<span>)</span><span>)</span> <span>{</span>
            template<span>.</span><span>header</span><span>(</span><span>"requestId"</span><span>,</span> requestId<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>服务接收请求：</strong></p>
<div><pre><code><span>@Slf4j</span>
<span>@Component</span>
<span>public</span> <span>class</span> <span>LogInterceptor</span> <span>extends</span> <span>HandlerInterceptorAdapter</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>afterCompletion</span><span>(</span><span>HttpServletRequest</span> arg0<span>,</span> <span>HttpServletResponse</span> arg1<span>,</span> <span>Object</span> arg2<span>,</span> <span>Exception</span> arg3<span>)</span> <span>{</span>
        MDC<span>.</span><span>remove</span><span>(</span><span>"requestId"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>postHandle</span><span>(</span><span>HttpServletRequest</span> arg0<span>,</span> <span>HttpServletResponse</span> arg1<span>,</span> <span>Object</span> arg2<span>,</span> <span>ModelAndView</span> arg3<span>)</span> <span>{</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>preHandle</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServletResponse</span> response<span>,</span> <span>Object</span> handler<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>

        <span>String</span> requestId <span>=</span> request<span>.</span><span>getHeader</span><span>(</span><span>BaseConstant</span><span>.</span>REQUEST_ID_KEY<span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>StringUtils</span><span>.</span><span>isBlank</span><span>(</span>requestId<span>)</span><span>)</span> <span>{</span>
            requestId <span>=</span> UUID<span>.</span><span>randomUUID</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>replace</span><span>(</span><span>"-"</span><span>,</span> <span>""</span><span>)</span><span>;</span>
        <span>}</span>
        MDC<span>.</span><span>put</span><span>(</span><span>"requestId"</span><span>,</span> requestId<span>)</span><span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h4 id="线程池异步调用-requestid-传递"> 线程池异步调用，requestId 传递</h4>
<p>因为<code>MDC</code>是基于<code>ThreadLocal</code>去实现的，异步过程中，子线程并没有办法获取到父线程<code>ThreadLocal</code>存储的数据，所以这里可以自定义线程池执行器，修改其中的<code>run()</code>方法：</p>
<div><pre><code><span>public</span> <span>class</span> <span>MyThreadPoolTaskExecutor</span> <span>extends</span> <span>ThreadPoolTaskExecutor</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>Runnable</span> runnable<span>)</span> <span>{</span>
        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> context <span>=</span> MDC<span>.</span><span>getCopyOfContextMap</span><span>(</span><span>)</span><span>;</span>
        <span>super</span><span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>run</span><span>(</span>runnable<span>,</span> context<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>private</span> <span>void</span> <span>run</span><span>(</span><span>Runnable</span> runnable<span>,</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> context<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>context <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            MDC<span>.</span><span>setContextMap</span><span>(</span>context<span>)</span><span>;</span>
        <span>}</span>
        <span>try</span> <span>{</span>
            runnable<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>finally</span> <span>{</span>
            MDC<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h4 id="使用-mq-发送消息给第三方系统"> 使用 MQ 发送消息给第三方系统</h4>
<p>在 MQ 发送的消息体中自定义属性<code>requestId</code>，接收方消费消息后，自己解析<code>requestId</code>使用即可。</p>
]]></content:encoded>
    </item>
    <item>
      <title>拿来即用的Java线程池最佳实践</title>
      <link>https://javaguide.cn/java/concurrent/%E6%8B%BF%E6%9D%A5%E5%8D%B3%E7%94%A8%E7%9A%84java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <guid>https://javaguide.cn/java/concurrent/%E6%8B%BF%E6%9D%A5%E5%8D%B3%E7%94%A8%E7%9A%84java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <source url="https://javaguide.cn/rss.xml">拿来即用的Java线程池最佳实践</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>这篇文章篇幅虽短，但是绝对是干货。标题稍微有点夸张，嘿嘿，实际都是自己使用线程池的时候总结的一些个人感觉比较重要的点。</p>
<h2 id="线程池知识回顾"> 线程池知识回顾</h2>
<p>开始这篇文章之前还是简单介绍一嘴线程池，之前写的<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485808&amp;idx=1&amp;sn=1013253533d73450cef673aee13267ab&amp;chksm=cea246bbf9d5cfad1c21316340a0ef1609a7457fea4113a1f8d69e8c91e7d9cd6285f5ee1490&amp;token=510053261&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">《新手也能看懂的线程池学习总结》</a>这篇文章介绍的很详细了。</p>
<h3 id="为什么要使用线程池"> 为什么要使用线程池？</h3>
<blockquote>
<p><strong>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p>
</blockquote>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="线程池在实际项目的使用场景"> 线程池在实际项目的使用场景</h3>
<p><strong>线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。</strong></p>
<p>假设我们要执行三个不相关的耗时任务，Guide 画图给大家展示了使用线程池前后的区别。</p>
<p>注意：<strong>下面三个任务可能做的是同一件事情，也可能是不一样的事情。</strong></p>
<p><img src="./images/thread-pool/1bc44c67-26ba-42ab-bcb8-4e29e6fd99b9.png" alt="使用线程池前后对比" /></p>
<h3 id="如何使用线程池"> 如何使用线程池？</h3>
<p>一般是通过 <code>ThreadPoolExecutor</code> 的构造函数来创建线程池，然后提交任务给线程池执行就可以了。</p>
<p><code>ThreadPoolExecutor</code>构造函数如下：</p>
<div><pre><code>    <span>/**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */</span>
    <span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span><span>//线程池的核心线程数量</span>
                              <span>int</span> maximumPoolSize<span>,</span><span>//线程池的最大线程数</span>
                              <span>long</span> keepAliveTime<span>,</span><span>//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span>
                              <span>TimeUnit</span> unit<span>,</span><span>//时间单位</span>
                              <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span><span>//任务队列，用来储存等待执行任务的队列</span>
                              <span>ThreadFactory</span> threadFactory<span>,</span><span>//线程工厂，用来创建线程，一般默认即可</span>
                              <span>RejectedExecutionHandler</span> handler<span>//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>
                               <span>)</span> <span>{</span>
        <span>if</span> <span>(</span>corePoolSize <span>&lt;</span> <span>0</span> <span>||</span>
            maximumPoolSize <span>&lt;=</span> <span>0</span> <span>||</span>
            maximumPoolSize <span>&lt;</span> corePoolSize <span>||</span>
            keepAliveTime <span>&lt;</span> <span>0</span><span>)</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>workQueue <span>==</span> <span>null</span> <span>||</span> threadFactory <span>==</span> <span>null</span> <span>||</span> handler <span>==</span> <span>null</span><span>)</span>
            <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>corePoolSize <span>=</span> corePoolSize<span>;</span>
        <span>this</span><span>.</span>maximumPoolSize <span>=</span> maximumPoolSize<span>;</span>
        <span>this</span><span>.</span>workQueue <span>=</span> workQueue<span>;</span>
        <span>this</span><span>.</span>keepAliveTime <span>=</span> unit<span>.</span><span>toNanos</span><span>(</span>keepAliveTime<span>)</span><span>;</span>
        <span>this</span><span>.</span>threadFactory <span>=</span> threadFactory<span>;</span>
        <span>this</span><span>.</span>handler <span>=</span> handler<span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>简单演示一下如何使用线程池，更详细的介绍，请看：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485808&amp;idx=1&amp;sn=1013253533d73450cef673aee13267ab&amp;chksm=cea246bbf9d5cfad1c21316340a0ef1609a7457fea4113a1f8d69e8c91e7d9cd6285f5ee1490&amp;token=510053261&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">《新手也能看懂的线程池学习总结》</a> 。</p>
<div><pre><code>    <span>private</span> <span>static</span> <span>final</span> <span>int</span> CORE_POOL_SIZE <span>=</span> <span>5</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_POOL_SIZE <span>=</span> <span>10</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> QUEUE_CAPACITY <span>=</span> <span>100</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Long</span> KEEP_ALIVE_TIME <span>=</span> <span>1L</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>//使用阿里巴巴推荐的创建线程池的方式</span>
        <span>//通过ThreadPoolExecutor构造函数自定义参数创建</span>
        <span>ThreadPoolExecutor</span> executor <span>=</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>
                CORE_POOL_SIZE<span>,</span>
                MAX_POOL_SIZE<span>,</span>
                KEEP_ALIVE_TIME<span>,</span>
                <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>
                <span>new</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>></span></span><span>(</span>QUEUE_CAPACITY<span>)</span><span>,</span>
                <span>new</span> <span>ThreadPoolExecutor<span>.</span>CallerRunsPolicy</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            executor<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
                <span>try</span> <span>{</span>
                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2000</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"CurrentThread name:"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>"date："</span> <span>+</span> <span>Instant</span><span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span><span>)</span><span>;</span>
        <span>}</span>
        <span>//终止线程池</span>
        executor<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
        <span>try</span> <span>{</span>
            executor<span>.</span><span>awaitTermination</span><span>(</span><span>5</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Finished all threads"</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>控制台输出：</p>
<div><pre><code><span>CurrentThread</span> name<span>:</span>pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>5d</span>ate：<span>2020</span><span>-</span><span>06</span><span>-</span><span>06</span>T11<span>:</span><span>45</span><span>:</span><span>31.639</span>Z
<span>CurrentThread</span> name<span>:</span>pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>3d</span>ate：<span>2020</span><span>-</span><span>06</span><span>-</span><span>06</span>T11<span>:</span><span>45</span><span>:</span><span>31.639</span>Z
<span>CurrentThread</span> name<span>:</span>pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>1d</span>ate：<span>2020</span><span>-</span><span>06</span><span>-</span><span>06</span>T11<span>:</span><span>45</span><span>:</span><span>31.636</span>Z
<span>CurrentThread</span> name<span>:</span>pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>4d</span>ate：<span>2020</span><span>-</span><span>06</span><span>-</span><span>06</span>T11<span>:</span><span>45</span><span>:</span><span>31.639</span>Z
<span>CurrentThread</span> name<span>:</span>pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>2d</span>ate：<span>2020</span><span>-</span><span>06</span><span>-</span><span>06</span>T11<span>:</span><span>45</span><span>:</span><span>31.639</span>Z
<span>CurrentThread</span> name<span>:</span>pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>2d</span>ate：<span>2020</span><span>-</span><span>06</span><span>-</span><span>06</span>T11<span>:</span><span>45</span><span>:</span><span>33.656</span>Z
<span>CurrentThread</span> name<span>:</span>pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>4d</span>ate：<span>2020</span><span>-</span><span>06</span><span>-</span><span>06</span>T11<span>:</span><span>45</span><span>:</span><span>33.656</span>Z
<span>CurrentThread</span> name<span>:</span>pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>1d</span>ate：<span>2020</span><span>-</span><span>06</span><span>-</span><span>06</span>T11<span>:</span><span>45</span><span>:</span><span>33.656</span>Z
<span>CurrentThread</span> name<span>:</span>pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>3d</span>ate：<span>2020</span><span>-</span><span>06</span><span>-</span><span>06</span>T11<span>:</span><span>45</span><span>:</span><span>33.656</span>Z
<span>CurrentThread</span> name<span>:</span>pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>5d</span>ate：<span>2020</span><span>-</span><span>06</span><span>-</span><span>06</span>T11<span>:</span><span>45</span><span>:</span><span>33.656</span>Z
<span>Finished</span> all threads
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="线程池最佳实践"> 线程池最佳实践</h2>
<p>简单总结一下我了解的使用线程池的时候应该注意的东西，网上似乎还没有专门写这方面的文章。</p>
<p>因为Guide还比较菜，有补充和完善的地方，可以在评论区告知或者在微信上与我交流。</p>
<h3 id="_1-使用-threadpoolexecutor-的构造函数声明线程池"> 1. 使用 <code>ThreadPoolExecutor</code> 的构造函数声明线程池</h3>
<p><strong>1. 线程池必须手动通过 <code>ThreadPoolExecutor</code> 的构造函数来声明，避免使用<code>Executors</code> 类的 <code>newFixedThreadPool</code> 和 <code>newCachedThreadPool</code> ，因为可能会有 OOM 的风险。</strong></p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
</blockquote>
<p>说白了就是：<strong>使用有界队列，控制线程创建数量。</strong></p>
<p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p>
<ol>
<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li>
<li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li>
</ol>
<h3 id="_2-监测线程池运行状态"> 2.监测线程池运行状态</h3>
<p>你可以通过一些手段来检测线程池的运行状态比如 SpringBoot 中的 Actuator 组件。</p>
<p>除此之外，我们还可以利用 <code>ThreadPoolExecutor</code> 的相关 API做一个简陋的监控。从下图可以看出， <code>ThreadPoolExecutor</code>提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。</p>
<p><img src="./images/thread-pool/ddf22709-bff5-45b4-acb7-a3f2e6798608.png" alt="" /></p>
<p>下面是一个简单的 Demo。<code>printThreadPoolStatus()</code>会每隔一秒打印出线程池的线程数、活跃线程数、完成的任务数、以及队列中的任务数。</p>
<div><pre><code>    <span>/**
     * 打印线程池的状态
     *
     * @param threadPool 线程池对象
     */</span>
    <span>public</span> <span>static</span> <span>void</span> <span>printThreadPoolStatus</span><span>(</span><span>ThreadPoolExecutor</span> threadPool<span>)</span> <span>{</span>
        <span>ScheduledExecutorService</span> scheduledExecutorService <span>=</span> <span>new</span> <span>ScheduledThreadPoolExecutor</span><span>(</span><span>1</span><span>,</span> <span>createThreadFactory</span><span>(</span><span>"print-images/thread-pool-status"</span><span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span>
        scheduledExecutorService<span>.</span><span>scheduleAtFixedRate</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            log<span>.</span><span>info</span><span>(</span><span>"========================="</span><span>)</span><span>;</span>
            log<span>.</span><span>info</span><span>(</span><span>"ThreadPool Size: [{}]"</span><span>,</span> threadPool<span>.</span><span>getPoolSize</span><span>(</span><span>)</span><span>)</span><span>;</span>
            log<span>.</span><span>info</span><span>(</span><span>"Active Threads: {}"</span><span>,</span> threadPool<span>.</span><span>getActiveCount</span><span>(</span><span>)</span><span>)</span><span>;</span>
            log<span>.</span><span>info</span><span>(</span><span>"Number of Tasks : {}"</span><span>,</span> threadPool<span>.</span><span>getCompletedTaskCount</span><span>(</span><span>)</span><span>)</span><span>;</span>
            log<span>.</span><span>info</span><span>(</span><span>"Number of Tasks in Queue: {}"</span><span>,</span> threadPool<span>.</span><span>getQueue</span><span>(</span><span>)</span><span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
            log<span>.</span><span>info</span><span>(</span><span>"========================="</span><span>)</span><span>;</span>
        <span>}</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_3-建议不同类别的业务用不同的线程池"> 3.建议不同类别的业务用不同的线程池</h3>
<p>很多人在实际项目中都会有类似这样的问题：<strong>我的项目中多个业务需要用到线程池，是为每个线程池都定义一个还是说定义一个公共的线程池呢？</strong></p>
<p>一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。</p>
<p><strong>我们再来看一个真实的事故案例！</strong> (本案例来源自：<a href="https://club.perfma.com/article/646639" target="_blank" rel="noopener noreferrer">《线程池运用不当的一次线上事故》</a> ，很精彩的一个案例)</p>
<p><img src="./images/thread-pool/5b9b814d-722a-4116-b066-43dc80fc1dc4.png" alt="案例代码概览" /></p>
<p>上面的代码可能会存在死锁的情况，为什么呢？画个图给大家捋一捋。</p>
<p>试想这样一种极端情况：假如我们线程池的核心线程数为 <strong>n</strong>，父任务（扣费任务）数量为 <strong>n</strong>，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 <strong>&quot;死锁&quot;</strong>。</p>
<p><img src="./images/thread-pool/线程池使用不当导致死锁.png" alt="线程池使用不当导致死锁" /></p>
<p>解决方法也很简单，就是新增加一个用于执行子任务的线程池专门为其服务。</p>
<h3 id="_4-别忘记给线程池命名"> 4.别忘记给线程池命名</h3>
<p>初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。</p>
<p>默认情况下创建的线程名字类似 pool-1-thread-n 这样的，没有业务含义，不利于我们定位问题。</p>
<p>给线程池里的线程命名通常有下面两种方式：</p>
<p>**1.利用 guava 的 <code>ThreadFactoryBuilder</code> **</p>
<div><pre><code><span>ThreadFactory</span> threadFactory <span>=</span> <span>new</span> <span>ThreadFactoryBuilder</span><span>(</span><span>)</span>
                        <span>.</span><span>setNameFormat</span><span>(</span>threadNamePrefix <span>+</span> <span>"-%d"</span><span>)</span>
                        <span>.</span><span>setDaemon</span><span>(</span><span>true</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
<span>ExecutorService</span> threadPool <span>=</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>corePoolSize<span>,</span> maximumPoolSize<span>,</span> keepAliveTime<span>,</span> <span>TimeUnit</span><span>.</span>MINUTES<span>,</span> workQueue<span>,</span> threadFactory<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>2.自己实现 <code>ThreadFactor</code>。</strong></p>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>Executors</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>ThreadFactory</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>atomic<span>.</span></span><span>AtomicInteger</span><span>;</span>
<span>/**
 * 线程工厂，它设置线程名称，有利于我们定位问题。
 */</span>
<span>public</span> <span>final</span> <span>class</span> <span>NamingThreadFactory</span> <span>implements</span> <span>ThreadFactory</span> <span>{</span>

    <span>private</span> <span>final</span> <span>AtomicInteger</span> threadNum <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>
    <span>private</span> <span>final</span> <span>ThreadFactory</span> delegate<span>;</span>
    <span>private</span> <span>final</span> <span>String</span> name<span>;</span>

    <span>/**
     * 创建一个带名字的线程池生产工厂
     */</span>
    <span>public</span> <span>NamingThreadFactory</span><span>(</span><span>ThreadFactory</span> delegate<span>,</span> <span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>delegate <span>=</span> delegate<span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span> <span>// TODO consider uniquifying this</span>
    <span>}</span>

    <span>@Override</span> 
    <span>public</span> <span>Thread</span> <span>newThread</span><span>(</span><span>Runnable</span> r<span>)</span> <span>{</span>
        <span>Thread</span> t <span>=</span> delegate<span>.</span><span>newThread</span><span>(</span>r<span>)</span><span>;</span>
        t<span>.</span><span>setName</span><span>(</span>name <span>+</span> <span>" [#"</span> <span>+</span> threadNum<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span> <span>+</span> <span>"]"</span><span>)</span><span>;</span>
        <span>return</span> t<span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id="_5-正确配置线程池参数"> 5.正确配置线程池参数</h3>
<p>说到如何给线程池配置参数，美团的骚操作至今让我难忘（后面会提到）！</p>
<p>我们先来看一下各种书籍和博客上一般推荐的配置线程池参数的方式，可以作为参考！</p>
<h4 id="常规操作"> 常规操作</h4>
<p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：<strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了<strong>上下文切换</strong>成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p>
<blockquote>
<p>上下文切换：</p>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
</blockquote>
<p><strong>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</strong></p>
<p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p>
<p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<h4 id="美团的骚操作"> 美团的骚操作</h4>
<p>美团技术团队在<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener noreferrer">《Java线程池实现原理及其在美团业务中的实践》</a>这篇文章中介绍到对线程池参数实现可自定义配置的思路和方法。</p>
<p>美团技术团队的思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：</p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><strong>为什么是这三个参数？</strong></p>
<p>我在这篇<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485808&amp;idx=1&amp;sn=1013253533d73450cef673aee13267ab&amp;chksm=cea246bbf9d5cfad1c21316340a0ef1609a7457fea4113a1f8d69e8c91e7d9cd6285f5ee1490&amp;token=510053261&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">《新手也能看懂的线程池学习总结》</a> 中就说过这三个参数是 <code>ThreadPoolExecutor</code>  最重要的参数，它们基本决定了线程池对于任务的处理策略。</p>
<p><strong>如何支持参数动态配置？</strong> 且看 <code>ThreadPoolExecutor</code> 提供的下面这些方法。</p>
<p><img src="./images/thread-pool/b6fd95a7-4c9d-4fc6-ad26-890adb3f6c4c.png" alt="" /></p>
<p>格外需要注意的是<code>corePoolSize</code>，   程序运行期间的时候，我们调用 <code>setCorePoolSize（）</code>这个方法的话，线程池会首先判断当前工作线程数是否大于<code>corePoolSize</code>，如果大于的话就会回收工作线程。</p>
<p>另外，你也看到了上面并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做 <code>ResizableCapacityLinkedBlockIngQueue</code> 的队列（主要就是把<code>LinkedBlockingQueue</code>的capacity 字段的final关键字修饰给去掉了，让它变为可变的）。</p>
<p>最终实现的可动态修改线程池参数效果如下。👏👏👏</p>
<p><img src="./images/thread-pool/19a0255a-6ef3-4835-98d1-a839d1983332.png" alt="动态配置线程池参数最终效果" /></p>
<p>还没看够？推荐 why神的<a href="https://mp.weixin.qq.com/s/9HLuPcoWmTqAeFKa1kj-_A" target="_blank" rel="noopener noreferrer">《如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。》</a>这篇文章，深度剖析，很不错哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>类文件结构详解</title>
      <link>https://javaguide.cn/java/jvm/class-file-structure/</link>
      <guid>https://javaguide.cn/java/jvm/class-file-structure/</guid>
      <source url="https://javaguide.cn/rss.xml">类文件结构详解</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="类文件结构详解"> 类文件结构详解</h1>
<h2 id="一-概述"> 一 概述</h2>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p>Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成<code>.class</code>文件最终运行在 Java 虚拟机之上。<code>.class</code>文件的二进制格式可以使用 <a href="https://www.x-ways.net/winhex/" target="_blank" rel="noopener noreferrer">WinHex</a> 查看。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktop类文件结构概览.png" alt="java虚拟机" /></p>
<p>可以说<code>.class</code>文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</p>
<h2 id="二-class-文件结构总结"> 二 Class 文件结构总结</h2>
<p>根据 Java 虚拟机规范，Class 文件通过 <code>ClassFile</code> 定义，有点类似 C 语言的结构体。</p>
<p><code>ClassFile</code> 的结构如下：</p>
<div><pre><code><span>ClassFile</span> <span>{</span>
    u4             magic<span>;</span> <span>//Class 文件的标志</span>
    u2             minor_version<span>;</span><span>//Class 的小版本号</span>
    u2             major_version<span>;</span><span>//Class 的大版本号</span>
    u2             constant_pool_count<span>;</span><span>//常量池的数量</span>
    cp_info        constant_pool<span>[</span>constant_pool_count<span>-</span><span>1</span><span>]</span><span>;</span><span>//常量池</span>
    u2             access_flags<span>;</span><span>//Class 的访问标记</span>
    u2             this_class<span>;</span><span>//当前类</span>
    u2             super_class<span>;</span><span>//父类</span>
    u2             interfaces_count<span>;</span><span>//接口</span>
    u2             interfaces<span>[</span>interfaces_count<span>]</span><span>;</span><span>//一个类可以实现多个接口</span>
    u2             fields_count<span>;</span><span>//Class 文件的字段属性</span>
    field_info     fields<span>[</span>fields_count<span>]</span><span>;</span><span>//一个类会可以有多个字段</span>
    u2             methods_count<span>;</span><span>//Class 文件的方法数量</span>
    method_info    methods<span>[</span>methods_count<span>]</span><span>;</span><span>//一个类可以有个多个方法</span>
    u2             attributes_count<span>;</span><span>//此类的属性表中的属性数</span>
    attribute_info attributes<span>[</span>attributes_count<span>]</span><span>;</span><span>//属性表集合</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>通过分析 <code>ClassFile</code> 的内容，我们便可以知道 class 文件的组成。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/16d5ec47609818fc.jpeg" alt="" /></p>
<p>下面这张图是通过 IDEA 插件 <code>jclasslib</code> 查看的，你可以更直观看到 Class 文件结构。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210401170711475.png" alt="" /></p>
<p>使用 <code>jclasslib</code> 不光可以直观地查看某个类对应的字节码文件，还可以查看类的基本信息、常量池、接口、属性、函数等信息。</p>
<p>下面详细介绍一下 Class 文件结构涉及到的一些组件。</p>
<h3 id="_2-1-魔数-magic-number"> 2.1 魔数（Magic Number）</h3>
<div><pre><code>    u4             magic<span>;</span> <span>//Class 文件的标志</span>
</code></pre>
<div><span>1</span><br></div></div><p>每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。</p>
<p>程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。</p>
<h3 id="_2-2-class-文件版本号-minor-major-version"> 2.2 Class 文件版本号（Minor&amp;Major Version）</h3>
<div><pre><code>    u2             minor_version<span>;</span><span>//Class 的小版本号</span>
    u2             major_version<span>;</span><span>//Class 的大版本号</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是<strong>次版本号</strong>，第 7 和第 8 位是<strong>主版本号</strong>。</p>
<p>每当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。你可以使用 <code>javap -v</code> 命令来快速查看 Class 文件的版本号信息。</p>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p>
<h3 id="_2-3-常量池-constant-pool"> 2.3 常量池（Constant Pool）</h3>
<div><pre><code>    u2             constant_pool_count<span>;</span><span>//常量池的数量</span>
    cp_info        constant_pool<span>[</span>constant_pool_count<span>-</span><span>1</span><span>]</span><span>;</span><span>//常量池</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>紧接着主次版本号之后的是常量池，常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p>
<p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">标志（tag）</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONSTANT_utf8_info</td>
<td style="text-align:center">1</td>
<td style="text-align:center">UTF-8 编码的字符串</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Integer_info</td>
<td style="text-align:center">3</td>
<td style="text-align:center">整形字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Float_info</td>
<td style="text-align:center">4</td>
<td style="text-align:center">浮点型字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Long_info</td>
<td style="text-align:center">５</td>
<td style="text-align:center">长整型字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Double_info</td>
<td style="text-align:center">６</td>
<td style="text-align:center">双精度浮点型字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Class_info</td>
<td style="text-align:center">７</td>
<td style="text-align:center">类或接口的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_String_info</td>
<td style="text-align:center">８</td>
<td style="text-align:center">字符串类型字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Fieldref_info</td>
<td style="text-align:center">９</td>
<td style="text-align:center">字段的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Methodref_info</td>
<td style="text-align:center">10</td>
<td style="text-align:center">类中方法的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_InterfaceMethodref_info</td>
<td style="text-align:center">11</td>
<td style="text-align:center">接口中方法的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_NameAndType_info</td>
<td style="text-align:center">12</td>
<td style="text-align:center">字段或方法的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_MothodType_info</td>
<td style="text-align:center">16</td>
<td style="text-align:center">标志方法类型</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_MethodHandle_info</td>
<td style="text-align:center">15</td>
<td style="text-align:center">表示方法句柄</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_InvokeDynamic_info</td>
<td style="text-align:center">18</td>
<td style="text-align:center">表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)。</p>
<h3 id="_2-4-访问标志-access-flags"> 2.4 访问标志(Access Flags)</h3>
<p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型，如果是类的话是否声明为 <code>final</code> 等等。</p>
<p>类访问和属性修饰符:</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/访问标志.png" alt="类访问和属性修饰符" /></p>
<p>我们定义了一个 Employee 类</p>
<div><pre><code><span>package</span> <span>top<span>.</span>snailclimb<span>.</span>bean</span><span>;</span>
<span>public</span> <span>class</span> <span>Employee</span> <span>{</span>
   <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>通过<code>javap -v class类名</code> 指令来看一下类的访问标志。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/查看类的访问标志.png" alt="查看类的访问标志" /></p>
<h3 id="_2-5-当前类-this-class-、父类-super-class-、接口-interfaces-索引集合"> 2.5 当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</h3>
<div><pre><code>    u2             this_class<span>;</span><span>//当前类</span>
    u2             super_class<span>;</span><span>//父类</span>
    u2             interfaces_count<span>;</span><span>//接口</span>
    u2             interfaces<span>[</span>interfaces_count<span>]</span><span>;</span><span>//一个类可以实现多个接口</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p>
<p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p>
<h3 id="_2-6-字段表集合-fields"> 2.6 字段表集合（Fields）</h3>
<div><pre><code>    u2             fields_count<span>;</span><span>//Class 文件的字段的个数</span>
    field_info     fields<span>[</span>fields_count<span>]</span><span>;</span><span>//一个类会可以有个字段</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p>
<p><strong>field info(字段表) 的结构:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/字段表的结构.png" alt="字段表的结构 " /></p>
<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li>
<li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li>
<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>
</ul>
<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p>
<p><strong>字段的 access_flag 的取值:</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/JVM/image-20201031084342859.png" alt="字段的 access_flag 的取值" /></p>
<h3 id="_2-7-方法表集合-methods"> 2.7 方法表集合（Methods）</h3>
<div><pre><code>    u2             methods_count<span>;</span><span>//Class 文件的方法的数量</span>
    method_info    methods<span>[</span>methods_count<span>]</span><span>;</span><span>//一个类可以有个多个方法</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>methods_count 表示方法的数量，而 method_info 表示方法表。</p>
<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p>
<p><strong>method_info(方法表的) 结构:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/方法表的结构.png" alt="方法表的结构" /></p>
<p><strong>方法表的 access_flag 取值：</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/JVM/image-20201031084248965.png" alt="方法表的 access_flag 取值" /></p>
<p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
<h3 id="_2-8-属性表集合-attributes"> 2.8 属性表集合（Attributes）</h3>
<div><pre><code>   u2             attributes_count<span>;</span><span>//此类的属性表中的属性数</span>
   attribute_info attributes<span>[</span>attributes_count<span>]</span><span>;</span><span>//属性表集合</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html</a></li>
<li><a href="https://coolshell.cn/articles/9229.html" target="_blank" rel="noopener noreferrer">https://coolshell.cn/articles/9229.html</a></li>
<li><a href="https://blog.csdn.net/luanlouis/article/details/39960815" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/luanlouis/article/details/39960815</a></li>
<li>《实战 Java 虚拟机》</li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktop类文件结构概览.png" type="image/png"/>
    </item>
    <item>
      <title>类加载过程详解</title>
      <link>https://javaguide.cn/java/jvm/class-loading-process/</link>
      <guid>https://javaguide.cn/java/jvm/class-loading-process/</guid>
      <source url="https://javaguide.cn/rss.xml">类加载过程详解</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="类加载过程详解"> 类加载过程详解</h1>
<h2 id="类的生命周期"> 类的生命周期</h2>
<p>一个类的完整生命周期如下：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/类加载过程-完善.png" alt="" /></p>
<h2 id="类加载过程"> 类加载过程</h2>
<p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</p>
<p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/类加载过程.png" alt="" /></p>
<p>详见：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4" target="_blank" rel="noopener noreferrer">jvm规范5.4</a> 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210607102244508.png" alt="" /></p>
<h3 id="加载"> 加载</h3>
<p>类加载过程的第一步，主要完成下面 3 件事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li>
</ol>
<p>虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：&quot;通过全类名获取定义此类的二进制字节流&quot; 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 <code>ZIP</code> 包中读取（日后出现的 <code>JAR</code>、<code>EAR</code>、<code>WAR</code> 格式的基础）、其他文件生成（典型应用就是 <code>JSP</code>）等等。</p>
<p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p>
<p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p>
<p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p>
<h3 id="验证"> 验证</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/验证阶段.png" alt="验证阶段示意图" /></p>
<h3 id="准备"> 准备</h3>
<p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ol>
<li>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>
<li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。相关阅读：<a href="https://github.com/fenixsoft/jvm_book/issues/75" target="_blank" rel="noopener noreferrer">《深入理解Java虚拟机（第3版）》勘误#75</a></li>
<li>这里所设置的初始值&quot;通常情况&quot;下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li>
</ol>
<p><strong>基本数据类型的零值</strong> ： (图片来自《深入理解 Java 虚拟机》第 3 版  7.33 )</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/基本数据类型的零值.png" alt="基本数据类型的零值" /></p>
<h3 id="解析"> 解析</h3>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h3 id="初始化"> 初始化</h3>
<p>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p>
<blockquote>
<p>说明： <code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p>
</blockquote>
<p>对于<code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个进程阻塞，并且这种阻塞很难被发现。</p>
<p>对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p>
<ol>
<li>当遇到 <code>new</code> 、 <code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这 4 条直接码指令时，比如 <code>new</code> 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
<ul>
<li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li>
<li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li>
<li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li>
<li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li>
</ul>
</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</li>
<li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li>
<li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，
就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</li>
<li><strong>「补充，来自<a href="https://github.com/Snailclimb/JavaGuide/issues/745" target="_blank" rel="noopener noreferrer">issue745</a>」</strong> 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<h2 id="卸载"> 卸载</h2>
<blockquote>
<p>卸载这部分内容来自 <a href="https://github.com/Snailclimb/JavaGuide/issues/662" target="_blank" rel="noopener noreferrer">issue#662</a>由 <strong><a href="https://github.com/guang19" target="_blank" rel="noopener noreferrer">guang19</a></strong> 补充完善。</p>
</blockquote>
<p>卸载类即该类的 Class 对象被 GC。</p>
<p>卸载类需要满足 3 个要求:</p>
<ol>
<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器的实例已被 GC</li>
</ol>
<p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，jdk 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
<p><strong>参考</strong></p>
<ul>
<li>《深入理解 Java 虚拟机》</li>
<li>《实战 Java 虚拟机》</li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/类加载过程-完善.png" type="image/png"/>
    </item>
    <item>
      <title>类加载器详解</title>
      <link>https://javaguide.cn/java/jvm/classloader/</link>
      <guid>https://javaguide.cn/java/jvm/classloader/</guid>
      <source url="https://javaguide.cn/rss.xml">类加载器详解</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="类加载器详解"> 类加载器详解</h1>
<h2 id="回顾一下类加载过程"> 回顾一下类加载过程</h2>
<p>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/类加载过程.png" alt="类加载过程" /></p>
<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p>
<p>所有的类都由类加载器加载，加载的作用就是将 <code>.class</code>文件加载到内存。</p>
<h2 id="类加载器总结"> 类加载器总结</h2>
<p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ol>
<li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li>
<li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li>
<li><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li>
</ol>
<h2 id="双亲委派模型"> 双亲委派模型</h2>
<h3 id="双亲委派模型介绍"> 双亲委派模型介绍</h3>
<p>每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS图片.png" alt="ClassLoader" /></p>
<p>每个类加载都有一个父类加载器，我们通过下面的程序来验证。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ClassLoaderDemo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ClassLodarDemo's ClassLoader is "</span> <span>+</span> <span>ClassLoaderDemo</span><span>.</span><span>class</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"The Parent of ClassLodarDemo's ClassLoader is "</span> <span>+</span> <span>ClassLoaderDemo</span><span>.</span><span>class</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>.</span><span>getParent</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"The GrandParent of ClassLodarDemo's ClassLoader is "</span> <span>+</span> <span>ClassLoaderDemo</span><span>.</span><span>class</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>.</span><span>getParent</span><span>(</span><span>)</span><span>.</span><span>getParent</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>Output</p>
<div><pre><code>ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2
The Parent of ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586
The GrandParent of ClassLodarDemo&#39;s ClassLoader is null
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code>，
<code>ExtClassLoader</code>的父类加载器为 null，<strong>null 并不代表<code>ExtClassLoader</code>没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> 。</p>
<p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 Mother ClassLoader 和一个 Father ClassLoader 。另外，类加载器之间的“父子”关系也不是通过继承来体现的，是由“优先级”来决定。官方 API 文档对这部分的描述如下:</p>
<blockquote>
<p>The Java platform uses a delegation model for loading classes. <strong>The basic idea is that every class loader has a &quot;parent&quot; class loader.</strong> When loading a class, a class loader first &quot;delegates&quot; the search for the class to its parent class loader before attempting to find the class itself.</p>
</blockquote>
<h3 id="双亲委派模型实现源码分析"> 双亲委派模型实现源码分析</h3>
<p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</p>
<div><pre><code><span>private</span> <span>final</span> <span>ClassLoader</span> parent<span>;</span>
<span>protected</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>loadClass</span><span>(</span><span>String</span> name<span>,</span> <span>boolean</span> resolve<span>)</span>
        <span>throws</span> <span>ClassNotFoundException</span>
    <span>{</span>
        <span>synchronized</span> <span>(</span><span>getClassLoadingLock</span><span>(</span>name<span>)</span><span>)</span> <span>{</span>
            <span>// 首先，检查请求的类是否已经被加载过</span>
            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> c <span>=</span> <span>findLoadedClass</span><span>(</span>name<span>)</span><span>;</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>null</span><span>)</span> <span>{</span>
                <span>long</span> t0 <span>=</span> <span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span><span>;</span>
                <span>try</span> <span>{</span>
                    <span>if</span> <span>(</span>parent <span>!=</span> <span>null</span><span>)</span> <span>{</span><span>//父加载器不为空，调用父加载器loadClass()方法处理</span>
                        c <span>=</span> parent<span>.</span><span>loadClass</span><span>(</span>name<span>,</span> <span>false</span><span>)</span><span>;</span>
                    <span>}</span> <span>else</span> <span>{</span><span>//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span>
                        c <span>=</span> <span>findBootstrapClassOrNull</span><span>(</span>name<span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> e<span>)</span> <span>{</span>
                   <span>//抛出异常说明父类加载器无法完成加载请求</span>
                <span>}</span>

                <span>if</span> <span>(</span>c <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    <span>long</span> t1 <span>=</span> <span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span><span>;</span>
                    <span>//自己尝试加载</span>
                    c <span>=</span> <span>findClass</span><span>(</span>name<span>)</span><span>;</span>

                    <span>// this is the defining class loader; record the stats</span>
                    <span><span>sun<span>.</span>misc<span>.</span></span>PerfCounter</span><span>.</span><span>getParentDelegationTime</span><span>(</span><span>)</span><span>.</span><span>addTime</span><span>(</span>t1 <span>-</span> t0<span>)</span><span>;</span>
                    <span><span>sun<span>.</span>misc<span>.</span></span>PerfCounter</span><span>.</span><span>getFindClassTime</span><span>(</span><span>)</span><span>.</span><span>addElapsedTimeFrom</span><span>(</span>t1<span>)</span><span>;</span>
                    <span><span>sun<span>.</span>misc<span>.</span></span>PerfCounter</span><span>.</span><span>getFindClasses</span><span>(</span><span>)</span><span>.</span><span>increment</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>if</span> <span>(</span>resolve<span>)</span> <span>{</span>
                <span>resolveClass</span><span>(</span>c<span>)</span><span>;</span>
            <span>}</span>
            <span>return</span> c<span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h3 id="双亲委派模型的好处"> 双亲委派模型的好处</h3>
<p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p>
<h3 id="如果我们不想用双亲委派模型怎么办"> 如果我们不想用双亲委派模型怎么办？</h3>
<p><s>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</s></p>
<p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/871" target="_blank" rel="noopener noreferrer">issue871</a> ）</strong> ：自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法</p>
<h2 id="自定义类加载器"> 自定义类加载器</h2>
<p>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>。</p>
<h2 id="推荐阅读"> 推荐阅读</h2>
<ul>
<li><a href="https://blog.csdn.net/xyang81/article/details/7292380" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/xyang81/article/details/7292380</a></li>
<li><a href="https://juejin.im/post/5c04892351882516e70dcc9b" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5c04892351882516e70dcc9b</a></li>
<li><a href="http://gityuan.com/2016/01/24/java-classloader/" target="_blank" rel="noopener noreferrer">http://gityuan.com/2016/01/24/java-classloader/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/类加载过程.png" type="image/png"/>
    </item>
    <item>
      <title>JDK 监控和故障处理工具总结</title>
      <link>https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools/</link>
      <guid>https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools/</guid>
      <source url="https://javaguide.cn/rss.xml">JDK 监控和故障处理工具总结</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="jdk-监控和故障处理工具总结"> JDK 监控和故障处理工具总结</h1>
<h2 id="jdk-命令行工具"> JDK 命令行工具</h2>
<p>这些命令在 JDK 安装目录下的 bin 目录下：</p>
<ul>
<li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li>
<li><strong><code>jstat</code></strong>（JVM Statistics Monitoring Tool）:  用于收集 HotSpot 虚拟机各方面的运行数据;</li>
<li><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;</li>
<li><strong><code>jmap</code></strong> (Memory Map for Java) : 生成堆转储快照;</li>
<li><strong><code>jhat</code></strong> (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</li>
<li><strong><code>jstack</code></strong> (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li>
</ul>
<h3 id="jps-查看所有-java-进程"> <code>jps</code>:查看所有 Java 进程</h3>
<p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code> 命令。</p>
<p><code>jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。<code>jps -q</code> ：只输出进程的本地虚拟机唯一 ID。</p>
<div><pre><code>C:\Users\SnailClimb>jps
7360 NettyClient2
17396
7972 Launcher
16504 Jps
17340 NettyServer
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。</p>
<div><pre><code>C:\Users\SnailClimb>jps <span>-</span>l
7360 firstNettyDemo<span>.</span>NettyClient2
17396
7972 org<span>.</span>jetbrains<span>.</span>jps<span>.</span>cmdline<span>.</span>Launcher
16492 sun<span>.</span>tools<span>.</span>jps<span>.</span>Jps
17340 firstNettyDemo<span>.</span>NettyServer
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p>
<p><code>jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p>
<h3 id="jstat-监视虚拟机各种运行状态信息"> <code>jstat</code>: 监视虚拟机各种运行状态信息</h3>
<p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p>
<p><strong><code>jstat</code> 命令使用格式：</strong></p>
<div><pre><code>jstat <span>-</span>&lt;option> <span>[</span><span>-</span>t<span>]</span> <span>[</span><span>-</span>h&lt;lines><span>]</span> &lt;vmid> <span>[</span>&lt;interval> <span>[</span>&lt;count><span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>比如 <code>jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p>
<p><strong>常见的 option 如下：</strong></p>
<ul>
<li><code>jstat -class vmid</code> ：显示 ClassLoader 的相关信息；</li>
<li><code>jstat -compiler vmid</code> ：显示 JIT 编译的相关信息；</li>
<li><code>jstat -gc vmid</code> ：显示与 GC 相关的堆信息；</li>
<li><code>jstat -gccapacity vmid</code> ：显示各个代的容量及使用情况；</li>
<li><code>jstat -gcnew vmid</code> ：显示新生代信息；</li>
<li><code>jstat -gcnewcapcacity vmid</code> ：显示新生代大小与使用情况；</li>
<li><code>jstat -gcold vmid</code> ：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了；</li>
<li><code>jstat -gcoldcapacity vmid</code> ：显示老年代的大小；</li>
<li><code>jstat -gcpermcapacity vmid</code> ：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了；</li>
<li><code>jstat -gcutil vmid</code> ：显示垃圾收集信息；</li>
</ul>
<p>另外，加上 <code>-t</code>参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。</p>
<h3 id="jinfo-实时地查看和调整虚拟机各项参数"> <code>jinfo</code>: 实时地查看和调整虚拟机各项参数</h3>
<p><code>jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p>
<p><code>jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code>-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p>
<div><pre><code>C:\Users\SnailClimb>jinfo  <span>-</span>flag MaxHeapSize 17340
<span>-</span>XX:MaxHeapSize=2124414976
C:\Users\SnailClimb>jinfo  <span>-</span>flag PrintGC 17340
<span>-</span>XX:<span>-</span>PrintGC
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p>
<p><code>jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</p>
<div><pre><code>C:\Users\SnailClimb>jinfo  <span>-</span>flag  PrintGC 17340
<span>-</span>XX:<span>-</span>PrintGC

C:\Users\SnailClimb>jinfo  <span>-</span>flag  <span>+</span>PrintGC 17340

C:\Users\SnailClimb>jinfo  <span>-</span>flag  PrintGC 17340
<span>-</span>XX:<span>+</span>PrintGC
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="jmap-生成堆转储快照"> <code>jmap</code>:生成堆转储快照</h3>
<p><code>jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code>jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code>“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 <code>kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p>
<p><code>jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在 Windows 平台下也是受限制的。</p>
<p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p>
<div><pre><code>C:\Users\SnailClimb>jmap <span>-</span>dump:format=b<span>,</span>file=C:\Users\SnailClimb\Desktop\heap<span>.</span>hprof 17340
Dumping heap to C:\Users\SnailClimb\Desktop\heap<span>.</span>hprof <span>.</span><span>.</span><span>.</span>
Heap dump file created
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="jhat-分析-heapdump-文件"> <strong><code>jhat</code></strong>: 分析 heapdump 文件</h3>
<p><strong><code>jhat</code></strong> 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。</p>
<div><pre><code>C:\Users\SnailClimb>jhat C:\Users\SnailClimb\Desktop\heap<span>.</span>hprof
Reading <span>from</span> C:\Users\SnailClimb\Desktop\heap<span>.</span>hprof<span>.</span><span>.</span><span>.</span>
Dump file created Sat May 04 12:30:31 CST 2019
Snapshot read<span>,</span> resolving<span>.</span><span>.</span><span>.</span>
Resolving 131419 objects<span>.</span><span>.</span><span>.</span>
Chasing references<span>,</span> expect 26 dots<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
Eliminating duplicate references<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
Snapshot resolved<span>.</span>
Started HTTP server on port 7000
Server is ready<span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>访问 <a href="http://localhost:7000/" target="_blank" rel="noopener noreferrer">http://localhost:7000/</a></p>
<h3 id="jstack-生成虚拟机当前时刻的线程快照"> <strong><code>jstack</code></strong> :生成虚拟机当前时刻的线程快照</h3>
<p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p>
<p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p>
<p><strong>下面是一个线程死锁的代码。我们下面会通过 <code>jstack</code> 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>DeadLockDemo</span> <span>{</span>
    <span>private</span> <span>static</span> <span>Object</span> resource1 <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span><span>//资源 1</span>
    <span>private</span> <span>static</span> <span>Object</span> resource2 <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span><span>//资源 2</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>synchronized</span> <span>(</span>resource1<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"get resource1"</span><span>)</span><span>;</span>
                <span>try</span> <span>{</span>
                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"waiting get resource2"</span><span>)</span><span>;</span>
                <span>synchronized</span> <span>(</span>resource2<span>)</span> <span>{</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"get resource2"</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>,</span> <span>"线程 1"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>

        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>synchronized</span> <span>(</span>resource2<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"get resource2"</span><span>)</span><span>;</span>
                <span>try</span> <span>{</span>
                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"waiting get resource1"</span><span>)</span><span>;</span>
                <span>synchronized</span> <span>(</span>resource1<span>)</span> <span>{</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>+</span> <span>"get resource1"</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>,</span> <span>"线程 2"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>Output</p>
<div><pre><code>Thread[线程 1,5,main]get resource1
Thread[线程 2,5,main]get resource2
Thread[线程 1,5,main]waiting get resource2
Thread[线程 2,5,main]waiting get resource1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>
<p><strong>通过 <code>jstack</code> 命令分析：</strong></p>
<div><pre><code>C:\Users\SnailClimb>jps
13792 KotlinCompileDaemon
7360 NettyClient2
17396
7972 Launcher
8932 Launcher
9256 DeadLockDemo
10764 Jps
17340 NettyServer

C:\Users\SnailClimb>jstack 9256
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>输出的部分内容如下：</p>
<div><pre><code>Found one Java<span>-</span>level deadlock:
=============================
<span>"线程 2"</span>:
  waiting to lock monitor 0x000000000333e668 <span>(</span>object 0x00000000d5efe1c0<span>,</span> a java<span>.</span>lang<span>.</span>Object<span>)</span><span>,</span>
  which is held by <span>"线程 1"</span>
<span>"线程 1"</span>:
  waiting to lock monitor 0x000000000333be88 <span>(</span>object 0x00000000d5efe1d0<span>,</span> a java<span>.</span>lang<span>.</span>Object<span>)</span><span>,</span>
  which is held by <span>"线程 2"</span>

Java stack information <span>for</span> the threads listed above:
===================================================
<span>"线程 2"</span>:
        at DeadLockDemo<span>.</span>lambda<span>$main</span><span>$1</span><span>(</span>DeadLockDemo<span>.</span>java:31<span>)</span>
        <span>-</span> waiting to lock &lt;0x00000000d5efe1c0> <span>(</span>a java<span>.</span>lang<span>.</span>Object<span>)</span>
        <span>-</span> locked &lt;0x00000000d5efe1d0> <span>(</span>a java<span>.</span>lang<span>.</span>Object<span>)</span>
        at DeadLockDemo$<span>$Lambda</span><span>$2</span><span>/</span>1078694789<span>.</span>run<span>(</span>Unknown Source<span>)</span>
        at java<span>.</span>lang<span>.</span>Thread<span>.</span>run<span>(</span>Thread<span>.</span>java:748<span>)</span>
<span>"线程 1"</span>:
        at DeadLockDemo<span>.</span>lambda<span>$main</span><span>$0</span><span>(</span>DeadLockDemo<span>.</span>java:16<span>)</span>
        <span>-</span> waiting to lock &lt;0x00000000d5efe1d0> <span>(</span>a java<span>.</span>lang<span>.</span>Object<span>)</span>
        <span>-</span> locked &lt;0x00000000d5efe1c0> <span>(</span>a java<span>.</span>lang<span>.</span>Object<span>)</span>
        at DeadLockDemo$<span>$Lambda</span><span>$1</span><span>/</span>1324119927<span>.</span>run<span>(</span>Unknown Source<span>)</span>
        at java<span>.</span>lang<span>.</span>Thread<span>.</span>run<span>(</span>Thread<span>.</span>java:748<span>)</span>

Found 1 deadlock<span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>可以看到 <code>jstack</code> 命令已经帮我们找到发生死锁的线程的具体信息。</p>
<h2 id="jdk-可视化分析工具"> JDK 可视化分析工具</h2>
<h3 id="jconsole-java-监视与管理控制台"> JConsole:Java 监视与管理控制台</h3>
<p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出<code>console</code>命令启动或者在 JDK 目录下的 bin 目录找到<code>jconsole.exe</code>然后双击启动。</p>
<h4 id="连接-jconsole"> 连接 Jconsole</h4>
<p><img src="./pictures/jdk监控和故障处理工具总结/1JConsole连接.png" alt="连接 Jconsole" /></p>
<p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p>
<div><pre><code><span>-Djava.rmi.server.hostname</span><span>=</span><span>外网访问 ip 地址 </span>
<span>-Dcom.sun.management.jmxremote.port</span><span>=</span><span>60001   //监控的端口号</span>
<span>-Dcom.sun.management.jmxremote.authenticate</span><span>=</span><span>false   //关闭认证</span>
<span>-Dcom.sun.management.jmxremote.ssl</span><span>=</span><span>false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在使用 JConsole 连接时，远程进程地址如下：</p>
<div><pre><code>外网访问 ip 地址:60001 
</code></pre>
<div><span>1</span><br></div></div><h4 id="查看-java-程序概况"> 查看 Java 程序概况</h4>
<p><img src="./pictures/jdk监控和故障处理工具总结/2查看Java程序概况.png" alt="查看 Java 程序概况 " /></p>
<h4 id="内存监控"> 内存监控</h4>
<p>JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。</p>
<p>点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。</p>
<blockquote>
<ul>
<li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li>
<li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li>
</ul>
</blockquote>
<p><img src="./pictures/jdk监控和故障处理工具总结/3内存监控.png" alt="内存监控 " /></p>
<h4 id="线程监控"> 线程监控</h4>
<p>类似我们前面讲的 <code>jstack</code> 命令，不过这个是可视化的。</p>
<p>最下面有一个&quot;检测死锁 (D)&quot;按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。</p>
<p><img src="./pictures/jdk监控和故障处理工具总结/4线程监控.png" alt="线程监控 " /></p>
<h3 id="visual-vm-多合一故障处理工具"> Visual VM:多合一故障处理工具</h3>
<p>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<a href="https://visualvm.github.io/" target="_blank" rel="noopener noreferrer">https://visualvm.github.io/</a> 。Visual VM 中文文档:<a href="https://visualvm.github.io/documentation.html" target="_blank" rel="noopener noreferrer">https://visualvm.github.io/documentation.html</a>。</p>
<p>下面这段话摘自《深入理解 Java 虚拟机》。</p>
<blockquote>
<p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p>
</blockquote>
<p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p>
<ul>
<li><strong>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</strong></li>
<li><strong>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</strong></li>
<li><strong>dump 以及分析堆转储快照（jmap、jhat）。</strong></li>
<li><strong>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</strong></li>
<li><strong>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</strong></li>
<li><strong>其他 plugins 的无限的可能性......</strong></li>
</ul>
<p>这里就不具体介绍 VisualVM 的使用，如果想了解的话可以看:</p>
<ul>
<li><a href="https://visualvm.github.io/documentation.html" target="_blank" rel="noopener noreferrer">https://visualvm.github.io/documentation.html</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html" target="_blank" rel="noopener noreferrer">https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>JVM 垃圾回收详解</title>
      <link>https://javaguide.cn/java/jvm/jvm-garbage-collection/</link>
      <guid>https://javaguide.cn/java/jvm/jvm-garbage-collection/</guid>
      <source url="https://javaguide.cn/rss.xml">JVM 垃圾回收详解</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="jvm-垃圾回收详解"> JVM 垃圾回收详解</h1>
<h2 id="写在前面"> 写在前面</h2>
<h3 id="本节常见面试题"> 本节常见面试题</h3>
<p>问题答案在文中都有提到</p>
<ul>
<li>如何判断对象是否死亡（两种方法）。</li>
<li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li>
<li>如何判断一个常量是废弃常量</li>
<li>如何判断一个类是无用的类</li>
<li>垃圾收集有哪些算法，各自的特点？</li>
<li>HotSpot 为什么要分为新生代和老年代？</li>
<li>常见的垃圾回收器有哪些？</li>
<li>介绍一下 CMS,G1 收集器。</li>
<li>Minor Gc 和 Full GC 有什么不同呢？</li>
</ul>
<h3 id="本文导火索"> 本文导火索</h3>
<p><img src="./pictures/jvm垃圾回收/29176325.png" alt="" /></p>
<p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>
<h2 id="_1-揭开-jvm-内存分配与回收的神秘面纱"> 1 揭开 JVM 内存分配与回收的神秘面纱</h2>
<p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p><strong>堆空间的基本结构：</strong></p>
<p><img src="./pictures/jvm垃圾回收/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.png" alt="" /></p>
<p>上图所示的 Eden 区、From Survivor0(&quot;From&quot;) 区、To Survivor1(&quot;To&quot;) 区都属于新生代，Old Memory 区属于老年代。</p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为大于 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置默认值，这个值会在虚拟机运行过程中进行调整，可以通过<code>-XX:+PrintTenuringDistribution</code>来打印出当次 GC 后的 Threshold。</p>
<blockquote>
<p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/552" target="_blank" rel="noopener noreferrer">issue552</a>）</strong>：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p>
<p><strong>动态年龄计算的代码如下</strong></p>
<div><pre><code>uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {
 //survivor_capacity是survivor空间的大小
 size_t desired_survivor_size = (size_t)((((double)survivor_capacity)*TargetSurvivorRatio)/100);
 size_t total = 0;
 uint age = 1;
 while (age &lt; table_size) {
     //sizes数组是每个年龄段对象大小
     total += sizes[age];
     if (total &gt; desired_survivor_size) {
         break;
     }
     age++;
 }
 uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;
 ...
}

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></blockquote>
<p>经过这次 GC 后，Eden 区和&quot;From&quot;区已经被清空。这个时候，&quot;From&quot;和&quot;To&quot;会交换他们的角色，也就是新的&quot;To&quot;就是上次 GC 前的“From”，新的&quot;From&quot;就是上次 GC 前的&quot;To&quot;。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，在这个过程中，有可能当次 Minor GC 后，Survivor 的&quot;From&quot;区域空间不够用，有一些还达不到进入老年代条件的实例放不下，则放不下的部分会提前进入老年代。</p>
<p>接下来我们提供一个调试脚本来测试这个过程。</p>
<p><strong>调试代码参数如下</strong></p>
<div><pre><code>-verbose:gc
-Xmx200M
-Xms200M
-Xmn50M
-XX:+PrintGCDetails
-XX:TargetSurvivorRatio=60
-XX:+PrintTenuringDistribution
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:MaxTenuringThreshold=3
-XX:+UseConcMarkSweepGC
-XX:+UseParNewGC
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>示例代码如下：</strong></p>
<div><pre><code><span>/*
* 本实例用于java GC以后，新生代survivor区域的变化，以及晋升到老年代的时间和方式的测试代码。需要自行分步注释不需要的代码进行反复测试对比
*
* 由于java的main函数以及其他基础服务也会占用一些eden空间，所以要提前空跑一次main函数，来看看这部分占用。
*
* 自定义的代码中，我们使用堆内分配数组和栈内分配数组的方式来分别模拟不可被GC的和可被GC的资源。
*
*
* */</span>

<span>public</span> <span>class</span> <span>JavaGcTest</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>//空跑一次main函数来查看java服务本身占用的空间大小，我这里是占用了3M。所以40-3=37，下面分配三个1M的数组和一个34M的垃圾数组。</span>


        <span>// 为了达到TargetSurvivorRatio（期望占用的Survivor区域的大小）这个比例指定的值, 即5M*60%=3M(Desired survivor size)，</span>
        <span>// 这里用1M的数组的分配来达到Desired survivor size</span>
        <span>//说明: 5M为S区的From或To的大小，60%为TargetSurvivorRatio参数指定,可以更改参数获取不同的效果。</span>
        <span>byte</span><span>[</span><span>]</span> byte1m_1 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1</span> <span>*</span> <span>1024</span> <span>*</span> <span>1024</span><span>]</span><span>;</span>
        <span>byte</span><span>[</span><span>]</span> byte1m_2 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1</span> <span>*</span> <span>1024</span> <span>*</span> <span>1024</span><span>]</span><span>;</span>
        <span>byte</span><span>[</span><span>]</span> byte1m_3 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1</span> <span>*</span> <span>1024</span> <span>*</span> <span>1024</span><span>]</span><span>;</span>

        <span>//使用函数方式来申请空间，函数运行完毕以后，就会变成垃圾等待回收。此时应保证eden的区域占用达到100%。可以通过调整传入值来达到效果。</span>
        <span>makeGarbage</span><span>(</span><span>34</span><span>)</span><span>;</span>

        <span>//再次申请一个数组，因为eden已经满了，所以这里会触发Minor GC</span>
        <span>byte</span><span>[</span><span>]</span> byteArr <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>10</span><span>*</span><span>1024</span><span>*</span><span>1024</span><span>]</span><span>;</span>
        <span>// 这次Minor Gc时, 三个1M的数组因为尚有引用，所以进入From区域（因为是第一次GC）age为1</span>
        <span>// 且由于From区已经占用达到了60%(-XX:TargetSurvivorRatio=60), 所以会重新计算对象晋升的age。</span>
        <span>// 计算方法见上文，计算出age：min(age, MaxTenuringThreshold) = 1，输出中会有Desired survivor size 3145728 bytes, new threshold 1 (max 3)字样</span>
        <span>//新的数组byteArr进入eden区域。</span>


        <span>//再次触发垃圾回收，证明三个1M的数组会因为其第二次回收后age为2，大于上一次计算出的new threshold 1，所以进入老年代。</span>
        <span>//而byteArr因为超过survivor的单个区域，直接进入了老年代。</span>
        <span>makeGarbage</span><span>(</span><span>34</span><span>)</span><span>;</span>
    <span>}</span>
    <span>private</span> <span>static</span> <span>void</span> <span>makeGarbage</span><span>(</span><span>int</span> size<span>)</span><span>{</span>
        <span>byte</span><span>[</span><span>]</span> byteArrTemp <span>=</span> <span>new</span> <span>byte</span><span>[</span>size <span>*</span> <span>1024</span> <span>*</span> <span>1024</span><span>]</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>注意:如下输出结果中老年代的信息为 <code>concurrent mark-sweep generation</code> 和以前版本略有不同。另外，还列出了某次 GC 后是否重新生成了 threshold，以及各个年龄占用空间的大小。</p>
<div><pre><code><span>2021</span>-07-01T10:41:32.257+0800: <span>[</span>GC <span>(</span>Allocation Failure<span>)</span> <span>2021</span>-07-01T10:41:32.257+0800: <span>[</span>ParNew
Desired survivor size <span>3145728</span> bytes, new threshold <span>1</span> <span>(</span>max <span>3</span><span>)</span>
- age   <span>1</span>:    <span>3739264</span> bytes,    <span>3739264</span> total
<span>:</span> 40345K-<span>></span>3674K<span>(</span>46080K<span>)</span>, <span>0.0014584</span> secs<span>]</span> 40345K-<span>></span>3674K<span>(</span>199680K<span>)</span>, <span>0.0015063</span> secs<span>]</span> <span>[</span>Times: <span>user</span><span>=</span><span>0.00</span> <span>sys</span><span>=</span><span>0.00</span>, <span>real</span><span>=</span><span>0.00</span> secs<span>]</span>
<span>2021</span>-07-01T10:41:32.259+0800: <span>[</span>GC <span>(</span>Allocation Failure<span>)</span> <span>2021</span>-07-01T10:41:32.259+0800: <span>[</span>ParNew
Desired survivor size <span>3145728</span> bytes, new threshold <span>3</span> <span>(</span>max <span>3</span><span>)</span>
<span>:</span> 13914K-<span>></span>0K<span>(</span>46080K<span>)</span>, <span>0.0046596</span> secs<span>]</span> 13914K-<span>></span>13895K<span>(</span>199680K<span>)</span>, <span>0.0046873</span> secs<span>]</span> <span>[</span>Times: <span>user</span><span>=</span><span>0.00</span> <span>sys</span><span>=</span><span>0.00</span>, <span>real</span><span>=</span><span>0.00</span> secs<span>]</span>
Heap
 par new generation   total 46080K, used 35225K <span>[</span>0x05000000, 0x08200000, 0x08200000<span>)</span>
  eden space 40960K,  <span>86</span>% used <span>[</span>0x05000000, 0x072667f0, 0x07800000<span>)</span>
  from space 5120K,   <span>0</span>% used <span>[</span>0x07800000, 0x07800000, 0x07d00000<span>)</span>
  to   space 5120K,   <span>0</span>% used <span>[</span>0x07d00000, 0x07d00000, 0x08200000<span>)</span>
 concurrent mark-sweep generation total 153600K, used 13895K <span>[</span>0x08200000, 0x11800000, 0x11800000<span>)</span>
 Metaspace       used 153K, capacity 2280K, committed 2368K, reserved 4480K

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><img src="./pictures/jvm垃圾回收/堆内存.png" alt="堆内存常见分配策略 " /></p>
<h3 id="_1-1-对象优先在-eden-区分配"> 1.1 对象优先在 eden 区分配</h3>
<p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。</p>
<p><strong>测试：</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>GCTest</span> <span>{</span>

	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>byte</span><span>[</span><span>]</span> allocation1<span>,</span> allocation2<span>;</span>
		allocation1 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>30900</span><span>*</span><span>1024</span><span>]</span><span>;</span>
		<span>//allocation2 = new byte[900*1024];</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>通过以下方式运行：
<img src="./pictures/jvm垃圾回收/25178350.png" alt="" /></p>
<p>添加的参数：<code>-XX:+PrintGCDetails</code>
<img src="./pictures/jvm垃圾回收/10317146.png" alt="" /></p>
<p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28954286.jpg" alt="" /></p>
<p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p>
<div><pre><code>allocation2 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>900</span><span>*</span><span>1024</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28128785.jpg" alt="" /></p>
<p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p>
<div><pre><code><span>public</span> <span>class</span> <span>GCTest</span> <span>{</span>

	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>byte</span><span>[</span><span>]</span> allocation1<span>,</span> allocation2<span>,</span>allocation3<span>,</span>allocation4<span>,</span>allocation5<span>;</span>
		allocation1 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>32000</span><span>*</span><span>1024</span><span>]</span><span>;</span>
		allocation2 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1000</span><span>*</span><span>1024</span><span>]</span><span>;</span>
		allocation3 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1000</span><span>*</span><span>1024</span><span>]</span><span>;</span>
		allocation4 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1000</span><span>*</span><span>1024</span><span>]</span><span>;</span>
		allocation5 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1000</span><span>*</span><span>1024</span><span>]</span><span>;</span>
	<span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_1-2-大对象直接进入老年代"> 1.2 大对象直接进入老年代</h3>
<p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>
<p><strong>为什么要这样呢？</strong></p>
<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<h3 id="_1-3-长期存活的对象将进入老年代"> 1.3 长期存活的对象将进入老年代</h3>
<p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<h3 id="_1-4-动态对象年龄判定"> 1.4 动态对象年龄判定</h3>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<blockquote>
<p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552" target="_blank" rel="noopener noreferrer">issue552</a>）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，参见 <a href="https://github.com/Snailclimb/JavaGuide/issues/1199" target="_blank" rel="noopener noreferrer">issue1199</a> ），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p>
<p>jdk8 官方文档引用 ：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210523201742303.png" alt="" /></p>
<p><strong>动态年龄计算的代码如下：</strong></p>
<div><pre><code>uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {
//survivor_capacity是survivor空间的大小
size_t desired_survivor_size = (size_t)((((double)survivor_capacity)*TargetSurvivorRatio)/100);
size_t total = 0;
uint age = 1;
while (age &lt; table_size) {
  //sizes数组是每个年龄段对象大小
  total += sizes[age];
  if (total &gt; desired_survivor_size) {
      break;
  }
  age++;
}
uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;
...
}

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>额外补充说明(<a href="https://github.com/Snailclimb/JavaGuide/issues/672" target="_blank" rel="noopener noreferrer">issue672</a>)：<strong>关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解 Java 虚拟机》这本书。</strong>
如果你去 Oracle 的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener noreferrer">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p>
<p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p>
</blockquote>
<h3 id="_1-5-主要进行-gc-的区域"> 1.5 主要进行 gc 的区域</h3>
<p>周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道：</p>
<blockquote>
<p><s><em>“老年代 GC（Major GC/Full GC），指发生在老年代的 GC……”</em></s></p>
</blockquote>
<p>上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/b48228c2-ac00-4668-a78f-6f221f8563b5.png" alt="" /></p>
<p><strong>总结：</strong></p>
<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
<h3 id="_1-6-空间分配担保"> 1.6 空间分配担保</h3>
<p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p>
<p>《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：</p>
<blockquote>
<p>JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p>
<p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p>
</blockquote>
<h2 id="_2-对象已经死亡"> 2 对象已经死亡？</h2>
<p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p>
<p><img src="./pictures/jvm垃圾回收/11034259.png" alt="" /></p>
<h3 id="_2-1-引用计数法"> 2.1 引用计数法</h3>
<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ReferenceCountingGc</span> <span>{</span>
    <span>Object</span> instance <span>=</span> <span>null</span><span>;</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>ReferenceCountingGc</span> objA <span>=</span> <span>new</span> <span>ReferenceCountingGc</span><span>(</span><span>)</span><span>;</span>
		<span>ReferenceCountingGc</span> objB <span>=</span> <span>new</span> <span>ReferenceCountingGc</span><span>(</span><span>)</span><span>;</span>
		objA<span>.</span>instance <span>=</span> objB<span>;</span>
		objB<span>.</span>instance <span>=</span> objA<span>;</span>
		objA <span>=</span> <span>null</span><span>;</span>
		objB <span>=</span> <span>null</span><span>;</span>

	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_2-2-可达性分析算法"> 2.2 可达性分析算法</h3>
<p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>
<p><img src="./pictures/jvm垃圾回收/72762049.png" alt="可达性分析算法 " /></p>
<p>可作为 GC Roots 的对象包括下面几种:</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<h3 id="_2-3-再谈引用"> 2.3 再谈引用</h3>
<p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p>
<p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p>
<p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p>
<p><strong>1．强引用（StrongReference）</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p><strong>2．软引用（SoftReference）</strong></p>
<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><strong>3．弱引用（WeakReference）</strong></p>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><strong>4．虚引用（PhantomReference）</strong></p>
<p>&quot;虚引用&quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<h3 id="_2-4-不可达的对象并非-非死不可"> 2.4 不可达的对象并非“非死不可”</h3>
<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<blockquote>
<p><code>Object</code> 类中的 <code>finalize</code> 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 <code>finalize</code> 方法会被逐渐弃用移除。忘掉它的存在吧！</p>
<p>参考：</p>
<ul>
<li><a href="https://openjdk.java.net/jeps/421" target="_blank" rel="noopener noreferrer">JEP 421: Deprecate Finalization for Removal</a></li>
<li><a href="https://mp.weixin.qq.com/s/LW-paZAMD08DP_3-XCUxmg" target="_blank" rel="noopener noreferrer">是时候忘掉 finalize 方法了</a></li>
</ul>
</blockquote>
<h3 id="_2-5-如何判断一个常量是废弃常量"> 2.5 如何判断一个常量是废弃常量？</h3>
<p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p>
<p><s><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></s></p>
<blockquote>
<p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/747" target="_blank" rel="noopener noreferrer">issue747</a>，<a href="https://blog.csdn.net/q5706503/article/details/84640762" target="_blank" rel="noopener noreferrer">reference</a>）</strong> ：</p>
<ol>
<li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li>
<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li>
<li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li>
</ol>
</blockquote>
<p>假如在字符串常量池中存在字符串 &quot;abc&quot;，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 &quot;abc&quot; 就是废弃常量，如果这时发生内存回收的话而且有必要的话，&quot;abc&quot; 就会被系统清理出常量池了。</p>
<h3 id="_2-6-如何判断一个类是无用的类"> 2.6 如何判断一个类是无用的类</h3>
<p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="_3-垃圾收集算法"> 3 垃圾收集算法</h2>
<p><img src="./pictures/jvm垃圾回收/垃圾收集算法.png" alt="垃圾收集算法分类" /></p>
<h3 id="_3-1-标记-清除算法"> 3.1 标记-清除算法</h3>
<p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li><strong>效率问题</strong></li>
<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li>
</ol>
<p><img src="./pictures/jvm垃圾回收/标记-清除算法.jpeg" alt="" /></p>
<h3 id="_3-2-标记-复制算法"> 3.2 标记-复制算法</h3>
<p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p><img src="./pictures/jvm垃圾回收/90984624.png" alt="复制算法" /></p>
<h3 id="_3-3-标记-整理算法"> 3.3 标记-整理算法</h3>
<p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="./pictures/jvm垃圾回收/94057049.png" alt="标记-整理算法 " /></p>
<h3 id="_3-4-分代收集算法"> 3.4 分代收集算法</h3>
<p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p>
<p>根据上面的对分代收集算法的介绍回答。</p>
<h2 id="_4-垃圾收集器"> 4 垃圾收集器</h2>
<p><img src="./pictures/jvm垃圾回收/垃圾收集器.png" alt="垃圾收集器分类" /></p>
<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>
<p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p>
<h3 id="_4-1-serial-收集器"> 4.1 Serial 收集器</h3>
<p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>&quot;Stop The World&quot;</strong> ），直到它收集结束。</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="./pictures/jvm垃圾回收/46873026.png" alt=" Serial 收集器 " /></p>
<p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
<p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p>
<h3 id="_4-2-parnew-收集器"> 4.2 ParNew 收集器</h3>
<p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="./pictures/jvm垃圾回收/22018368.png" alt="ParNew 收集器 " /></p>
<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<p><strong>并行和并发概念补充：</strong></p>
<ul>
<li>
<p><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p>
</li>
<li>
<p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p>
</li>
</ul>
<h3 id="_4-3-parallel-scavenge-收集器"> 4.3 Parallel Scavenge 收集器</h3>
<p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p>
<div><pre><code>-XX:+UseParallelGC

    使用 Parallel 收集器+ 老年代串行

-XX:+UseParallelOldGC

    使用 Parallel 收集器+ 老年代并行

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="./pictures/jvm垃圾回收/parllel-scavenge收集器.png" alt="Parallel Scavenge 收集器 " /></p>
<p><strong>这是 JDK1.8 默认收集器</strong></p>
<p>使用 java -XX:+PrintCommandLineFlags -version 命令查看</p>
<div><pre><code>-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC
java version &quot;1.8.0_211&quot;
Java(TM) SE Runtime Environment (build 1.8.0_211-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p>
<h3 id="_4-4-serial-old-收集器"> 4.4.Serial Old 收集器</h3>
<p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<h3 id="_4-5-parallel-old-收集器"> 4.5 Parallel Old 收集器</h3>
<p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<h3 id="_4-6-cms-收集器"> 4.6 CMS 收集器</h3>
<p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p>
<p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p><img src="./pictures/jvm垃圾回收/CMS收集器.png" alt="CMS 垃圾收集器 " /></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>
</ul>
<h3 id="_4-7-g1-收集器"> 4.7 G1 收集器</h3>
<p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ul>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<h3 id="_4-8-zgc-收集器"> 4.8 ZGC 收集器</h3>
<p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p>
<p>在 ZGC 中出现 Stop The World 的情况会更少！</p>
<p>详情可以看 ： <a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html" target="_blank" rel="noopener noreferrer">《新一代垃圾回收器 ZGC 的探索与实践》</a></p>
<h2 id="参考"> 参考</h2>
<ul>
<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li>
<li>https://my.oschina.net/hosee/blog/644618</li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>大白话带你认识JVM</title>
      <link>https://javaguide.cn/java/jvm/jvm-intro/</link>
      <guid>https://javaguide.cn/java/jvm/jvm-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">大白话带你认识JVM</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="大白话带你认识jvm"> 大白话带你认识JVM</h1>
<blockquote>
<p>来自掘金用户：<a href="https://juejin.im/user/5c2400afe51d45451758aa96" target="_blank" rel="noopener noreferrer">说出你的愿望吧丷</a>投稿，原文地址：https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28</p>
</blockquote>
<h2 id="前言"> 前言</h2>
<p>如果在文中用词或者理解方面出现问题，欢迎指出。此文旨在提及而不深究，但会尽量效率地把知识点都抛出来</p>
<h2 id="一、jvm的基本介绍"> 一、JVM的基本介绍</h2>
<p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···</p>
<p>好，其实抛开这么专业的句子不说，就知道JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/d947f91e44c44c6c80222b49c2dee859-new-image19a36451-d673-486e-9c8e-3c7d8ab66929.png" alt="" /></p>
<h3 id="_1-1-java文件是如何被运行的"> 1.1 Java文件是如何被运行的</h3>
<p>比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。</p>
<p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong></p>
<h4 id="_1-类加载器"> ① 类加载器</h4>
<p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进JVM里面来。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/81f1813f371c40ffa1c1f6d78bc49ed9-new-image28314ec8-066f-451e-8373-4517917d6bf7.png" alt="" /></p>
<h4 id="_2-方法区"> ② 方法区</h4>
<p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等</p>
<p>类加载器将 .class 文件搬过来就是先丢到这一块上</p>
<h4 id="_3-堆"> ③ 堆</h4>
<p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的</p>
<h4 id="_4-栈"> ④ 栈</h4>
<p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p>
<p>我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用C来进行工作的，和Java没有太大的关系。</p>
<h4 id="_5-程序计数器"> ⑤ 程序计数器</h4>
<p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/897863ee5ecb4d92b9119d065f468262-new-imagef7287f0b-c9f0-4f22-9eb4-6968bbaa5a82.png" alt="" /></p>
<h4 id="小总结"> 小总结</h4>
<ol>
<li>Java文件经过编译后变成 .class 字节码文件</li>
<li>字节码文件通过类加载器被搬运到 JVM 虚拟机中</li>
<li>虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行</li>
</ol>
<h3 id="_1-2-简单的代码例子"> 1.2 简单的代码例子</h3>
<p>一个简单的学生类</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/29046a721c2548e0a0680ec5baf4ea95-new-imageb0b42e5e-8e25-409e-b7b9-6586a39a0b8d.png" alt="" /></p>
<p>一个main方法</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/a3d34d33eab74f6f8743ecf62807445c-new-image08506a9e-5101-4f30-b0bc-3abbcb8f1894.png" alt="" /></p>
<p>执行main方法的步骤如下:</p>
<ol>
<li>编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</li>
<li>JVM 找到 App 的主程序入口，执行main方法</li>
<li>这个main中的第一条语句为 Student student = new Student(&quot;tellUrDream&quot;) ，就是让 JVM 创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li>
<li>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</li>
<li>执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li>
<li>执行sayName()</li>
</ol>
<p>其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。</p>
<h2 id="二、类加载器的介绍"> 二、类加载器的介绍</h2>
<p>之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由 Execution Engine 来决定</p>
<h3 id="_2-1-类加载器的流程"> 2.1 类加载器的流程</h3>
<p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p>
<h4 id="_2-1-1-加载"> 2.1.1 加载</h4>
<ol>
<li>将class文件加载到内存</li>
<li>将静态数据结构转化成方法区中运行时的数据结构</li>
<li>在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口</li>
</ol>
<h4 id="_2-1-2-链接"> 2.1.2 链接</h4>
<ol>
<li>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li>
<li>准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</li>
<li>解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li>
</ol>
<h4 id="_2-1-3-初始化"> 2.1.3 初始化</h4>
<p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的0变成了显式初始化的3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p>
<blockquote>
<p>注意：字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，类构造器方法<code>&lt;clinit&gt;()</code>不同于类的构造器，这些方法都是字节码文件中只能给JVM识别的特殊方法。</p>
</blockquote>
<h4 id="_2-1-4-卸载"> 2.1.4 卸载</h4>
<p>GC将无用对象从内存中卸载</p>
<h3 id="_2-2-类加载器的加载顺序"> 2.2 类加载器的加载顺序</h3>
<p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p>
<ol>
<li>BootStrap ClassLoader：rt.jar</li>
<li>Extension ClassLoader: 加载扩展的jar包</li>
<li>App ClassLoader：指定的classpath下面的jar包</li>
<li>Custom ClassLoader：自定义的类加载器</li>
</ol>
<h3 id="_2-3-双亲委派机制"> 2.3 双亲委派机制</h3>
<p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class）时，子类加载器才会自行尝试加载。</p>
<p>这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p>
<p>其实这个也是一个隔离的作用，避免了我们的代码影响了 JDK 的代码，比如我现在自己定义一个 <code>java.lang.String</code> ：</p>
<div><pre><code><span>package</span> <span>java<span>.</span>lang</span><span>;</span>
<span>public</span> <span>class</span> <span>String</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>尝试运行当前类的 <code>main</code> 函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了 rt.jar 中的<code>java.lang.String</code>，然而发现这个里面并没有 <code>main</code> 方法。</p>
<h2 id="三、运行时数据区"> 三、运行时数据区</h2>
<h3 id="_3-1-本地方法栈和程序计数器"> 3.1 本地方法栈和程序计数器</h3>
<p>比如说我们现在点开Thread类的源码，会看到它的start0方法带有一个native关键字修饰，而且不存在方法体，这种用native修饰的方法就是本地方法，这是使用C来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。</p>
<p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p>
<p>如果执行的是native方法，那这个指针就不工作了。</p>
<h3 id="_3-2-方法区"> 3.2 方法区</h3>
<p>方法区主要的作用是存放类的元数据信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。</p>
<h3 id="_3-3-虚拟机栈和虚拟机堆"> 3.3 虚拟机栈和虚拟机堆</h3>
<p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p>
<h4 id="_3-3-1-虚拟机栈的概念"> 3.3.1 虚拟机栈的概念</h4>
<p>它是Java方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈</p>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span><span>{</span>
    <span>int</span> a <span>=</span> <span>1</span><span>;</span>
    
    <span>public</span> <span>void</span> <span>doSomething</span><span>(</span><span>)</span><span>{</span>
        <span>int</span> b <span>=</span> <span>2</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="_3-3-2-虚拟机栈存在的异常"> 3.3.2 虚拟机栈存在的异常</h4>
<p>如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <strong>OutOfMemoryError</strong>。</p>
<h4 id="_3-3-3-虚拟机栈的生命周期"> 3.3.3 虚拟机栈的生命周期</h4>
<p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p>
<p>这里补充一句：8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p>
<h4 id="_3-3-4-虚拟机栈的执行"> 3.3.4 虚拟机栈的执行</h4>
<p>我们经常说的栈帧数据，说白了在JVM中叫栈帧，放到Java中其实就是方法，它也是存放在栈中的。</p>
<p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法a，就会对应产生一个栈帧A1，然后A1会被压入栈中。同理方法b会有一个B1，方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1,A1。它是一个先进后出，后进先出原则。</p>
<h4 id="_3-3-5-局部变量的复用"> 3.3.5 局部变量的复用</h4>
<p>局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以Slot为最小单位，一个slot可以存放32位以内的数据类型。</p>
<p>虚拟机通过索引定位的方式使用局部变量表，范围为[0,局部变量表的slot的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些slot是可以复用的，当方法执行位置超过了某个变量，那么这个变量的slot可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。</p>
<h4 id="_3-3-6-虚拟机堆的概念"> 3.3.6 虚拟机堆的概念</h4>
<p>JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整</p>
<p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给GC算法进行回收。非堆内存其实我们已经说过了，就是方法区。在1.8中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是metaSpace是不存在于JVM中的，它使用的是本地内存。并有两个参数</p>
<div><pre><code>MetaspaceSize：初始化元空间大小，控制发生GC
MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。
</code></pre>
</div><p>移除的原因可以大致了解一下：融合HotSpot JVM和JRockit VM而做出的改变，因为JRockit是没有永久代的，不过这也间接性地解决了永久代的OOM问题。</p>
<h4 id="_3-3-7-eden年轻代的介绍"> 3.3.7 Eden年轻代的介绍</h4>
<p>当我们new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作TLAB，有兴趣可以了解一下。</p>
<p>当Eden空间满了之后，会触发一个叫做Minor GC（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 Minor GC，就会将存活对象移动到Survivor1区，此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。经过多次的 Minor GC后仍然存活的对象（<strong>这里的存活判断是15次，对应到虚拟机参数为 -XX:MaxTenuringThreshold 。为什么是15，因为HotSpot会在对象投中的标记字段里记录年龄，分配到的空间仅有4位，所以最多只能记录到15</strong>）会移动到老年代。老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，期间会停止所有线程等待GC的完成。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。</p>
<p>而且当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xmx来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/c02ecba3c33f43429a765987b928e423-new-image93b46f3d-33f9-46f9-a825-ec7129b004f6.png" alt="" /></p>
<p>补充说明：关于-XX:TargetSurvivorRatio参数的问题。其实也不一定是要满足-XX:MaxTenuringThreshold才移动到老年代。可以举个例子：如对象年龄5的占30%，年龄6的占36%，年龄7的占34%，加入某个年龄段（如例子中的年龄6）后，总占用超过Survivor空间*TargetSurvivorRatio的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即例子中的年龄6对象，就是年龄6和年龄7晋升到老年代），这时候无需等到MaxTenuringThreshold中要求的15</p>
<h4 id="_3-3-8-如何判断一个对象需要被干掉"> 3.3.8 如何判断一个对象需要被干掉</h4>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/1c1d85b5fb8b47239af2a5c0436eb2d7-new-image0cd10827-2f96-433c-9b16-93d4fe491d88.png" alt="" /></p>
<p>图中程序计数器、虚拟机栈、本地方法栈，3个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而Java堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p>
<p>在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法</p>
<p>1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。</p>
<p>2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如Java，C#等都是靠这招去判定对象是否存活的。</p>
<p>（了解一下即可）在Java语言汇总能作为GC Roots的对象分为以下几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）</li>
<li>方法区中静态变量所引用的对象（静态变量）</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈（即native修饰的方法）中JNI引用的对象（JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</li>
<li>已启动的且未终止的Java线程</li>
</ol>
<p>这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p>
<h4 id="_3-3-9-如何宣告一个对象的真正死亡"> 3.3.9 如何宣告一个对象的真正死亡</h4>
<p>首先必须要提到的是一个名叫 <strong>finalize()</strong> 的方法</p>
<p>finalize()是Object类的一个方法、一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用。</p>
<p>补充一句：并不提倡在程序中调用finalize()来进行自救。建议忘掉Java程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在Java9中已经被标记为 <strong>deprecated</strong> ，且 <code>java.lang.ref.Cleaner</code>（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比 <code>finalize</code> 来的更加的轻量及可靠。
　　
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/c807dab33f8b42329c1910d609e7ed21-new-image565aeab2-6d3e-4c2c-80f6-7a7b0f629fda.png" alt="" /></p>
<p>判断一个对象的死亡至少需要两次标记</p>
<ol>
<li>如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。</li>
<li>GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li>
</ol>
<p>如果确定对象已经死亡，我们又该如何回收这些垃圾呢</p>
<h3 id="_3-4-垃圾回收算法"> 3.4 垃圾回收算法</h3>
<p>不会非常详细的展开，常用的有标记清除，复制，标记整理和分代收集算法</p>
<h4 id="_3-4-1-标记清除算法"> 3.4.1 标记清除算法</h4>
<p>标记清除算法就是分为“标记”和“清除”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础来加以改进的。</p>
<p>其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。</p>
<p>不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/01605d96d85f4daab9bfa5e7000f0d31-new-image78e03b85-fbef-4df9-b41e-2b63d78d119f.png" alt="" /></p>
<p>此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题</p>
<h4 id="_3-4-2-复制算法"> 3.4.2 复制算法</h4>
<p>为了解决效率问题，复制算法就出现了。它将可用内存按容量划分成两等分，每次只使用其中的一块。和survivor一样也是用from和to两个指针这样的玩法。fromPlace存满了，就把存活的对象copy到另一块toPlace上，然后交换指针的内容。这样就解决了碎片的问题。</p>
<p>这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分低下了</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/fc349fbb9b204495a5321febe27818d4-new-image45920a9a-552c-4656-94d6-e3ca45ff9b76.png" alt="" /></p>
<p>不过它们分配的时候也不是按照1:1这样进行分配的，就类似于Eden和Survivor也不是等价分配是一个道理。</p>
<h4 id="_3-4-3-标记整理算法"> 3.4.3 标记整理算法</h4>
<p>复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/2599e9f722074d34a3f7fd9f0076f121-new-imagec76192ec-b63a-43e3-a6d6-cf01f749953f.png" alt="" /></p>
<h4 id="_3-4-4-分代收集算法"> 3.4.4 分代收集算法</h4>
<p>这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>
<p>说白了就是八仙过海各显神通，具体问题具体分析了而已。</p>
<h3 id="_3-5-了解-各种各样的垃圾回收器"> 3.5 （了解）各种各样的垃圾回收器</h3>
<p>HotSpot VM中的垃圾回收器，以及适用场景</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/11e9dcd0f1ee4f25836e6f1c47104c51-new-image69e1c56a-1d40-493a-9901-6efc647a01f3.png" alt="" /></p>
<p>到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old</p>
<p>从jdk9开始，G1收集器成为默认的垃圾收集器
目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge 回收新生代停顿长达1.5秒。G1回收器回收同样大小的新生代只停顿0.2秒。</p>
<h3 id="_3-6-了解-jvm的常用参数"> 3.6 （了解）JVM的常用参数</h3>
<p>JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>含义</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms</td>
<td>初始堆大小</td>
<td>物理内存的1/64(&lt;1GB)</td>
<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
<td>物理内存的1/4(&lt;1GB)</td>
<td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td>
</tr>
<tr>
<td>-Xmn</td>
<td>年轻代大小(1.4or lator)</td>
<td></td>
<td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>设置年轻代大小(for 1.3/1.4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:MaxNewSize</td>
<td>年轻代最大值(for 1.3/1.4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>设置持久代(perm gen)初始值</td>
<td>物理内存的1/64</td>
<td></td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>设置持久代最大值</td>
<td>物理内存的1/4</td>
<td></td>
</tr>
<tr>
<td>-Xss</td>
<td>每个线程的堆栈大小</td>
<td></td>
<td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>
<td></td>
<td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>Eden区与Survivor区的大小比值</td>
<td></td>
<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>
</tr>
<tr>
<td>-XX:+DisableExplicitGC</td>
<td>关闭System.gc()</td>
<td></td>
<td>这个参数需要严格的测试</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>对象超过多大是直接在旧生代分配</td>
<td>0</td>
<td>单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>并行收集器的线程数</td>
<td></td>
<td>此值最好配置与处理器数目相等 同样适用于CMS</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td>
<td></td>
<td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td>
</tr>
</tbody>
</table>
<p>其实还有一些打印及CMS方面的参数，这里就不以一一列举了</p>
<h2 id="四、关于jvm调优的一些方面"> 四、关于JVM调优的一些方面</h2>
<p>根据刚刚涉及的jvm的知识点，我们可以尝试对JVM进行调优，主要就是堆内存那块</p>
<p>所有线程共享数据区大小=新生代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m。所以java堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用fullgc，所以老年代过小的话反而是会增多fullgc的）。此值对系统性能影响较大，Sun官方推荐配置为java堆的3/8。</p>
<h3 id="_4-1-调整最大堆内存和最小堆内存"> 4.1 调整最大堆内存和最小堆内存</h3>
<p>-Xmx –Xms：指定java堆最大值（默认值是物理内存的1/4(&lt;1GB)）和初始java堆最小值（默认值是物理内存的1/64(&lt;1GB))</p>
<p>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于40%了，JVM就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于70%，又会动态缩小不过不会小于–Xms。就这么简单</p>
<p>开发过程中，通常会将 -Xms 与 -Xmx两个参数配置成相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p>
<p>我们执行下面的代码</p>
<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Xmx="</span> <span>+</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>maxMemory</span><span>(</span><span>)</span> <span>/</span> <span>1024.0</span> <span>/</span> <span>1024</span> <span>+</span> <span>"M"</span><span>)</span><span>;</span>    <span>//系统的最大空间</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"free mem="</span> <span>+</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>freeMemory</span><span>(</span><span>)</span> <span>/</span> <span>1024.0</span> <span>/</span> <span>1024</span> <span>+</span> <span>"M"</span><span>)</span><span>;</span>  <span>//系统的空闲空间</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"total mem="</span> <span>+</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>totalMemory</span><span>(</span><span>)</span> <span>/</span> <span>1024.0</span> <span>/</span> <span>1024</span> <span>+</span> <span>"M"</span><span>)</span><span>;</span>  <span>//当前可用的总空间</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意：此处设置的是Java堆大小，也就是新生代大小 + 老年代大小</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/5e7b352c16d74c789c665af46d3a2509-new-imagedd645dae-307d-4572-b6e2-b5a9925a46cd.png" alt="" /></p>
<p>设置一个VM options的参数</p>
<div><pre><code>-Xmx20m -Xms5m -XX:+PrintGCDetails
</code></pre>
</div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/fe99e355f4754fa4be7427cb65261f3d-new-imagebb5cf485-99f8-43eb-8809-2a89e6a1768e.png" alt="" /></p>
<p>再次启动main方法</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/300539f6560043dd8a3fe085d28420e6-new-image3c581a2e-196f-4b01-90f1-c27731b4610b.png" alt="" /></p>
<p>这里GC弹出了一个Allocation Failure分配失败，这个事情发生在PSYoungGen，也就是年轻代中</p>
<p>这时候申请到的内存为18M，空闲内存为4.214195251464844M</p>
<p>我们此时创建一个字节数组看看，执行下面的代码</p>
<div><pre><code><span>byte</span><span>[</span><span>]</span> b <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1</span> <span>*</span> <span>1024</span> <span>*</span> <span>1024</span><span>]</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"分配了1M空间给数组"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Xmx="</span> <span>+</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>maxMemory</span><span>(</span><span>)</span> <span>/</span> <span>1024.0</span> <span>/</span> <span>1024</span> <span>+</span> <span>"M"</span><span>)</span><span>;</span>  <span>//系统的最大空间</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"free mem="</span> <span>+</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>freeMemory</span><span>(</span><span>)</span> <span>/</span> <span>1024.0</span> <span>/</span> <span>1024</span> <span>+</span> <span>"M"</span><span>)</span><span>;</span>  <span>//系统的空闲空间</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"total mem="</span> <span>+</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>totalMemory</span><span>(</span><span>)</span> <span>/</span> <span>1024.0</span> <span>/</span> <span>1024</span> <span>+</span> <span>"M"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/bdd717d0a3394be7a733760052773374-new-image371b5d59-0020-4091-9874-603c0ab0073d.png" alt="" /></p>
<p>此时free memory就又缩水了，不过total memory是没有变化的。Java会尽可能将total mem的值维持在最小堆内存大小</p>
<div><pre><code>byte[] b = new byte[10 * 1024 * 1024];
System.out.println(&quot;分配了10M空间给数组&quot;);
System.out.println(&quot;Xmx=&quot; + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的最大空间
System.out.println(&quot;free mem=&quot; + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的空闲空间
System.out.println(&quot;total mem=&quot; + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + &quot;M&quot;);  //当前可用的总空间
</code></pre>
</div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/0fd7550ae2144adca8ed2ede12d5fb96-new-image0c31ff20-289d-4088-8c67-a846d0c5d1e0.png" alt="" /></p>
<p>这时候我们创建了一个10M的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的total memory已经变成了15M，这就是已经申请了一次内存的结果。</p>
<p>此时我们再跑一下这个代码</p>
<div><pre><code><span>System</span><span>.</span><span>gc</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Xmx="</span> <span>+</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>maxMemory</span><span>(</span><span>)</span> <span>/</span> <span>1024.0</span> <span>/</span> <span>1024</span> <span>+</span> <span>"M"</span><span>)</span><span>;</span>    <span>//系统的最大空间</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"free mem="</span> <span>+</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>freeMemory</span><span>(</span><span>)</span> <span>/</span> <span>1024.0</span> <span>/</span> <span>1024</span> <span>+</span> <span>"M"</span><span>)</span><span>;</span>  <span>//系统的空闲空间</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"total mem="</span> <span>+</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>totalMemory</span><span>(</span><span>)</span> <span>/</span> <span>1024.0</span> <span>/</span> <span>1024</span> <span>+</span> <span>"M"</span><span>)</span><span>;</span>  <span>//当前可用的总空间</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/4cc44b5d5d1c40c48640ece6a296b1ac-new-image4b57baf6-085b-4150-9c60-ac51b0f815d7.png" alt="" /></p>
<p>此时我们手动执行了一次fullgc，此时total memory的内存空间又变回5.5M了，此时又是把申请的内存释放掉的结果。</p>
<h3 id="_4-2-调整新生代和老年代的比值"> 4.2 调整新生代和老年代的比值</h3>
<p>-XX:NewRatio --- 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p>
<p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</p>
<h3 id="_4-3-调整survivor区和eden区的比值"> 4.3 调整Survivor区和Eden区的比值</h3>
<p>-XX:SurvivorRatio（幸存代）--- 设置两个Survivor区和eden的比值</p>
<p>例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10</p>
<h3 id="_4-4-设置年轻代和老年代的大小"> 4.4 设置年轻代和老年代的大小</h3>
<p>-XX:NewSize --- 设置年轻代大小</p>
<p>-XX:MaxNewSize --- 设置年轻代最大值</p>
<p>可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的Eden和Survivor的占比为8:1:1，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的gc，需要注意。</p>
<h3 id="_4-5-小总结"> 4.5 小总结</h3>
<p>根据实际事情调整新生代和幸存代的大小，官方推荐新生代占java堆的3/8，幸存代占新生代的1/10</p>
<p>在OOM时，记得Dump出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump文件，这个文件可以使用VisualVM或者Java自带的Java VisualVM工具。</p>
<div><pre><code>-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径
</code></pre>
</div><p>一般我们也可以通过编写脚本的方式来让OOM出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。</p>
<h3 id="_4-6-永久区的设置"> 4.6 永久区的设置</h3>
<div><pre><code>-XX:PermSize -XX:MaxPermSize
</code></pre>
</div><p>初始空间（默认为物理内存的1/64）和最大空间（默认为物理内存的1/4）。也就是说，jvm启动时，永久区一开始就占用了PermSize大小的空间，如果空间还不够，可以继续扩展，但是不能超过MaxPermSize，否则会OOM。</p>
<p>tips：如果堆空间没有用完也抛出了OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出OOM。</p>
<h3 id="_4-7-jvm的栈参数调优"> 4.7 JVM的栈参数调优</h3>
<h4 id="_4-7-1-调整每个线程栈空间的大小"> 4.7.1 调整每个线程栈空间的大小</h4>
<p>可以通过-Xss：调整每个线程栈空间的大小</p>
<p>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右</p>
<h4 id="_4-7-2-设置线程栈的大小"> 4.7.2 设置线程栈的大小</h4>
<div><pre><code>-XXThreadStackSize：
    设置线程栈的大小(0 means use default stack size)
</code></pre>
</div><p>这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供demo了</p>
<h3 id="_4-8-可以直接跳过了-jvm其他参数介绍"> 4.8 (可以直接跳过了)JVM其他参数介绍</h3>
<p>形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。</p>
<h4 id="_4-8-1-设置内存页的大小"> 4.8.1 设置内存页的大小</h4>
<div><pre><code>-XXThreadStackSize：
    设置内存页的大小，不可设置过大，会影响Perm的大小
</code></pre>
</div><h4 id="_4-8-2-设置原始类型的快速优化"> 4.8.2 设置原始类型的快速优化</h4>
<div><pre><code>-XX:+UseFastAccessorMethods：
    设置原始类型的快速优化
</code></pre>
</div><h4 id="_4-8-3-设置关闭手动gc"> 4.8.3 设置关闭手动GC</h4>
<div><pre><code>-XX:+DisableExplicitGC：
    设置关闭System.gc()(这个参数需要严格的测试)
</code></pre>
</div><h4 id="_4-8-4-设置垃圾最大年龄"> 4.8.4 设置垃圾最大年龄</h4>
<div><pre><code>-XX:MaxTenuringThreshold
    设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.
    对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,
    则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,
    增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.
</code></pre>
</div><h4 id="_4-8-5-加快编译速度"> 4.8.5 加快编译速度</h4>
<div><pre><code>-XX:+AggressiveOpts
</code></pre>
</div><p>加快编译速度</p>
<h4 id="_4-8-6-改善锁机制性能"> 4.8.6 改善锁机制性能</h4>
<div><pre><code>-XX:+UseBiasedLocking
</code></pre>
</div><h4 id="_4-8-7-禁用垃圾回收"> 4.8.7 禁用垃圾回收</h4>
<div><pre><code>-Xnoclassgc
</code></pre>
</div><h4 id="_4-8-8-设置堆空间存活时间"> 4.8.8 设置堆空间存活时间</h4>
<div><pre><code>-XX:SoftRefLRUPolicyMSPerMB
    设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。
</code></pre>
</div><h4 id="_4-8-9-设置对象直接分配在老年代"> 4.8.9 设置对象直接分配在老年代</h4>
<div><pre><code>-XX:PretenureSizeThreshold
    设置对象超过多大时直接在老年代分配，默认值是0。
</code></pre>
</div><h4 id="_4-8-10-设置tlab占eden区的比例"> 4.8.10 设置TLAB占eden区的比例</h4>
<div><pre><code>-XX:TLABWasteTargetPercent
    设置TLAB占eden区的百分比，默认值是1% 。 
</code></pre>
</div><h4 id="_4-8-11设置是否优先ygc"> 4.8.11设置是否优先YGC</h4>
<div><pre><code>-XX:+CollectGen0First
    设置FullGC时是否先YGC，默认值是false。
</code></pre>
</div><h2 id="finally"> finally</h2>
<p>真的扯了很久这东西，参考了多方的资料，有极客时间的《深入拆解虚拟机》和《Java核心技术面试精讲》，也有百度，也有自己在学习的一些线上课程的总结。希望对你有所帮助，谢谢。</p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/d947f91e44c44c6c80222b49c2dee859-new-image19a36451-d673-486e-9c8e-3c7d8ab66929.png" type="image/png"/>
    </item>
    <item>
      <title>最重要的 JVM 参数总结</title>
      <link>https://javaguide.cn/java/jvm/jvm-parameters-intro/</link>
      <guid>https://javaguide.cn/java/jvm/jvm-parameters-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">最重要的 JVM 参数总结</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="最重要的-jvm-参数总结"> 最重要的 JVM 参数总结</h1>
<p>本文由 JavaGuide 翻译自 <a href="https://www.baeldung.com/jvm-parameters" target="_blank" rel="noopener noreferrer">https://www.baeldung.com/jvm-parameters</a>，并对文章进行了大量的完善补充。翻译不易，如需转载请注明出处，作者：<a href="https://www.baeldung.com/author/baeldung/" target="_blank" rel="noopener noreferrer">baeldung</a> 。</p>
<h2 id="_1-概述"> 1.概述</h2>
<p>在本篇文章中，你将掌握最常用的 JVM 参数配置。如果对于下面提到了一些概念比如堆、</p>
<h2 id="_2-堆内存相关"> 2.堆内存相关</h2>
<blockquote>
<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
</blockquote>
<h3 id="_2-1-显式指定堆内存-xms和-xmx"> 2.1.显式指定堆内存<code>–Xms</code>和<code>-Xmx</code></h3>
<p>与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定最小和最大堆大小（推荐显示指定大小），以下参数可以帮助你实现：</p>
<div><pre><code>-Xms&lt;heap size&gt;[unit] 
-Xmx&lt;heap size&gt;[unit]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li><strong>heap size</strong> 表示要初始化内存的具体大小。</li>
<li><strong>unit</strong> 表示要初始化内存的单位。单位为***“ g”*** (GB) 、***“ m”***（MB）、***“ k”***（KB）。</li>
</ul>
<p>举个栗子🌰，如果我们要为JVM分配最小2 GB和最大5 GB的堆内存大小，我们的参数应该这样来写：</p>
<div><pre><code>-Xms2G -Xmx5G
</code></pre>
<div><span>1</span><br></div></div><h3 id="_2-2-显式新生代内存-young-generation"> 2.2.显式新生代内存(Young Generation)</h3>
<p>根据<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" target="_blank" rel="noopener noreferrer">Oracle官方文档</a>，在堆总可用内存配置完成之后，第二大影响因素是为 <code>Young Generation</code> 在堆内存所占的比例。默认情况下，YG 的最小大小为 1310 <em>MB</em>，最大大小为<em>无限制</em>。</p>
<p>一共有两种指定 新生代内存(Young Ceneration)大小的方法：</p>
<p><strong>1.通过<code>-XX:NewSize</code>和<code>-XX:MaxNewSize</code>指定</strong></p>
<div><pre><code>-XX:NewSize=&lt;young size&gt;[unit] 
-XX:MaxNewSize=&lt;young size&gt;[unit]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>举个栗子🌰，如果我们要为 新生代分配 最小256m 的内存，最大 1024m的内存我们的参数应该这样来写：</p>
<div><pre><code>-XX:NewSize=256m
-XX:MaxNewSize=1024m
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>2.通过<code>-Xmn&lt;young size&gt;[unit]</code>指定</strong></p>
<p>举个栗子🌰，如果我们要为 新生代分配256m的内存（NewSize与MaxNewSize设为一致），我们的参数应该这样来写：</p>
<div><pre><code>-Xmn256m 
</code></pre>
<div><span>1</span><br></div></div><p>GC 调优策略中很重要的一条经验总结是这样说的：</p>
<blockquote>
<p>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p>
</blockquote>
<p>另外，你还可以通过**<code>-XX:NewRatio=&lt;int&gt;</code>**来设置新生代和老年代内存的比值。</p>
<p>比如下面的参数就是设置新生代（包括Eden和两个Survivor区）与老年代的比值为1。也就是说：新生代与老年代所占比值为1：1，新生代占整个堆栈的 1/2。</p>
<div><pre><code>-XX:NewRatio=1
</code></pre>
<div><span>1</span><br></div></div><h3 id="_2-3-显式指定永久代-元空间的大小"> 2.3.显式指定永久代/元空间的大小</h3>
<p><strong>从Java 8开始，如果我们没有指定 Metaspace 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。</strong></p>
<p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>
<div><pre><code><span>-</span>XX<span>:</span><span>PermSize</span><span>=</span><span>N</span> <span>//方法区 (永久代) 初始大小</span>
<span>-</span>XX<span>:</span><span>MaxPermSize</span><span>=</span><span>N</span> <span>//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<p><strong>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。</strong></p>
<p>下面是一些常用参数：</p>
<div><pre><code><span>-</span>XX<span>:</span><span>MetaspaceSize</span><span>=</span><span>N</span> <span>//设置 Metaspace 的初始（和最小大小）</span>
<span>-</span>XX<span>:</span><span>MaxMetaspaceSize</span><span>=</span><span>N</span> <span>//设置 Metaspace 的最大大小，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="_3-垃圾收集相关"> 3.垃圾收集相关</h2>
<h3 id="_3-1-垃圾回收器"> 3.1.垃圾回收器</h3>
<p>为了提高应用程序的稳定性，选择正确的<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener noreferrer">垃圾收集</a>算法至关重要。</p>
<p>JVM具有四种类型的<em>GC</em>实现：</p>
<ul>
<li>串行垃圾收集器</li>
<li>并行垃圾收集器</li>
<li>CMS垃圾收集器</li>
<li>G1垃圾收集器</li>
</ul>
<p>可以使用以下参数声明这些实现：</p>
<div><pre><code>-XX:+UseSerialGC
-XX:+UseParallelGC
-XX:+UseParNewGC
-XX:+UseG1GC
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>有关<em>垃圾回收</em>实施的更多详细信息，请参见<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md" target="_blank" rel="noopener noreferrer">此处</a>。</p>
<h3 id="_3-2-gc记录"> 3.2.GC记录</h3>
<p>为了严格监控应用程序的运行状况，我们应该始终检查JVM的<em>垃圾回收</em>性能。最简单的方法是以人类可读的格式记录<em>GC</em>活动。</p>
<p>使用以下参数，我们可以记录<em>GC</em>活动：</p>
<div><pre><code>-XX:+UseGCLogFileRotation 
-XX:NumberOfGCLogFiles=&lt; number of log files &gt; 
-XX:GCLogFileSize=&lt; file size &gt;[ unit ]
-Xloggc:/path/to/gc.log
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="推荐阅读"> 推荐阅读</h2>
<ul>
<li><a href="https://www.jianshu.com/p/832fc4d4cb53" target="_blank" rel="noopener noreferrer">CMS GC 默认新生代是多大？</a></li>
<li><a href="https://www.cnblogs.com/hongdada/p/10277782.html" target="_blank" rel="noopener noreferrer">CMS GC启动参数优化配置</a></li>
<li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener noreferrer">从实际案例聊聊Java应用的GC优化-美团技术团队</a></li>
<li><a href="https://www.choupangxia.com/2019/11/11/interview-jvm-gc-08/" target="_blank" rel="noopener noreferrer">JVM性能调优详解</a> （2019-11-11）</li>
<li><a href="https://segmentfault.com/a/1190000010603813" target="_blank" rel="noopener noreferrer">JVM参数使用手册</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 内存区域详解</title>
      <link>https://javaguide.cn/java/jvm/memory-area/</link>
      <guid>https://javaguide.cn/java/jvm/memory-area/</guid>
      <source url="https://javaguide.cn/rss.xml">Java 内存区域详解</source>
      <category>Java</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="java-内存区域详解"> Java 内存区域详解</h1>
<p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p>
<h2 id="写在前面-常见面试题"> 写在前面 (常见面试题)</h2>
<h3 id="基本问题"> 基本问题</h3>
<ul>
<li><strong>介绍下 Java 内存区域（运行时数据区）</strong></li>
<li><strong>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</strong></li>
<li><strong>对象的访问定位的两种方式（句柄和直接指针两种方式）</strong></li>
</ul>
<h3 id="拓展问题"> 拓展问题</h3>
<ul>
<li><strong>String 类和常量池</strong></li>
<li><strong>8 种基本类型的包装类和常量池</strong></li>
</ul>
<h2 id="一-概述"> 一 概述</h2>
<p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>
<h2 id="二-运行时数据区域"> 二 运行时数据区域</h2>
<p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。</p>
<p><strong>JDK 1.8 之前：</strong></p>
<p><img src="./pictures/java内存区域/JVM运行时数据区域.png" alt="" /></p>
<p><strong>JDK 1.8 ：</strong></p>
<p><img src="./pictures/java内存区域/Java运行时数据区域JDK1.8.png" alt="" /></p>
<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存 (非运行时数据区的一部分)</li>
</ul>
<h3 id="_2-1-程序计数器"> 2.1 程序计数器</h3>
<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>
<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>
<h3 id="_2-2-java-虚拟机栈"> 2.2 Java 虚拟机栈</h3>
<p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p>
<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>
<p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<p><img src="./pictures/java内存区域/《深入理解虚拟机》第三版的第2章-虚拟机栈.png" alt="" /></p>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p><strong>扩展：那么方法/函数如何调用？</strong></p>
<p>Java 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>
<p>Java 方法有两种返回方式：</p>
<ol>
<li>return 语句。</li>
<li>抛出异常。</li>
</ol>
<p>不管哪种返回方式都会导致栈帧被弹出。</p>
<h3 id="_2-3-本地方法栈"> 2.3 本地方法栈</h3>
<p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p>
<h3 id="_2-4-堆"> 2.4 堆</h3>
<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永生代(Permanent Generation)</li>
</ol>
<p><img src="./pictures/java内存区域/JVM堆内存结构-JDK7.png" alt="JVM堆内存结构-JDK7" /></p>
<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p><img src="./pictures/java内存区域/JVM堆内存结构-jdk8.png" alt="JVM堆内存结构-JDK8" /></p>
<p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<blockquote>
<p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/552" target="_blank" rel="noopener noreferrer">issue552</a>）</strong> ：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p>
<p><strong>动态年龄计算的代码如下</strong></p>
<div><pre><code>uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {
	//survivor_capacity是survivor空间的大小
size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);
size_t total = 0;
uint age = 1;
while (age &lt; table_size) {
total += sizes[age];//sizes数组是每个年龄段对象大小
if (total &gt; desired_survivor_size) break;
age++;
}
uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;
	...
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></blockquote>
<p>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p>
<ol>
<li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值，详见：<a href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size" target="_blank" rel="noopener noreferrer">Default Java 8 max heap size</a>)</li>
<li>......</li>
</ol>
<h3 id="_2-5-方法区"> 2.5 方法区</h3>
<p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p>
<h4 id="_2-5-1-方法区和永久代的关系"> 2.5.1 方法区和永久代的关系</h4>
<blockquote>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
</blockquote>
<h4 id="_2-5-2-常用参数"> 2.5.2 常用参数</h4>
<p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>
<div><pre><code><span>-</span>XX<span>:</span><span>PermSize</span><span>=</span><span>N</span> <span>//方法区 (永久代) 初始大小</span>
<span>-</span>XX<span>:</span><span>MaxPermSize</span><span>=</span><span>N</span> <span>//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p>下面是一些常用参数：</p>
<div><pre><code><span>-</span>XX<span>:</span><span>MetaspaceSize</span><span>=</span><span>N</span> <span>//设置 Metaspace 的初始（和最小大小）</span>
<span>-</span>XX<span>:</span><span>MaxMetaspaceSize</span><span>=</span><span>N</span> <span>//设置 Metaspace 的最大大小</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>
<h4 id="_2-5-3-为什么要将永久代-permgen-替换为元空间-metaspace-呢"> 2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h4>
<p>下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5</p>
<p><img src="https://img-blog.csdnimg.cn/20210425134508117.png" alt="" /></p>
<ol>
<li>
<p>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<blockquote>
<p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
</li>
</ol>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<ol start="2">
<li>
<p>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
</li>
<li>
<p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
</li>
</ol>
<h3 id="_2-6-运行时常量池"> 2.6 运行时常量池</h3>
<p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>
<p><s><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></s></p>
<blockquote>
<p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/747" target="_blank" rel="noopener noreferrer">issue747</a>，<a href="https://blog.csdn.net/q5706503/article/details/84640762" target="_blank" rel="noopener noreferrer">reference</a>）</strong> ：</p>
<ol>
<li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li>
<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li>
<li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li>
</ol>
</blockquote>
<p>相关问题：JVM 常量池中存储的是对象还是引用呢？： https://www.zhihu.com/question/57109429/answer/151717241 by RednaxelaFX</p>
<h3 id="_2-7-直接内存"> 2.7 直接内存</h3>
<p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）<strong>与</strong>缓存区（Buffer）<strong>的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为</strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h2 id="三-hotspot-虚拟机对象探秘"> 三 HotSpot 虚拟机对象探秘</h2>
<p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>
<h3 id="_3-1-对象的创建"> 3.1 对象的创建</h3>
<p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。
<img src="./pictures/java内存区域/Java创建对象的过程.png" alt="Java创建对象的过程" /></p>
<h4 id="step1-类加载检查"> Step1:类加载检查</h4>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h4 id="step2-分配内存"> Step2:分配内存</h4>
<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;），值得注意的是，复制算法内存也是规整的</p>
<p><img src="./pictures/java内存区域/内存分配的两种方式.png" alt="内存分配的两种方式" /></p>
<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h4 id="step3-初始化零值"> Step3:初始化零值</h4>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="step4-设置对象头"> Step4:设置对象头</h4>
<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h4 id="step5-执行-init-方法"> Step5:执行 init 方法</h4>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h3 id="_3-2-对象的内存布局"> 3.2 对象的内存布局</h3>
<p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="_3-3-对象的访问定位"> 3.3 对象的访问定位</h3>
<p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p>
<ol>
<li>
<p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p>
<p><img src="./pictures/java内存区域/对象的访问定位-使用句柄.png" alt="对象的访问定位-使用句柄" /></p>
</li>
<li>
<p><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p>
</li>
</ol>
<p><img src="./pictures/java内存区域/对象的访问定位-直接指针.png" alt="对象的访问定位-直接指针" /></p>
<p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>
<h2 id="四-重点补充内容"> 四 重点补充内容</h2>
<h3 id="_4-1-字符串常量池常见问题"> 4.1 字符串常量池常见问题</h3>
<p>我们先来看一个非常常见的面试题：<strong>String 类型的变量和常量做“+”运算时发生了什么？</strong> 。</p>
<p>先来看字符串不加 <code>final</code> 关键字拼接的情况（JDK1.8）：</p>
<div><pre><code><span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
<span>String</span> str2 <span>=</span> <span>"ing"</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>//常量池中的对象</span>
<span>String</span> str4 <span>=</span> str1 <span>+</span> str2<span>;</span> <span>//在堆上创建的新的对象</span>
<span>String</span> str5 <span>=</span> <span>"string"</span><span>;</span><span>//常量池中的对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str3 <span>==</span> str4<span>)</span><span>;</span><span>//false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str3 <span>==</span> str5<span>)</span><span>;</span><span>//true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str4 <span>==</span> str5<span>)</span><span>;</span><span>//false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。</p>
</blockquote>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210817123252441.png" alt="" /></p>
<blockquote>
<p>对于基本数据类型来说，== 比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</p>
</blockquote>
<p>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。</p>
<blockquote>
<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针为字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<div><pre><code><span>String</span> aa <span>=</span> <span>"ab"</span><span>;</span> <span>// 放在常量池中</span>
<span>String</span> bb <span>=</span> <span>"ab"</span><span>;</span> <span>// 从常量池中查找</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>aa<span>==</span>bb<span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。</p>
</blockquote>
<p>并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</p>
<blockquote>
<p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210817142715396.png" alt="" /></p>
<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ol>
<li>基本数据类型(byte、boolean、short、char、int、float、long、double)以及字符串常量</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ol>
</blockquote>
<p>因此，<code>str1</code> 、 <code>str2</code> 、 <code>str3</code> 都属于字符串常量池中的对象。</p>
<p>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</p>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<div><pre><code><span>String</span> str4 <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>.</span><span>append</span><span>(</span>str1<span>)</span><span>.</span><span>append</span><span>(</span>str2<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>因此，<code>str4</code> 并不是字符串常量池中存在的对象，属于堆上的新对象。</p>
<p>我画了一个图帮助理解：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/字符串拼接-常量池.png" alt="" /></p>
<p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p>
<p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p>
<div><pre><code><span>final</span> <span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
<span>final</span> <span>String</span> str2 <span>=</span> <span>"ing"</span><span>;</span>
<span>// 下面两个表达式其实是等价的</span>
<span>String</span> c <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>// 常量池中的对象</span>
<span>String</span> d <span>=</span> str1 <span>+</span> str2<span>;</span> <span>// 常量池中的对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c <span>==</span> d<span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就想到于访问常量。</p>
<p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p>
<p>示例代码如下（<code>str2</code> 在运行时才能确定其值）：</p>
<div><pre><code><span>final</span> <span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
<span>final</span> <span>String</span> str2 <span>=</span> <span>getStr</span><span>(</span><span>)</span><span>;</span>
<span>String</span> c <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>// 常量池中的对象</span>
<span>String</span> d <span>=</span> str1 <span>+</span> str2<span>;</span> <span>// 在堆上创建的新的对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c <span>==</span> d<span>)</span><span>;</span><span>// false</span>
<span>public</span> <span>static</span> <span>String</span> <span>getStr</span><span>(</span><span>)</span> <span>{</span>
      <span>return</span> <span>"ing"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>我们再来看一个类似的问题！</strong></p>
<div><pre><code><span>String</span> str1 <span>=</span> <span>"abcd"</span><span>;</span>
<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1<span>==</span>str2<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2<span>==</span>str3<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的代码运行之后会输出什么呢？</p>
<p>答案是：</p>
<div><pre><code>false
false
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>这是为什么呢？</strong></p>
<p>我们先来看下面这种创建字符串对象的方式：</p>
<div><pre><code><span>// 从字符串常量池中拿对象</span>
<span>String</span> str1 <span>=</span> <span>"abcd"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这种情况下，jvm 会先检查字符串常量池中有没有&quot;abcd&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；</p>
<p>因此，<code>str1</code> 指向的是字符串常量池的对象。</p>
<p>我们再来看下面这种创建字符串对象的方式：</p>
<div><pre><code><span>// 直接在堆内存空间创建一个新的对象。</span>
<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>只要使用 new 的方式创建对象，便需要创建新的对象</strong> 。</p>
<p>使用 new 的方式创建对象的方式如下，可以简单概括为 3 步：</p>
<ol>
<li>在堆中创建一个字符串对象</li>
<li>检查字符串常量池中是否有和 new 的字符串值相等的字符串常量</li>
<li>如果没有的话需要在字符串常量池中也创建一个值相等的字符串常量，如果有的话，就直接返回堆中的字符串实例对象地址。</li>
</ol>
<p>因此，<code>str2</code> 和 <code>str3</code> 都是在堆中新创建的对象。</p>
<p><strong>字符串常量池比较特殊，它的主要使用方法有两种：</strong></p>
<ol>
<li>直接使用双引号声明出来的 <code>String</code> 对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的 <code>String</code> 对象，使用 <code>String</code> 提供的 <code>intern()</code> 方法也有同样的效果。<code>String.intern()</code> 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7 之前（不包含 1.7）的处理方式是在常量池中创建与此 <code>String</code> 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7 以及之后，字符串常量池被从方法区拿到了堆中，jvm 不会在常量池中创建该对象，而是将堆中这个对象的引用直接放到常量池中，减少不必要的内存开销。</li>
</ol>
<p>示例代码如下（JDK 1.8） :</p>
<div><pre><code><span>String</span> s1 <span>=</span> <span>"Javatpoint"</span><span>;</span>
<span>String</span> s2 <span>=</span> s1<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>
<span>String</span> s3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"Javatpoint"</span><span>)</span><span>;</span>
<span>String</span> s4 <span>=</span> s3<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>==</span>s2<span>)</span><span>;</span> <span>// True</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>==</span>s3<span>)</span><span>;</span> <span>// False</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>==</span>s4<span>)</span><span>;</span> <span>// True</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s2<span>==</span>s3<span>)</span><span>;</span> <span>// False</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s2<span>==</span>s4<span>)</span><span>;</span> <span>// True</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s3<span>==</span>s4<span>)</span><span>;</span> <span>// False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>总结</strong> ：</p>
<ol>
<li>对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</li>
<li>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</li>
<li>一般来说，我们要尽量避免通过 new 的方式创建字符串。使用双引号声明的 <code>String</code> 对象（ <code>String s1 = &quot;java&quot;</code> ）更利于让编译器有机会优化我们的代码，同时也更易于阅读。</li>
<li>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器程序编译期就可以确定它的值，其效果就想到于访问常量。</li>
</ol>
<h3 id="_4-2-string-s1-new-string-abc-这句话创建了几个字符串对象"> 4.2 String s1 = new String(&quot;abc&quot;);这句话创建了几个字符串对象？</h3>
<p>会创建 1 或 2 个字符串：</p>
<ul>
<li>如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。</li>
<li>如果字符串常量池中没有字符串常量“abc”，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</li>
</ul>
<p><strong>验证：</strong></p>
<div><pre><code><span>String</span> s1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abc"</span><span>)</span><span>;</span><span>// 堆内存的地址值</span>
<span>String</span> s2 <span>=</span> <span>"abc"</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s2<span>)</span><span>;</span><span>// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>.</span><span>equals</span><span>(</span>s2<span>)</span><span>)</span><span>;</span><span>// 输出 true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>结果：</strong></p>
<div><pre><code>false
true
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_4-3-8-种基本类型的包装类和常量池"> 4.3 8 种基本类型的包装类和常量池</h3>
<p>Java 基本类型的包装类的大部分都实现了常量池技术。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
<div><pre><code><span>Integer</span> i1 <span>=</span> <span>33</span><span>;</span>
<span>Integer</span> i2 <span>=</span> <span>33</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1 <span>==</span> i2<span>)</span><span>;</span><span>// 输出 true</span>
<span>Integer</span> i11 <span>=</span> <span>333</span><span>;</span>
<span>Integer</span> i22 <span>=</span> <span>333</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i11 <span>==</span> i22<span>)</span><span>;</span><span>// 输出 false</span>
<span>Double</span> i3 <span>=</span> <span>1.2</span><span>;</span>
<span>Double</span> i4 <span>=</span> <span>1.2</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i3 <span>==</span> i4<span>)</span><span>;</span><span>// 输出 false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>Integer 缓存源代码：</strong></p>
<div><pre><code><span>/**
*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。
*/</span>
<span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>i <span>>=</span> <span>IntegerCache</span><span>.</span>low <span>&amp;&amp;</span> i <span>&lt;=</span> <span>IntegerCache</span><span>.</span>high<span>)</span>
      <span>return</span> <span>IntegerCache</span><span>.</span>cache<span>[</span>i <span>+</span> <span>(</span><span>-</span><span>IntegerCache</span><span>.</span>low<span>)</span><span>]</span><span>;</span>
    <span>return</span> <span>new</span> <span>Integer</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
<span>private</span> <span>static</span> <span>class</span> <span>IntegerCache</span> <span>{</span>
    <span>static</span> <span>final</span> <span>int</span> low <span>=</span> <span>-</span><span>128</span><span>;</span>
    <span>static</span> <span>final</span> <span>int</span> high<span>;</span>
    <span>static</span> <span>final</span> <span>Integer</span> cache<span>[</span><span>]</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong><code>Character</code> 缓存源码:</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>Character</span> <span>valueOf</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>c <span>&lt;=</span> <span>127</span><span>)</span> <span>{</span> <span>// must cache</span>
      <span>return</span> <span>CharacterCache</span><span>.</span>cache<span>[</span><span>(</span><span>int</span><span>)</span>c<span>]</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>new</span> <span>Character</span><span>(</span>c<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>static</span> <span>class</span> <span>CharacterCache</span> <span>{</span>
    <span>private</span> <span>CharacterCache</span><span>(</span><span>)</span><span>{</span><span>}</span>

    <span>static</span> <span>final</span> <span>Character</span> cache<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>Character</span><span>[</span><span>127</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>static</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cache<span>.</span>length<span>;</span> i<span>++</span><span>)</span>
            cache<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Character</span><span>(</span><span>(</span><span>char</span><span>)</span>i<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong><code>Boolean</code> 缓存源码：</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>Boolean</span> <span>valueOf</span><span>(</span><span>boolean</span> b<span>)</span> <span>{</span>
    <span>return</span> <span>(</span>b <span>?</span> TRUE <span>:</span> FALSE<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<p>下面我们来看一下问题。下面的代码的输出结果是 <code>true</code> 还是 <code>flase</code> 呢？</p>
<div><pre><code><span>Integer</span> i1 <span>=</span> <span>40</span><span>;</span>
<span>Integer</span> i2 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1<span>==</span>i2<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是常量池中的对象。而<code>Integer i1 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code> 。你答对了吗？</p>
<p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/20210313164740893.png" alt="" /></p>
<p><strong>Integer 比较更丰富的一个例子:</strong></p>
<div><pre><code><span>Integer</span> i1 <span>=</span> <span>40</span><span>;</span>
<span>Integer</span> i2 <span>=</span> <span>40</span><span>;</span>
<span>Integer</span> i3 <span>=</span> <span>0</span><span>;</span>
<span>Integer</span> i4 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>
<span>Integer</span> i5 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>
<span>Integer</span> i6 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>0</span><span>)</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1 <span>==</span> i2<span>)</span><span>;</span><span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1 <span>==</span> i2 <span>+</span> i3<span>)</span><span>;</span><span>//true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1 <span>==</span> i4<span>)</span><span>;</span><span>// false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i4 <span>==</span> i5<span>)</span><span>;</span><span>// false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i4 <span>==</span> i5 <span>+</span> i6<span>)</span><span>;</span><span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>40</span> <span>==</span> i5 <span>+</span> i6<span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><code>i1</code> , <code>i2</code> , <code>i3</code> 都是常量池中的对象，<code>i4</code> , <code>i5</code> , <code>i6</code> 是堆中的对象。</p>
<p><code>i4 == i5 + i6</code> 为什么是 true 呢？因为， <code>i5</code> 和 <code>i6</code> 会进行自动拆箱操作，进行数值相加，即 <code>i4 == 40</code> 。 <code>Integer</code> 对象无法与数值进行直接比较，所以 <code>i4</code> 自动拆箱转为 int 值 40，最终这条语句转为 <code>40 == 40</code> 进行数值比较。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li>
<li>《实战 java 虚拟机》</li>
<li><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/index.html</a></li>
<li><a href="http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/" target="_blank" rel="noopener noreferrer">http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/</a></li>
<li><a href="https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou" target="_blank" rel="noopener noreferrer">https://dzone.com/articles/jvm-permgen-–-where-art-thou</a></li>
<li><a href="https://stackoverflow.com/questions/9095748/method-area-and-permgen" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/9095748/method-area-and-permgen</a></li>
<li>深入解析 String#intern<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener noreferrer">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></li>
<li>R 大（RednaxelaFX）关于常量折叠的回答：https://www.zhihu.com/question/55976094/answer/147302764</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java8新特性实战</title>
      <link>https://javaguide.cn/java/new-features/java8-common-new-features/</link>
      <guid>https://javaguide.cn/java/new-features/java8-common-new-features/</guid>
      <source url="https://javaguide.cn/rss.xml">Java8新特性实战</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="java8新特性实战"> Java8新特性实战</h1>
<blockquote>
<p>本文来自<a href="https://github.com/cowbi" target="_blank" rel="noopener noreferrer">cowbi</a>的投稿~</p>
</blockquote>
<p>Oracle 于 2014 发布了 Java8（jdk1.8），诸多原因使它成为目前市场上使用最多的 jdk 版本。虽然发布距今已将近 7 年，但很多程序员对其新特性还是不够了解，尤其是用惯了 java8 之前版本的老程序员，比如我。</p>
<p>为了不脱离队伍太远，还是有必要对这些新特性做一些总结梳理。它较 jdk.7 有很多变化或者说是优化，比如 interface 里可以有静态方法，并且可以有方法体，这一点就颠覆了之前的认知；<code>java.util.HashMap</code> 数据结构里增加了红黑树；还有众所周知的 Lambda 表达式等等。本文不能把所有的新特性都给大家一一分享，只列出比较常用的新特性给大家做详细讲解。更多相关内容请看<a href="https://www.oracle.com/java/technologies/javase/8-whats-new.html" target="_blank" rel="noopener noreferrer">官网关于 Java8 的新特性的介绍</a>。</p>
<h2 id="interface"> Interface</h2>
<p>interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。</p>
<p>为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用<code>default</code> 或 <code>static</code>修饰，这样就可以有方法体，实现类也不必重写此方法。</p>
<p>一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。</p>
<ol>
<li><code>default</code>修饰的方法，是普通实例方法，可以用<code>this</code>调用，可以被子类继承、重写。</li>
<li><code>static</code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用<code>Interface</code>调用。</li>
</ol>
<p>我们来看一个实际的例子。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>InterfaceNew</span> <span>{</span>
    <span>static</span> <span>void</span> <span>sm</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"interface提供的方式实现"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>static</span> <span>void</span> <span>sm2</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"interface提供的方式实现"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>default</span> <span>void</span> <span>def</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"interface default方法"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>default</span> <span>void</span> <span>def2</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"interface default2方法"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//须要实现类重写</span>
    <span>void</span> <span>f</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>interface</span> <span>InterfaceNew1</span> <span>{</span>
    <span>default</span> <span>void</span> <span>def</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"InterfaceNew1 default方法"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>如果有一个类既实现了 <code>InterfaceNew</code> 接口又实现了 <code>InterfaceNew1</code>接口，它们都有<code>def()</code>，并且 <code>InterfaceNew</code> 接口和 <code>InterfaceNew1</code>接口没有继承关系的话，这时就必须重写<code>def()</code>。不然的话，编译的时候就会报错。</p>
<div><pre><code><span>public</span> <span>class</span> <span>InterfaceNewImpl</span> <span>implements</span> <span>InterfaceNew</span> <span>,</span> <span>InterfaceNew1</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>InterfaceNewImpl</span> interfaceNew <span>=</span> <span>new</span> <span>InterfaceNewImpl</span><span>(</span><span>)</span><span>;</span>
        interfaceNew<span>.</span><span>def</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>def</span><span>(</span><span>)</span> <span>{</span>
        <span>InterfaceNew1</span><span>.</span><span>super</span><span>.</span><span>def</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>f</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>在 Java 8 ，接口和抽象类有什么区别的？</strong></p>
<p>很多小伙伴认为：“既然 interface 也可以有自己的方法实现，似乎和 abstract class 没多大区别了。”</p>
<p>其实它们还是有区别的</p>
<ol>
<li>
<p>interface 和 class 的区别，好像是废话，主要有：</p>
<ul>
<li>接口多实现，类单继承</li>
<li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li>
</ul>
</li>
<li>
<p>interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。</p>
</li>
</ol>
<p>开始我们也提到，interface 新增<code>default</code>和<code>static</code>修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代<code>abstract class</code>。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。</p>
<p><strong>记住接口永远和类不一样。</strong></p>
<h2 id="functional-interface-函数式接口"> functional interface 函数式接口</h2>
<p><strong>定义</strong>：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。</p>
<p>在 java 8 中专门有一个包放函数式接口<code>java.util.function</code>，该包下的所有接口都有 <code>@FunctionalInterface</code> 注解，提供函数式编程。</p>
<p>在其他包中也有函数式接口，其中一些没有<code>@FunctionalInterface</code> 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有</p>
<p><code>@FunctionalInterface</code>注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。</p>
<h2 id="lambda-表达式"> Lambda 表达式</h2>
<p>接下来谈众所周知的 Lambda 表达式。它是推动 Java 8 发布的最重要新特性。是继泛型(<code>Generics</code>)和注解(<code>Annotation</code>)以来最大的变化。</p>
<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。让 java 也能支持简单的<em>函数式编程</em>。</p>
<blockquote>
<p>Lambda 表达式是一个匿名函数，java 8 允许把函数作为参数传递进方法中。</p>
</blockquote>
<h3 id="语法格式"> 语法格式</h3>
<div><pre><code><span>(</span>parameters<span>)</span> <span>-></span> expression 或
<span>(</span>parameters<span>)</span> <span>-></span><span>{</span> statements<span>;</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="lambda-实战"> Lambda 实战</h3>
<p>我们用常用的实例来感受 Lambda 带来的便利</p>
<h4 id="替代匿名内部类"> 替代匿名内部类</h4>
<p>过去给方法传动态参数的唯一方法是使用内部类。比如</p>
<p><strong>1.<code>Runnable</code> 接口</strong></p>
<div><pre><code><span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>
            <span>@Override</span>
            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"The runable now is using!"</span><span>)</span><span>;</span>
            <span>}</span>
<span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
<span>//用lambda</span>
<span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"It's a lambda function!"</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>2.<code>Comperator</code> 接口</strong></p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> strings <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>

<span>Collections</span><span>.</span><span>sort</span><span>(</span>strings<span>,</span> <span>new</span> <span>Comparator</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span> <span>{</span>
<span>@Override</span>
<span>public</span> <span>int</span> <span>compare</span><span>(</span><span>Integer</span> o1<span>,</span> <span>Integer</span> o2<span>)</span> <span>{</span>
    <span>return</span> o1 <span>-</span> o2<span>;</span><span>}</span>
<span>}</span><span>)</span><span>;</span>

<span>//Lambda</span>
<span>Collections</span><span>.</span><span>sort</span><span>(</span>strings<span>,</span> <span>(</span><span>Integer</span> o1<span>,</span> <span>Integer</span> o2<span>)</span> <span>-></span> o1 <span>-</span> o2<span>)</span><span>;</span>
<span>//分解开</span>
<span>Comparator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> comperator <span>=</span> <span>(</span><span>Integer</span> o1<span>,</span> <span>Integer</span> o2<span>)</span> <span>-></span> o1 <span>-</span> o2<span>;</span>
<span>Collections</span><span>.</span><span>sort</span><span>(</span>strings<span>,</span> comperator<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>3.<code>Listener</code> 接口</strong></p>
<div><pre><code><span>JButton</span> button <span>=</span> <span>new</span> <span>JButton</span><span>(</span><span>)</span><span>;</span>
button<span>.</span><span>addItemListener</span><span>(</span><span>new</span> <span>ItemListener</span><span>(</span><span>)</span> <span>{</span>
<span>@Override</span>
<span>public</span> <span>void</span> <span>itemStateChanged</span><span>(</span><span>ItemEvent</span> e<span>)</span> <span>{</span>
   e<span>.</span><span>getItem</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>}</span><span>)</span><span>;</span>
<span>//lambda</span>
button<span>.</span><span>addItemListener</span><span>(</span>e <span>-></span> e<span>.</span><span>getItem</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>4.自定义接口</strong></p>
<p>上面的 3 个例子是我们在开发过程中最常见的，从中也能体会到 Lambda 带来的便捷与清爽。它只保留实际用到的代码，把无用代码全部省略。那它对接口有没有要求呢？我们发现这些匿名内部类只重写了接口的一个方法，当然也只有一个方法须要重写。这就是我们上文提到的<strong>函数式接口</strong>，也就是说只要方法的参数是函数式接口都可以用 Lambda 表达式。</p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Comparator</span><span><span>&lt;</span><span>T</span><span>></span></span><span>{</span><span>}</span>

<span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Runnable</span><span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>我们自定义一个函数式接口</p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>LambdaInterface</span> <span>{</span>
 <span>void</span> <span>f</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>//使用</span>
<span>public</span> <span>class</span> <span>LambdaClass</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>forEg</span><span>(</span><span>)</span> <span>{</span>
        <span>lambdaInterfaceDemo</span><span>(</span><span>(</span><span>)</span><span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"自定义函数式接口"</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//函数式接口参数</span>
    <span>static</span> <span>void</span> <span>lambdaInterfaceDemo</span><span>(</span><span>LambdaInterface</span> i<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="集合迭代"> 集合迭代</h4>
<div><pre><code><span>void</span> <span>lamndaFor</span><span>(</span><span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> strings <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>"1"</span><span>,</span> <span>"2"</span><span>,</span> <span>"3"</span><span>)</span><span>;</span>
        <span>//传统foreach</span>
        <span>for</span> <span>(</span><span>String</span> s <span>:</span> strings<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s<span>)</span><span>;</span>
        <span>}</span>
        <span>//Lambda foreach</span>
        strings<span>.</span><span>forEach</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s<span>)</span><span>)</span><span>;</span>
        <span>//or</span>
        strings<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
 				<span>//map</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        map<span>.</span><span>forEach</span><span>(</span><span>(</span>k<span>,</span>v<span>)</span><span>-></span><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>v<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="方法的引用"> 方法的引用</h4>
<p>Java 8 允许使用 <code>::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p>
<div><pre><code><span>public</span> <span>class</span> <span>LambdaClassSuper</span> <span>{</span>
    <span>LambdaInterface</span> <span>sf</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>LambdaClass</span> <span>extends</span> <span>LambdaClassSuper</span> <span>{</span>
    <span>public</span> <span>static</span> <span>LambdaInterface</span> <span>staticF</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>LambdaInterface</span> <span>f</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>

    <span>void</span> <span>show</span><span>(</span><span>)</span> <span>{</span>
        <span>//1.调用静态函数，返回类型必须是functional-interface</span>
        <span>LambdaInterface</span> t <span>=</span> <span>LambdaClass</span><span>::</span><span>staticF</span><span>;</span>

        <span>//2.实例方法调用</span>
        <span>LambdaClass</span> lambdaClass <span>=</span> <span>new</span> <span>LambdaClass</span><span>(</span><span>)</span><span>;</span>
        <span>LambdaInterface</span> lambdaInterface <span>=</span> lambdaClass<span>::</span><span>f</span><span>;</span>

        <span>//3.超类上的方法调用</span>
        <span>LambdaInterface</span> superf <span>=</span> <span>super</span><span>::</span><span>sf</span><span>;</span>

        <span>//4. 构造方法调用</span>
        <span>LambdaInterface</span> tt <span>=</span> <span>LambdaClassSuper</span><span>::</span><span>new</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h4 id="访问变量"> 访问变量</h4>
<div><pre><code><span>int</span> i <span>=</span> <span>0</span><span>;</span>
<span>Collections</span><span>.</span><span>sort</span><span>(</span>strings<span>,</span> <span>(</span><span>Integer</span> o1<span>,</span> <span>Integer</span> o2<span>)</span> <span>-></span> o1 <span>-</span> i<span>)</span><span>;</span>
<span>//i =3;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>lambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。</p>
<h2 id="stream"> Stream</h2>
<p>java 新增了 <code>java.util.stream</code> 包，它和之前的流大同小异。之前接触最多的是资源流，比如<code>java.io.FileInputStream</code>，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何<em>CRUD</em>。</p>
<p><code>Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p>
<p>它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p>
<h3 id="流类型"> 流类型</h3>
<ol>
<li>stream 串行流</li>
<li>parallelStream 并行流，可多线程执行</li>
</ol>
<h3 id="常用方法"> 常用方法</h3>
<p>接下来我们看<code>java.util.stream.Stream</code>常用方法</p>
<div><pre><code><span>/**
* 返回一个串行流
*/</span>
<span>default</span> <span>Stream</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>stream</span><span>(</span><span>)</span>

<span>/**
* 返回一个并行流
*/</span>
<span>default</span> <span>Stream</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>parallelStream</span><span>(</span><span>)</span>

<span>/**
* 返回T的流
*/</span>
<span>public</span> <span>static</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>Stream</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>of</span><span>(</span><span>T</span> t<span>)</span>

<span>/**
* 返回其元素是指定值的顺序流。
*/</span>
<span>public</span> <span>static</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>Stream</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>of</span><span>(</span><span>T</span><span>.</span><span>.</span><span>.</span> values<span>)</span> <span>{</span>
    <span>return</span> <span>Arrays</span><span>.</span><span>stream</span><span>(</span>values<span>)</span><span>;</span>
<span>}</span>


<span>/**
* 过滤，返回由与给定predicate匹配的该流的元素组成的流
*/</span>
<span>Stream</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>filter</span><span>(</span><span>Predicate</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> predicate<span>)</span><span>;</span>

<span>/**
* 此流的所有元素是否与提供的predicate匹配。
*/</span>
<span>boolean</span> <span>allMatch</span><span>(</span><span>Predicate</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> predicate<span>)</span>

<span>/**
* 此流任意元素是否有与提供的predicate匹配。
*/</span>
<span>boolean</span> <span>anyMatch</span><span>(</span><span>Predicate</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> predicate<span>)</span><span>;</span>

<span>/**
* 返回一个 Stream的构建器。
*/</span>
<span>public</span> <span>static</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>Builder</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>builder</span><span>(</span><span>)</span><span>;</span>

<span>/**
* 使用 Collector对此流的元素进行归纳
*/</span>
<span><span>&lt;</span><span>R</span><span>,</span> <span>A</span><span>></span></span> <span>R</span> <span>collect</span><span>(</span><span>Collector</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>A</span><span>,</span> <span>R</span><span>></span></span> collector<span>)</span><span>;</span>

<span>/**
 * 返回此流中的元素数。
*/</span>
<span>long</span> <span>count</span><span>(</span><span>)</span><span>;</span>

<span>/**
* 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。
*/</span>
<span>Stream</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>distinct</span><span>(</span><span>)</span><span>;</span>

<span>/**
 * 遍历
*/</span>
<span>void</span> <span>forEach</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> action<span>)</span><span>;</span>

<span>/**
* 用于获取指定数量的流，截短长度不能超过 maxSize 。
*/</span>
<span>Stream</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>limit</span><span>(</span><span>long</span> maxSize<span>)</span><span>;</span>

<span>/**
* 用于映射每个元素到对应的结果
*/</span>
<span><span>&lt;</span><span>R</span><span>></span></span> <span>Stream</span><span><span>&lt;</span><span>R</span><span>></span></span> <span>map</span><span>(</span><span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>extends</span> <span>R</span><span>></span></span> mapper<span>)</span><span>;</span>

<span>/**
* 根据提供的 Comparator进行排序。
*/</span>
<span>Stream</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>sorted</span><span>(</span><span>Comparator</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> comparator<span>)</span><span>;</span>

<span>/**
* 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。
*/</span>
<span>Stream</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>skip</span><span>(</span><span>long</span> n<span>)</span><span>;</span>

<span>/**
* 返回一个包含此流的元素的数组。
*/</span>
<span>Object</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>)</span><span>;</span>

<span>/**
* 使用提供的 generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。
*/</span>
<span><span>&lt;</span><span>A</span><span>></span></span> <span>A</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>IntFunction</span><span>&lt;</span><span>A</span><span>[</span><span>]</span><span>></span> generator<span>)</span><span>;</span>

<span>/**
* 合并流
*/</span>
<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Stream</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>concat</span><span>(</span><span>Stream</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>T</span><span>></span></span> a<span>,</span> <span>Stream</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>T</span><span>></span></span> b<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br></div></div><h3 id="实战"> 实战</h3>
<p>本文列出 <code>Stream</code> 具有代表性的方法之使用，更多的使用方法还是要看 Api。</p>
<div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>
  <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> strings <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>"abc"</span><span>,</span> <span>"def"</span><span>,</span> <span>"gkh"</span><span>,</span> <span>"abc"</span><span>)</span><span>;</span>
    <span>//返回符合条件的stream</span>
    <span>Stream</span><span><span>&lt;</span><span>String</span><span>></span></span> stringStream <span>=</span> strings<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>filter</span><span>(</span>s <span>-></span> <span>"abc"</span><span>.</span><span>equals</span><span>(</span>s<span>)</span><span>)</span><span>;</span>
    <span>//计算流符合条件的流的数量</span>
    <span>long</span> count <span>=</span> stringStream<span>.</span><span>count</span><span>(</span><span>)</span><span>;</span>

    <span>//forEach遍历->打印元素</span>
    strings<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>

    <span>//limit 获取到1个元素的stream</span>
    <span>Stream</span><span><span>&lt;</span><span>String</span><span>></span></span> limit <span>=</span> strings<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>limit</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>//toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环</span>
    <span>String</span><span>[</span><span>]</span> array <span>=</span> limit<span>.</span><span>toArray</span><span>(</span><span>String</span><span>[</span><span>]</span><span>::</span><span>new</span><span>)</span><span>;</span>

    <span>//map 对每个元素进行操作返回新流</span>
    <span>Stream</span><span><span>&lt;</span><span>String</span><span>></span></span> map <span>=</span> strings<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>map</span><span>(</span>s <span>-></span> s <span>+</span> <span>"22"</span><span>)</span><span>;</span>

    <span>//sorted 排序并打印</span>
    strings<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>sorted</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>

    <span>//Collectors collect 把abc放入容器中</span>
    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> collect <span>=</span> strings<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>filter</span><span>(</span>string <span>-></span> <span>"abc"</span><span>.</span><span>equals</span><span>(</span>string<span>)</span><span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>//把list转为string，各元素用，号隔开</span>
    <span>String</span> mergedString <span>=</span> strings<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>filter</span><span>(</span>string <span>-></span> <span>!</span>string<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>joining</span><span>(</span><span>","</span><span>)</span><span>)</span><span>;</span>

    <span>//对数组的统计，比如用</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> number <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>5</span><span>,</span> <span>4</span><span>)</span><span>;</span>

    <span>IntSummaryStatistics</span> statistics <span>=</span> number<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>mapToInt</span><span>(</span><span>(</span>x<span>)</span> <span>-></span> x<span>)</span><span>.</span><span>summaryStatistics</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"列表中最大的数 : "</span><span>+</span>statistics<span>.</span><span>getMax</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"列表中最小的数 : "</span><span>+</span>statistics<span>.</span><span>getMin</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"平均数 : "</span><span>+</span>statistics<span>.</span><span>getAverage</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"所有数之和 : "</span><span>+</span>statistics<span>.</span><span>getSum</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>//concat 合并流</span>
    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> strings2 <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>"xyz"</span><span>,</span> <span>"jqx"</span><span>)</span><span>;</span>
    <span>Stream</span><span>.</span><span>concat</span><span>(</span>strings2<span>.</span><span>stream</span><span>(</span><span>)</span><span>,</span>strings<span>.</span><span>stream</span><span>(</span><span>)</span><span>)</span><span>.</span><span>count</span><span>(</span><span>)</span><span>;</span>

    <span>//注意 一个Stream只能操作一次，不能断开，否则会报错。</span>
    <span>Stream</span> stream <span>=</span> strings<span>.</span><span>stream</span><span>(</span><span>)</span><span>;</span>
    <span>//第一次使用</span>
    stream<span>.</span><span>limit</span><span>(</span><span>2</span><span>)</span><span>;</span>
    <span>//第二次使用</span>
    stream<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
    <span>//报错 java.lang.IllegalStateException: stream has already been operated upon or closed</span>

    <span>//但是可以这样, 连续使用</span>
    stream<span>.</span><span>limit</span><span>(</span><span>2</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h3 id="延迟执行"> 延迟执行</h3>
<p>在执行返回 <code>Stream</code> 的方法时，并不立刻执行，而是等返回一个非 <code>Stream</code> 的方法后才执行。因为拿到 <code>Stream</code> 并不能直接用，而是需要处理成一个常规类型。这里的 <code>Stream</code> 可以想象成是二进制流（2 个完全不一样的东东），拿到也看不懂。</p>
<p>我们下面分解一下 <code>filter</code> 方法。</p>
<div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>laziness</span><span>(</span><span>)</span><span>{</span>
  <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> strings <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>"abc"</span><span>,</span> <span>"def"</span><span>,</span> <span>"gkh"</span><span>,</span> <span>"abc"</span><span>)</span><span>;</span>
  <span>Stream</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stream <span>=</span> strings<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>new</span> <span>Predicate</span><span>(</span><span>)</span> <span>{</span>
      <span>@Override</span>
      <span>public</span> <span>boolean</span> <span>test</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Predicate.test 执行"</span><span>)</span><span>;</span>
        <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
      <span>}</span><span>)</span><span>;</span>

   <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"count 执行"</span><span>)</span><span>;</span>
   stream<span>.</span><span>count</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>/*-------执行结果--------*/</span>
count 执行
<span>Predicate</span><span>.</span>test 执行
<span>Predicate</span><span>.</span>test 执行
<span>Predicate</span><span>.</span>test 执行
<span>Predicate</span><span>.</span>test 执行
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>按执行顺序应该是先打印 4 次「<code>Predicate.test</code> 执行」，再打印「<code>count</code> 执行」。实际结果恰恰相反。说明 filter 中的方法并没有立刻执行，而是等调用<code>count()</code>方法后才执行。</p>
<p>上面都是串行 <code>Stream</code> 的实例。并行 <code>parallelStream</code> 在使用方法上和串行一样。主要区别是 <code>parallelStream</code> 可多线程执行，是基于 ForkJoin 框架实现的，有时间大家可以了解一下 <code>ForkJoin</code> 框架和 <code>ForkJoinPool</code>。这里可以简单的理解它是通过线程池来实现的，这样就会涉及到线程安全，线程消耗等问题。下面我们通过代码来体验一下并行流的多线程执行。</p>
<div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>parallelStreamTest</span><span>(</span><span>)</span><span>{</span>
   <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> numbers <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>5</span><span>,</span> <span>4</span><span>)</span><span>;</span>
   numbers<span>.</span><span>parallelStream</span><span>(</span><span>)</span> <span>.</span><span>forEach</span><span>(</span>num<span>-></span><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>">>"</span><span>+</span>num<span>)</span><span>)</span><span>;</span>
<span>}</span>
<span>//执行结果</span>
main<span>>></span><span>5</span>
<span>ForkJoinPool</span><span>.</span>commonPool<span>-</span>worker<span>-</span><span>2</span><span>>></span><span>4</span>
<span>ForkJoinPool</span><span>.</span>commonPool<span>-</span>worker<span>-</span><span>11</span><span>>></span><span>1</span>
<span>ForkJoinPool</span><span>.</span>commonPool<span>-</span>worker<span>-</span><span>9</span><span>>></span><span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>从结果中我们看到，for-each 用到的是多线程。</p>
<h3 id="小结"> 小结</h3>
<p>从源码和实例中我们可以总结出一些 stream 的特点</p>
<ol>
<li>通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。</li>
<li>方法参数都是函数式接口类型</li>
<li>一个 Stream 只能操作一次，操作完就关闭了，继续使用这个 stream 会报错。</li>
<li>Stream 不保存数据，不改变数据源</li>
</ol>
<h2 id="optional"> Optional</h2>
<p>在<a href="https://share.weiyun.com/ThuqEbD5" target="_blank" rel="noopener noreferrer">阿里巴巴开发手册关于 Optional 的介绍</a>中这样写到：</p>
<blockquote>
<p>防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：</p>
<p>1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。</p>
<p>反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。</p>
<p>2） 数据库的查询结果可能为 null。</p>
<p>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。</p>
<p>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。</p>
<p>5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。</p>
<p>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。</p>
<p>正例：使用 JDK8 的 Optional 类来防止 NPE 问题。</p>
</blockquote>
<p>他建议使用 <code>Optional</code> 解决 NPE（<code>java.lang.NullPointerException</code>）问题，它就是为 NPE 而生的，其中可以包含空值或非空值。下面我们通过源码逐步揭开 <code>Optional</code> 的红盖头。</p>
<p>假设有一个 <code>Zoo</code> 类，里面有个属性 <code>Dog</code>，需求要获取 <code>Dog</code> 的 <code>age</code>。</p>
<div><pre><code><span>class</span> <span>Zoo</span> <span>{</span>
   <span>private</span> <span>Dog</span> dog<span>;</span>
<span>}</span>

<span>class</span> <span>Dog</span> <span>{</span>
   <span>private</span> <span>int</span> age<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>传统解决 NPE 的办法如下：</p>
<div><pre><code><span>Zoo</span> zoo <span>=</span> <span>getZoo</span><span>(</span><span>)</span><span>;</span>
<span>if</span><span>(</span>zoo <span>!=</span> <span>null</span><span>)</span><span>{</span>
   <span>Dog</span> dog <span>=</span> zoo<span>.</span><span>getDog</span><span>(</span><span>)</span><span>;</span>
   <span>if</span><span>(</span>dog <span>!=</span> <span>null</span><span>)</span><span>{</span>
      <span>int</span> age <span>=</span> dog<span>.</span><span>getAge</span><span>(</span><span>)</span><span>;</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>age<span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>层层判断对象非空，有人说这种方式很丑陋不优雅，我并不这么认为。反而觉得很整洁，易读，易懂。你们觉得呢？</p>
<p><code>Optional</code> 是这样的实现的：</p>
<div><pre><code><span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>zoo<span>)</span><span>.</span><span>map</span><span>(</span>o <span>-></span> o<span>.</span><span>getDog</span><span>(</span><span>)</span><span>)</span><span>.</span><span>map</span><span>(</span>d <span>-></span> d<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>.</span><span>ifPresent</span><span>(</span>age <span>-></span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>age<span>)</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>是不是简洁了很多呢？</p>
<h3 id="如何创建一个-optional"> 如何创建一个 Optional</h3>
<p>上例中<code>Optional.ofNullable</code>是其中一种创建 Optional 的方式。我们先看一下它的含义和其他创建 Optional 的源码方法。</p>
<div><pre><code><span>/**
* Common instance for {@code empty()}. 全局EMPTY对象
*/</span>
<span>private</span> <span>static</span> <span>final</span> <span>Optional</span><span><span>&lt;</span><span>?</span><span>></span></span> EMPTY <span>=</span> <span>new</span> <span>Optional</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>/**
* Optional维护的值
*/</span>
<span>private</span> <span>final</span> <span>T</span> value<span>;</span>

<span>/**
* 如果value是null就返回EMPTY，否则就返回of(T)
*/</span>
<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Optional</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>ofNullable</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>
   <span>return</span> value <span>==</span> <span>null</span> <span>?</span> <span>empty</span><span>(</span><span>)</span> <span>:</span> <span>of</span><span>(</span>value<span>)</span><span>;</span>
<span>}</span>
<span>/**
* 返回 EMPTY 对象
*/</span>
<span>public</span> <span>static</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>Optional</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>empty</span><span>(</span><span>)</span> <span>{</span>
   <span>Optional</span><span><span>&lt;</span><span>T</span><span>></span></span> t <span>=</span> <span>(</span><span>Optional</span><span><span>&lt;</span><span>T</span><span>></span></span><span>)</span> EMPTY<span>;</span>
   <span>return</span> t<span>;</span>
<span>}</span>
<span>/**
* 返回Optional对象
*/</span>
<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Optional</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>of</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Optional</span><span><span>&lt;</span><span>></span></span><span>(</span>value<span>)</span><span>;</span>
<span>}</span>
<span>/**
* 私有构造方法，给value赋值
*/</span>
<span>private</span> <span>Optional</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>
  <span>this</span><span>.</span>value <span>=</span> <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>value<span>)</span><span>;</span>
<span>}</span>
<span>/**
* 所以如果of(T value) 的value是null，会抛出NullPointerException异常，这样貌似就没处理NPE问题
*/</span>
<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>requireNonNull</span><span>(</span><span>T</span> obj<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>obj <span>==</span> <span>null</span><span>)</span>
         <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> obj<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p><code>ofNullable</code> 方法和<code>of</code>方法唯一区别就是当 value 为 null 时，<code>ofNullable</code> 返回的是<code>EMPTY</code>，of 会抛出 <code>NullPointerException</code> 异常。如果需要把 <code>NullPointerException</code> 暴漏出来就用 <code>of</code>，否则就用 <code>ofNullable</code>。</p>
<h3 id="map-相关方法。"> <code>map()</code>相关方法。</h3>
<div><pre><code><span>/**
* 如果value为null，返回EMPTY，否则返回Optional封装的参数值
*/</span>
<span>public</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>Optional</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>map</span><span>(</span><span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>extends</span> <span>U</span><span>></span></span> mapper<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>mapper<span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>!</span><span>isPresent</span><span>(</span><span>)</span><span>)</span>
            <span>return</span> <span>empty</span><span>(</span><span>)</span><span>;</span>
        <span>else</span> <span>{</span>
            <span>return</span> <span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>mapper<span>.</span><span>apply</span><span>(</span>value<span>)</span><span>)</span><span>;</span>
        <span>}</span>
<span>}</span>
<span>/**
* 如果value为null，返回EMPTY，否则返回Optional封装的参数值，如果参数值返回null会抛 NullPointerException
*/</span>
<span>public</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>Optional</span><span><span>&lt;</span><span>U</span><span>></span></span> <span>flatMap</span><span>(</span><span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>Optional</span><span>&lt;</span><span>U</span><span>></span><span>></span></span> mapper<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>mapper<span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>!</span><span>isPresent</span><span>(</span><span>)</span><span>)</span>
            <span>return</span> <span>empty</span><span>(</span><span>)</span><span>;</span>
        <span>else</span> <span>{</span>
            <span>return</span> <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>mapper<span>.</span><span>apply</span><span>(</span>value<span>)</span><span>)</span><span>;</span>
        <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><strong><code>map()</code> 和 <code>flatMap()</code> 有什么区别的？</strong></p>
<p><strong>1.参数不一样，<code>map</code> 的参数上面看到过，<code>flatMap</code> 的参数是这样</strong></p>
<div><pre><code><span>class</span> <span>ZooFlat</span> <span>{</span>
        <span>private</span> <span>DogFlat</span> dog <span>=</span> <span>new</span> <span>DogFlat</span><span>(</span><span>)</span><span>;</span>

        <span>public</span> <span>DogFlat</span> <span>getDog</span><span>(</span><span>)</span> <span>{</span>
            <span>return</span> dog<span>;</span>
        <span>}</span>
    <span>}</span>

<span>class</span> <span>DogFlat</span> <span>{</span>
        <span>private</span> <span>int</span> age <span>=</span> <span>1</span><span>;</span>
        <span>public</span> <span>Optional</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>age<span>)</span><span>;</span>
        <span>}</span>
<span>}</span>

<span>ZooFlat</span> zooFlat <span>=</span> <span>new</span> <span>ZooFlat</span><span>(</span><span>)</span><span>;</span>
<span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>zooFlat<span>)</span><span>.</span><span>map</span><span>(</span>o <span>-></span> o<span>.</span><span>getDog</span><span>(</span><span>)</span><span>)</span><span>.</span><span>flatMap</span><span>(</span>d <span>-></span> d<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>.</span><span>ifPresent</span><span>(</span>age <span>-></span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>age<span>)</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><strong>2.<code>flatMap()</code> 参数返回值如果是 null 会抛 <code>NullPointerException</code>，而 <code>map()</code> 返回<code>EMPTY</code>。</strong></p>
<h3 id="判断-value-是否为-null"> 判断 value 是否为 null</h3>
<div><pre><code><span>/**
* value是否为null
*/</span>
<span>public</span> <span>boolean</span> <span>isPresent</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> value <span>!=</span> <span>null</span><span>;</span>
<span>}</span>
<span>/**
* 如果value不为null执行consumer.accept
*/</span>
<span>public</span> <span>void</span> <span>ifPresent</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> consumer<span>)</span> <span>{</span>
   <span>if</span> <span>(</span>value <span>!=</span> <span>null</span><span>)</span>
    consumer<span>.</span><span>accept</span><span>(</span>value<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="获取-value"> 获取 value</h3>
<div><pre><code><span>/**
* Return the value if present, otherwise invoke {@code other} and return
* the result of that invocation.
* 如果value != null 返回value，否则返回other的执行结果
*/</span>
<span>public</span> <span>T</span> <span>orElseGet</span><span>(</span><span>Supplier</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>T</span><span>></span></span> other<span>)</span> <span>{</span>
    <span>return</span> value <span>!=</span> <span>null</span> <span>?</span> value <span>:</span> other<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>/**
* 如果value != null 返回value，否则返回T
*/</span>
<span>public</span> <span>T</span> <span>orElse</span><span>(</span><span>T</span> other<span>)</span> <span>{</span>
    <span>return</span> value <span>!=</span> <span>null</span> <span>?</span> value <span>:</span> other<span>;</span>
<span>}</span>

<span>/**
* 如果value != null 返回value，否则抛出参数返回的异常
*/</span>
<span>public</span> <span><span>&lt;</span><span>X</span> <span>extends</span> <span>Throwable</span><span>></span></span> <span>T</span> <span>orElseThrow</span><span>(</span><span>Supplier</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>X</span><span>></span></span> exceptionSupplier<span>)</span> <span>throws</span> <span>X</span> <span>{</span>
        <span>if</span> <span>(</span>value <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> value<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>throw</span> exceptionSupplier<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
<span>}</span>
<span>/**
* value为null抛出NoSuchElementException，不为空返回value。
*/</span>
<span>public</span> <span>T</span> <span>get</span><span>(</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>value <span>==</span> <span>null</span><span>)</span> <span>{</span>
      <span>throw</span> <span>new</span> <span>NoSuchElementException</span><span>(</span><span>"No value present"</span><span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> value<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h3 id="过滤值"> 过滤值</h3>
<div><pre><code><span>/**
* 1. 如果是empty返回empty
* 2. predicate.test(value)==true 返回this，否则返回empty
*/</span>
<span>public</span> <span>Optional</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>filter</span><span>(</span><span>Predicate</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> predicate<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>predicate<span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>!</span><span>isPresent</span><span>(</span><span>)</span><span>)</span>
            <span>return</span> <span>this</span><span>;</span>
        <span>else</span>
            <span>return</span> predicate<span>.</span><span>test</span><span>(</span>value<span>)</span> <span>?</span> <span>this</span> <span>:</span> <span>empty</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="小结-2"> 小结</h3>
<p>看完 <code>Optional</code> 源码，<code>Optional</code> 的方法真的非常简单，值得注意的是如果坚决不想看见 <code>NPE</code>，就不要用 <code>of()</code>、 <code>get()</code> 、<code>flatMap(..)</code>。最后再综合用一下 <code>Optional</code> 的高频方法。</p>
<div><pre><code><span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>zoo<span>)</span><span>.</span><span>map</span><span>(</span>o <span>-></span> o<span>.</span><span>getDog</span><span>(</span><span>)</span><span>)</span><span>.</span><span>map</span><span>(</span>d <span>-></span> d<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>.</span><span>filter</span><span>(</span>v<span>-></span>v<span>==</span><span>1</span><span>)</span><span>.</span><span>orElse</span><span>(</span><span>3</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="date-time-api"> Date-Time API</h2>
<p>这是对<code>java.util.Date</code>强有力的补充，解决了 Date 类的大部分痛点：</p>
<ol>
<li>非线程安全</li>
<li>时区处理麻烦</li>
<li>各种格式化、和时间计算繁琐</li>
<li>设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。</li>
</ol>
<p>我们从常用的时间实例来对比 java.util.Date 和新 Date 有什么区别。用<code>java.util.Date</code>的代码该改改了。</p>
<h3 id="java-time-主要类"> java.time 主要类</h3>
<p><code>java.util.Date</code> 既包含日期又包含时间，而  <code>java.time</code> 把它们进行了分离</p>
<div><pre><code><span>LocalDateTime</span><span>.</span><span>class</span> <span>//日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS</span>
<span>LocalDate</span><span>.</span><span>class</span> <span>//日期 format: yyyy-MM-dd</span>
<span>LocalTime</span><span>.</span><span>class</span> <span>//时间 format: HH:mm:ss</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="格式化"> 格式化</h3>
<p><strong>Java 8 之前:</strong></p>
<div><pre><code><span>public</span> <span>void</span> <span>oldFormat</span><span>(</span><span>)</span><span>{</span>
		<span>Date</span> now <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
    <span>//format yyyy-MM-dd HH:mm:ss</span>
    <span>SimpleDateFormat</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd"</span><span>)</span><span>;</span>
    <span>String</span> date  <span>=</span> sdf<span>.</span><span>format</span><span>(</span>now<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"date format : %s"</span><span>,</span> date<span>)</span><span>)</span><span>;</span>

    <span>//format HH:mm:ss</span>
    <span>SimpleDateFormat</span> sdft <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"HH:mm:ss"</span><span>)</span><span>;</span>
    <span>String</span> time <span>=</span> sdft<span>.</span><span>format</span><span>(</span>now<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"time format : %s"</span><span>,</span> time<span>)</span><span>)</span><span>;</span>

    <span>//format yyyy-MM-dd HH:mm:ss</span>
    <span>SimpleDateFormat</span> sdfdt <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
    <span>String</span> datetime <span>=</span> sdfdt<span>.</span><span>format</span><span>(</span>now<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"dateTime format : %s"</span><span>,</span> datetime<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>Java 8 之后:</strong></p>
<div><pre><code><span>public</span> <span>void</span> <span>newFormat</span><span>(</span><span>)</span><span>{</span>
    <span>//format yyyy-MM-dd</span>
    <span>LocalDate</span> date <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"date format : %s"</span><span>,</span> date<span>)</span><span>)</span><span>;</span>

    <span>//format HH:mm:ss</span>
    <span>LocalTime</span> time <span>=</span> <span>LocalTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>withNano</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"time format : %s"</span><span>,</span> time<span>)</span><span>)</span><span>;</span>

    <span>//format yyyy-MM-dd HH:mm:ss</span>
    <span>LocalDateTime</span> dateTime <span>=</span> <span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
    <span>DateTimeFormatter</span> dateTimeFormatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
    <span>String</span> dateTimeStr <span>=</span> dateTime<span>.</span><span>format</span><span>(</span>dateTimeFormatter<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"dateTime format : %s"</span><span>,</span> dateTimeStr<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="字符串转日期格式"> 字符串转日期格式</h3>
<p><strong>Java 8 之前:</strong></p>
<div><pre><code><span>//已弃用</span>
<span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>"2021-01-26"</span><span>)</span><span>;</span>
<span>//替换为</span>
<span>SimpleDateFormat</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd"</span><span>)</span><span>;</span>
<span>Date</span> date1 <span>=</span> sdf<span>.</span><span>parse</span><span>(</span><span>"2021-01-26"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>Java 8 之后:</strong></p>
<div><pre><code><span>LocalDate</span> date <span>=</span> <span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2021</span><span>,</span> <span>1</span><span>,</span> <span>26</span><span>)</span><span>;</span>
<span>LocalDate</span><span>.</span><span>parse</span><span>(</span><span>"2021-01-26"</span><span>)</span><span>;</span>

<span>LocalDateTime</span> dateTime <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2021</span><span>,</span> <span>1</span><span>,</span> <span>26</span><span>,</span> <span>12</span><span>,</span> <span>12</span><span>,</span> <span>22</span><span>)</span><span>;</span>
<span>LocalDateTime</span><span>.</span><span>parse</span><span>(</span><span>"2021-01-26 12:12:22"</span><span>)</span><span>;</span>

<span>LocalTime</span> time <span>=</span> <span>LocalTime</span><span>.</span><span>of</span><span>(</span><span>12</span><span>,</span> <span>12</span><span>,</span> <span>22</span><span>)</span><span>;</span>
<span>LocalTime</span><span>.</span><span>parse</span><span>(</span><span>"12:12:22"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>Java 8 之前</strong> 转换都需要借助 <code>SimpleDateFormat</code> 类，而<strong>Java 8 之后</strong>只需要 <code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>的  <code>of</code> 或 <code>parse</code> 方法。</p>
<h3 id="日期计算"> 日期计算</h3>
<p>下面仅以<strong>一周后日期</strong>为例，其他单位（年、月、日、1/2 日、时等等）大同小异。另外，这些单位都在 <em>java.time.temporal.ChronoUnit</em> 枚举中定义。</p>
<p><strong>Java 8 之前:</strong></p>
<div><pre><code><span>public</span> <span>void</span> <span>afterDay</span><span>(</span><span>)</span><span>{</span>
     <span>//一周后的日期</span>
     <span>SimpleDateFormat</span> formatDate <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd"</span><span>)</span><span>;</span>
     <span>Calendar</span> ca <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
     ca<span>.</span><span>add</span><span>(</span><span>Calendar</span><span>.</span>DATE<span>,</span> <span>7</span><span>)</span><span>;</span>
     <span>Date</span> d <span>=</span> ca<span>.</span><span>getTime</span><span>(</span><span>)</span><span>;</span>
     <span>String</span> after <span>=</span> formatDate<span>.</span><span>format</span><span>(</span>d<span>)</span><span>;</span>
     <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"一周后日期："</span> <span>+</span> after<span>)</span><span>;</span>

   <span>//算两个日期间隔多少天，计算间隔多少年，多少月方法类似</span>
     <span>String</span> dates1 <span>=</span> <span>"2021-12-23"</span><span>;</span>
   <span>String</span> dates2 <span>=</span> <span>"2021-02-26"</span><span>;</span>
     <span>SimpleDateFormat</span> format <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd"</span><span>)</span><span>;</span>
     <span>Date</span> date1 <span>=</span> format<span>.</span><span>parse</span><span>(</span>dates1<span>)</span><span>;</span>
     <span>Date</span> date2 <span>=</span> format<span>.</span><span>parse</span><span>(</span>dates2<span>)</span><span>;</span>
     <span>int</span> day <span>=</span> <span>(</span><span>int</span><span>)</span> <span>(</span><span>(</span>date1<span>.</span><span>getTime</span><span>(</span><span>)</span> <span>-</span> date2<span>.</span><span>getTime</span><span>(</span><span>)</span><span>)</span> <span>/</span> <span>(</span><span>1000</span> <span>*</span> <span>3600</span> <span>*</span> <span>24</span><span>)</span><span>)</span><span>;</span>
     <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dates2 <span>+</span> <span>"和"</span> <span>+</span> dates2 <span>+</span> <span>"相差"</span> <span>+</span> day <span>+</span> <span>"天"</span><span>)</span><span>;</span>
     <span>//结果：2021-12-23和2021-12-23相差300天</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><strong>Java 8 之后:</strong></p>
<div><pre><code><span>public</span> <span>void</span> <span>pushWeek</span><span>(</span><span>)</span><span>{</span>
     <span>//一周后的日期</span>
     <span>LocalDate</span> localDate <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
     <span>//方法1</span>
     <span>LocalDate</span> after <span>=</span> localDate<span>.</span><span>plus</span><span>(</span><span>1</span><span>,</span> <span>ChronoUnit</span><span>.</span>WEEKS<span>)</span><span>;</span>
     <span>//方法2</span>
     <span>LocalDate</span> after2 <span>=</span> localDate<span>.</span><span>plusWeeks</span><span>(</span><span>1</span><span>)</span><span>;</span>
     <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"一周后日期："</span> <span>+</span> after<span>)</span><span>;</span>

     <span>//算两个日期间隔多少天，计算间隔多少年，多少月</span>
     <span>LocalDate</span> date1 <span>=</span> <span>LocalDate</span><span>.</span><span>parse</span><span>(</span><span>"2021-02-26"</span><span>)</span><span>;</span>
     <span>LocalDate</span> date2 <span>=</span> <span>LocalDate</span><span>.</span><span>parse</span><span>(</span><span>"2021-12-23"</span><span>)</span><span>;</span>
     <span>Period</span> period <span>=</span> <span>Period</span><span>.</span><span>between</span><span>(</span>date1<span>,</span> date2<span>)</span><span>;</span>
     <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"date1 到 date2 相隔："</span>
                <span>+</span> period<span>.</span><span>getYears</span><span>(</span><span>)</span> <span>+</span> <span>"年"</span>
                <span>+</span> period<span>.</span><span>getMonths</span><span>(</span><span>)</span> <span>+</span> <span>"月"</span>
                <span>+</span> period<span>.</span><span>getDays</span><span>(</span><span>)</span> <span>+</span> <span>"天"</span><span>)</span><span>;</span>
		 <span>//打印结果是 “date1 到 date2 相隔：0年9月27天”</span>
     <span>//这里period.getDays()得到的天是抛去年月以外的天数，并不是总天数</span>
     <span>//如果要获取纯粹的总天数应该用下面的方法</span>
     <span>long</span> day <span>=</span> date2<span>.</span><span>toEpochDay</span><span>(</span><span>)</span> <span>-</span> date1<span>.</span><span>toEpochDay</span><span>(</span><span>)</span><span>;</span>
     <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date2 <span>+</span> <span>"和"</span> <span>+</span> date2 <span>+</span> <span>"相差"</span> <span>+</span> day <span>+</span> <span>"天"</span><span>)</span><span>;</span>
     <span>//打印结果：2021-12-23和2021-12-23相差300天</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="获取指定日期"> 获取指定日期</h3>
<p>除了日期计算繁琐，获取特定一个日期也很麻烦，比如获取本月最后一天，第一天。</p>
<p><strong>Java 8 之前:</strong></p>
<div><pre><code><span>public</span> <span>void</span> <span>getDay</span><span>(</span><span>)</span> <span>{</span>

        <span>SimpleDateFormat</span> format <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd"</span><span>)</span><span>;</span>
        <span>//获取当前月第一天：</span>
        <span>Calendar</span> c <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>DAY_OF_MONTH<span>,</span> <span>1</span><span>)</span><span>;</span>
        <span>String</span> first <span>=</span> format<span>.</span><span>format</span><span>(</span>c<span>.</span><span>getTime</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"first day:"</span> <span>+</span> first<span>)</span><span>;</span>

        <span>//获取当前月最后一天</span>
        <span>Calendar</span> ca <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        ca<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>DAY_OF_MONTH<span>,</span> ca<span>.</span><span>getActualMaximum</span><span>(</span><span>Calendar</span><span>.</span>DAY_OF_MONTH<span>)</span><span>)</span><span>;</span>
        <span>String</span> last <span>=</span> format<span>.</span><span>format</span><span>(</span>ca<span>.</span><span>getTime</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"last day:"</span> <span>+</span> last<span>)</span><span>;</span>

        <span>//当年最后一天</span>
        <span>Calendar</span> currCal <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>Calendar</span> calendar <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        calendar<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
        calendar<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>YEAR<span>,</span> currCal<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>YEAR<span>)</span><span>)</span><span>;</span>
        calendar<span>.</span><span>roll</span><span>(</span><span>Calendar</span><span>.</span>DAY_OF_YEAR<span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span>
        <span>Date</span> time <span>=</span> calendar<span>.</span><span>getTime</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"last day:"</span> <span>+</span> format<span>.</span><span>format</span><span>(</span>time<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>Java 8 之后:</strong></p>
<div><pre><code><span>public</span> <span>void</span> <span>getDayNew</span><span>(</span><span>)</span> <span>{</span>
    <span>LocalDate</span> today <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
    <span>//获取当前月第一天：</span>
    <span>LocalDate</span> firstDayOfThisMonth <span>=</span> today<span>.</span><span>with</span><span>(</span><span>TemporalAdjusters</span><span>.</span><span>firstDayOfMonth</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>// 取本月最后一天</span>
    <span>LocalDate</span> lastDayOfThisMonth <span>=</span> today<span>.</span><span>with</span><span>(</span><span>TemporalAdjusters</span><span>.</span><span>lastDayOfMonth</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>//取下一天：</span>
    <span>LocalDate</span> nextDay <span>=</span> lastDayOfThisMonth<span>.</span><span>plusDays</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>//当年最后一天</span>
    <span>LocalDate</span> lastday <span>=</span> today<span>.</span><span>with</span><span>(</span><span>TemporalAdjusters</span><span>.</span><span>lastDayOfYear</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>//2021年最后一个周日，如果用Calendar是不得烦死。</span>
    <span>LocalDate</span> lastMondayOf2021 <span>=</span> <span>LocalDate</span><span>.</span><span>parse</span><span>(</span><span>"2021-12-31"</span><span>)</span><span>.</span><span>with</span><span>(</span><span>TemporalAdjusters</span><span>.</span><span>lastInMonth</span><span>(</span><span>DayOfWeek</span><span>.</span>SUNDAY<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><code>java.time.temporal.TemporalAdjusters</code> 里面还有很多便捷的算法，这里就不带大家看 Api 了，都很简单，看了秒懂。</p>
<h3 id="jdbc-和-java8"> JDBC 和 java8</h3>
<p>现在 jdbc 时间类型和 java8 时间类型对应关系是</p>
<ol>
<li><code>Date</code> ---&gt; <code>LocalDate</code></li>
<li><code>Time</code> ---&gt; <code>LocalTime</code></li>
<li><code>Timestamp</code> ---&gt; <code>LocalDateTime</code></li>
</ol>
<p>而之前统统对应 <code>Date</code>，也只有 <code>Date</code>。</p>
<h3 id="时区"> 时区</h3>
<blockquote>
<p>时区：正式的时区划分为每隔经度 15° 划分一个时区，全球共 24 个时区，每个时区相差 1 小时。但为了行政上的方便，常将 1 个国家或 1 个省份划在一起，比如我国幅员宽广，大概横跨 5 个时区，实际上只用东八时区的标准时即北京时间为准。</p>
</blockquote>
<p><code>java.util.Date</code> 对象实质上存的是 1970 年 1 月 1 日 0 点（ GMT）至 Date 对象所表示时刻所经过的毫秒数。也就是说不管在哪个时区 new Date，它记录的毫秒数都一样，和时区无关。但在使用上应该把它转换成当地时间，这就涉及到了时间的国际化。<code>java.util.Date</code> 本身并不支持国际化，需要借助 <code>TimeZone</code>。</p>
<div><pre><code><span>//北京时间：Wed Jan 27 14:05:29 CST 2021</span>
<span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>

<span>SimpleDateFormat</span> bjSdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
<span>//北京时区</span>
bjSdf<span>.</span><span>setTimeZone</span><span>(</span><span>TimeZone</span><span>.</span><span>getTimeZone</span><span>(</span><span>"Asia/Shanghai"</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"毫秒数:"</span> <span>+</span> date<span>.</span><span>getTime</span><span>(</span><span>)</span> <span>+</span> <span>", 北京时间:"</span> <span>+</span> bjSdf<span>.</span><span>format</span><span>(</span>date<span>)</span><span>)</span><span>;</span>

<span>//东京时区</span>
<span>SimpleDateFormat</span> tokyoSdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
tokyoSdf<span>.</span><span>setTimeZone</span><span>(</span><span>TimeZone</span><span>.</span><span>getTimeZone</span><span>(</span><span>"Asia/Tokyo"</span><span>)</span><span>)</span><span>;</span>  <span>// 设置东京时区</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"毫秒数:"</span> <span>+</span> date<span>.</span><span>getTime</span><span>(</span><span>)</span> <span>+</span> <span>", 东京时间:"</span> <span>+</span> tokyoSdf<span>.</span><span>format</span><span>(</span>date<span>)</span><span>)</span><span>;</span>

<span>//如果直接print会自动转成当前时区的时间</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>)</span><span>;</span>
<span>//Wed Jan 27 14:05:29 CST 2021</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>在新特性中引入了  <code>java.time.ZonedDateTime</code> 来表示带时区的时间。它可以看成是 <code>LocalDateTime + ZoneId</code>。</p>
<div><pre><code><span>//当前时区时间</span>
<span>ZonedDateTime</span> zonedDateTime <span>=</span> <span>ZonedDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"当前时区时间: "</span> <span>+</span> zonedDateTime<span>)</span><span>;</span>

<span>//东京时间</span>
<span>ZoneId</span> zoneId <span>=</span> <span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>ZoneId</span><span>.</span>SHORT_IDS<span>.</span><span>get</span><span>(</span><span>"JST"</span><span>)</span><span>)</span><span>;</span>
<span>ZonedDateTime</span> tokyoTime <span>=</span> zonedDateTime<span>.</span><span>withZoneSameInstant</span><span>(</span>zoneId<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"东京时间: "</span> <span>+</span> tokyoTime<span>)</span><span>;</span>

<span>// ZonedDateTime 转 LocalDateTime</span>
<span>LocalDateTime</span> localDateTime <span>=</span> tokyoTime<span>.</span><span>toLocalDateTime</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"东京时间转当地时间: "</span> <span>+</span> localDateTime<span>)</span><span>;</span>

<span>//LocalDateTime 转 ZonedDateTime</span>
<span>ZonedDateTime</span> localZoned <span>=</span> localDateTime<span>.</span><span>atZone</span><span>(</span><span>ZoneId</span><span>.</span><span>systemDefault</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"本地时区时间: "</span> <span>+</span> localZoned<span>)</span><span>;</span>

<span>//打印结果</span>
当前时区时间<span>:</span> <span>2021</span><span>-</span><span>01</span><span>-</span><span>27</span>T14<span>:</span><span>43</span><span>:</span><span>58.735</span><span>+</span><span>08</span><span>:</span><span>00</span><span>[</span><span>Asia</span><span>/</span><span>Shanghai</span><span>]</span>
东京时间<span>:</span> <span>2021</span><span>-</span><span>01</span><span>-</span><span>27</span>T15<span>:</span><span>43</span><span>:</span><span>58.735</span><span>+</span><span>09</span><span>:</span><span>00</span><span>[</span><span>Asia</span><span>/</span><span>Tokyo</span><span>]</span>
东京时间转当地时间<span>:</span> <span>2021</span><span>-</span><span>01</span><span>-</span><span>27</span>T15<span>:</span><span>43</span><span>:</span><span>58.735</span>
当地时区时间<span>:</span> <span>2021</span><span>-</span><span>01</span><span>-</span><span>27</span>T15<span>:</span><span>53</span><span>:</span><span>35.618</span><span>+</span><span>08</span><span>:</span><span>00</span><span>[</span><span>Asia</span><span>/</span><span>Shanghai</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="小结-3"> 小结</h3>
<p>通过上面比较新老 <code>Date</code> 的不同，当然只列出部分功能上的区别，更多功能还得自己去挖掘。总之 date-time-api 给日期操作带来了福利。在日常工作中遇到 date 类型的操作，第一考虑的是 date-time-api，实在解决不了再考虑老的 Date。</p>
<h2 id="总结"> 总结</h2>
<p>我们梳理总结的 java 8 新特性有</p>
<ul>
<li>Interface &amp; functional Interface</li>
<li>Lambda</li>
<li>Stream</li>
<li>Optional</li>
<li>Date time-api</li>
</ul>
<p>这些都是开发当中比较常用的特性。梳理下来发现它们真香，而我却没有更早的应用。总觉得学习 java 8 新特性比较麻烦，一直使用老的实现方式。其实这些新特性几天就可以掌握，一但掌握，效率会有很大的提高。其实我们涨工资也是涨的学习的钱，不学习终究会被淘汰，35 岁危机会提前来临。</p>
]]></content:encoded>
    </item>
    <item>
      <title>《Java8指南》中文翻译</title>
      <link>https://javaguide.cn/java/new-features/java8-tutorial-translate/</link>
      <guid>https://javaguide.cn/java/new-features/java8-tutorial-translate/</guid>
      <source url="https://javaguide.cn/rss.xml">《Java8指南》中文翻译</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="《java8指南》中文翻译"> 《Java8指南》中文翻译</h1>
<p>随着 Java 8 的普及度越来越高，很多人都提到面试中关于Java 8 也是非常常问的知识点。应各位要求和需要，我打算对这部分知识做一个总结。本来准备自己总结的，后面看到Github 上有一个相关的仓库，地址：
<a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="noopener noreferrer">https://github.com/winterbe/java8-tutorial</a>。这个仓库是英文的，我对其进行了翻译并添加和修改了部分内容，下面是正文。</p>
<hr>
<p>欢迎阅读我对Java 8的介绍。本教程将逐步指导您完成所有新语言功能。 在简短的代码示例的基础上，您将学习如何使用默认接口方法，lambda表达式，方法引用和可重复注释。 在本文的最后，您将熟悉最新的 API 更改，如流，函数式接口(Functional Interfaces)，Map 类的扩展和新的 Date API。 没有大段枯燥的文字，只有一堆注释的代码片段。</p>
<h3 id="接口的默认方法-default-methods-for-interfaces"> 接口的默认方法(Default Methods for Interfaces)</h3>
<p>Java 8使我们能够通过使用 <code>default</code> 关键字向接口添加非抽象方法实现。 此功能也称为<a href="http://stackoverflow.com/a/24102730" target="_blank" rel="noopener noreferrer">虚拟扩展方法</a>。</p>
<p>第一个例子：</p>
<div><pre><code><span>interface</span> <span>Formula</span><span>{</span>

    <span>double</span> <span>calculate</span><span>(</span><span>int</span> a<span>)</span><span>;</span>

    <span>default</span> <span>double</span> <span>sqrt</span><span>(</span><span>int</span> a<span>)</span> <span>{</span>
        <span>return</span> <span>Math</span><span>.</span><span>sqrt</span><span>(</span>a<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Formula 接口中除了抽象方法计算接口公式还定义了默认方法 <code>sqrt</code>。 实现该接口的类只需要实现抽象方法 <code>calculate</code>。 默认方法<code>sqrt</code> 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>

  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>// 通过匿名内部类方式访问接口</span>
    <span>Formula</span> formula <span>=</span> <span>new</span> <span>Formula</span><span>(</span><span>)</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>double</span> <span>calculate</span><span>(</span><span>int</span> a<span>)</span> <span>{</span>
            <span>return</span> <span>sqrt</span><span>(</span>a <span>*</span> <span>100</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>

    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>formula<span>.</span><span>calculate</span><span>(</span><span>100</span><span>)</span><span>)</span><span>;</span>     <span>// 100.0</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>formula<span>.</span><span>sqrt</span><span>(</span><span>16</span><span>)</span><span>)</span><span>;</span>           <span>// 4.0</span>

  <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>formula 是作为匿名对象实现的。该代码非常容易理解，6行代码实现了计算 <code>sqrt(a * 100)</code>。在下一节中，我们将会看到在 Java 8 中实现单个方法对象有一种更好更方便的方法。</p>
<p><strong>译者注：</strong> 不管是抽象类还是接口，都可以通过匿名内部类的方式访问。不能通过抽象类或者接口直接创建对象。对于上面通过匿名内部类方式访问接口，我们可以这样理解：一个内部类实现了接口里的抽象方法并且返回一个内部类对象，之后我们让接口的引用来指向这个对象。</p>
<h3 id="lambda表达式-lambda-expressions"> Lambda表达式(Lambda expressions)</h3>
<p>首先看看在老版本的Java中是如何排列字符串的：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> names <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>"peter"</span><span>,</span> <span>"anna"</span><span>,</span> <span>"mike"</span><span>,</span> <span>"xenia"</span><span>)</span><span>;</span>

<span>Collections</span><span>.</span><span>sort</span><span>(</span>names<span>,</span> <span>new</span> <span>Comparator</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>String</span> a<span>,</span> <span>String</span> b<span>)</span> <span>{</span>
        <span>return</span> b<span>.</span><span>compareTo</span><span>(</span>a<span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>只需要给静态方法<code>Collections.sort</code> 传入一个 List 对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给 <code>sort</code> 方法。</p>
<p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p>
<div><pre><code><span>Collections</span><span>.</span><span>sort</span><span>(</span>names<span>,</span> <span>(</span><span>String</span> a<span>,</span> <span>String</span> b<span>)</span> <span>-></span> <span>{</span>
    <span>return</span> b<span>.</span><span>compareTo</span><span>(</span>a<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看出，代码变得更短且更具有可读性，但是实际上还可以写得更短：</p>
<div><pre><code><span>Collections</span><span>.</span><span>sort</span><span>(</span>names<span>,</span> <span>(</span><span>String</span> a<span>,</span> <span>String</span> b<span>)</span> <span>-></span> b<span>.</span><span>compareTo</span><span>(</span>a<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p>
<div><pre><code>names<span>.</span><span>sort</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>-></span> b<span>.</span><span>compareTo</span><span>(</span>a<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>List 类本身就有一个 <code>sort</code> 方法。并且Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还有什么其他用法。</p>
<h3 id="函数式接口-functional-interfaces"> 函数式接口(Functional Interfaces)</h3>
<p><strong>译者注：</strong> 原文对这部分解释不太清楚，故做了修改！</p>
<p>Java 语言设计者们投入了大量精力来思考如何使现有的函数友好地支持Lambda。最终采取的方法是：增加函数式接口的概念。<strong>“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。</strong> 像这样的接口，可以被隐式转换为lambda表达式。<code>java.lang.Runnable</code> 与 <code>java.util.concurrent.Callable</code> 是函数式接口最典型的两个例子。Java 8增加了一种特殊的注解<code>@FunctionalInterface</code>,但是这个注解通常不是必须的(某些情况建议使用)，只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。一般建议在接口上使用<code>@FunctionalInterface</code> 注解进行声明，这样的话，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的，如下图所示</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/@FunctionalInterface.png" alt="@FunctionalInterface 注解" /></p>
<p>示例：</p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Converter</span><span><span>&lt;</span><span>F</span><span>,</span> <span>T</span><span>></span></span> <span>{</span>
  <span>T</span> <span>convert</span><span>(</span><span>F</span> from<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code>    <span>// TODO 将数字字符串转换为整数类型</span>
    <span>Converter</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> converter <span>=</span> <span>(</span>from<span>)</span> <span>-></span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>from<span>)</span><span>;</span>
    <span>Integer</span> converted <span>=</span> converter<span>.</span><span>convert</span><span>(</span><span>"123"</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>converted<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>//class java.lang.Integer</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>译者注：</strong> 大部分函数式接口都不用我们自己写，Java8都给我们实现好了，这些接口都在java.util.function包里。</p>
<h3 id="方法和构造函数引用-method-and-constructor-references"> 方法和构造函数引用(Method and Constructor References)</h3>
<p>前一节中的代码还可以通过静态方法引用来表示：</p>
<div><pre><code>    <span>Converter</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> converter <span>=</span> <span>Integer</span><span>::</span><span>valueOf</span><span>;</span>
    <span>Integer</span> converted <span>=</span> converter<span>.</span><span>convert</span><span>(</span><span>"123"</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>converted<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>   <span>//class java.lang.Integer</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Java 8允许您通过<code>::</code>关键字传递方法或构造函数的引用。 上面的示例显示了如何引用静态方法。 但我们也可以引用对象方法：</p>
<div><pre><code><span>class</span> <span>Something</span> <span>{</span>
    <span>String</span> <span>startsWith</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>return</span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>Something</span> something <span>=</span> <span>new</span> <span>Something</span><span>(</span><span>)</span><span>;</span>
<span>Converter</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> converter <span>=</span> something<span>::</span><span>startsWith</span><span>;</span>
<span>String</span> converted <span>=</span> converter<span>.</span><span>convert</span><span>(</span><span>"Java"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>converted<span>)</span><span>;</span>    <span>// "J"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>接下来看看构造函数是如何使用<code>::</code>关键字来引用的，首先我们定义一个包含多个构造函数的简单类：</p>
<div><pre><code><span>class</span> <span>Person</span> <span>{</span>
    <span>String</span> firstName<span>;</span>
    <span>String</span> lastName<span>;</span>

    <span>Person</span><span>(</span><span>)</span> <span>{</span><span>}</span>

    <span>Person</span><span>(</span><span>String</span> firstName<span>,</span> <span>String</span> lastName<span>)</span> <span>{</span>
        <span>this</span><span>.</span>firstName <span>=</span> firstName<span>;</span>
        <span>this</span><span>.</span>lastName <span>=</span> lastName<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>接下来我们指定一个用来创建Person对象的对象工厂接口：</p>
<div><pre><code><span>interface</span> <span>PersonFactory</span><span><span>&lt;</span><span>P</span> <span>extends</span> <span>Person</span><span>></span></span> <span>{</span>
    <span>P</span> <span>create</span><span>(</span><span>String</span> firstName<span>,</span> <span>String</span> lastName<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这里我们使用构造函数引用来将他们关联起来，而不是手动实现一个完整的工厂：</p>
<div><pre><code><span>PersonFactory</span><span><span>&lt;</span><span>Person</span><span>></span></span> personFactory <span>=</span> <span>Person</span><span>::</span><span>new</span><span>;</span>
<span>Person</span> person <span>=</span> personFactory<span>.</span><span>create</span><span>(</span><span>"Peter"</span><span>,</span> <span>"Parker"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>我们只需要使用 <code>Person::new</code> 来获取Person类构造函数的引用，Java编译器会自动根据<code>PersonFactory.create</code>方法的参数类型来选择合适的构造函数。</p>
<h3 id="lambda-表达式作用域-lambda-scopes"> Lambda 表达式作用域(Lambda Scopes)</h3>
<h4 id="访问局部变量"> 访问局部变量</h4>
<p>我们可以直接在 lambda 表达式中访问外部的局部变量：</p>
<div><pre><code><span>final</span> <span>int</span> num <span>=</span> <span>1</span><span>;</span>
<span>Converter</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> stringConverter <span>=</span>
        <span>(</span>from<span>)</span> <span>-></span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>from <span>+</span> num<span>)</span><span>;</span>

stringConverter<span>.</span><span>convert</span><span>(</span><span>2</span><span>)</span><span>;</span>     <span>// 3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：</p>
<div><pre><code><span>int</span> num <span>=</span> <span>1</span><span>;</span>
<span>Converter</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> stringConverter <span>=</span>
        <span>(</span>from<span>)</span> <span>-></span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>from <span>+</span> num<span>)</span><span>;</span>

stringConverter<span>.</span><span>convert</span><span>(</span><span>2</span><span>)</span><span>;</span>     <span>// 3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>不过这里的 num 必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：</p>
<div><pre><code><span>int</span> num <span>=</span> <span>1</span><span>;</span>
<span>Converter</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> stringConverter <span>=</span>
        <span>(</span>from<span>)</span> <span>-></span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>from <span>+</span> num<span>)</span><span>;</span>
num <span>=</span> <span>3</span><span>;</span><span>//在lambda表达式中试图修改num同样是不允许的。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="访问字段和静态变量"> 访问字段和静态变量</h4>
<p>与局部变量相比，我们对lambda表达式中的实例字段和静态变量都有读写访问权限。 该行为和匿名对象是一致的。</p>
<div><pre><code><span>class</span> <span>Lambda4</span> <span>{</span>
    <span>static</span> <span>int</span> outerStaticNum<span>;</span>
    <span>int</span> outerNum<span>;</span>

    <span>void</span> <span>testScopes</span><span>(</span><span>)</span> <span>{</span>
        <span>Converter</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> stringConverter1 <span>=</span> <span>(</span>from<span>)</span> <span>-></span> <span>{</span>
            outerNum <span>=</span> <span>23</span><span>;</span>
            <span>return</span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>from<span>)</span><span>;</span>
        <span>}</span><span>;</span>

        <span>Converter</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> stringConverter2 <span>=</span> <span>(</span>from<span>)</span> <span>-></span> <span>{</span>
            outerStaticNum <span>=</span> <span>72</span><span>;</span>
            <span>return</span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>from<span>)</span><span>;</span>
        <span>}</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="访问默认接口方法"> 访问默认接口方法</h4>
<p>还记得第一节中的 formula 示例吗？ <code>Formula</code> 接口定义了一个默认方法<code>sqrt</code>，可以从包含匿名对象的每个 formula 实例访问该方法。 这不适用于lambda表达式。</p>
<p>无法从 lambda 表达式中访问默认方法,故以下代码无法编译：</p>
<div><pre><code><span>Formula</span> formula <span>=</span> <span>(</span>a<span>)</span> <span>-></span> <span>sqrt</span><span>(</span>a <span>*</span> <span>100</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="内置函数式接口-built-in-functional-interfaces"> 内置函数式接口(Built-in Functional Interfaces)</h3>
<p>JDK 1.8 API包含许多内置函数式接口。 其中一些接口在老版本的 Java 中是比较常见的比如： <code>Comparator</code> 或<code>Runnable</code>，这些接口都增加了<code>@FunctionalInterface</code>注解以便能用在 lambda 表达式上。</p>
<p>但是 Java 8 API 同样还提供了很多全新的函数式接口来让你的编程工作更加方便，有一些接口是来自 <a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="noopener noreferrer">Google Guava</a> 库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p>
<h4 id="predicate"> Predicate</h4>
<p>Predicate 接口是只有一个参数的返回布尔类型值的 <strong>断言型</strong> 接口。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）：</p>
<p><strong>译者注：</strong> Predicate 接口源码如下</p>
<div><pre><code><span>package</span> <span>java<span>.</span>util<span>.</span>function</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Objects</span><span>;</span>

<span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Predicate</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>
    
    <span>// 该方法是接受一个传入类型,返回一个布尔值.此方法应用于判断.</span>
    <span>boolean</span> <span>test</span><span>(</span><span>T</span> t<span>)</span><span>;</span>

    <span>//and方法与关系型运算符"&amp;&amp;"相似，两边都成立才返回true</span>
    <span>default</span> <span>Predicate</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>and</span><span>(</span><span>Predicate</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> other<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>other<span>)</span><span>;</span>
        <span>return</span> <span>(</span>t<span>)</span> <span>-></span> <span>test</span><span>(</span>t<span>)</span> <span>&amp;&amp;</span> other<span>.</span><span>test</span><span>(</span>t<span>)</span><span>;</span>
    <span>}</span>
    <span>// 与关系运算符"!"相似，对判断进行取反</span>
    <span>default</span> <span>Predicate</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>negate</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>(</span>t<span>)</span> <span>-></span> <span>!</span><span>test</span><span>(</span>t<span>)</span><span>;</span>
    <span>}</span>
    <span>//or方法与关系型运算符"||"相似，两边只要有一个成立就返回true</span>
    <span>default</span> <span>Predicate</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>or</span><span>(</span><span>Predicate</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> other<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>other<span>)</span><span>;</span>
        <span>return</span> <span>(</span>t<span>)</span> <span>-></span> <span>test</span><span>(</span>t<span>)</span> <span>||</span> other<span>.</span><span>test</span><span>(</span>t<span>)</span><span>;</span>
    <span>}</span>
   <span>// 该方法接收一个Object对象,返回一个Predicate类型.此方法用于判断第一个test的方法与第二个test方法相同(equal).</span>
    <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Predicate</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>isEqual</span><span>(</span><span>Object</span> targetRef<span>)</span> <span>{</span>
        <span>return</span> <span>(</span><span>null</span> <span>==</span> targetRef<span>)</span>
                <span>?</span> <span>Objects</span><span>::</span><span>isNull</span>
                <span>:</span> object <span>-></span> targetRef<span>.</span><span>equals</span><span>(</span>object<span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>示例：</p>
<div><pre><code><span>Predicate</span><span><span>&lt;</span><span>String</span><span>></span></span> predicate <span>=</span> <span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>></span> <span>0</span><span>;</span>

predicate<span>.</span><span>test</span><span>(</span><span>"foo"</span><span>)</span><span>;</span>              <span>// true</span>
predicate<span>.</span><span>negate</span><span>(</span><span>)</span><span>.</span><span>test</span><span>(</span><span>"foo"</span><span>)</span><span>;</span>     <span>// false</span>

<span>Predicate</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> nonNull <span>=</span> <span>Objects</span><span>::</span><span>nonNull</span><span>;</span>
<span>Predicate</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> isNull <span>=</span> <span>Objects</span><span>::</span><span>isNull</span><span>;</span>

<span>Predicate</span><span><span>&lt;</span><span>String</span><span>></span></span> isEmpty <span>=</span> <span>String</span><span>::</span><span>isEmpty</span><span>;</span>
<span>Predicate</span><span><span>&lt;</span><span>String</span><span>></span></span> isNotEmpty <span>=</span> isEmpty<span>.</span><span>negate</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="function"> Function</h4>
<p>Function 接口接受一个参数并生成结果。默认方法可用于将多个函数链接在一起（compose, andThen）：</p>
<p><strong>译者注：</strong> Function  接口源码如下</p>
<div><pre><code>
<span>package</span> <span>java<span>.</span>util<span>.</span>function</span><span>;</span>
 
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Objects</span><span>;</span>
 
<span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Function</span><span><span>&lt;</span><span>T</span><span>,</span> <span>R</span><span>></span></span> <span>{</span>
    
    <span>//将Function对象应用到输入的参数上，然后返回计算结果。</span>
    <span>R</span> <span>apply</span><span>(</span><span>T</span> t<span>)</span><span>;</span>
    <span>//将两个Function整合，并返回一个能够执行两个Function对象功能的Function对象。</span>
    <span>default</span> <span><span>&lt;</span><span>V</span><span>></span></span> <span>Function</span><span><span>&lt;</span><span>V</span><span>,</span> <span>R</span><span>></span></span> <span>compose</span><span>(</span><span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>V</span><span>,</span> <span>?</span> <span>extends</span> <span>T</span><span>></span></span> before<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>before<span>)</span><span>;</span>
        <span>return</span> <span>(</span><span>V</span> v<span>)</span> <span>-></span> <span>apply</span><span>(</span>before<span>.</span><span>apply</span><span>(</span>v<span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>// </span>
    <span>default</span> <span><span>&lt;</span><span>V</span><span>></span></span> <span>Function</span><span><span>&lt;</span><span>T</span><span>,</span> <span>V</span><span>></span></span> <span>andThen</span><span>(</span><span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>R</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> after<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>after<span>)</span><span>;</span>
        <span>return</span> <span>(</span><span>T</span> t<span>)</span> <span>-></span> after<span>.</span><span>apply</span><span>(</span><span>apply</span><span>(</span>t<span>)</span><span>)</span><span>;</span>
    <span>}</span>
 
    <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Function</span><span><span>&lt;</span><span>T</span><span>,</span> <span>T</span><span>></span></span> <span>identity</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> t <span>-></span> t<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><div><pre><code><span>Function</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> toInteger <span>=</span> <span>Integer</span><span>::</span><span>valueOf</span><span>;</span>
<span>Function</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> backToString <span>=</span> toInteger<span>.</span><span>andThen</span><span>(</span><span>String</span><span>::</span><span>valueOf</span><span>)</span><span>;</span>
backToString<span>.</span><span>apply</span><span>(</span><span>"123"</span><span>)</span><span>;</span>     <span>// "123"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="supplier"> Supplier</h4>
<p>Supplier 接口产生给定泛型类型的结果。 与 Function 接口不同，Supplier 接口不接受参数。</p>
<div><pre><code><span>Supplier</span><span><span>&lt;</span><span>Person</span><span>></span></span> personSupplier <span>=</span> <span>Person</span><span>::</span><span>new</span><span>;</span>
personSupplier<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>   <span>// new Person</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="consumer"> Consumer</h4>
<p>Consumer 接口表示要对单个输入参数执行的操作。</p>
<div><pre><code><span>Consumer</span><span><span>&lt;</span><span>Person</span><span>></span></span> greeter <span>=</span> <span>(</span>p<span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello, "</span> <span>+</span> p<span>.</span>firstName<span>)</span><span>;</span>
greeter<span>.</span><span>accept</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"Luke"</span><span>,</span> <span>"Skywalker"</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="comparator"> Comparator</h4>
<p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p>
<div><pre><code><span>Comparator</span><span><span>&lt;</span><span>Person</span><span>></span></span> comparator <span>=</span> <span>(</span>p1<span>,</span> p2<span>)</span> <span>-></span> p1<span>.</span>firstName<span>.</span><span>compareTo</span><span>(</span>p2<span>.</span>firstName<span>)</span><span>;</span>

<span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"John"</span><span>,</span> <span>"Doe"</span><span>)</span><span>;</span>
<span>Person</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"Alice"</span><span>,</span> <span>"Wonderland"</span><span>)</span><span>;</span>

comparator<span>.</span><span>compare</span><span>(</span>p1<span>,</span> p2<span>)</span><span>;</span>             <span>// > 0</span>
comparator<span>.</span><span>reversed</span><span>(</span><span>)</span><span>.</span><span>compare</span><span>(</span>p1<span>,</span> p2<span>)</span><span>;</span>  <span>// &lt; 0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="optional"> Optional</h2>
<p>Optional不是函数式接口，而是用于防止 NullPointerException 的漂亮工具。这是下一节的一个重要概念，让我们快速了解一下Optional的工作原理。</p>
<p>Optional 是一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在Java 8中，你应该返回 Optional 而不是 null。</p>
<p>译者注：示例中每个方法的作用已经添加。</p>
<div><pre><code><span>//of()：为非null的值创建一个Optional</span>
<span>Optional</span><span><span>&lt;</span><span>String</span><span>></span></span> optional <span>=</span> <span>Optional</span><span>.</span><span>of</span><span>(</span><span>"bam"</span><span>)</span><span>;</span>
<span>// isPresent()： 如果值存在返回true，否则返回false</span>
optional<span>.</span><span>isPresent</span><span>(</span><span>)</span><span>;</span>           <span>// true</span>
<span>//get()：如果Optional有值则将其返回，否则抛出NoSuchElementException</span>
optional<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>                 <span>// "bam"</span>
<span>//orElse()：如果有值则将其返回，否则返回指定的其它值</span>
optional<span>.</span><span>orElse</span><span>(</span><span>"fallback"</span><span>)</span><span>;</span>    <span>// "bam"</span>
<span>//ifPresent()：如果Optional实例有值则为其调用consumer，否则不做处理</span>
optional<span>.</span><span>ifPresent</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>)</span><span>)</span><span>;</span>     <span>// "b"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>推荐阅读：<a href="https://blog.kaaass.net/archives/764" target="_blank" rel="noopener noreferrer">[Java8]如何正确使用Optional</a></p>
<h2 id="streams-流"> Streams(流)</h2>
<p><code>java.util.Stream</code> 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如<code>java.util.Collection</code> 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。</p>
<p>首先看看Stream是怎么用，首先创建实例代码需要用到的数据List：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> stringList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
stringList<span>.</span><span>add</span><span>(</span><span>"ddd2"</span><span>)</span><span>;</span>
stringList<span>.</span><span>add</span><span>(</span><span>"aaa2"</span><span>)</span><span>;</span>
stringList<span>.</span><span>add</span><span>(</span><span>"bbb1"</span><span>)</span><span>;</span>
stringList<span>.</span><span>add</span><span>(</span><span>"aaa1"</span><span>)</span><span>;</span>
stringList<span>.</span><span>add</span><span>(</span><span>"bbb3"</span><span>)</span><span>;</span>
stringList<span>.</span><span>add</span><span>(</span><span>"ccc"</span><span>)</span><span>;</span>
stringList<span>.</span><span>add</span><span>(</span><span>"bbb2"</span><span>)</span><span>;</span>
stringList<span>.</span><span>add</span><span>(</span><span>"ddd1"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：</p>
<h3 id="filter-过滤"> Filter(过滤)</h3>
<p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于<strong>中间操作</strong>，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p>
<div><pre><code>        <span>// 测试 Filter(过滤)</span>
        stringList
                <span>.</span><span>stream</span><span>(</span><span>)</span>
                <span>.</span><span>filter</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>startsWith</span><span>(</span><span>"a"</span><span>)</span><span>)</span>
                <span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span><span>//aaa2 aaa1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。</p>
<h3 id="sorted-排序"> Sorted(排序)</h3>
<p>排序是一个 <strong>中间操作</strong>，返回的是排序好后的 Stream。<strong>如果你不指定一个自定义的 Comparator 则会使用默认排序。</strong></p>
<div><pre><code>        <span>// 测试 Sort (排序)</span>
        stringList
                <span>.</span><span>stream</span><span>(</span><span>)</span>
                <span>.</span><span>sorted</span><span>(</span><span>)</span>
                <span>.</span><span>filter</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>startsWith</span><span>(</span><span>"a"</span><span>)</span><span>)</span>
                <span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span><span>// aaa1 aaa2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringList是不会被修改的：</p>
<div><pre><code>    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>stringList<span>)</span><span>;</span><span>// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="map-映射"> Map(映射)</h3>
<p>中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。</p>
<p>下面的示例展示了将字符串转换为大写字符串。你也可以通过map来将对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p>
<div><pre><code>        <span>// 测试 Map 操作</span>
        stringList
                <span>.</span><span>stream</span><span>(</span><span>)</span>
                <span>.</span><span>map</span><span>(</span><span>String</span><span>::</span><span>toUpperCase</span><span>)</span>
                <span>.</span><span>sorted</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>-></span> b<span>.</span><span>compareTo</span><span>(</span>a<span>)</span><span>)</span>
                <span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span><span>// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "BBB1", "AAA2", "AAA1"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="match-匹配"> Match(匹配)</h3>
<p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 <strong>最终操作</strong> ，并返回一个 boolean 类型的值。</p>
<div><pre><code>        <span>// 测试 Match (匹配)操作</span>
        <span>boolean</span> anyStartsWithA <span>=</span>
                stringList
                        <span>.</span><span>stream</span><span>(</span><span>)</span>
                        <span>.</span><span>anyMatch</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>startsWith</span><span>(</span><span>"a"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>anyStartsWithA<span>)</span><span>;</span>      <span>// true</span>

        <span>boolean</span> allStartsWithA <span>=</span>
                stringList
                        <span>.</span><span>stream</span><span>(</span><span>)</span>
                        <span>.</span><span>allMatch</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>startsWith</span><span>(</span><span>"a"</span><span>)</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>allStartsWithA<span>)</span><span>;</span>      <span>// false</span>

        <span>boolean</span> noneStartsWithZ <span>=</span>
                stringList
                        <span>.</span><span>stream</span><span>(</span><span>)</span>
                        <span>.</span><span>noneMatch</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>startsWith</span><span>(</span><span>"z"</span><span>)</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>noneStartsWithZ<span>)</span><span>;</span>      <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="count-计数"> Count(计数)</h3>
<p>计数是一个 <strong>最终操作</strong>，返回Stream中元素的个数，<strong>返回值类型是 long</strong>。</p>
<div><pre><code>      <span>//测试 Count (计数)操作</span>
        <span>long</span> startsWithB <span>=</span>
                stringList
                        <span>.</span><span>stream</span><span>(</span><span>)</span>
                        <span>.</span><span>filter</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>startsWith</span><span>(</span><span>"b"</span><span>)</span><span>)</span>
                        <span>.</span><span>count</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>startsWithB<span>)</span><span>;</span>    <span>// 3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="reduce-规约"> Reduce(规约)</h3>
<p>这是一个 <strong>最终操作</strong> ，允许通过指定的函数来将stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的：</p>
<div><pre><code>        <span>//测试 Reduce (规约)操作</span>
        <span>Optional</span><span><span>&lt;</span><span>String</span><span>></span></span> reduced <span>=</span>
                stringList
                        <span>.</span><span>stream</span><span>(</span><span>)</span>
                        <span>.</span><span>sorted</span><span>(</span><span>)</span>
                        <span>.</span><span>reduce</span><span>(</span><span>(</span>s1<span>,</span> s2<span>)</span> <span>-></span> s1 <span>+</span> <span>"#"</span> <span>+</span> s2<span>)</span><span>;</span>

        reduced<span>.</span><span>ifPresent</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span><span>//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>译者注：</strong> 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于<code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);</code>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p>
<div><pre><code><span>// 字符串连接，concat = "ABCD"</span>
<span>String</span> concat <span>=</span> <span>Stream</span><span>.</span><span>of</span><span>(</span><span>"A"</span><span>,</span> <span>"B"</span><span>,</span> <span>"C"</span><span>,</span> <span>"D"</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>""</span><span>,</span> <span>String</span><span>::</span><span>concat</span><span>)</span><span>;</span> 
<span>// 求最小值，minValue = -3.0</span>
<span>double</span> minValue <span>=</span> <span>Stream</span><span>.</span><span>of</span><span>(</span><span>-</span><span>1.5</span><span>,</span> <span>1.0</span><span>,</span> <span>-</span><span>3.0</span><span>,</span> <span>-</span><span>2.0</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>Double</span><span>.</span>MAX_VALUE<span>,</span> <span>Double</span><span>::</span><span>min</span><span>)</span><span>;</span> 
<span>// 求和，sumValue = 10, 有起始值</span>
<span>int</span> sumValue <span>=</span> <span>Stream</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>0</span><span>,</span> <span>Integer</span><span>::</span><span>sum</span><span>)</span><span>;</span>
<span>// 求和，sumValue = 10, 无起始值</span>
sumValue <span>=</span> <span>Stream</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>Integer</span><span>::</span><span>sum</span><span>)</span><span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
<span>// 过滤，字符串连接，concat = "ace"</span>
concat <span>=</span> <span>Stream</span><span>.</span><span>of</span><span>(</span><span>"a"</span><span>,</span> <span>"B"</span><span>,</span> <span>"c"</span><span>,</span> <span>"D"</span><span>,</span> <span>"e"</span><span>,</span> <span>"F"</span><span>)</span><span>.</span>
 <span>filter</span><span>(</span>x <span>-></span> x<span>.</span><span>compareTo</span><span>(</span><span>"Z"</span><span>)</span> <span>></span> <span>0</span><span>)</span><span>.</span>
 <span>reduce</span><span>(</span><span>""</span><span>,</span> <span>String</span><span>::</span><span>concat</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。更多内容查看： <a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener noreferrer">IBM：Java 8 中的 Streams API 详解</a></p>
<h2 id="parallel-streams-并行流"> Parallel Streams(并行流)</h2>
<p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p>
<p>下面的例子展示了是如何通过并行Stream来提升性能：</p>
<p>首先我们创建一个没有重复元素的大表：</p>
<div><pre><code><span>int</span> max <span>=</span> <span>1000000</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> values <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>max<span>)</span><span>;</span>
<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> max<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>UUID</span> uuid <span>=</span> UUID<span>.</span><span>randomUUID</span><span>(</span><span>)</span><span>;</span>
    values<span>.</span><span>add</span><span>(</span>uuid<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们分别用串行和并行两种方式对其进行排序，最后看看所用时间的对比。</p>
<h3 id="sequential-sort-串行排序"> Sequential Sort(串行排序)</h3>
<div><pre><code><span>//串行排序</span>
<span>long</span> t0 <span>=</span> <span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span><span>;</span>
<span>long</span> count <span>=</span> values<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>sorted</span><span>(</span><span>)</span><span>.</span><span>count</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>count<span>)</span><span>;</span>

<span>long</span> t1 <span>=</span> <span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span><span>;</span>

<span>long</span> millis <span>=</span> <span>TimeUnit</span><span>.</span>NANOSECONDS<span>.</span><span>toMillis</span><span>(</span>t1 <span>-</span> t0<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"sequential sort took: %d ms"</span><span>,</span> millis<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code>1000000
sequential sort took: 709 ms//串行排序所用的时间
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="parallel-sort-并行排序"> Parallel Sort(并行排序)</h3>
<div><pre><code><span>//并行排序</span>
<span>long</span> t0 <span>=</span> <span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span><span>;</span>

<span>long</span> count <span>=</span> values<span>.</span><span>parallelStream</span><span>(</span><span>)</span><span>.</span><span>sorted</span><span>(</span><span>)</span><span>.</span><span>count</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>count<span>)</span><span>;</span>

<span>long</span> t1 <span>=</span> <span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span><span>;</span>

<span>long</span> millis <span>=</span> <span>TimeUnit</span><span>.</span>NANOSECONDS<span>.</span><span>toMillis</span><span>(</span>t1 <span>-</span> t0<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"parallel sort took: %d ms"</span><span>,</span> millis<span>)</span><span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>1000000</span>
parallel sort took<span>:</span> <span>475</span> ms<span>//串行排序所用的时间</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面两个代码几乎是一样的，但是并行版的快了 50% 左右，唯一需要做的改动就是将 <code>stream()</code> 改为<code>parallelStream()</code>。</p>
<h2 id="maps"> Maps</h2>
<p>前面提到过，Map 类型不支持 streams，不过Map提供了一些新的有用的方法来处理一些日常任务。Map接口本身没有可用的 <code>stream()</code>方法，但是你可以在键，值上创建专门的流或者通过 <code>map.keySet().stream()</code>,<code>map.values().stream()</code>和<code>map.entrySet().stream()</code>。</p>
<p>此外,Maps 支持各种新的和有用的方法来执行常见任务。</p>
<div><pre><code><span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    map<span>.</span><span>putIfAbsent</span><span>(</span>i<span>,</span> <span>"val"</span> <span>+</span> i<span>)</span><span>;</span>
<span>}</span>

map<span>.</span><span>forEach</span><span>(</span><span>(</span>id<span>,</span> val<span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>val<span>)</span><span>)</span><span>;</span><span>//val0 val1 val2 val3 val4 val5 val6 val7 val8 val9</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>putIfAbsent</code> 阻止我们在null检查时写入额外的代码;<code>forEach</code>接受一个 consumer 来对 map 中的每个元素操作。</p>
<p>此示例显示如何使用函数在 map 上计算代码：</p>
<div><pre><code>map<span>.</span><span>computeIfPresent</span><span>(</span><span>3</span><span>,</span> <span>(</span>num<span>,</span> val<span>)</span> <span>-></span> val <span>+</span> num<span>)</span><span>;</span>
map<span>.</span><span>get</span><span>(</span><span>3</span><span>)</span><span>;</span>             <span>// val33</span>

map<span>.</span><span>computeIfPresent</span><span>(</span><span>9</span><span>,</span> <span>(</span>num<span>,</span> val<span>)</span> <span>-></span> <span>null</span><span>)</span><span>;</span>
map<span>.</span><span>containsKey</span><span>(</span><span>9</span><span>)</span><span>;</span>     <span>// false</span>

map<span>.</span><span>computeIfAbsent</span><span>(</span><span>23</span><span>,</span> num <span>-></span> <span>"val"</span> <span>+</span> num<span>)</span><span>;</span>
map<span>.</span><span>containsKey</span><span>(</span><span>23</span><span>)</span><span>;</span>    <span>// true</span>

map<span>.</span><span>computeIfAbsent</span><span>(</span><span>3</span><span>,</span> num <span>-></span> <span>"bam"</span><span>)</span><span>;</span>
map<span>.</span><span>get</span><span>(</span><span>3</span><span>)</span><span>;</span>             <span>// val33</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>接下来展示如何在Map里删除一个键值全都匹配的项：</p>
<div><pre><code>map<span>.</span><span>remove</span><span>(</span><span>3</span><span>,</span> <span>"val3"</span><span>)</span><span>;</span>
map<span>.</span><span>get</span><span>(</span><span>3</span><span>)</span><span>;</span>             <span>// val33</span>
map<span>.</span><span>remove</span><span>(</span><span>3</span><span>,</span> <span>"val33"</span><span>)</span><span>;</span>
map<span>.</span><span>get</span><span>(</span><span>3</span><span>)</span><span>;</span>             <span>// null</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>另外一个有用的方法：</p>
<div><pre><code>map<span>.</span><span>getOrDefault</span><span>(</span><span>42</span><span>,</span> <span>"not found"</span><span>)</span><span>;</span>  <span>// not found</span>
</code></pre>
<div><span>1</span><br></div></div><p>对Map的元素做合并也变得很容易了：</p>
<div><pre><code>map<span>.</span><span>merge</span><span>(</span><span>9</span><span>,</span> <span>"val9"</span><span>,</span> <span>(</span>value<span>,</span> newValue<span>)</span> <span>-></span> value<span>.</span><span>concat</span><span>(</span>newValue<span>)</span><span>)</span><span>;</span>
map<span>.</span><span>get</span><span>(</span><span>9</span><span>)</span><span>;</span>             <span>// val9</span>
map<span>.</span><span>merge</span><span>(</span><span>9</span><span>,</span> <span>"concat"</span><span>,</span> <span>(</span>value<span>,</span> newValue<span>)</span> <span>-></span> value<span>.</span><span>concat</span><span>(</span>newValue<span>)</span><span>)</span><span>;</span>
map<span>.</span><span>get</span><span>(</span><span>9</span><span>)</span><span>;</span>             <span>// val9concat</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Merge 做的事情是如果键名不存在则插入，否则对原键对应的值做合并操作并重新插入到map中。</p>
<h2 id="date-api-日期相关api"> Date API(日期相关API)</h2>
<p>Java 8在 <code>java.time</code> 包下包含一个全新的日期和时间API。新的Date API与Joda-Time库相似，但它们不一样。以下示例涵盖了此新 API 的最重要部分。译者对这部分内容参考相关书籍做了大部分修改。</p>
<p><strong>译者注(总结)：</strong></p>
<ul>
<li>
<p>Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 <code>System.currentTimeMillis()</code> 来获取当前的微秒数。某一个特定的时间点也可以使用 <code>Instant</code> 类来表示，<code>Instant</code> 类也可以用来创建旧版本的<code>java.util.Date</code> 对象。</p>
</li>
<li>
<p>在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类<code>ZoneId</code>（在<code>java.time</code>包中）表示一个区域标识符。 它有一个名为<code>getAvailableZoneIds</code>的静态方法，它返回所有区域标识符。</p>
</li>
<li>
<p>jdk1.8中新增了 LocalDate 与 LocalDateTime等类来解决日期处理方法，同时引入了一个新的类DateTimeFormatter 来解决日期格式化问题。可以使用Instant代替 Date，LocalDateTime代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat。</p>
</li>
</ul>
<h3 id="clock"> Clock</h3>
<p>Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 <code>System.currentTimeMillis()</code> 来获取当前的微秒数。某一个特定的时间点也可以使用 <code>Instant</code> 类来表示，<code>Instant</code> 类也可以用来创建旧版本的<code>java.util.Date</code> 对象。</p>
<div><pre><code><span>Clock</span> clock <span>=</span> <span>Clock</span><span>.</span><span>systemDefaultZone</span><span>(</span><span>)</span><span>;</span>
<span>long</span> millis <span>=</span> clock<span>.</span><span>millis</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>millis<span>)</span><span>;</span><span>//1552379579043</span>
<span>Instant</span> instant <span>=</span> clock<span>.</span><span>instant</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>instant<span>)</span><span>;</span>
<span>Date</span> legacyDate <span>=</span> <span>Date</span><span>.</span><span>from</span><span>(</span>instant<span>)</span><span>;</span> <span>//2019-03-12T08:46:42.588Z</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>legacyDate<span>)</span><span>;</span><span>//Tue Mar 12 16:32:59 CST 2019</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="timezones-时区"> Timezones(时区)</h3>
<p>在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类<code>ZoneId</code>（在<code>java.time</code>包中）表示一个区域标识符。 它有一个名为<code>getAvailableZoneIds</code>的静态方法，它返回所有区域标识符。</p>
<div><pre><code><span>//输出所有区域标识符</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>ZoneId</span><span>.</span><span>getAvailableZoneIds</span><span>(</span><span>)</span><span>)</span><span>;</span>

<span>ZoneId</span> zone1 <span>=</span> <span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"Europe/Berlin"</span><span>)</span><span>;</span>
<span>ZoneId</span> zone2 <span>=</span> <span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"Brazil/East"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zone1<span>.</span><span>getRules</span><span>(</span><span>)</span><span>)</span><span>;</span><span>// ZoneRules[currentStandardOffset=+01:00]</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zone2<span>.</span><span>getRules</span><span>(</span><span>)</span><span>)</span><span>;</span><span>// ZoneRules[currentStandardOffset=-03:00]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="localtime-本地时间"> LocalTime(本地时间)</h3>
<p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>
<div><pre><code><span>LocalTime</span> now1 <span>=</span> <span>LocalTime</span><span>.</span><span>now</span><span>(</span>zone1<span>)</span><span>;</span>
<span>LocalTime</span> now2 <span>=</span> <span>LocalTime</span><span>.</span><span>now</span><span>(</span>zone2<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>now1<span>.</span><span>isBefore</span><span>(</span>now2<span>)</span><span>)</span><span>;</span>  <span>// false</span>

<span>long</span> hoursBetween <span>=</span> <span>ChronoUnit</span><span>.</span>HOURS<span>.</span><span>between</span><span>(</span>now1<span>,</span> now2<span>)</span><span>;</span>
<span>long</span> minutesBetween <span>=</span> <span>ChronoUnit</span><span>.</span>MINUTES<span>.</span><span>between</span><span>(</span>now1<span>,</span> now2<span>)</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>hoursBetween<span>)</span><span>;</span>       <span>// -3</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>minutesBetween<span>)</span><span>;</span>     <span>// -239</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串.</p>
<div><pre><code><span>LocalTime</span> late <span>=</span> <span>LocalTime</span><span>.</span><span>of</span><span>(</span><span>23</span><span>,</span> <span>59</span><span>,</span> <span>59</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>late<span>)</span><span>;</span>       <span>// 23:59:59</span>
<span>DateTimeFormatter</span> germanFormatter <span>=</span>
    <span>DateTimeFormatter</span>
        <span>.</span><span>ofLocalizedTime</span><span>(</span><span>FormatStyle</span><span>.</span>SHORT<span>)</span>
        <span>.</span><span>withLocale</span><span>(</span><span>Locale</span><span>.</span>GERMAN<span>)</span><span>;</span>

<span>LocalTime</span> leetTime <span>=</span> <span>LocalTime</span><span>.</span><span>parse</span><span>(</span><span>"13:37"</span><span>,</span> germanFormatter<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>leetTime<span>)</span><span>;</span>   <span>// 13:37</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="localdate-本地日期"> LocalDate(本地日期)</h3>
<p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p>
<div><pre><code><span>LocalDate</span> today <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span><span>//获取现在的日期</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"今天的日期: "</span><span>+</span>today<span>)</span><span>;</span><span>//2019-03-12</span>
<span>LocalDate</span> tomorrow <span>=</span> today<span>.</span><span>plus</span><span>(</span><span>1</span><span>,</span> <span>ChronoUnit</span><span>.</span>DAYS<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"明天的日期: "</span><span>+</span>tomorrow<span>)</span><span>;</span><span>//2019-03-13</span>
<span>LocalDate</span> yesterday <span>=</span> tomorrow<span>.</span><span>minusDays</span><span>(</span><span>2</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"昨天的日期: "</span><span>+</span>yesterday<span>)</span><span>;</span><span>//2019-03-11</span>
<span>LocalDate</span> independenceDay <span>=</span> <span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>Month</span><span>.</span>MARCH<span>,</span> <span>12</span><span>)</span><span>;</span>
<span>DayOfWeek</span> dayOfWeek <span>=</span> independenceDay<span>.</span><span>getDayOfWeek</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"今天是周几:"</span><span>+</span>dayOfWeek<span>)</span><span>;</span><span>//TUESDAY</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>从字符串解析一个 LocalDate 类型和解析 LocalTime 一样简单,下面是使用  <code>DateTimeFormatter</code> 解析字符串的例子：</p>
<div><pre><code>    <span>String</span> str1 <span>=</span> <span>"2014==04==12 01时06分09秒"</span><span>;</span>
        <span>// 根据需要解析的日期、时间字符串定义解析所用的格式器</span>
        <span>DateTimeFormatter</span> fomatter1 <span>=</span> <span>DateTimeFormatter</span>
                <span>.</span><span>ofPattern</span><span>(</span><span>"yyyy==MM==dd HH时mm分ss秒"</span><span>)</span><span>;</span>

        <span>LocalDateTime</span> dt1 <span>=</span> <span>LocalDateTime</span><span>.</span><span>parse</span><span>(</span>str1<span>,</span> fomatter1<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt1<span>)</span><span>;</span> <span>// 输出 2014-04-12T01:06:09</span>

        <span>String</span> str2 <span>=</span> <span>"2014$$$四月$$$13 20小时"</span><span>;</span>
        <span>DateTimeFormatter</span> fomatter2 <span>=</span> <span>DateTimeFormatter</span>
                <span>.</span><span>ofPattern</span><span>(</span><span>"yyy$$$MMM$$$dd HH小时"</span><span>)</span><span>;</span>
        <span>LocalDateTime</span> dt2 <span>=</span> <span>LocalDateTime</span><span>.</span><span>parse</span><span>(</span>str2<span>,</span> fomatter2<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt2<span>)</span><span>;</span> <span>// 输出 2014-04-13T20:00</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>再来看一个使用 <code>DateTimeFormatter</code> 格式化日期的示例</p>
<div><pre><code><span>LocalDateTime</span> rightNow<span>=</span><span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
<span>String</span> date<span>=</span><span>DateTimeFormatter</span><span>.</span>ISO_LOCAL_DATE_TIME<span>.</span><span>format</span><span>(</span>rightNow<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>)</span><span>;</span><span>//2019-03-12T16:26:48.29</span>
<span>DateTimeFormatter</span> formatter<span>=</span><span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"YYYY-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>formatter<span>.</span><span>format</span><span>(</span>rightNow<span>)</span><span>)</span><span>;</span><span>//2019-03-12 16:26:48</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>🐛 修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/1157" target="_blank" rel="noopener noreferrer">issue#1157</a>）</strong>：使用 <code>YYYY</code> 显示年份时，会显示当前时间所在周的年份，在跨年周会有问题。一般情况下都使用 <code>yyyy</code>，来显示准确的年份。</p>
<p>跨年导致日期显示错误示例：</p>
<div><pre><code><span>LocalDateTime</span> rightNow <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2020</span><span>,</span> <span>12</span><span>,</span> <span>31</span><span>,</span> <span>12</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
<span>String</span> date<span>=</span> <span>DateTimeFormatter</span><span>.</span>ISO_LOCAL_DATE_TIME<span>.</span><span>format</span><span>(</span>rightNow<span>)</span><span>;</span>
<span>// 2020-12-31T12:00:00</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>)</span><span>;</span>
<span>DateTimeFormatter</span> formatterOfYYYY <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"YYYY-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
<span>// 2021-12-31 12:00:00</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>formatterOfYYYY<span>.</span><span>format</span><span>(</span>rightNow<span>)</span><span>)</span><span>;</span>

<span>DateTimeFormatter</span> formatterOfYyyy <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
<span>// 2020-12-31 12:00:00</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>formatterOfYyyy<span>.</span><span>format</span><span>(</span>rightNow<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>从下图可以更清晰的看到具体的错误，并且 IDEA 已经智能地提示更倾向于使用  <code>yyyy</code> 而不是  <code>YYYY</code> 。</p>
<p><img src="https://img-blog.csdnimg.cn/2021042717491413.png" alt="" /></p>
<h3 id="localdatetime-本地日期时间"> LocalDateTime(本地日期时间)</h3>
<p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime 和 LocalTime还有 LocalDate 一样，都是不可变的。LocalDateTime 提供了一些能访问具体字段的方法。</p>
<div><pre><code><span>LocalDateTime</span> sylvester <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2014</span><span>,</span> <span>Month</span><span>.</span>DECEMBER<span>,</span> <span>31</span><span>,</span> <span>23</span><span>,</span> <span>59</span><span>,</span> <span>59</span><span>)</span><span>;</span>

<span>DayOfWeek</span> dayOfWeek <span>=</span> sylvester<span>.</span><span>getDayOfWeek</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dayOfWeek<span>)</span><span>;</span>      <span>// WEDNESDAY</span>

<span>Month</span> month <span>=</span> sylvester<span>.</span><span>getMonth</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>month<span>)</span><span>;</span>          <span>// DECEMBER</span>

<span>long</span> minuteOfDay <span>=</span> sylvester<span>.</span><span>getLong</span><span>(</span><span>ChronoField</span><span>.</span>MINUTE_OF_DAY<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>minuteOfDay<span>)</span><span>;</span>    <span>// 1439</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的<code>java.util.Date</code>。</p>
<div><pre><code><span>Instant</span> instant <span>=</span> sylvester
        <span>.</span><span>atZone</span><span>(</span><span>ZoneId</span><span>.</span><span>systemDefault</span><span>(</span><span>)</span><span>)</span>
        <span>.</span><span>toInstant</span><span>(</span><span>)</span><span>;</span>

<span>Date</span> legacyDate <span>=</span> <span>Date</span><span>.</span><span>from</span><span>(</span>instant<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>legacyDate<span>)</span><span>;</span>     <span>// Wed Dec 31 23:59:59 CET 2014</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p>
<div><pre><code><span>DateTimeFormatter</span> formatter <span>=</span>
    <span>DateTimeFormatter</span>
        <span>.</span><span>ofPattern</span><span>(</span><span>"MMM dd, yyyy - HH:mm"</span><span>)</span><span>;</span>
<span>LocalDateTime</span> parsed <span>=</span> <span>LocalDateTime</span><span>.</span><span>parse</span><span>(</span><span>"Nov 03, 2014 - 07:13"</span><span>,</span> formatter<span>)</span><span>;</span>
<span>String</span> string <span>=</span> formatter<span>.</span><span>format</span><span>(</span>parsed<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>string<span>)</span><span>;</span>     <span>// Nov 03, 2014 - 07:13</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。
关于时间日期格式的详细信息在<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener noreferrer">这里</a>。</p>
<h2 id="annotations-注解"> Annotations(注解)</h2>
<p>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。
首先定义一个包装类Hints注解用来放置一组具体的Hint注解：</p>
<div><pre><code><span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>Hints</span> <span>{</span>
    <span>Hint</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>@Repeatable</span><span>(</span><span>Hints</span><span>.</span><span>class</span><span>)</span>
<span>@interface</span> <span>Hint</span> <span>{</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下<code>@Repeatable</code>即可。</p>
<p>例 1: 使用包装类当容器来存多个注解（老方法）</p>
<div><pre><code><span>@Hints</span><span>(</span><span>{</span><span>@Hint</span><span>(</span><span>"hint1"</span><span>)</span><span>,</span> <span>@Hint</span><span>(</span><span>"hint2"</span><span>)</span><span>}</span><span>)</span>
<span>class</span> <span>Person</span> <span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>例 2：使用多重注解（新方法）</p>
<div><pre><code><span>@Hint</span><span>(</span><span>"hint1"</span><span>)</span>
<span>@Hint</span><span>(</span><span>"hint2"</span><span>)</span>
<span>class</span> <span>Person</span> <span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：</p>
<div><pre><code><span>Hint</span> hint <span>=</span> <span>Person</span><span>.</span><span>class</span><span>.</span><span>getAnnotation</span><span>(</span><span>Hint</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>hint<span>)</span><span>;</span>                   <span>// null</span>
<span>Hints</span> hints1 <span>=</span> <span>Person</span><span>.</span><span>class</span><span>.</span><span>getAnnotation</span><span>(</span><span>Hints</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>hints1<span>.</span><span>value</span><span>(</span><span>)</span><span>.</span>length<span>)</span><span>;</span>  <span>// 2</span>

<span>Hint</span><span>[</span><span>]</span> hints2 <span>=</span> <span>Person</span><span>.</span><span>class</span><span>.</span><span>getAnnotationsByType</span><span>(</span><span>Hint</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>hints2<span>.</span>length<span>)</span><span>;</span>          <span>// 2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>即便我们没有在 <code>Person</code>类上定义 <code>@Hints</code>注解，我们还是可以通过 <code>getAnnotation(Hints.class)</code>来获取 <code>@Hints</code>注解，更加方便的方法是使用 <code>getAnnotationsByType</code> 可以直接获取到所有的<code>@Hint</code>注解。
另外Java 8的注解还增加到两种新的target上了：</p>
<div><pre><code><span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>TYPE_PARAMETER<span>,</span> <span>ElementType</span><span>.</span>TYPE_USE<span>}</span><span>)</span>
<span>@interface</span> <span>MyAnnotation</span> <span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="where-to-go-from-here"> Where to go from here?</h2>
<p>关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如<code>Arrays.parallelSort</code>, <code>StampedLock</code>和<code>CompletableFuture</code>等等。</p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/@FunctionalInterface.png" type="image/png"/>
    </item>
    <item>
      <title>JAD 反编译</title>
      <link>https://javaguide.cn/java/tips/jad/</link>
      <guid>https://javaguide.cn/java/tips/jad/</guid>
      <source url="https://javaguide.cn/rss.xml">JAD 反编译</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="jad-反编译"> JAD 反编译</h1>
<p><a href="https://varaneckas.com/jad/" target="_blank" rel="noopener noreferrer">jad</a>反编译工具，已经不再更新，且只支持 JDK1.4，但并不影响其强大的功能。</p>
<p>基本用法：<code>jad xxx.class</code>，会生成直接可读的 <code>xxx.jad</code> 文件。</p>
<h2 id="自动拆装箱"> 自动拆装箱</h2>
<p>对于基本类型和包装类型之间的转换，通过 xxxValue()和 valueOf()两个方法完成自动拆装箱，使用 jad 进行反编译可以看到该过程：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Demo</span> <span>{</span>
  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span> x <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>10</span><span>)</span><span>;</span>  <span>// 自动拆箱</span>
    <span>Integer</span> y <span>=</span> x<span>;</span>            <span>// 自动装箱</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>反编译后结果：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Demo</span>
<span>{</span>
    <span>public</span> <span>Demo</span><span>(</span><span>)</span><span>{</span><span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span> args<span>[</span><span>]</span><span>)</span>
    <span>{</span>
        <span>int</span> i <span>=</span> <span>(</span><span>new</span> <span>Integer</span><span>(</span><span>10</span><span>)</span><span>)</span><span>.</span><span>intValue</span><span>(</span><span>)</span><span>;</span>   <span>// intValue()拆箱</span>
        <span>Integer</span> integer <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>i<span>)</span><span>;</span>   <span>// valueOf()装箱</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="foreach-语法糖"> foreach 语法糖</h2>
<p>在遍历迭代时可以 foreach 语法糖，对于数组类型直接转换成 for 循环：</p>
<div><pre><code><span>// 原始代码</span>
<span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>}</span><span>;</span>
	<span>for</span><span>(</span><span>int</span> item<span>:</span> arr<span>)</span> <span>{</span>
    	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>item<span>)</span><span>;</span>
	<span>}</span>
<span>}</span>

<span>// 反编译后代码</span>
<span>int</span> ai<span>[</span><span>]</span> <span>=</span> <span>{</span>
    <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span>
<span>}</span><span>;</span>
<span>int</span> ai1<span>[</span><span>]</span> <span>=</span> ai<span>;</span>
<span>int</span> i <span>=</span> ai1<span>.</span>length<span>;</span>
<span>// 转换成for循环</span>
<span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span>
<span>{</span>
    <span>int</span> k <span>=</span> ai1<span>[</span>j<span>]</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>k<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>对于容器类的遍历会使用 iterator 进行迭代：</p>
<div><pre><code><span>import</span> <span>java<span>.</span>io<span>.</span></span><span>PrintStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>*</span><span>;</span>

<span>public</span> <span>class</span> <span>Demo</span>
<span>{</span>
    <span>public</span> <span>Demo</span><span>(</span><span>)</span> <span>{</span><span>}</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span> args<span>[</span><span>]</span><span>)</span>
    <span>{</span>
        <span>ArrayList</span> arraylist <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>
        arraylist<span>.</span><span>add</span><span>(</span><span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span>
        arraylist<span>.</span><span>add</span><span>(</span><span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>
        arraylist<span>.</span><span>add</span><span>(</span><span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>3</span><span>)</span><span>)</span><span>;</span>
        <span>Integer</span> integer<span>;</span>
        <span>// 使用的for循环+Iterator，类似于链表迭代：</span>
        <span>// for (ListNode cur = head; cur != null; System.out.println(cur.val)){</span>
        <span>//     cur = cur.next;</span>
    	<span>// }</span>
        <span>for</span><span>(</span><span>Iterator</span> iterator <span>=</span> arraylist<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span> iterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>;</span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>integer<span>)</span><span>)</span>
            integer <span>=</span> <span>(</span><span>Integer</span><span>)</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="arrays-aslist-t"> Arrays.asList(T...)</h2>
<p>熟悉 Arrays.asList(T...)用法的小伙伴都应该知道，asList()方法传入的参数不能是基本类型的数组，必须包装成包装类型再使用，否则对应生成的列表的大小永远是 1：</p>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>*</span><span>;</span>
<span>public</span> <span>class</span> <span>Demo</span> <span>{</span>
  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> arr1 <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>;</span>
    <span>Integer</span><span>[</span><span>]</span> arr2 <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>;</span>
    <span>List</span> lists1 <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>arr1<span>)</span><span>;</span>
    <span>List</span> lists2 <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>arr2<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>lists1<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 1</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>lists2<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 3</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>从反编译结果来解释，为什么传入基本类型的数组后，返回的 List 大小是 1：</p>
<div><pre><code><span>// 反编译后文件</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>PrintStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Arrays</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>List</span><span>;</span>

<span>public</span> <span>class</span> <span>Demo</span>
<span>{</span>
    <span>public</span> <span>Demo</span><span>(</span><span>)</span> <span>{</span><span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span> args<span>[</span><span>]</span><span>)</span>
    <span>{</span>
        <span>int</span> ai<span>[</span><span>]</span> <span>=</span> <span>{</span>
            <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span>
        <span>}</span><span>;</span>
        <span>// 使用包装类型，全部元素由int包装为Integer</span>
        <span>Integer</span> ainteger<span>[</span><span>]</span> <span>=</span> <span>{</span>
            <span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>1</span><span>)</span><span>,</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>2</span><span>)</span><span>,</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>3</span><span>)</span>
        <span>}</span><span>;</span>

        <span>// 注意这里被反编译成二维数组，而且是一个1行三列的二维数组</span>
        <span>// list.size()当然返回1</span>
        <span>List</span> list <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>new</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>{</span> ai <span>}</span><span>)</span><span>;</span>
        <span>List</span> list1 <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>ainteger<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>list<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>list1<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>从上面结果可以看到，传入基本类型的数组后，会被转换成一个二维数组，而且是**new int[1][arr.length]**这样的数组，调用 list.size()当然返回 1。</p>
<h2 id="注解"> 注解</h2>
<p>Java 中的类、接口、枚举、注解都可以看做是类类型。使用 jad 来看一下@interface 被转换成什么：</p>
<div><pre><code><span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Retention</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>RetentionPolicy</span><span>;</span>

<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>Foo</span><span>{</span>
  <span>String</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
  <span>boolean</span> <span>bar</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>查看反编译代码可以看出：</p>
<ul>
<li>自定义的注解类 Foo 被转换成接口 Foo，并且继承 Annotation 接口</li>
<li>原来自定义接口中的 value()和 bar()被转换成抽象方法</li>
</ul>
<div><pre><code><span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Annotation</span><span>;</span>

<span>public</span> <span>interface</span> <span>Foo</span>
    <span>extends</span> <span>Annotation</span>
<span>{</span>
    <span>public</span> <span>abstract</span> <span>String</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>boolean</span> <span>bar</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>注解通常和反射配合使用，而且既然自定义的注解最终被转换成接口，注解中的属性被转换成接口中的抽象方法，那么通过反射之后拿到接口实例，在通过接口实例自然能够调用对应的抽象方法：</p>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Arrays</span><span>;</span>

<span>@Foo</span><span>(</span>value<span>=</span><span>{</span><span>"sherman"</span><span>,</span> <span>"decompiler"</span><span>}</span><span>,</span> bar<span>=</span><span>true</span><span>)</span>
<span>public</span> <span>class</span> <span>Demo</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Foo</span> foo <span>=</span> <span>Demo</span><span>.</span><span>class</span><span>.</span><span>getAnnotation</span><span>(</span><span>Foo</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>foo<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span> <span>// [sherman, decompiler]</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>foo<span>.</span><span>bar</span><span>(</span><span>)</span><span>)</span><span>;</span>                    <span>// true</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="枚举"> 枚举</h2>
<p>通过 jad 反编译可以很好地理解枚举类。</p>
<h3 id="空枚举"> 空枚举</h3>
<p>先定义一个空的枚举类：</p>
<div><pre><code><span>public</span> <span>enum</span> <span>DummyEnum</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>使用 jad 反编译查看结果：</p>
<ul>
<li>自定义枚举类被转换成 final 类，并且继承 Enum</li>
<li>提供了两个参数（name，odinal）的私有构造器，并且调用了父类的构造器。注意即使没有提供任何参数，也会有该构造器，其中 name 就是枚举实例的名称，odinal 是枚举实例的索引号</li>
<li>初始化了一个 private static final 自定义类型的空数组 <strong>$VALUES</strong></li>
<li>提供了两个 public static 方法：
<ul>
<li>values()方法通过 clone()方法返回内部$VALUES 的浅拷贝。这个方法结合私有构造器可以完美实现单例模式，想一想 values()方法是不是和单例模式中 getInstance()方法功能类似</li>
<li>valueOf(String s)：调用父类 Enum 的 valueOf 方法并强转返回</li>
</ul>
</li>
</ul>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>DummyEnum</span> <span>extends</span> <span>Enum</span>
<span>{</span>
	<span>// 功能和单例模式的getInstance()方法相同</span>
    <span>public</span> <span>static</span> <span>DummyEnum</span><span>[</span><span>]</span> <span>values</span><span>(</span><span>)</span>
    <span>{</span>
        <span>return</span> <span>(</span><span>DummyEnum</span><span>[</span><span>]</span><span>)</span>$VALUES<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
	<span>// 调用父类的valueOf方法，并强转返回</span>
    <span>public</span> <span>static</span> <span>DummyEnum</span> <span>valueOf</span><span>(</span><span>String</span> s<span>)</span>
    <span>{</span>
        <span>return</span> <span>(</span><span>DummyEnum</span><span>)</span><span>Enum</span><span>.</span><span>valueOf</span><span>(</span><span>DummyEnum</span><span>,</span> s<span>)</span><span>;</span>
    <span>}</span>
	<span>// 默认提供一个私有的两个参数的构造器，并调用父类Enum的构造器</span>
    <span>private</span> <span>DummyEnum</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> i<span>)</span>
    <span>{</span>
        <span>super</span><span>(</span>s<span>,</span> i<span>)</span><span>;</span>
    <span>}</span>
	<span>// 初始化一个private static final的本类空数组</span>
    <span>private</span> <span>static</span> <span>final</span> <span>DummyEnum</span> $VALUES<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>DummyEnum</span><span>[</span><span>0</span><span>]</span><span>;</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="包含抽象方法的枚举"> 包含抽象方法的枚举</h3>
<p>枚举类中也可以包含抽象方法，但是必须定义枚举实例并且立即重写抽象方法，就像下面这样：</p>
<div><pre><code><span>public</span> <span>enum</span> <span>DummyEnum</span> <span>{</span>
    DUMMY1 <span>{</span>
        <span>public</span> <span>void</span> <span>dummyMethod</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"[1]: implements abstract method in enum class"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>,</span>

    DUMMY2 <span>{</span>
        <span>public</span> <span>void</span> <span>dummyMethod</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"[2]: implements abstract method in enum class"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>

    <span>abstract</span> <span>void</span> <span>dummyMethod</span><span>(</span><span>)</span><span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>再来反编译看看有哪些变化：</p>
<ul>
<li>原来 final class 变成了 abstract class：这很好理解，有抽象方法的类自然是抽象类</li>
<li>多了两个 public static final 的成员 DUMMY1、DUMMY2，这两个实例的初始化过程被放到了 static 代码块中，并且实例过程中直接重写了抽象方法，类似于匿名内部类的形式。</li>
<li>数组 <strong>$VALUES[]</strong> 初始化时放入枚举实例</li>
</ul>
<p>还有其它变化么？</p>
<p>在反编译后的 DummyEnum 类中，是存在抽象方法的，而枚举实例在静态代码块中初始化过程中重写了抽象方法。在 Java 中，抽象方法和抽象方法重写同时放在一个类中，只能通过内部类形式完成。因此上面第二点应该说成就是以内部类形式初始化。</p>
<p>可以看一下 DummyEnum.class 存放的位置，应该多了两个文件：</p>
<ul>
<li>DummyEnum$1.class</li>
<li>DummyEnum$2.class</li>
</ul>
<p>Java 中.class 文件出现 $ 符号表示有内部类存在，就像OutClass$InnerClass，这两个文件出现也应证了上面的匿名内部类初始化的说法。</p>
<div><pre><code><span>import</span> <span>java<span>.</span>io<span>.</span></span><span>PrintStream</span><span>;</span>

<span>public</span> <span>abstract</span> <span>class</span> <span>DummyEnum</span> <span>extends</span> <span>Enum</span>
<span>{</span>
    <span>public</span> <span>static</span> <span>DummyEnum</span><span>[</span><span>]</span> <span>values</span><span>(</span><span>)</span>
    <span>{</span>
        <span>return</span> <span>(</span><span>DummyEnum</span><span>[</span><span>]</span><span>)</span>$VALUES<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>DummyEnum</span> <span>valueOf</span><span>(</span><span>String</span> s<span>)</span>
    <span>{</span>
        <span>return</span> <span>(</span><span>DummyEnum</span><span>)</span><span>Enum</span><span>.</span><span>valueOf</span><span>(</span><span>DummyEnum</span><span>,</span> s<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>DummyEnum</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> i<span>)</span>
    <span>{</span>
        <span>super</span><span>(</span>s<span>,</span> i<span>)</span><span>;</span>
    <span>}</span>

	<span>// 抽象方法</span>
    <span>abstract</span> <span>void</span> <span>dummyMethod</span><span>(</span><span>)</span><span>;</span>

	<span>// 两个pubic static final实例</span>
    <span>public</span> <span>static</span> <span>final</span> <span>DummyEnum</span> DUMMY1<span>;</span>
    <span>public</span> <span>static</span> <span>final</span> <span>DummyEnum</span> DUMMY2<span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>DummyEnum</span> $VALUES<span>[</span><span>]</span><span>;</span>

 	<span>// static代码块进行初始化</span>
    <span>static</span>
    <span>{</span>
        DUMMY1 <span>=</span> <span>new</span> <span>DummyEnum</span><span>(</span><span>"DUMMY1"</span><span>,</span> <span>0</span><span>)</span> <span>{</span>
            <span>public</span> <span>void</span> <span>dummyMethod</span><span>(</span><span>)</span>
            <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"[1]: implements abstract method in enum class"</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
<span>;</span>
        DUMMY2 <span>=</span> <span>new</span> <span>DummyEnum</span><span>(</span><span>"DUMMY2"</span><span>,</span> <span>1</span><span>)</span> <span>{</span>
            <span>public</span> <span>void</span> <span>dummyMethod</span><span>(</span><span>)</span>
            <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"[2]: implements abstract method in enum class"</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
<span>;</span>
		<span>// 对本类数组进行初始化</span>
        $VALUES <span>=</span> <span>(</span><span>new</span> <span>DummyEnum</span><span>[</span><span>]</span> <span>{</span>
            DUMMY1<span>,</span> DUMMY2
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h3 id="正常的枚举类"> 正常的枚举类</h3>
<p>实际开发中，枚举类通常的形式是有两个参数（int code，Sring msg）的构造器，可以作为状态码进行返回。Enum 类实际上也是提供了包含两个参数且是 protected 的构造器，这里为了避免歧义，将枚举类的构造器设置为三个，使用 jad 反编译：</p>
<p>最大的变化是：现在的 private 构造器从 2 个参数变成 5 个，而且在内部仍然将前两个参数通过 super 传递给父类，剩余的三个参数才是真正自己提供的参数。可以想象，如果自定义的枚举类只提供了一个参数，最终生成底层代码中 private 构造器应该有三个参数，前两个依然通过 super 传递给父类。</p>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>CustomEnum</span> <span>extends</span> <span>Enum</span>
<span>{</span>
    <span>public</span> <span>static</span> <span>CustomEnum</span><span>[</span><span>]</span> <span>values</span><span>(</span><span>)</span>
    <span>{</span>
        <span>return</span> <span>(</span><span>CustomEnum</span><span>[</span><span>]</span><span>)</span>$VALUES<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>CustomEnum</span> <span>valueOf</span><span>(</span><span>String</span> s<span>)</span>
    <span>{</span>
        <span>return</span> <span>(</span><span>CustomEnum</span><span>)</span><span>Enum</span><span>.</span><span>valueOf</span><span>(</span><span>CustomEnum</span><span>,</span> s<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>CustomEnum</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>,</span> <span>String</span> s1<span>,</span> <span>Object</span> obj<span>)</span>
    <span>{</span>
        <span>super</span><span>(</span>s<span>,</span> i<span>)</span><span>;</span>
        code <span>=</span> j<span>;</span>
        msg <span>=</span> s1<span>;</span>
        data <span>=</span> obj<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>final</span> <span>CustomEnum</span> FIRST<span>;</span>
    <span>public</span> <span>static</span> <span>final</span> <span>CustomEnum</span> SECOND<span>;</span>
    <span>public</span> <span>static</span> <span>final</span> <span>CustomEnum</span> THIRD<span>;</span>
    <span>private</span> <span>int</span> code<span>;</span>
    <span>private</span> <span>String</span> msg<span>;</span>
    <span>private</span> <span>Object</span> data<span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>CustomEnum</span> $VALUES<span>[</span><span>]</span><span>;</span>

    <span>static</span>
    <span>{</span>
        FIRST <span>=</span> <span>new</span> <span>CustomEnum</span><span>(</span><span>"FIRST"</span><span>,</span> <span>0</span><span>,</span> <span>10010</span><span>,</span> <span>"first"</span><span>,</span> <span>Long</span><span>.</span><span>valueOf</span><span>(</span><span>100L</span><span>)</span><span>)</span><span>;</span>
        SECOND <span>=</span> <span>new</span> <span>CustomEnum</span><span>(</span><span>"SECOND"</span><span>,</span> <span>1</span><span>,</span> <span>10020</span><span>,</span> <span>"second"</span><span>,</span> <span>"Foo"</span><span>)</span><span>;</span>
        THIRD <span>=</span> <span>new</span> <span>CustomEnum</span><span>(</span><span>"THIRD"</span><span>,</span> <span>2</span><span>,</span> <span>10030</span><span>,</span> <span>"third"</span><span>,</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>)</span><span>;</span>
        $VALUES <span>=</span> <span>(</span><span>new</span> <span>CustomEnum</span><span>[</span><span>]</span> <span>{</span>
            FIRST<span>,</span> SECOND<span>,</span> THIRD
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>一文带你看遍 JDK9~15 的重要新特性！</title>
      <link>https://javaguide.cn/java/new-features/java%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</link>
      <guid>https://javaguide.cn/java/new-features/java%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</guid>
      <source url="https://javaguide.cn/rss.xml">一文带你看遍 JDK9~15 的重要新特性！</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="一文带你看遍-jdk9-15-的重要新特性"> 一文带你看遍 JDK9~15 的重要新特性！</h1>
<p>Java 8 新特性见这里：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484744&amp;idx=1&amp;sn=9db31dca13d327678845054af75efb74&amp;chksm=cea24a83f9d5c3956f4feb9956b068624ab2fdd6c4a75fe52d5df5dca356a016577301399548&amp;token=1082669959&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">Java8 新特性最佳指南</a> 。</p>
<p>你可以在 <a href="http://jdk.java.net/archive/" target="_blank" rel="noopener noreferrer">Archived OpenJDK General-Availability Releases</a> 上下载自己需要的 JDK 版本！</p>
<p>官方的新特性说明文档地址： https://openjdk.java.net/projects/jdk/ 。</p>
<p><em>Guide ：别人家的特性都用了几年了，我 Java 才出来，哈哈！真实！</em></p>
<h2 id="java9"> Java9</h2>
<p>发布于 2017 年 9 月 21 日 。作为 Java8 之后 3 年半才发布的新版本，Java 9 带 来了很多重大的变化其中最重要的改动是 Java 平台模块系统的引入，其他还有诸如集合、Stream 流</p>
<h3 id="java-平台模块系统"> Java 平台模块系统</h3>
<p>Java 平台模块系统是<a href="https://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener noreferrer">Jigsaw Project</a>的一部分，把模块化开发实践引入到了 Java 平台中，可以让我们的代码可重用性更好！</p>
<p>什么是模块系统？官方的定义是：A uniquely named, reusable group of related packages, as well as resources (such as images and XML files) and a module descriptor.</p>
<p>简单来说，你可以将一个模块看作是一组唯一命名、可重用的包、资源和模块描述文件（module-info.java）。</p>
<p>任意一个 jar 文件，只要加上一个 模块描述文件（module-info.java），就可以升级为一个模块。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/module-structure.png" alt="" /></p>
<p>在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。</p>
<p>我们可以通过 exports 关键词精准控制哪些类可以对外开放使用，哪些类只能内部使用。</p>
<div><pre><code><span>module</span> <span>my<span>.</span>module</span> <span>{</span>
    <span>//exports 公开指定包的所有公共成员</span>
    <span>exports</span> <span>com<span>.</span>my<span>.</span>package<span>.</span>name</span><span>;</span>
<span>}</span>

<span>module</span> <span>my<span>.</span>module</span> <span>{</span>
     <span>//exports…to 限制访问的成员范围</span>
    export com<span>.</span>my<span>.</span><span>package</span><span>.</span>name <span>to</span> <span>com<span>.</span>specific<span>.</span>package</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Java 9 模块的重要特征是在其工件（artifact）的根目录中包含了一个描述模块的 <code>module-info.java</code> 文 件。 工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。</p>
<p>想要深入了解 Java 9 的模块化，参见：</p>
<ul>
<li><a href="https://openjdk.java.net/projects/jigsaw/quick-start" target="_blank" rel="noopener noreferrer">《Project Jigsaw: Module System Quick-Start Guide》</a></li>
<li><a href="https://stacktraceguru.com/java9/module-introduction" target="_blank" rel="noopener noreferrer">《Java 9 Modules: part 1》</a></li>
</ul>
<h3 id="jshell"> Jshell</h3>
<p>jshell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。</p>
<p>在 Jshell 中可以直接输入表达式并查看其执行结果。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210816083417616.png" alt="" /></p>
<h3 id="集合增强"> 集合增强</h3>
<p>增加 了 <code>List.of()</code>、<code>Set.of()</code>、<code>Map.of()</code> 和 <code>Map.ofEntries()</code>等工厂方法来创建不可变集合（这部分内容有点参考 Guava 的味道）</p>
<div><pre><code><span>List</span><span>.</span><span>of</span><span>(</span><span>"Java"</span><span>,</span> <span>"C++"</span><span>)</span><span>;</span>
<span>Set</span><span>.</span><span>of</span><span>(</span><span>"Java"</span><span>,</span> <span>"C++"</span><span>)</span><span>;</span>
<span>Map</span><span>.</span><span>of</span><span>(</span><span>"Java"</span><span>,</span> <span>1</span><span>,</span> <span>"C++"</span><span>,</span> <span>2</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用 <code>of()</code> 创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 <code>java.lang.UnsupportedOperationException</code> 异常。</p>
<p><code>Collectors</code> 中增加了新的方法 <code>filtering()</code> 和 <code>flatMapping()</code>。</p>
<p><code>Collectors</code> 的 <code>filtering()</code> 方法类似于 <code>Stream</code> 类的 <code>filter()</code> 方法，都是用于过滤元素。</p>
<blockquote>
<p>Java 8 为 <code>Collectors</code> 类引入了 <code>groupingBy</code> 操作，用于根据特定的属性将对象分组。</p>
</blockquote>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span><span>"x"</span><span>,</span><span>"www"</span><span>,</span> <span>"yy"</span><span>,</span> <span>"zz"</span><span>)</span><span>;</span>
<span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>List</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> result <span>=</span> list<span>.</span><span>stream</span><span>(</span><span>)</span>
        <span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>groupingBy</span><span>(</span><span>String</span><span>::</span><span>length</span><span>,</span>
                <span>Collectors</span><span>.</span><span>filtering</span><span>(</span>s <span>-></span> <span>!</span>s<span>.</span><span>contains</span><span>(</span><span>"z"</span><span>)</span><span>,</span>
                        <span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result<span>)</span><span>;</span> <span>// {1=[x], 2=[yy], 3=[www]}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="stream-optional-增强"> Stream &amp; Optional 增强</h3>
<p><code>Stream</code> 中增加了新的方法 <code>ofNullable()</code>、<code>dropWhile()</code>、<code>takeWhile()</code> 以及 <code>iterate()</code> 方法的重载方法。</p>
<p>Java 9 中的 <code>ofNullable()</code> 方 法允许我们创建一个单元素的 <code>Stream</code>，可以包含一个非空元素，也可以创建一个空 <code>Stream</code>。 而在 Java 8 中则不可以创建空的 <code>Stream</code> 。</p>
<div><pre><code><span>Stream</span><span><span>&lt;</span><span>String</span><span>></span></span> stringStream <span>=</span> <span>Stream</span><span>.</span><span>ofNullable</span><span>(</span><span>"Java"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>stringStream<span>.</span><span>count</span><span>(</span><span>)</span><span>)</span><span>;</span><span>// 1</span>
<span>Stream</span><span><span>&lt;</span><span>String</span><span>></span></span> nullStream <span>=</span> <span>Stream</span><span>.</span><span>ofNullable</span><span>(</span><span>null</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>nullStream<span>.</span><span>count</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>takeWhile()</code> 方法可以从 <code>Stream</code> 中依次获取满足条件的元素，直到不满足条件为止结束获取。</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> integerList <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span><span>11</span><span>,</span> <span>33</span><span>,</span> <span>66</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>13</span><span>)</span><span>;</span>
integerList<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>takeWhile</span><span>(</span>x <span>-></span> x <span>&lt;</span> <span>50</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span><span>// 11 33</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>dropWhile()</code> 方法的效果和 <code>takeWhile()</code> 相反。</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> integerList2 <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span><span>11</span><span>,</span> <span>33</span><span>,</span> <span>66</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>13</span><span>)</span><span>;</span>
integerList2<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>dropWhile</span><span>(</span>x <span>-></span> x <span>&lt;</span> <span>50</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span><span>// 66 8 9 13</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>iterate()</code> 方法的新重载方法提供了一个 <code>Predicate</code> 参数 (判断条件)来决定什么时候结束迭代</p>
<div><pre><code><span>public</span> <span>static</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>Stream</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>iterate</span><span>(</span><span>final</span> <span>T</span> seed<span>,</span> <span>final</span> <span>UnaryOperator</span><span><span>&lt;</span><span>T</span><span>></span></span> f<span>)</span> <span>{</span>
<span>}</span>
<span>// 新增加的重载方法</span>
<span>public</span> <span>static</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>Stream</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>iterate</span><span>(</span><span>T</span> seed<span>,</span> <span>Predicate</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> hasNext<span>,</span> <span>UnaryOperator</span><span><span>&lt;</span><span>T</span><span>></span></span> next<span>)</span> <span>{</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>两者的使用对比如下，新的 <code>iterate()</code> 重载方法更加灵活一些。</p>
<div><pre><code><span>// 使用原始 iterate() 方法输出数字 1~10</span>
<span>Stream</span><span>.</span><span>iterate</span><span>(</span><span>1</span><span>,</span> i <span>-></span> i <span>+</span> <span>1</span><span>)</span><span>.</span><span>limit</span><span>(</span><span>10</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
<span>// 使用新的 iterate() 重载方法输出数字 1~10</span>
<span>Stream</span><span>.</span><span>iterate</span><span>(</span><span>1</span><span>,</span> i <span>-></span> i <span>&lt;=</span> <span>10</span><span>,</span> i <span>-></span> i <span>+</span> <span>1</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>Optional</code> 类中新增了 <code>ifPresentOrElse()</code>、<code>or()</code> 和 <code>stream()</code> 等方法</p>
<p><code>ifPresentOrElse()</code> 方法接受两个参数 <code>Consumer</code> 和 <code>Runnable</code> ，如果 <code>Optional</code> 不为空调用 <code>Consumer</code> 参数，为空则调用 <code>Runnable</code> 参数。</p>
<div><pre><code><span>public</span> <span>void</span> <span>ifPresentOrElse</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> action<span>,</span> <span>Runnable</span> emptyAction<span>)</span>

<span>Optional</span><span><span>&lt;</span><span>Object</span><span>></span></span> objectOptional <span>=</span> <span>Optional</span><span>.</span><span>empty</span><span>(</span><span>)</span><span>;</span>
objectOptional<span>.</span><span>ifPresentOrElse</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>,</span> <span>(</span><span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Empty!!!"</span><span>)</span><span>)</span><span>;</span><span>// Empty!!!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>or()</code> 方法接受一个 <code>Supplier</code> 参数 ，如果 <code>Optional</code> 为空则返回 <code>Supplier</code> 参数指定的 <code>Optional</code> 值。</p>
<div><pre><code><span>public</span> <span>Optional</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>or</span><span>(</span><span>Supplier</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Optional</span><span>&lt;</span><span>?</span> <span>extends</span> <span>T</span><span>></span><span>></span></span> supplier<span>)</span>

<span>Optional</span><span><span>&lt;</span><span>Object</span><span>></span></span> objectOptional <span>=</span> <span>Optional</span><span>.</span><span>empty</span><span>(</span><span>)</span><span>;</span>
objectOptional<span>.</span><span>or</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>Optional</span><span>.</span><span>of</span><span>(</span><span>"java"</span><span>)</span><span>)</span><span>.</span><span>ifPresent</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span><span>//java</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="string-存储结构变更"> String 存储结构变更</h3>
<p>JDK 8 及之前的版本，<code>String</code> 一直是用 <code>char[]</code> 存储。在 Java 9 之后，<code>String</code> 的实现改用 <code>byte[]</code> 数组存储字符串。</p>
<h3 id="进程-api"> 进程 API</h3>
<p>Java 9 增加了 <code>ProcessHandle</code> 接口，可以对原生进程进行管理，尤其适合于管理长时间运行的进程。</p>
<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>ProcessHandle</span><span>.</span><span>current</span><span>(</span><span>)</span><span>.</span><span>pid</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>ProcessHandle</span><span>.</span><span>current</span><span>(</span><span>)</span><span>.</span><span>info</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210816104614414.png" alt="" /></p>
<h3 id="平台日志-api-和服务"> 平台日志 API 和服务</h3>
<p>Java 9 允许为 JDK 和应用配置同样的日志实现。新增了 <code>System.LoggerFinder</code> 用来管理 JDK 使 用的日志记录器实现。JVM 在运行时只有一个系统范围的 <code>LoggerFinder</code> 实例。</p>
<p>我们可以通过添加自己的 <code>System.LoggerFinder</code> 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。</p>
<h3 id="反应式流-reactive-streams"> 反应式流 （ Reactive Streams ）</h3>
<p>在 Java9 中的 <code>java.util.concurrent.Flow</code> 类中新增了反应式流规范的核心接口 。</p>
<p><code>Flow</code> 中包含了 <code>Flow.Publisher</code>、<code>Flow.Subscriber</code>、<code>Flow.Subscription</code> 和 <code>Flow.Processor</code> 等 4 个核心接口。Java 9 还提供了<code>SubmissionPublisher</code> 作为<code>Flow.Publisher</code> 的一个实现。</p>
<h3 id="变量句柄"> 变量句柄</h3>
<p>变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等</p>
<p>变量句柄的含义类似于已有的方法句柄 <code>MethodHandle</code> ，由 Java 类 <code>java.lang.invoke.VarHandle</code> 来表示，可以使用类 <code>java.lang.invoke.MethodHandles.Lookup</code> 中的静态工厂方法来创建 <code>VarHandle</code> 对象。</p>
<p><code>VarHandle</code> 的出现替代了 <code>java.util.concurrent.atomic</code> 和 <code>sun.misc.Unsafe</code> 的部分操作。并且提供了一系列标准的内存屏障操作，用于更加细粒度的控制内存排序。在安全性、可用性、性能上都要优于现有的 API。</p>
<h3 id="改进方法句柄-method-handle"> 改进方法句柄（Method Handle）</h3>
<p>方法句柄从 Java7 开始引入，Java9 在类<code>java.lang.invoke.MethodHandles</code> 中新增了更多的静态方法来创建不同类型的方法句柄。</p>
<h3 id="接口私有方法"> 接口私有方法</h3>
<p>Java 9 允许在接口中使用私有方法。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>MyInterface</span> <span>{</span>
    <span>private</span> <span>void</span> <span>methodPrivate</span><span>(</span><span>)</span><span>{</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="java9-其它新特性"> Java9 其它新特性</h3>
<ul>
<li><strong>try-with-resources 增强</strong> ：在 try-with-resources 语句中可以使用 effectively-final 变量（什么是 effectively-final 变量，见这篇文章：<a href="https://ilkinulas.github.io/programming/java/2016/03/27/effectively-final-java.html" target="_blank" rel="noopener noreferrer">《Effectively Final Variables in Java》</a></li>
<li>类 <code>CompletableFuture</code> 中增加了几个新的方法（<code>completeAsync</code> ，<code>orTimeout</code> 等）</li>
<li><strong>Nashorn 引擎的增强</strong> ：Nashorn 从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性（Java 11 中已经被弃用）。</li>
<li><strong>I/O 流的新特性</strong> ：增加了新的方法来读取和复制 <code>InputStream</code> 中包含的数据</li>
<li><strong>改进应用的安全性能</strong> ：Java 9 新增了 4 个 SHA- 3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 SHA3-512</li>
<li>......</li>
</ul>
<h2 id="java10"> Java10</h2>
<p>发布于 2018 年 3 月 20 日，最知名的特性应该是 var 关键字（局部变量类型推断）的引入了，其他还有垃圾收集器改善、GC 改进、性能提升、线程管控等一批新特性</p>
<h3 id="var-局部变量推断"> var(局部变量推断)</h3>
<p>由于太多 Java 开发者希望 Java 中引入局部变量推断，于是 Java 10 的时候它来了，也算是众望所归了！</p>
<p>Java 10 提供了 var 关键字声明局部变量。</p>
<blockquote>
<p>Scala 和 Kotlin 中有 val 关键字 ( <code>final var</code> 组合关键字)，Java10 中并没有引入。</p>
</blockquote>
<p>Java 10 只引入了 var，而</p>
<div><pre><code><span>var</span> id <span>=</span> <span>0</span><span>;</span>
<span>var</span> codefx <span>=</span> <span>new</span> <span>URL</span><span>(</span><span>"https://mp.weixin.qq.com/"</span><span>)</span><span>;</span>
<span>var</span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>var</span> list <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
<span>var</span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>var</span> p <span>=</span> <span>Paths</span><span>.</span><span>of</span><span>(</span><span>"src/test/java/Java9FeaturesTest.java"</span><span>)</span><span>;</span>
<span>var</span> numbers <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span><span>"a"</span><span>,</span> <span>"b"</span><span>,</span> <span>"c"</span><span>)</span><span>;</span>
<span>for</span> <span>(</span><span>var</span> n <span>:</span> list<span>)</span>
    <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>n<span>+</span> <span>" "</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>var 关键字只能用于带有构造器的局部变量和 for 循环中。</p>
<div><pre><code><span>var</span> count<span>=</span><span>null</span><span>;</span> <span>//❌编译不通过，不能声明为 null</span>
<span>var</span> r <span>=</span> <span>(</span><span>)</span> <span>-></span> <span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span><span>;</span><span>//❌编译不通过,不能声明为 Lambda表达式</span>
<span>var</span> array <span>=</span> <span>{</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>}</span><span>;</span><span>//❌编译不通过,不能声明数组</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>var 并不会改变 Java 是一门静态类型语言的事实，编译器负责推断出类型。</p>
<p>相关阅读：<a href="https://zhuanlan.zhihu.com/p/34911982" target="_blank" rel="noopener noreferrer">《Java 10 新特性之局部变量类型推断》</a>。</p>
<h3 id="集合增强-2"> 集合增强</h3>
<p><code>list</code>，<code>set</code>，<code>map</code> 提供了静态方法<code>copyOf()</code>返回入参集合的一个不可变拷贝。</p>
<p>以下为 JDK 的源码：</p>
<div><pre><code><span>static</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>copyOf</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> coll<span>)</span> <span>{</span>
    <span>return</span> <span>ImmutableCollections</span><span>.</span><span>listCopy</span><span>(</span>coll<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用 <code>copyOf()</code> 创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 <code>java.lang.UnsupportedOperationException</code> 异常。 IDEA 也会有相应的提示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210816154125579.png" alt="" /></p>
<p><code>java.util.stream.Collectors</code> 中新增了静态方法，用于将流中的元素收集为不可变的集合。</p>
<div><pre><code><span>var</span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
list<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toUnmodifiableList</span><span>(</span><span>)</span><span>)</span><span>;</span>
list<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toUnmodifiableSet</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="optional"> Optional</h3>
<p>新增了<code>orElseThrow()</code>方法来在没有值时抛出指定的异常。</p>
<div><pre><code><span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>cache<span>.</span><span>getIfPresent</span><span>(</span>key<span>)</span><span>)</span>
        <span>.</span><span>orElseThrow</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>new</span> <span>PrestoException</span><span>(</span>NOT_FOUND<span>,</span> <span>"Missing entry found for key: "</span> <span>+</span> key<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="并行全垃圾回收器-g1"> 并行全垃圾回收器 G1</h3>
<p>从 Java9 开始 G1 就了默认的垃圾回收器，G1 是以一种低延时的垃圾回收器来设计的，旨在避免进行 Full GC,但是 Java9 的 G1 的 FullGC 依然是使用单线程去完成标记清除算法,这可能会导致垃圾回收期在无法回收内存的时候触发 Full GC。</p>
<p>为了最大限度地减少 Full GC 造成的应用停顿的影响，从 Java10 开始，G1 的 FullGC 改为并行的标记清除算法，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。</p>
<h3 id="应用程序类数据共享-扩展-cds-功能"> 应用程序类数据共享(扩展 CDS 功能)</h3>
<p>在 Java 5 中就已经引入了类数据共享机制 (Class Data Sharing，简称 CDS)，允许将一组类预处理为共享归档文件，以便在运行时能够进行内存映射以减少 Java 程序的启动时间，当多个 Java 虚拟机（JVM）共享相同的归档文件时，还可以减少动态内存的占用量，同时减少多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用。CDS 在当时还是 Oracle JDK 的商业特性。</p>
<p>Java 10 在现有的 CDS 功能基础上再次拓展，以允许应用类放置在共享存档中。CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS 为 (Application Class-Data Sharing，AppCDS) 支持，大大加大了 CDS 的适用范围。其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升。</p>
<h3 id="java10-其他新特性"> Java10 其他新特性</h3>
<ul>
<li><strong>线程-局部管控</strong>：Java 10 中线程管控引入 JVM 安全点的概念，将允许在不运行全局 JVM 安全点的情况下实现线程回调，由线程本身或者 JVM 线程来执行，同时保持线程处于阻塞状态，这种方式使得停止单个线程变成可能，而不是只能启用或停止所有线程</li>
<li><strong>备用存储装置上的堆分配</strong>：Java 10 中将使得 JVM 能够使用适用于不同类型的存储机制的堆，在可选内存设备上进行堆内存分配</li>
<li><strong>统一的垃圾回收接口</strong>：Java 10 中，hotspot/gc 代码实现方面，引入一个干净的 GC 接口，改进不同 GC 源代码的隔离性，多个 GC 之间共享的实现细节代码应该存在于辅助类中。统一垃圾回收接口的主要原因是：让垃圾回收器（GC）这部分代码更加整洁，便于新人上手开发，便于后续排查相关问题。</li>
<li>......</li>
</ul>
<h2 id="java11"> Java11</h2>
<p>Java11 于 2018 年 9 月 25 日正式发布，这是很重要的一个版本！Java 11 和 2017 年 9 月份发布的 Java 9 以及 2018 年 3 月份发布的 Java 10 相比，其最大的区别就是：在长期支持(Long-Term-Support)方面，<strong>Oracle 表示会对 Java 11 提供大力支持，这一支持将会持续至 2026 年 9 月。这是据 Java 8 以后支持的首个长期版本。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210603202746605.png" alt="" /></p>
<h3 id="string"> String</h3>
<p>Java 11 增加了一系列的字符串处理方法，如以下所示。</p>
<p><em>Guide：说白点就是多了层封装，JDK 开发组的人没少看市面上常见的工具类框架啊!</em></p>
<div><pre><code><span>//判断字符串是否为空</span>
<span>" "</span><span>.</span><span>isBlank</span><span>(</span><span>)</span><span>;</span><span>//true</span>
<span>//去除字符串首尾空格</span>
<span>" Java "</span><span>.</span><span>strip</span><span>(</span><span>)</span><span>;</span><span>// "Java"</span>
<span>//去除字符串首部空格</span>
<span>" Java "</span><span>.</span><span>stripLeading</span><span>(</span><span>)</span><span>;</span>   <span>// "Java "</span>
<span>//去除字符串尾部空格</span>
<span>" Java "</span><span>.</span><span>stripTrailing</span><span>(</span><span>)</span><span>;</span>  <span>// " Java"</span>
<span>//重复字符串多少次</span>
<span>"Java"</span><span>.</span><span>repeat</span><span>(</span><span>3</span><span>)</span><span>;</span>             <span>// "JavaJavaJava"</span>

<span>//返回由行终止符分隔的字符串集合。</span>
<span>"A\nB\nC"</span><span>.</span><span>lines</span><span>(</span><span>)</span><span>.</span><span>count</span><span>(</span><span>)</span><span>;</span>    <span>// 3</span>
<span>"A\nB\nC"</span><span>.</span><span>lines</span><span>(</span><span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="optional-2"> Optional</h3>
<p>新增了<code>empty()</code>方法来判断指定的 <code>Optional</code> 对象是否为空。</p>
<div><pre><code><span>var</span> op <span>=</span> <span>Optional</span><span>.</span><span>empty</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>op<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//判断指定的 Optional 对象是否为空</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="zgc-可伸缩低延迟垃圾收集器"> ZGC(可伸缩低延迟垃圾收集器)</h3>
<p><strong>ZGC 即 Z Garbage Collector</strong>，是一个可伸缩的、低延迟的垃圾收集器。</p>
<p>ZGC 主要为了满足如下目标进行设计：</p>
<ul>
<li>GC 停顿时间不超过 10ms</li>
<li>即能处理几百 MB 的小堆，也能处理几个 TB 的大堆</li>
<li>应用吞吐能力不会下降超过 15%（与 G1 回收算法相比）</li>
<li>方便在此基础上引入新的 GC 特性和利用 colored 针以及 Load barriers 优化奠定基础</li>
<li>当前只支持 Linux/x64 位平台</li>
</ul>
<p>ZGC 目前 <strong>处在实验阶段</strong>，只支持 Linux/x64 平台。</p>
<p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p>
<p>在 ZGC 中出现 Stop The World 的情况会更少！</p>
<p>详情可以看 ： <a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html" target="_blank" rel="noopener noreferrer">《新一代垃圾回收器 ZGC 的探索与实践》</a></p>
<h3 id="标准-http-client-升级"> 标准 HTTP Client 升级</h3>
<p>Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化，在前两个版本中进行孵化的同时，Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。</p>
<p>并且，Java11 中，Http Client 的包名由 <code>jdk.incubator.http</code> 改为<code>java.net.http</code>，该 API 通过 <code>CompleteableFuture</code> 提供非阻塞请求和响应语义。使用起来也很简单，如下：</p>
<div><pre><code><span>var</span> request <span>=</span> <span>HttpRequest</span><span>.</span><span>newBuilder</span><span>(</span><span>)</span>
    <span>.</span><span>uri</span><span>(</span>URI<span>.</span><span>create</span><span>(</span><span>"https://javastack.cn"</span><span>)</span><span>)</span>
    <span>.</span><span>GET</span><span>(</span><span>)</span>
    <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
<span>var</span> client <span>=</span> <span>HttpClient</span><span>.</span><span>newHttpClient</span><span>(</span><span>)</span><span>;</span>

<span>// 同步</span>
<span>HttpResponse</span><span><span>&lt;</span><span>String</span><span>></span></span> response <span>=</span> client<span>.</span><span>send</span><span>(</span>request<span>,</span> <span>HttpResponse<span>.</span>BodyHandlers</span><span>.</span><span>ofString</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>response<span>.</span><span>body</span><span>(</span><span>)</span><span>)</span><span>;</span>

<span>// 异步</span>
client<span>.</span><span>sendAsync</span><span>(</span>request<span>,</span> <span>HttpResponse<span>.</span>BodyHandlers</span><span>.</span><span>ofString</span><span>(</span><span>)</span><span>)</span>
    <span>.</span><span>thenApply</span><span>(</span><span>HttpResponse</span><span>::</span><span>body</span><span>)</span>
    <span>.</span><span>thenAccept</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="var-lambda-参数的局部变量语法"> var(Lambda 参数的局部变量语法)</h3>
<p>从 Java 10 开始，便引入了局部变量类型推断这一关键特性。类型推断允许使用关键字 var 作为局部变量的类型而不是实际类型，编译器根据分配给变量的值推断出类型。</p>
<p>Java 10 中对 var 关键字存在几个限制</p>
<ul>
<li>只能用于局部变量上</li>
<li>声明时必须初始化</li>
<li>不能用作方法参数</li>
<li>不能在 Lambda 表达式中使用</li>
</ul>
<p>Java11 开始允许开发者在 Lambda 表达式中使用 var 进行参数声明。</p>
<div><pre><code><span>// 下面两者是等价的</span>
<span>Consumer</span><span><span>&lt;</span><span>String</span><span>></span></span> consumer <span>=</span> <span>(</span><span>var</span> i<span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>
<span>Consumer</span><span><span>&lt;</span><span>String</span><span>></span></span> consumer <span>=</span> <span>(</span><span>String</span> i<span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="启动单文件源代码程序"> 启动单文件源代码程序</h3>
<p><a href="https://openjdk.java.net/jeps/330" target="_blank" rel="noopener noreferrer">JEP 330:启动单文件源代码程序（aunch Single-File Source-Code Programs）</a> 可以让我们运行单一文件的 Java 源代码。此功能允许使用 Java 解释器直接执行 Java 源代码。源代码在内存中编译，然后由解释器执行，不需要在磁盘上生成 <code>.class</code> 文件了。</p>
<p>唯一的约束在于所有相关的类必须定义在同一个 Java 文件中。</p>
<p>对于 Java 初学者并希望尝试简单程序的人特别有用，并且能和 jshell 一起使用</p>
<p>一定能程度上增强了使用 Java 来写脚本程序的能力。</p>
<h3 id="java11-其他新特性"> Java11 其他新特性</h3>
<ul>
<li><strong>新的垃圾回收器 Epsilon</strong> ：一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间</li>
<li><strong>低开销的 Heap Profiling</strong> ：Java 11 中提供一种低开销的 Java 堆分配采样方法，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息</li>
<li><strong>TLS1.3 协议</strong> ：Java 11 中包含了传输层安全性（TLS）1.3 规范（RFC 8446）的实现，替换了之前版本中包含的 TLS，包括 TLS 1.2，同时还改进了其他 TLS 功能，例如 OCSP 装订扩展（RFC 6066，RFC 6961），以及会话散列和扩展主密钥扩展（RFC 7627），在安全性和性能方面也做了很多提升</li>
<li><strong>飞行记录器(Java Flight Recorder)</strong> ：飞行记录器之前是商业版 JDK 的一项分析工具，但在 Java 11 中，其代码被包含到公开代码库中，这样所有人都能使用该功能了。</li>
<li>......</li>
</ul>
<h2 id="java12"> Java12</h2>
<h3 id="string-2"> String</h3>
<p>Java 11 增加了两个的字符串处理方法，如以下所示。</p>
<p><code>indent()</code> 方法可以实现字符串缩进。</p>
<div><pre><code><span>String</span> text <span>=</span> <span>"Java"</span><span>;</span>
<span>// 缩进 4 格</span>
text <span>=</span> text<span>.</span><span>indent</span><span>(</span><span>4</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>text<span>)</span><span>;</span>
text <span>=</span> text<span>.</span><span>indent</span><span>(</span><span>-</span><span>10</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>text<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>输出：</p>
<div><pre><code>     Java
Java
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>transform()</code> 方法可以用来转变指定字符串。</p>
<div><pre><code><span>String</span> result <span>=</span> <span>"foo"</span><span>.</span><span>transform</span><span>(</span>input <span>-></span> input <span>+</span> <span>" bar"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result<span>)</span><span>;</span> <span>// foo bar</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="文件比较"> 文件比较</h3>
<p>Java 12 添加了以下方法来比较两个文件：</p>
<div><pre><code><span>public</span> <span>static</span> <span>long</span> <span>mismatch</span><span>(</span><span>Path</span> path<span>,</span> <span>Path</span> path2<span>)</span> <span>throws</span> <span>IOException</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>mismatch()</code> 方法用于比较两个文件，并返回第一个不匹配字符的位置，如果文件相同则返回 -1L。</p>
<p>代码示例（两个文件内容相同的情况）：</p>
<div><pre><code><span>Path</span> filePath1 <span>=</span> <span>Files</span><span>.</span><span>createTempFile</span><span>(</span><span>"file1"</span><span>,</span> <span>".txt"</span><span>)</span><span>;</span>
<span>Path</span> filePath2 <span>=</span> <span>Files</span><span>.</span><span>createTempFile</span><span>(</span><span>"file2"</span><span>,</span> <span>".txt"</span><span>)</span><span>;</span>
<span>Files</span><span>.</span><span>writeString</span><span>(</span>filePath1<span>,</span> <span>"Java 12 Article"</span><span>)</span><span>;</span>
<span>Files</span><span>.</span><span>writeString</span><span>(</span>filePath2<span>,</span> <span>"Java 12 Article"</span><span>)</span><span>;</span>

<span>long</span> mismatch <span>=</span> <span>Files</span><span>.</span><span>mismatch</span><span>(</span>filePath1<span>,</span> filePath2<span>)</span><span>;</span>
<span>assertEquals</span><span>(</span><span>-</span><span>1</span><span>,</span> mismatch<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码示例（两个文件内容不相同的情况）：</p>
<div><pre><code><span>Path</span> filePath3 <span>=</span> <span>Files</span><span>.</span><span>createTempFile</span><span>(</span><span>"file3"</span><span>,</span> <span>".txt"</span><span>)</span><span>;</span>
<span>Path</span> filePath4 <span>=</span> <span>Files</span><span>.</span><span>createTempFile</span><span>(</span><span>"file4"</span><span>,</span> <span>".txt"</span><span>)</span><span>;</span>
<span>Files</span><span>.</span><span>writeString</span><span>(</span>filePath3<span>,</span> <span>"Java 12 Article"</span><span>)</span><span>;</span>
<span>Files</span><span>.</span><span>writeString</span><span>(</span>filePath4<span>,</span> <span>"Java 12 Tutorial"</span><span>)</span><span>;</span>

<span>long</span> mismatch <span>=</span> <span>Files</span><span>.</span><span>mismatch</span><span>(</span>filePath3<span>,</span> filePath4<span>)</span><span>;</span>
<span>assertEquals</span><span>(</span><span>8</span><span>,</span> mismatch<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="数字格式化工具类"> 数字格式化工具类</h3>
<p><code>NumberFormat</code> 新增了对复杂的数字进行格式化的支持</p>
<div><pre><code><span>NumberFormat</span> fmt <span>=</span> <span>NumberFormat</span><span>.</span><span>getCompactNumberInstance</span><span>(</span><span>Locale</span><span>.</span>US<span>,</span> <span>NumberFormat<span>.</span>Style</span><span>.</span>SHORT<span>)</span><span>;</span>
<span>String</span> result <span>=</span> fmt<span>.</span><span>format</span><span>(</span><span>1000</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result<span>)</span><span>;</span> <span>// 输出为 1K，计算工资是多少K更方便了。。。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="shenandoah-gc"> Shenandoah GC</h3>
<p>Redhat 主导开发的 Pauseless GC 实现，主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等</p>
<p>和 Java11 开源的 ZGC 相比（需要升级到 JDK11 才能使用），Shenandoah GC 有稳定的 JDK8u 版本，在 Java8 占据主要市场份额的今天有更大的可落地性。</p>
<h3 id="g1-收集器提升"> G1 收集器提升</h3>
<p>Java12 为默认的垃圾收集器 G1 带来了两项更新:</p>
<ul>
<li><strong>可中止的混合收集集合</strong> ：JEP344 的实现，为了达到用户提供的停顿时间目标，JEP 344 通过把要被回收的区域集（混合收集集合）拆分为强制和可选部分，使 G1 垃圾回收器能中止垃圾回收过程。 G1 可以中止可选部分的回收以达到停顿时间目标</li>
<li><strong>及时返回未使用的已分配内存</strong> ：JEP346 的实现，增强 G1 GC，以便在空闲时自动将 Java 堆内存返回给操作系统</li>
</ul>
<h3 id="预览新特性"> 预览新特性</h3>
<p>作为预览特性加入，需要在<code>javac</code>编译和<code>java</code>运行时增加参数<code>--enable-preview</code> 。</p>
<h4 id="增强-switch"> 增强 Switch</h4>
<p>传统的 <code>switch</code> 语法存在容易漏写 <code>break</code> 的问题，而且从代码整洁性层面来看，多个 break 本质也是一种重复</p>
<p>Java12 增强了 <code>swtich</code> 表达式，使用类似 lambda 语法条件匹配成功后的执行块，不需要多写 break 。</p>
<div><pre><code><span>switch</span> <span>(</span>day<span>)</span> <span>{</span>
    <span>case</span> MONDAY<span>,</span> FRIDAY<span>,</span> SUNDAY <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>6</span><span>)</span><span>;</span>
    <span>case</span> TUESDAY                <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>7</span><span>)</span><span>;</span>
    <span>case</span> THURSDAY<span>,</span> SATURDAY     <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>8</span><span>)</span><span>;</span>
    <span>case</span> WEDNESDAY              <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>9</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="instanceof-模式匹配"> instanceof 模式匹配</h4>
<p><code>instanceof</code> 主要在<strong>类型强转前探测对象的具体类型</strong>。</p>
<p>之前的版本中，我们需要显示地对对象进行类型转换。</p>
<div><pre><code><span>Object</span> obj <span>=</span> <span>"我是字符串"</span><span>;</span>
<span>if</span><span>(</span>obj <span>instanceof</span> <span>String</span><span>)</span><span>{</span>
   <span>String</span> str <span>=</span> <span>(</span><span>String</span><span>)</span> obj<span>;</span>
	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>新版的 <code>instanceof</code> 可以在判断是否属于具体的类型同时完成转换。</p>
<div><pre><code><span>Object</span> obj <span>=</span> <span>"我是字符串"</span><span>;</span>
<span>if</span><span>(</span>obj <span>instanceof</span> <span>String</span> str<span>)</span><span>{</span>
	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="java13"> Java13</h2>
<h3 id="增强-zgc-释放未使用内存"> 增强 ZGC(释放未使用内存)</h3>
<p>在 Java 11 中是实验性的引入的 ZGC 在实际的使用中存在未能主动将未使用的内存释放给操作系统的问题。</p>
<p>ZGC 堆由一组称为 ZPages 的堆区域组成。在 GC 周期中清空 ZPages 区域时，它们将被释放并返回到页面缓存 <strong>ZPageCache</strong> 中，此缓存中的 ZPages 按最近最少使用（LRU）的顺序，并按照大小进行组织。</p>
<p>在 Java 13 中，ZGC 将向操作系统返回被标识为长时间未使用的页面，这样它们将可以被其他进程重用。</p>
<h3 id="socketapi-重构"> SocketAPI 重构</h3>
<p>Java Socket API 终于迎来了重大更新！</p>
<p>Java 13 将 Socket API 的底层进行了重写， <code>NioSocketImpl</code> 是对 <code>PlainSocketImpl</code> 的直接替代，它使用 <code>java.util.concurrent</code> 包下的锁而不是同步方法。如果要使用旧实现，请使用 <code>-Djdk.net.usePlainSocketImpl=true</code>。</p>
<p>并且，在 Java 13 中是默认使用新的 Socket 实现。</p>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>NioSocketImpl</span> <span>extends</span> <span>SocketImpl</span> <span>implements</span> <span>PlatformSocketImpl</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="filesystems"> FileSystems</h3>
<p><code>FileSystems</code> 类中添加了以下三种新方法，以便更容易地使用将文件内容视为文件系统的文件系统提供程序：</p>
<ul>
<li><code>newFileSystem(Path)</code></li>
<li><code>newFileSystem(Path, Map&lt;String, ?&gt;)</code></li>
<li><code>newFileSystem(Path, Map&lt;String, ?&gt;, ClassLoader)</code></li>
</ul>
<h3 id="动态-cds-存档"> 动态 CDS 存档</h3>
<p>Java 13 中对 Java 10 中引入的应用程序类数据共享(AppCDS)进行了进一步的简化、改进和扩展，即：<strong>允许在 Java 应用程序执行结束时动态进行类归档</strong>，具体能够被归档的类包括所有已被加载，但不属于默认基层 CDS 的应用程序类和引用类库中的类。</p>
<p>这提高了应用程序类数据共享（<a href="https://openjdk.java.net/jeps/310" target="_blank" rel="noopener noreferrer">AppCDS</a>）的可用性。无需用户进行试运行来为每个应用程序创建类列表。</p>
<div><pre><code>$ java -XX:ArchiveClassesAtExit<span>=</span>my_app_cds.jsa -cp my_app.jar
$ java -XX:SharedArchiveFile<span>=</span>my_app_cds.jsa -cp my_app.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="预览新特性-2"> 预览新特性</h3>
<h4 id="文本块"> 文本块</h4>
<p>解决 Java 定义多行字符串时只能通过换行转义或者换行连接符来变通支持的问题，引入<strong>三重双引号</strong>来定义多行文本。</p>
<p>Java 13 支持两个 <code>&quot;&quot;&quot;</code> 符号中间的任何内容都会被解释为字符串的一部分，包括换行符。</p>
<p>未支持文本块之前的 HTML 写法：</p>
<div><pre><code><span>String</span> json <span>=</span><span>"{\n"</span> <span>+</span>
              <span>"   \"name\":\"mkyong\",\n"</span> <span>+</span>
              <span>"   \"age\":38\n"</span> <span>+</span>
              <span>"}\n"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>支持文本块之后的 HTML 写法：</p>
<div><pre><code> <span>String</span> json <span>=</span> <span>"""
                {
                    "name":"mkyong",
                    "age":38
                }
                """</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>未支持文本块之前的 SQL 写法：</p>
<div><pre><code>String query <span>=</span> <span>"SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`\n"</span> <span>+</span>
               <span>"WHERE `CITY` = 'INDIANAPOLIS'\n"</span> <span>+</span>
               <span>"ORDER BY `EMP_ID`, `LAST_NAME`;\n"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>支持文本块之后的 SQL 写法：</p>
<div><pre><code>String query <span>=</span> <span>"""
               SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`
               WHERE `CITY` = 'INDIANAPOLIS'
               ORDER BY `EMP_ID`, `LAST_NAME`;
               """</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>另外，<code>String</code> 类新增加了 3 个新的方法来操作文本块：</p>
<ul>
<li><code>formatted(Object... args)</code> ：它类似于 <code>String</code> 的<code>format()</code>方法。添加它是为了支持文本块的格式设置。</li>
<li><code>stripIndent()</code> ：用于去除文本块中每一行开头和结尾的空格。</li>
<li><code>translateEscapes()</code> ：转义序列如 <em>“\\t”</em> 转换为 <em>“\t”</em></li>
</ul>
<p>由于文本块是一项预览功能，可以在未来版本中删除，因此这些新方法被标记为弃用。</p>
<div><pre><code><span>@Deprecated</span><span>(</span>forRemoval<span>=</span><span>true</span><span>,</span> since<span>=</span><span>"13"</span><span>)</span>
<span>public</span> <span>String</span> <span>stripIndent</span><span>(</span><span>)</span> <span>{</span>
<span>}</span>
<span>@Deprecated</span><span>(</span>forRemoval<span>=</span><span>true</span><span>,</span> since<span>=</span><span>"13"</span><span>)</span>
<span>public</span> <span>String</span> <span>formatted</span><span>(</span><span>Object</span><span>.</span><span>.</span><span>.</span> args<span>)</span> <span>{</span>

<span>}</span>
<span>@Deprecated</span><span>(</span>forRemoval<span>=</span><span>true</span><span>,</span> since<span>=</span><span>"13"</span><span>)</span>
<span>public</span> <span>String</span> <span>translateEscapes</span><span>(</span><span>)</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="增强-switch-引入-yield-关键字到-switch-中"> 增强 Switch(引入 yield 关键字到 Switch 中)</h4>
<p><code>Switch</code> 表达式中就多了一个关键字用于跳出 <code>Switch</code> 块的关键字 <code>yield</code>，主要用于返回一个值</p>
<p><code>yield</code>和 <code>return</code> 的区别在于：<code>return</code> 会直接跳出当前循环或者方法，而 <code>yield</code> 只会跳出当前 <code>Switch</code> 块，同时在使用 <code>yield</code> 时，需要有 <code>default</code> 条件</p>
<div><pre><code> <span>private</span> <span>static</span> <span>String</span> <span>descLanguage</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>return</span> <span>switch</span> <span>(</span>name<span>)</span> <span>{</span>
            <span>case</span> <span>"Java"</span><span>:</span> <span>yield</span> <span>"object-oriented, platform independent and secured"</span><span>;</span>
            <span>case</span> <span>"Ruby"</span><span>:</span> <span>yield</span> <span>"a programmer's best friend"</span><span>;</span>
            <span>default</span><span>:</span> <span>yield</span> name <span>+</span><span>" is a good language"</span><span>;</span>
        <span>}</span><span>;</span>
 <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="java14"> Java14</h2>
<h3 id="空指针异常精准提示"> 空指针异常精准提示</h3>
<p>通过 JVM 参数中添加<code>-XX:+ShowCodeDetailsInExceptionMessages</code>，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题。</p>
<div><pre><code>a<span>.</span>b<span>.</span>c<span>.</span>i <span>=</span> <span>99</span><span>;</span> <span>// 假设这段代码会发生空指针</span>
</code></pre>
<div><span>1</span><br></div></div><p>Java 14 之前：</p>
<div><pre><code><span>Exception</span> in thread <span>"main"</span> <span><span>java<span>.</span>lang<span>.</span></span>NullPointerException</span>
    at <span>NullPointerExample</span><span>.</span><span>main</span><span>(</span><span>NullPointerExample</span><span>.</span>java<span>:</span><span>5</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Java 14 之后：</p>
<div><pre><code> <span>// 增加参数后提示的异常中很明确的告知了哪里为空导致</span>
<span>Exception</span> in thread <span>"main"</span> <span><span>java<span>.</span>lang<span>.</span></span>NullPointerException</span><span>:</span>
        <span>Cannot</span> read field <span>'c'</span> because <span>'a.b'</span> is <span>null</span><span>.</span>
    at <span>Prog</span><span>.</span><span>main</span><span>(</span><span>Prog</span><span>.</span>java<span>:</span><span>5</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="switch-的增强-转正"> switch 的增强(转正)</h3>
<p>Java12 引入的 switch（预览特性）在 Java14 变为正式版本，不需要增加参数来启用，直接在 JDK14 中就能使用。</p>
<p>Java12 为 switch 表达式引入了类似 lambda 语法条件匹配成功后的执行块，不需要多写 break ，Java13 提供了 <code>yield</code> 来在 block 中返回值。</p>
<div><pre><code><span>String</span> result <span>=</span> <span>switch</span> <span>(</span>day<span>)</span> <span>{</span>
            <span>case</span> <span>"M"</span><span>,</span> <span>"W"</span><span>,</span> <span>"F"</span> <span>-></span> <span>"MWF"</span><span>;</span>
            <span>case</span> <span>"T"</span><span>,</span> <span>"TH"</span><span>,</span> <span>"S"</span> <span>-></span> <span>"TTS"</span><span>;</span>
            <span>default</span> <span>-></span> <span>{</span>
                <span>if</span><span>(</span>day<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span>
                    <span>yield</span> <span>"Please insert a valid day."</span><span>;</span>
                <span>else</span>
                    <span>yield</span> <span>"Looks like a Sunday."</span><span>;</span>
            <span>}</span>

        <span>}</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="预览新特性-3"> 预览新特性</h3>
<h4 id="record-关键字"> record 关键字</h4>
<p><code>record</code> 关键字可以简化 <strong>数据类</strong>（一个 Java 类一旦实例化就不能再修改）的定义方式，使用 <code>record</code> 代替 <code>class</code> 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 <code>toString()</code>，<code>hashCode()</code>, <code>equals()</code>方法</p>
<p>类似于使用 <code>class</code> 定义类，同时使用了 lombok 插件，并打上了<code>@Getter,@ToString,@EqualsAndHashCode</code>注解</p>
<div><pre><code><span>/**
 * 这个类具有两个特征
 * 1. 所有成员属性都是final
 * 2. 全部方法由构造方法，和两个成员属性访问器组成（共三个）
 * 那么这种类就很适合使用record来声明
 */</span>
<span>final</span> <span>class</span> <span>Rectangle</span> <span>implements</span> <span>Shape</span> <span>{</span>
    <span>final</span> <span>double</span> length<span>;</span>
    <span>final</span> <span>double</span> width<span>;</span>

    <span>public</span> <span>Rectangle</span><span>(</span><span>double</span> length<span>,</span> <span>double</span> width<span>)</span> <span>{</span>
        <span>this</span><span>.</span>length <span>=</span> length<span>;</span>
        <span>this</span><span>.</span>width <span>=</span> width<span>;</span>
    <span>}</span>

    <span>double</span> <span>length</span><span>(</span><span>)</span> <span>{</span> <span>return</span> length<span>;</span> <span>}</span>
    <span>double</span> <span>width</span><span>(</span><span>)</span> <span>{</span> <span>return</span> width<span>;</span> <span>}</span>
<span>}</span>
<span>/**
 * 1. 使用record声明的类会自动拥有上面类中的三个方法
 * 2. 在这基础上还附赠了equals()，hashCode()方法以及toString()方法
 * 3. toString方法中包括所有成员属性的字符串表示形式及其名称
 */</span>
<span>record</span> <span>Rectangle</span><span>(</span><span>float</span> length<span>,</span> <span>float</span> width<span>)</span> <span>{</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h4 id="文本块-2"> 文本块</h4>
<p>Java14 中，文本块依然是预览特性，不过，其引入了两个新的转义字符：</p>
<ul>
<li><code>\</code> : 表示行尾，不引入换行符</li>
<li><code>\s</code> ：表示单个空格</li>
</ul>
<div><pre><code><span>String</span> str <span>=</span> <span>"凡心所向，素履所往，生如逆旅，一苇以航。"</span><span>;</span>

<span>String</span> str2 <span>=</span> <span>""</span>"
        凡心所向，素履所往， \
        生如逆旅，一苇以航。<span>""</span>"<span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2<span>)</span><span>;</span><span>// 凡心所向，素履所往， 生如逆旅，一苇以航。</span>
<span>String</span> text <span>=</span> <span>"""
        java
        c++\sphp
        """</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>text<span>)</span><span>;</span>
<span>//输出：</span>
java
c<span>++</span> php
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="instanceof-增强"> instanceof 增强</h4>
<p>依然是<strong>预览特性</strong> ，Java 12 新特性中介绍过。</p>
<h3 id="java14-其他特性"> Java14 其他特性</h3>
<ul>
<li>从 Java11 引入的 ZGC 作为继 G1 过后的下一代 GC 算法，从支持 Linux 平台到 Java14 开始支持 MacOS 和 Window（个人感觉是终于可以在日常开发工具中先体验下 ZGC 的效果了，虽然其实 G1 也够用）</li>
<li>移除了 CMS(Concurrent Mark Sweep) 垃圾收集器（功成而退）</li>
<li>新增了 jpackage 工具，标配将应用打成 jar 包外，还支持不同平台的特性包，比如 linux 下的<code>deb</code>和<code>rpm</code>，window 平台下的<code>msi</code>和<code>exe</code></li>
</ul>
<h2 id="java15"> Java15</h2>
<h3 id="charsequence"> CharSequence</h3>
<p><code>CharSequence</code> 接口添加了一个默认方法 <code>isEmpty()</code> 来判断字符序列为空，如果是则返回 true。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>CharSequence</span> <span>{</span>
  <span>default</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
      <span>return</span> <span>this</span><span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="treemap"> TreeMap</h3>
<p><code>TreeMap</code> 新引入了下面这些方法：</p>
<ul>
<li><code>putIfAbsent()</code></li>
<li><code>computeIfAbsent()</code></li>
<li><code>computeIfPresent()</code></li>
<li><code>compute()</code></li>
<li><code>merge()</code></li>
</ul>
<h3 id="zgc-转正"> ZGC(转正)</h3>
<p>Java11 的时候 ，ZGC 还在试验阶段。</p>
<p>当时，ZGC 的出现让众多 Java 开发者看到了垃圾回收器的另外一种可能，因此备受关注。</p>
<p>经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！</p>
<p>不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启动 ZGC：</p>
<div><pre><code>$ java -XX:+UseZGC className
</code></pre>
<div><span>1</span><br></div></div><h3 id="eddsa-数字签名算法"> EdDSA(数字签名算法)</h3>
<p>新加入了一个安全性和性能都更强的基于 Edwards-Curve Digital Signature Algorithm （EdDSA）实现的数字签名算法。</p>
<p>虽然其性能优于现有的 ECDSA 实现，不过，它并不会完全取代 JDK 中现有的椭圆曲线数字签名算法( ECDSA)。</p>
<div><pre><code><span>KeyPairGenerator</span> kpg <span>=</span> <span>KeyPairGenerator</span><span>.</span><span>getInstance</span><span>(</span><span>"Ed25519"</span><span>)</span><span>;</span>
<span>KeyPair</span> kp <span>=</span> kpg<span>.</span><span>generateKeyPair</span><span>(</span><span>)</span><span>;</span>

<span>byte</span><span>[</span><span>]</span> msg <span>=</span> <span>"test_string"</span><span>.</span><span>getBytes</span><span>(</span><span>StandardCharsets</span><span>.</span>UTF_8<span>)</span><span>;</span>

<span>Signature</span> sig <span>=</span> <span>Signature</span><span>.</span><span>getInstance</span><span>(</span><span>"Ed25519"</span><span>)</span><span>;</span>
sig<span>.</span><span>initSign</span><span>(</span>kp<span>.</span><span>getPrivate</span><span>(</span><span>)</span><span>)</span><span>;</span>
sig<span>.</span><span>update</span><span>(</span>msg<span>)</span><span>;</span>
<span>byte</span><span>[</span><span>]</span> s <span>=</span> sig<span>.</span><span>sign</span><span>(</span><span>)</span><span>;</span>

<span>String</span> encodedString <span>=</span> <span>Base64</span><span>.</span><span>getEncoder</span><span>(</span><span>)</span><span>.</span><span>encodeToString</span><span>(</span>s<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>encodedString<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>输出：</p>
<div><pre><code>0Hc0lxxASZNvS52WsvnncJOH/mlFhnA8Tc6D/k5DtAX5BSsNVjtPF4R4+yMWXVjrvB2mxVXmChIbki6goFBgAg==
</code></pre>
<div><span>1</span><br></div></div><h3 id="文本块-转正"> 文本块(转正)</h3>
<p>在 Java 15 ，文本块是正式的功能特性了。</p>
<h3 id="隐藏类-hidden-classes"> 隐藏类(Hidden Classes)</h3>
<p>隐藏类是为框架（frameworks）所设计的，隐藏类不能直接被其他类的字节码使用，只能在运行时生成类并通过反射间接使用它们。</p>
<h3 id="预览新特性-4"> 预览新特性</h3>
<h4 id="密封类"> 密封类</h4>
<p>Java 15 对 Java 14 中引入的预览新特性进行了增强，主要是引入了一个新的概念 <strong>密封类（Sealed Classes）。</strong></p>
<p>密封类可以对继承或者实现它们的类进行限制。</p>
<p>比如抽象类 <code>Person</code> 只允许 <code>Employee</code> 和 <code>Manager</code> 继承。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>sealed</span> <span>class</span> <span>Person</span>
    <span>permits</span> <span>Employee</span><span>,</span> <span>Manager</span> <span>{</span>

    <span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>另外，任何扩展密封类的类本身都必须声明为 <code>sealed</code>、<code>non-sealed</code> 或 <code>final</code>。</p>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Employee</span> <span>extends</span> <span>Person</span> <span>{</span>
<span>}</span>

<span>public</span> <span>non-sealed</span> <span>class</span> <span>Manager</span> <span>extends</span> <span>Person</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210820153955587.png" alt="" /></p>
<p>如果允许扩展的子类和封闭类在同一个源代码文件里，封闭类可以不使用 permits 语句，Java 编译器将检索源文件，在编译期为封闭类添加上许可的子类。</p>
<h4 id="instanceof-模式匹配-2"> instanceof 模式匹配</h4>
<p>Java 15 并没有对此特性进行调整，继续预览特性，主要用于接受更多的使用反馈。</p>
<p>在未来的 Java 版本中，Java 的目标是继续完善 <code>instanceof</code> 模式匹配新特性。</p>
<h3 id="java15-其他新特性"> Java15 其他新特性</h3>
<ul>
<li><strong>Nashorn JavaScript 引擎彻底移除</strong> ：Nashorn 从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性。在 Java 11 中就已经被弃用，到了 Java 15 就彻底被删除了。</li>
<li><strong>DatagramSocket API 重构</strong></li>
<li><strong>禁用和废弃偏向锁（Biased Locking）</strong> ： 偏向锁的引入增加了 JVM 的复杂性大于其带来的性能提升。不过，你仍然可以使用 <code>-XX:+UseBiasedLocking</code> 启用偏向锁定，但它会提示 这是一个已弃用的 API。</li>
<li>......</li>
</ul>
<h2 id="总结"> 总结</h2>
<h3 id="关于预览特性"> 关于预览特性</h3>
<p>先贴一段 oracle 官网原文：<code>This is a preview feature, which is a feature whose design, specification, and implementation are complete, but is not permanent, which means that the feature may exist in a different form or not at all in future JDK releases. To compile and run code that contains preview features, you must specify additional command-line options.</code></p>
<p>这是一个预览功能，该功能的设计，规格和实现是完整的，但不是永久性的，这意味着该功能可能以其他形式存在或在将来的 JDK 版本中根本不存在。 要编译和运行包含预览功能的代码，必须指定其他命令行选项。</p>
<p>就以<code>switch</code>的增强为例子，从 Java12 中推出，到 Java13 中将继续增强，直到 Java14 才正式转正进入 JDK 可以放心使用，不用考虑后续 JDK 版本对其的改动或修改</p>
<p>一方面可以看出 JDK 作为标准平台在增加新特性的严谨态度，另一方面个人认为是对于预览特性应该采取审慎使用的态度。特性的设计和实现容易，但是其实际价值依然需要在使用中去验证</p>
<h3 id="jvm-虚拟机优化"> JVM 虚拟机优化</h3>
<p>每次 Java 版本的发布都伴随着对 JVM 虚拟机的优化，包括对现有垃圾回收算法的改进，引入新的垃圾回收算法，移除老旧的不再适用于今天的垃圾回收算法等</p>
<p>整体优化的方向是<strong>高效，低时延的垃圾回收表现</strong></p>
<p>对于日常的应用开发者可能比较关注新的语法特性，但是从一个公司角度来说，在考虑是否升级 Java 平台时更加考虑的是<strong>JVM 运行时的提升</strong></p>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li>JDK Project Overview ： &lt;https://openjdk.java.net/projects/jdk/ &gt;</li>
<li>IBM Developer Java9 <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/" target="_blank" rel="noopener noreferrer">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/</a></li>
<li>Guide to Java10 <a href="https://www.baeldung.com/java-10-overview" target="_blank" rel="noopener noreferrer">https://www.baeldung.com/java-10-overview</a></li>
<li>Java 10 新特性介绍<a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html" target="_blank" rel="noopener noreferrer">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html</a></li>
<li>IBM Devloper Java11 <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-11/index.html" target="_blank" rel="noopener noreferrer">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-11/index.html</a></li>
<li>Java 11 – Features and Comparison： <a href="https://www.geeksforgeeks.org/java-11-features-and-comparison/" target="_blank" rel="noopener noreferrer">https://www.geeksforgeeks.org/java-11-features-and-comparison/</a></li>
<li>Oracle Java12 ReleaseNote <a href="https://www.oracle.com/technetwork/java/javase/12all-relnotes-5211423.html#NewFeature" target="_blank" rel="noopener noreferrer">https://www.oracle.com/technetwork/java/javase/12all-relnotes-5211423.html#NewFeature</a></li>
<li>Oracle Java13 ReleaseNote <a href="https://www.oracle.com/technetwork/java/javase/13all-relnotes-5461743.html#NewFeature" target="_blank" rel="noopener noreferrer">https://www.oracle.com/technetwork/java/javase/13all-relnotes-5461743.html#NewFeature</a></li>
<li>New Features in Java 12 <a href="https://www.baeldung.com/java-12-new-features" target="_blank" rel="noopener noreferrer">https://www.baeldung.com/java-12-new-features</a></li>
<li>New Java13 Features <a href="https://www.baeldung.com/java-13-new-features" target="_blank" rel="noopener noreferrer">https://www.baeldung.com/java-13-new-features</a></li>
<li>Java13 新特性概述 <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-13/index.html" target="_blank" rel="noopener noreferrer">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-13/index.html</a></li>
<li>Oracle Java14 record <a href="https://docs.oracle.com/en/java/javase/14/language/records.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/en/java/javase/14/language/records.html</a></li>
<li>java14-features <a href="https://www.techgeeknext.com/java/java14-features" target="_blank" rel="noopener noreferrer">https://www.techgeeknext.com/java/java14-features</a></li>
<li>Java 14 Features : <a href="https://www.journaldev.com/37273/java-14-features" target="_blank" rel="noopener noreferrer">https://www.journaldev.com/37273/java-14-features</a></li>
<li>What is new in Java 15: https://mkyong.com/java/what-is-new-in-java-15/</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/module-structure.png" type="image/png"/>
    </item>
    <item>
      <title>主页</title>
      <link>https://javaguide.cn/</link>
      <guid>https://javaguide.cn/</guid>
      <source url="https://javaguide.cn/rss.xml">主页</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>👉 <strong><a href="https://t.1yb.co/GXLF" target="_blank" rel="noopener noreferrer">我整理汇总了一些 Java 面试相关的 PDF 资料（质量很高！不要在看网上的那些东拼西凑的垃圾面试题了！！！），希望对需要的小伙伴有帮助（点击下载）！</a></strong></p>
<blockquote>
<ol>
<li><strong>贡献指南</strong> ：欢迎参与 <a href="https://github.com/Snailclimb/JavaGuide/issues/1235" target="_blank" rel="noopener noreferrer">JavaGuide 的维护工作</a>，这是一件非常有意义的事情。</li>
<li><strong>知识星球</strong> : 简历指导/Java 学习/面试指导/面试小册。欢迎加入<a href="https://sourl.cn/v9dbdC" target="_blank" rel="noopener noreferrer">我的知识星球</a> 。</li>
<li><strong>面试专版</strong> ：准备面试的小伙伴可以考虑面试专版：<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试进阶指北 》</a> (质量很高，专为面试打造)</li>
<li><strong>转载须知</strong> ：以下所有文章如非文首说明为转载皆为我（Guide 哥）的原创，转载在文首注明出处，如发现恶意抄袭/搬运，会动用法律武器维护自己的权益。让我们一起维护一个良好的技术创作环境！⛽️</li>
</ol>
</blockquote>
<h2 id="👇推荐阅读"> 👇推荐阅读</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/379041500" target="_blank" rel="noopener noreferrer">Java学习路线</a> : 一份涵盖 Java 后端开发必备技能的学习路线！全面且清晰！</li>
<li><a href="https://gitee.com/SnailClimb/awesome-java" target="_blank" rel="noopener noreferrer">Java开源项目精选</a> ：收集整理了 Gitee/Github 上非常棒的 Java 开源项目集合。Java 开发必备！</li>
<li><a href="/high-quality-technical-articles/">Java技术文章精选集</a> : 精选一些和 Java 相关的优质技术文章，每一篇都值得你阅读 3 遍以上！</li>
<li><a href="https://gitee.com/SnailClimb/awesome-cs" target="_blank" rel="noopener noreferrer">Java书单精选</a> : Java 后端开发值得一读的一些书籍。</li>
</ul>
<h2 id="🔥pdf-资源"> 🔥PDF 资源</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=100029614&amp;idx=1&amp;sn=62993c5cf10265cb7018db7f1ec67250&amp;chksm=4ea1fb6579d67273499b7243641d4ef372decd08047bfbb6dfb5843ef81c7ccba209086cf345#rd" target="_blank" rel="noopener noreferrer">《JavaGuide 面试突击版》</a></li>
<li><a href="https://t.1yb.co/Fy0u" target="_blank" rel="noopener noreferrer">《消息队列常见知识点&amp;面试题总结》</a></li>
<li><a href="https://t.1yb.co/GXLF" target="_blank" rel="noopener noreferrer">《Java 工程师进阶知识完全扫盲》</a></li>
<li><a href="https://t.1yb.co/GXLF" target="_blank" rel="noopener noreferrer">《分布式相关面试题汇总》</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=100021725&amp;idx=1&amp;sn=2db9664ca25363139a81691043e9fd8f&amp;chksm=4ea19a1679d61300d8990f7e43bfc7f476577a81b712cf0f9c6f6552a8b219bc081efddb5c54#rd" target="_blank" rel="noopener noreferrer">《图解计算机基础》</a></li>
</ul>
<h2 id="💡官方公众号"> 💡官方公众号</h2>
<p>最新更新会第一时间同步在公众号，强烈推荐大家关注一波！另外，公众号上有很多干货不会同步在线阅读网站。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-08/167598cd2e17b8ec.png" alt="我的公众号" /></p>
<h2 id="🙉联系我"> 🙉联系我</h2>
<p>交流/加群/互看朋友圈，欢迎添加我的微信（备注“Github”即可）。</p>
<p><img src="./../media/pictures/weixin.jpeg" alt="" /></p>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-08/167598cd2e17b8ec.png" type="image/png"/>
    </item>
    <item>
      <title>手把手教你定位常见 Java 性能问题</title>
      <link>https://javaguide.cn/java/tips/locate-performance-problems/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9A%E4%BD%8D%E5%B8%B8%E8%A7%81Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</link>
      <guid>https://javaguide.cn/java/tips/locate-performance-problems/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9A%E4%BD%8D%E5%B8%B8%E8%A7%81Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</guid>
      <source url="https://javaguide.cn/rss.xml">手把手教你定位常见 Java 性能问题</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="手把手教你定位常见-java-性能问题"> 手把手教你定位常见 Java 性能问题</h1>
<blockquote>
<p>本文来自木木匠投稿。</p>
</blockquote>
<h2 id="概述"> 概述</h2>
<p>性能优化一向是后端服务优化的重点，但是线上性能故障问题不是经常出现，或者受限于业务产品，根本就没办法出现性能问题，包括笔者自己遇到的性能问题也不多，所以为了提前储备知识，当出现问题的时候不会手忙脚乱，我们本篇文章来模拟下常见的几个 Java 性能故障，来学习怎么去分析和定位。</p>
<h2 id="预备知识"> 预备知识</h2>
<p>既然是定位问题，肯定是需要借助工具，我们先了解下需要哪些工具可以帮忙定位问题。</p>
<p><strong>top 命令</strong></p>
<p><code>top</code>命令使我们最常用的 Linux 命令之一，它可以实时的显示当前正在执行的进程的 CPU 使用率，内存使用率等系统信息。<code>top -Hp pid</code> 可以查看线程的系统资源使用情况。</p>
<p><strong>vmstat 命令</strong></p>
<p>vmstat 是一个指定周期和采集次数的虚拟内存检测工具，可以统计内存，CPU，swap 的使用情况，它还有一个重要的常用功能，用来观察进程的上下文切换。字段说明如下:</p>
<ul>
<li>
<p>r: 运行队列中进程数量（当数量大于 CPU 核数表示有阻塞的线程）</p>
</li>
<li>
<p>b: 等待 IO 的进程数量</p>
</li>
<li>
<p>swpd: 使用虚拟内存大小</p>
</li>
<li>
<p>free: 空闲物理内存大小</p>
</li>
<li>
<p>buff: 用作缓冲的内存大小(内存和硬盘的缓冲区)</p>
</li>
<li>
<p>cache: 用作缓存的内存大小（CPU 和内存之间的缓冲区）</p>
</li>
<li>
<p>si: 每秒从交换区写到内存的大小，由磁盘调入内存</p>
</li>
<li>
<p>so: 每秒写入交换区的内存大小，由内存调入磁盘</p>
</li>
<li>
<p>bi: 每秒读取的块数</p>
</li>
<li>
<p>bo: 每秒写入的块数</p>
</li>
<li>
<p>in: 每秒中断数，包括时钟中断。</p>
</li>
<li>
<p>cs: 每秒上下文切换数。</p>
</li>
<li>
<p>us: 用户进程执行时间百分比(user time)</p>
</li>
<li>
<p>sy: 内核系统进程执行时间百分比(system time)</p>
</li>
<li>
<p>wa: IO 等待时间百分比</p>
</li>
<li>
<p>id: 空闲时间百分比</p>
<p><strong>pidstat 命令</strong></p>
</li>
</ul>
<p>pidstat 是 Sysstat 中的一个组件，也是一款功能强大的性能监测工具，<code>top</code> 和 <code>vmstat</code> 两个命令都是监测进程的内存、CPU 以及 I/O 使用情况，而 pidstat 命令可以检测到线程级别的。<code>pidstat</code>命令线程切换字段说明如下：</p>
<ul>
<li>
<p>UID ：被监控任务的真实用户 ID。</p>
</li>
<li>
<p>TGID ：线程组 ID。</p>
</li>
<li>
<p>TID：线程 ID。</p>
</li>
<li>
<p>cswch/s：主动切换上下文次数，这里是因为资源阻塞而切换线程，比如锁等待等情况。</p>
</li>
<li>
<p>nvcswch/s：被动切换上下文次数，这里指 CPU 调度切换了线程。</p>
<p><strong>jstack 命令</strong></p>
</li>
</ul>
<p>jstack 是 JDK 工具命令，它是一种线程堆栈分析工具，最常用的功能就是使用 <code>jstack pid</code> 命令查看线程的堆栈信息，也经常用来排除死锁情况。</p>
<p><strong>jstat 命令</strong></p>
<p>它可以检测 Java 程序运行的实时情况，包括堆内存信息和垃圾回收信息，我们常常用来查看程序垃圾回收情况。常用的命令是<code>jstat -gc pid</code>。信息字段说明如下：</p>
<ul>
<li>
<p>S0C：年轻代中 To Survivor 的容量（单位 KB）；</p>
</li>
<li>
<p>S1C：年轻代中 From Survivor 的容量（单位 KB）；</p>
</li>
<li>
<p>S0U：年轻代中 To Survivor 目前已使用空间（单位 KB）；</p>
</li>
<li>
<p>S1U：年轻代中 From Survivor 目前已使用空间（单位 KB）；</p>
</li>
<li>
<p>EC：年轻代中 Eden 的容量（单位 KB）；</p>
</li>
<li>
<p>EU：年轻代中 Eden 目前已使用空间（单位 KB）；</p>
</li>
<li>
<p>OC：老年代的容量（单位 KB）；</p>
</li>
<li>
<p>OU：老年代目前已使用空间（单位 KB）；</p>
</li>
<li>
<p>MC：元空间的容量（单位 KB）；</p>
</li>
<li>
<p>MU：元空间目前已使用空间（单位 KB）；</p>
</li>
<li>
<p>YGC：从应用程序启动到采样时年轻代中 gc 次数；</p>
</li>
<li>
<p>YGCT：从应用程序启动到采样时年轻代中 gc 所用时间 (s)；</p>
</li>
<li>
<p>FGC：从应用程序启动到采样时 老年代（Full Gc）gc 次数；</p>
</li>
<li>
<p>FGCT：从应用程序启动到采样时 老年代代（Full Gc）gc 所用时间 (s)；</p>
</li>
<li>
<p>GCT：从应用程序启动到采样时 gc 用的总时间 (s)。</p>
<p><strong>jmap 命令</strong></p>
</li>
</ul>
<p>jmap 也是 JDK 工具命令，他可以查看堆内存的初始化信息以及堆内存的使用情况，还可以生成 dump 文件来进行详细分析。查看堆内存情况命令<code>jmap -heap pid</code>。</p>
<p><strong>mat 内存工具</strong></p>
<p>MAT(Memory Analyzer Tool)工具是 eclipse 的一个插件(MAT 也可以单独使用)，它分析大内存的 dump 文件时，可以非常直观的看到各个对象在堆空间中所占用的内存大小、类实例数量、对象引用关系、利用 OQL 对象查询，以及可以很方便的找出对象 GC Roots 的相关信息。</p>
<p><strong>idea 中也有这么一个插件，就是 JProfiler</strong>。</p>
<p>相关阅读：<a href="https://segmentfault.com/a/1190000017795841" target="_blank" rel="noopener noreferrer">《性能诊断利器 JProfiler 快速入门和最佳实践》</a></p>
<h2 id="模拟环境准备"> 模拟环境准备</h2>
<p>基础环境 jdk1.8，采用 SpringBoot 框架来写几个接口来触发模拟场景，首先是模拟 CPU 占满情况</p>
<h3 id="cpu-占满"> CPU 占满</h3>
<p>模拟 CPU 占满还是比较简单，直接写一个死循环计算消耗 CPU 即可。</p>
<div><pre><code> 	<span>/**
     * 模拟CPU占满
     */</span>
    <span>@GetMapping</span><span>(</span><span>"/cpu/loop"</span><span>)</span>
    <span>public</span> <span>void</span> <span>testCPULoop</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请求cpu死循环"</span><span>)</span><span>;</span>
        <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>setName</span><span>(</span><span>"loop-thread-cpu"</span><span>)</span><span>;</span>
        <span>int</span> num <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
            num<span>++</span><span>;</span>
            <span>if</span> <span>(</span>num <span>==</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"reset"</span><span>)</span><span>;</span>
            <span>}</span>
            num <span>=</span> <span>0</span><span>;</span>
        <span>}</span>

    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>请求接口地址测试<code>curl localhost:8080/cpu/loop</code>,发现 CPU 立马飙升到 100%</p>
<p><img src="./images/3be5a280b0f5499a80c706c8e5da2a4f-1.png" alt="" /></p>
<p>通过执行<code>top -Hp 32805</code> 查看 Java 线程情况</p>
<p><img src="./images/3d8d5ffd3ada43fb86ef54b05408c656-1.png" alt="" /></p>
<p>执行 <code>printf '%x' 32826</code> 获取 16 进制的线程 id，用于<code>dump</code>信息查询，结果为 <code>803a</code>。最后我们执行<code>jstack 32805 |grep -A 20 803a</code>来查看下详细的<code>dump</code>信息。</p>
<p><img src="./images/1fb751b0d78b4a3b8d0f528598ae885d-1.png" alt="" /></p>
<p>这里<code>dump</code>信息直接定位出了问题方法以及代码行，这就定位出了 CPU 占满的问题。</p>
<h3 id="内存泄露"> 内存泄露</h3>
<p>模拟内存泄漏借助了 ThreadLocal 对象来完成，ThreadLocal 是一个线程私有变量，可以绑定到线程上，在整个线程的生命周期都会存在，但是由于 ThreadLocal 的特殊性，ThreadLocal 是基于 ThreadLocalMap 实现的，ThreadLocalMap 的 Entry 继承 WeakReference，而 Entry 的 Key 是 WeakReference 的封装，换句话说 Key 就是弱引用，弱引用在下次 GC 之后就会被回收，如果 ThreadLocal 在 set 之后不进行后续的操作，因为 GC 会把 Key 清除掉，但是 Value 由于线程还在存活，所以 Value 一直不会被回收，最后就会发生内存泄漏。</p>
<div><pre><code><span>/**
     * 模拟内存泄漏
     */</span>
    <span>@GetMapping</span><span>(</span>value <span>=</span> <span>"/memory/leak"</span><span>)</span>
    <span>public</span> <span>String</span> <span>leak</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"模拟内存泄漏"</span><span>)</span><span>;</span>
        <span>ThreadLocal</span><span>&lt;</span><span>Byte</span><span>[</span><span>]</span><span>></span> localVariable <span>=</span> <span>new</span> <span>ThreadLocal</span><span>&lt;</span><span>Byte</span><span>[</span><span>]</span><span>></span><span>(</span><span>)</span><span>;</span>
        localVariable<span>.</span><span>set</span><span>(</span><span>new</span> <span>Byte</span><span>[</span><span>4096</span> <span>*</span> <span>1024</span><span>]</span><span>)</span><span>;</span><span>// 为线程添加变量</span>
        <span>return</span> <span>"ok"</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们给启动加上堆内存大小限制，同时设置内存溢出的时候输出堆栈快照并输出日志。</p>
<div><pre><code>java -jar -Xms500m -Xmx500m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath<span>=</span>/tmp/heapdump.hprof -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/tmp/heaplog.log analysis-demo-0.0.1-SNAPSHOT.jar
</code></pre>
<div><span>1</span><br></div></div><p>启动成功后我们循环执行 100 次,<code>for i in {1..500}; do curl localhost:8080/memory/leak;done</code>,还没执行完毕，系统已经返回 500 错误了。查看系统日志出现了如下异常：</p>
<div><pre><code>java.lang.OutOfMemoryError: Java heap space
</code></pre>
<div><span>1</span><br></div></div><p>我们用<code>jstat -gc pid</code> 命令来看看程序的 GC 情况。</p>
<p><img src="./images/e9bf831860f442a3a992eef64ebb6a50-1.png" alt="" /></p>
<p>很明显，内存溢出了，堆内存经过 45 次 Full Gc 之后都没释放出可用内存，这说明当前堆内存中的对象都是存活的，有 GC Roots 引用，无法回收。那是什么原因导致内存溢出呢？是不是我只要加大内存就行了呢？如果是普通的内存溢出也许扩大内存就行了，但是如果是内存泄漏的话，扩大的内存不一会就会被占满，所以我们还需要确定是不是内存泄漏。我们之前保存了堆 Dump 文件，这个时候借助我们的 MAT 工具来分析下。导入工具选择<code>Leak Suspects Report</code>，工具直接就会给你列出问题报告。</p>
<p><img src="./images/392e4090c0094657ae29af030d3646e3-1.png" alt="" /></p>
<p>这里已经列出了可疑的 4 个内存泄漏问题，我们点击其中一个查看详情。</p>
<p><img src="./images/53fd3ee9a1a0448ca1878e865f4e5f96-1.png" alt="" /></p>
<p>这里已经指出了内存被线程占用了接近 50M 的内存，占用的对象就是 ThreadLocal。如果想详细的通过手动去分析的话，可以点击<code>Histogram</code>,查看最大的对象占用是谁，然后再分析它的引用关系，即可确定是谁导致的内存溢出。</p>
<p><img src="./images/ba07b0fee1754ffc943e546a18a3907e-1.png" alt="" /></p>
<p>上图发现占用内存最大的对象是一个 Byte 数组，我们看看它到底被那个 GC Root 引用导致没有被回收。按照上图红框操作指引，结果如下图：</p>
<p><img src="./images/0605fbf554814a23b80f6351408598be-1.png" alt="" /></p>
<p>我们发现 Byte 数组是被线程对象引用的，图中也标明，Byte 数组对像的 GC Root 是线程，所以它是不会被回收的，展开详细信息查看，我们发现最终的内存占用对象是被 ThreadLocal 对象占据了。这也和 MAT 工具自动帮我们分析的结果一致。</p>
<h3 id="死锁"> 死锁</h3>
<p>死锁会导致耗尽线程资源，占用内存，表现就是内存占用升高，CPU 不一定会飙升(看场景决定)，如果是直接 new 线程，会导致 JVM 内存被耗尽，报无法创建线程的错误，这也是体现了使用线程池的好处。</p>
<div><pre><code> <span>ExecutorService</span> service <span>=</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>4</span><span>,</span> <span>10</span><span>,</span>
            <span>0</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span> <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>1024</span><span>)</span><span>,</span>
            <span>Executors</span><span>.</span><span>defaultThreadFactory</span><span>(</span><span>)</span><span>,</span>
            <span>new</span> <span>ThreadPoolExecutor<span>.</span>AbortPolicy</span><span>(</span><span>)</span><span>)</span><span>;</span>
   <span>/**
     * 模拟死锁
     */</span>
    <span>@GetMapping</span><span>(</span><span>"/cpu/test"</span><span>)</span>
    <span>public</span> <span>String</span> <span>testCPU</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请求cpu"</span><span>)</span><span>;</span>
        <span>Object</span> lock1 <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
        <span>Object</span> lock2 <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
        service<span>.</span><span>submit</span><span>(</span><span>new</span> <span>DeadLockThread</span><span>(</span>lock1<span>,</span> lock2<span>)</span><span>,</span> <span>"deadLookThread-"</span> <span>+</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span><span>)</span><span>)</span><span>;</span>
        service<span>.</span><span>submit</span><span>(</span><span>new</span> <span>DeadLockThread</span><span>(</span>lock2<span>,</span> lock1<span>)</span><span>,</span> <span>"deadLookThread-"</span> <span>+</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> <span>"ok"</span><span>;</span>
    <span>}</span>

<span>public</span> <span>class</span> <span>DeadLockThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>
    <span>private</span> <span>Object</span> lock1<span>;</span>
    <span>private</span> <span>Object</span> lock2<span>;</span>

    <span>public</span> <span>DeadLockThread1</span><span>(</span><span>Object</span> lock1<span>,</span> <span>Object</span> lock2<span>)</span> <span>{</span>
        <span>this</span><span>.</span>lock1 <span>=</span> lock1<span>;</span>
        <span>this</span><span>.</span>lock2 <span>=</span> lock2<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>synchronized</span> <span>(</span>lock2<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>"get lock2 and wait lock1"</span><span>)</span><span>;</span>
            <span>try</span> <span>{</span>
                <span>TimeUnit</span><span>.</span>MILLISECONDS<span>.</span><span>sleep</span><span>(</span><span>2000</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
            <span>synchronized</span> <span>(</span>lock1<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>"get lock1 and lock2 "</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>我们循环请求接口 2000 次，发现不一会系统就出现了日志错误，线程池和队列都满了,由于我选择的当队列满了就拒绝的策略，所以系统直接抛出异常。</p>
<div><pre><code>java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@2760298 rejected from java.util.concurrent.ThreadPoolExecutor@7ea7cd51[Running, pool size = 10, active threads = 10, queued tasks = 1024, completed tasks = 846]
</code></pre>
<div><span>1</span><br></div></div><p>通过<code>ps -ef|grep java</code>命令找出 Java 进程 pid，执行<code>jstack pid</code> 即可出现 java 线程堆栈信息，这里发现了 5 个死锁，我们只列出其中一个，很明显线程<code>pool-1-thread-2</code>锁住了<code>0x00000000f8387d88</code>等待<code>0x00000000f8387d98</code>锁，线程<code>pool-1-thread-1</code>锁住了<code>0x00000000f8387d98</code>等待锁<code>0x00000000f8387d88</code>,这就产生了死锁。</p>
<div><pre><code><span>Java</span> stack information <span>for</span> the threads listed above<span>:</span>
<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span>
<span>"pool-1-thread-2"</span><span>:</span>
        at <span><span>top<span>.</span>luozhou<span>.</span>analysisdemo<span>.</span>controller<span>.</span></span>DeadLockThread2</span><span>.</span><span>run</span><span>(</span><span>DeadLockThread</span><span>.</span>java<span>:</span><span>30</span><span>)</span>
        <span>-</span> waiting <span>to</span> <span>lock</span> <span><span>&lt;</span>0x00000000f8387d98<span>></span></span> <span>(</span>a <span><span>java<span>.</span>lang<span>.</span></span>Object</span><span>)</span>
        <span>-</span> locked <span><span>&lt;</span>0x00000000f8387d88<span>></span></span> <span>(</span>a <span><span>java<span>.</span>lang<span>.</span></span>Object</span><span>)</span>
        at <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span>Executors</span>$<span>RunnableAdapter</span><span>.</span><span>call</span><span>(</span><span>Executors</span><span>.</span>java<span>:</span><span>511</span><span>)</span>
        at <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span>FutureTask</span><span>.</span><span>run</span><span>(</span><span>FutureTask</span><span>.</span>java<span>:</span><span>266</span><span>)</span>
        at <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span>ThreadPoolExecutor</span><span>.</span><span>runWorker</span><span>(</span><span>ThreadPoolExecutor</span><span>.</span>java<span>:</span><span>1149</span><span>)</span>
        at <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span>ThreadPoolExecutor</span>$<span>Worker</span><span>.</span><span>run</span><span>(</span><span>ThreadPoolExecutor</span><span>.</span>java<span>:</span><span>624</span><span>)</span>
        at <span><span>java<span>.</span>lang<span>.</span></span>Thread</span><span>.</span><span>run</span><span>(</span><span>Thread</span><span>.</span>java<span>:</span><span>748</span><span>)</span>
<span>"pool-1-thread-1"</span><span>:</span>
        at <span><span>top<span>.</span>luozhou<span>.</span>analysisdemo<span>.</span>controller<span>.</span></span>DeadLockThread1</span><span>.</span><span>run</span><span>(</span><span>DeadLockThread</span><span>.</span>java<span>:</span><span>30</span><span>)</span>
        <span>-</span> waiting <span>to</span> <span>lock</span> <span><span>&lt;</span>0x00000000f8387d88<span>></span></span> <span>(</span>a <span><span>java<span>.</span>lang<span>.</span></span>Object</span><span>)</span>
        <span>-</span> locked <span><span>&lt;</span>0x00000000f8387d98<span>></span></span> <span>(</span>a <span><span>java<span>.</span>lang<span>.</span></span>Object</span><span>)</span>
        at <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span>Executors</span>$<span>RunnableAdapter</span><span>.</span><span>call</span><span>(</span><span>Executors</span><span>.</span>java<span>:</span><span>511</span><span>)</span>
        at <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span>FutureTask</span><span>.</span><span>run</span><span>(</span><span>FutureTask</span><span>.</span>java<span>:</span><span>266</span><span>)</span>
        at <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span>ThreadPoolExecutor</span><span>.</span><span>runWorker</span><span>(</span><span>ThreadPoolExecutor</span><span>.</span>java<span>:</span><span>1149</span><span>)</span>
        at <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span>ThreadPoolExecutor</span>$<span>Worker</span><span>.</span><span>run</span><span>(</span><span>ThreadPoolExecutor</span><span>.</span>java<span>:</span><span>624</span><span>)</span>
        at <span><span>java<span>.</span>lang<span>.</span></span>Thread</span><span>.</span><span>run</span><span>(</span><span>Thread</span><span>.</span>java<span>:</span><span>748</span><span>)</span>

 <span>Found</span> <span>5</span> deadlocks<span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="线程频繁切换"> 线程频繁切换</h3>
<p>上下文切换会导致将大量 CPU 时间浪费在寄存器、内核栈以及虚拟内存的保存和恢复上，导致系统整体性能下降。当你发现系统的性能出现明显的下降时候，需要考虑是否发生了大量的线程上下文切换。</p>
<div><pre><code> <span>@GetMapping</span><span>(</span>value <span>=</span> <span>"/thread/swap"</span><span>)</span>
    <span>public</span> <span>String</span> <span>theadSwap</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"模拟线程切换"</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> num<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadSwap1</span><span>(</span><span>new</span> <span>AtomicInteger</span><span>(</span><span>0</span><span>)</span><span>)</span><span>,</span><span>"thread-swap"</span><span>+</span>i<span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>"ok"</span><span>;</span>
    <span>}</span>
<span>public</span> <span>class</span> <span>ThreadSwap1</span> <span>implements</span> <span>Runnable</span> <span>{</span>
    <span>private</span> <span>AtomicInteger</span> integer<span>;</span>

    <span>public</span> <span>ThreadSwap1</span><span>(</span><span>AtomicInteger</span> integer<span>)</span> <span>{</span>
        <span>this</span><span>.</span>integer <span>=</span> integer<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
            integer<span>.</span><span>addAndGet</span><span>(</span><span>1</span><span>)</span><span>;</span>
            <span>Thread</span><span>.</span><span>yield</span><span>(</span><span>)</span><span>;</span> <span>//让出CPU资源</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>这里我创建多个线程去执行基础的原子+1 操作，然后让出 CPU 资源，理论上 CPU 就会去调度别的线程，我们请求接口创建 100 个线程看看效果如何，<code>curl localhost:8080/thread/swap?num=100</code>。接口请求成功后，我们执行 <code>vmstat 1 10</code>，表示每 1 秒打印一次，打印 10 次，线程切换采集结果如下：</p>
<div><pre><code>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
101  0 128000 878384    908 468684    0    0     0     0 4071 8110498 14 86  0  0  0
100  0 128000 878384    908 468684    0    0     0     0 4065 8312463 15 85  0  0  0
100  0 128000 878384    908 468684    0    0     0     0 4107 8207718 14 87  0  0  0
100  0 128000 878384    908 468684    0    0     0     0 4083 8410174 14 86  0  0  0
100  0 128000 878384    908 468684    0    0     0     0 4083 8264377 14 86  0  0  0
100  0 128000 878384    908 468688    0    0     0   108 4182 8346826 14 86  0  0  0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这里我们关注 4 个指标，<code>r</code>,<code>cs</code>,<code>us</code>,<code>sy</code>。</p>
<p><strong>r=100</strong>,说明等待的进程数量是 100，线程有阻塞。</p>
<p><strong>cs=800 多万</strong>，说明每秒上下文切换了 800 多万次，这个数字相当大了。</p>
<p><strong>us=14</strong>，说明用户态占用了 14%的 CPU 时间片去处理逻辑。</p>
<p><strong>sy=86</strong>，说明内核态占用了 86%的 CPU，这里明显就是做上下文切换工作了。</p>
<p>我们通过<code>top</code>命令以及<code>top -Hp pid</code>查看进程和线程 CPU 情况，发现 Java 进程 CPU 占满了，但是线程 CPU 使用情况很平均，没有某一个线程把 CPU 吃满的情况。</p>
<div><pre><code>PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 87093 root      20   0 4194788 299056  13252 S 399.7 16.1  65:34.67 java
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
 87189 root      20   0 4194788 299056  13252 R  4.7 16.1   0:41.11 java
 87129 root      20   0 4194788 299056  13252 R  4.3 16.1   0:41.14 java
 87130 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.51 java
 87133 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.59 java
 87134 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.95 java
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>结合上面用户态 CPU 只使用了 14%，内核态 CPU 占用了 86%，可以基本判断是 Java 程序线程上下文切换导致性能问题。</p>
<p>我们使用<code>pidstat</code>命令来看看 Java 进程内部的线程切换数据，执行<code>pidstat -p 87093 -w 1 10</code>,采集数据如下：</p>
<div><pre><code>11:04:30 PM   UID       TGID       TID   cswch/s nvcswch/s  Command
11:04:30 PM     0         -     87128      0.00     16.07  |__java
11:04:30 PM     0         -     87129      0.00     15.60  |__java
11:04:30 PM     0         -     87130      0.00     15.54  |__java
11:04:30 PM     0         -     87131      0.00     15.60  |__java
11:04:30 PM     0         -     87132      0.00     15.43  |__java
11:04:30 PM     0         -     87133      0.00     16.02  |__java
11:04:30 PM     0         -     87134      0.00     15.66  |__java
11:04:30 PM     0         -     87135      0.00     15.23  |__java
11:04:30 PM     0         -     87136      0.00     15.33  |__java
11:04:30 PM     0         -     87137      0.00     16.04  |__java
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>根据上面采集的信息，我们知道 Java 的线程每秒切换 15 次左右，正常情况下，应该是个位数或者小数。结合这些信息我们可以断定 Java 线程开启过多，导致频繁上下文切换，从而影响了整体性能。</p>
<p><strong>为什么系统的上下文切换是每秒 800 多万，而 Java 进程中的某一个线程切换才 15 次左右？</strong></p>
<p>系统上下文切换分为三种情况:</p>
<p>1、多任务：在多任务环境中，一个进程被切换出 CPU，运行另外一个进程，这里会发生上下文切换。</p>
<p>2、中断处理：发生中断时，硬件会切换上下文。在 vmstat 命令中是<code>in</code></p>
<p>3、用户和内核模式切换：当操作系统中需要在用户模式和内核模式之间进行转换时，需要进行上下文切换,比如进行系统函数调用。</p>
<p>Linux 为每个 CPU 维护了一个就绪队列，将活跃进程按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。也就是 vmstat 命令中的<code>r</code>。</p>
<p>那么，进程在什么时候才会被调度到 CPU 上运行呢？</p>
<ul>
<li>进程执行完终止了，它之前使用的 CPU 会释放出来，这时再从就绪队列中拿一个新的进程来运行</li>
<li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片被轮流分配给各个进程。当某个进程时间片耗尽了就会被系统挂起，切换到其它等待 CPU 的进程运行。</li>
<li>进程在系统资源不足时，要等待资源满足后才可以运行，这时进程也会被挂起，并由系统调度其它进程运行。</li>
<li>当进程通过睡眠函数 sleep 主动挂起时，也会重新调度。</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li>
<li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li>
</ul>
<p>结合我们之前的内容分析，阻塞的就绪队列是 100 左右，而我们的 CPU 只有 4 核，这部分原因造成的上下文切换就可能会相当高，再加上中断次数是 4000 左右和系统的函数调用等，整个系统的上下文切换到 800 万也不足为奇了。Java 内部的线程切换才 15 次，是因为线程使用<code>Thread.yield()</code>来让出 CPU 资源，但是 CPU 有可能继续调度该线程，这个时候线程之间并没有切换，这也是为什么内部的某个线程切换次数并不是非常大的原因。</p>
<h2 id="总结"> 总结</h2>
<p>本文模拟了常见的性能问题场景，分析了如何定位 CPU100%、内存泄漏、死锁、线程频繁切换问题。分析问题我们需要做好两件事，第一，掌握基本的原理，第二，借助好工具。本文也列举了分析问题的常用工具和命令，希望对你解决问题有所帮助。当然真正的线上环境可能十分复杂，并没有模拟的环境那么简单，但是原理是一样的，问题的表现也是类似的，我们重点抓住原理，活学活用，相信复杂的线上问题也可以顺利解决。</p>
<h2 id="参考"> 参考</h2>
<p>1、https://linux.die.net/man/1/pidstat</p>
<p>2、https://linux.die.net/man/8/vmstat</p>
<p>3、https://help.eclipse.org/2020-03/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html</p>
<p>4、https://www.linuxblogs.cn/articles/18120200.html</p>
<p>5、https://www.tutorialspoint.com/what-is-context-switching-in-operating-system</p>
]]></content:encoded>
    </item>
    <item>
      <title>RestFul API 简明教程</title>
      <link>https://javaguide.cn/system-design/basis/RESTfulAPI/</link>
      <guid>https://javaguide.cn/system-design/basis/RESTfulAPI/</guid>
      <source url="https://javaguide.cn/rss.xml">RestFul API 简明教程</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="restful-api-简明教程"> RestFul API 简明教程</h1>
<p><img src="https://img-blog.csdnimg.cn/2021050713553862.png" alt="" /></p>
<p>大家好，我是 Guide哥！</p>
<p>这篇文章简单聊聊后端程序员必备的 RESTful API 相关的知识。</p>
<p>开始正式介绍 RESTful API 之前，我们需要首先搞清 ：<strong>API 到底是什么？</strong></p>
<h2 id="何为-api"> 何为 API？</h2>
<p><img src="https://img-blog.csdnimg.cn/20210507153833945.png" alt="" /></p>
<p><strong>API（Application Programming Interface）</strong> 翻译过来是应用程序编程接口的意思。</p>
<p>我们在进行后端开发的时候，主要的工作就是为前端或者其他后端服务提供 API 比如查询用户数据的 API 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210507130629538.png" alt="" /></p>
<p>但是， API 不仅仅代表后端系统暴露的接口，像框架中提供的方法也属于 API 的范畴。</p>
<p>为了方便大家理解，我再列举几个例子 🌰：</p>
<ol>
<li>你通过某电商网站搜索某某商品，电商网站的前端就调用了后端提供了搜索商品相关的 API。</li>
<li>你使用 JDK 开发 Java 程序，想要读取用户的输入的话，你就需要使用 JDK 提供的 IO 相关的 API。</li>
<li>......</li>
</ol>
<p>你可以把 API 理解为程序与程序之间通信的桥梁，其本质就是一个函数而已。另外，API 的使用也不是没有章法的，它的规则由（比如数据输入和输出的格式）API 提供方制定。</p>
<h2 id="何为-restful-api"> 何为 RESTful API？</h2>
<p><strong>RESTful API</strong> 经常也被叫做 <strong>REST API</strong>，它是基于 REST 构建的 API。这个 REST 到底是什么，我们后文在讲，涉及到的概念比较多。</p>
<p>如果你看 RESTful API 相关的文章的话一般都比较晦涩难懂，主要是因为 REST 涉及到的一些概念比较难以理解。但是，实际上，我们平时开发用到的 RESTful API 的知识非常简单也很容易概括！</p>
<p>举个例子，如果我给你下面两个 API 你是不是立马能知道它们是干什么用的！这就是 RESTful API 的强大之处！</p>
<div><pre><code>GET    /classes：列出所有班级
POST   /classes：新建一个班级
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>RESTful API 可以让你看到 URL+Http Method 就知道这个 URL 是干什么的，让你看到了 HTTP 状态码（status code）就知道请求结果如何。</strong></p>
<p>像咱们在开发过程中设计 API 的时候也应该至少要满足 RESTful API 的最基本的要求（比如接口中尽量使用名词，使用 <code>POST</code> 请求创建资源，<code>DELETE</code> 请求删除资源等等，示例：<code>GET /notes/id</code>：获取某个指定 id 的笔记的信息）。</p>
<h2 id="解读-rest"> 解读 REST</h2>
<p><strong>REST</strong> 是 <code>REpresentational State Transfer</code> 的缩写。这个词组的翻译过来就是“<strong>表现层状态转化</strong>”。</p>
<p>这样理解起来甚是晦涩，实际上 REST 的全称是 <strong>Resource Representational State Transfer</strong> ，直白地翻译过来就是 <strong>“资源”在网络传输中以某种“表现形式”进行“状态转移”</strong> 。如果还是不能继续理解，请继续往下看，相信下面的讲解一定能让你理解到底啥是 REST 。</p>
<p>我们分别对上面涉及到的概念进行解读，以便加深理解，实际上你不需要搞懂下面这些概念，也能看懂我下一部分要介绍到的内容。不过，为了更好地能跟别人扯扯 “RESTful API”我建议你还是要好好理解一下！</p>
<ul>
<li><strong>资源（Resource）</strong> ：我们可以把真实的对象数据称为资源。一个资源既可以是一个集合，也可以是单个个体。比如我们的班级 classes 是代表一个集合形式的资源，而特定的 class 代表单个个体资源。每一种资源都有特定的 URI（统一资源标识符）与之对应，如果我们需要获取这个资源，访问这个 URI 就可以了，比如获取特定的班级：<code>/class/12</code>。另外，资源也可以包含子资源，比如 <code>/classes/classId/teachers</code>：列出某个指定班级的所有老师的信息</li>
<li><strong>表现形式（Representational）</strong>：&quot;资源&quot;是一种信息实体，它可以有多种外在表现形式。我们把&quot;资源&quot;具体呈现出来的形式比如 <code>json</code>，<code>xml</code>，<code>image</code>,<code>txt</code> 等等叫做它的&quot;表现层/表现形式&quot;。</li>
<li><strong>状态转移（State Transfer）</strong> ：大家第一眼看到这个词语一定会很懵逼？内心 BB：这尼玛是啥啊？ 大白话来说 REST 中的状态转移更多地描述的服务器端资源的状态，比如你通过增删改查（通过 HTTP 动词实现）引起资源状态的改变。ps:互联网通信协议 HTTP 协议，是一个无状态协议，所有的资源状态都保存在服务器端。</li>
</ul>
<p>综合上面的解释，我们总结一下什么是 RESTful 架构：</p>
<ol>
<li>每一个 URI 代表一种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现形式比如 <code>json</code>，<code>xml</code>，<code>image</code>,<code>txt</code> 等等；</li>
<li>客户端通过特定的 HTTP 动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;。</li>
</ol>
<h2 id="restful-api-规范"> RESTful API 规范</h2>
<p><img src="https://img-blog.csdnimg.cn/20210507154007779.png" alt="" /></p>
<h3 id="动作"> 动作</h3>
<ul>
<li><code>GET</code>：请求从服务器获取特定资源。举个例子：<code>GET /classes</code>（获取所有班级）</li>
<li><code>POST</code> ：在服务器上创建一个新的资源。举个例子：<code>POST /classes</code>（创建班级）</li>
<li><code>PUT</code> ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /classes/12</code>（更新编号为 12 的班级）</li>
<li><code>DELETE</code> ：从服务器删除特定的资源。举个例子：<code>DELETE /classes/12</code>（删除编号为 12 的班级）</li>
<li><code>PATCH</code> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li>
</ul>
<h3 id="路径-接口命名"> 路径（接口命名）</h3>
<p>路径又称&quot;终点&quot;（endpoint），表示 API 的具体网址。实际开发中常见的规范如下：</p>
<ol>
<li><strong>网址中不能有动词，只能有名词，API 中的名词也应该使用复数。</strong> 因为 REST 中的资源往往和数据库中的表对应，而数据库中的表都是同种记录的&quot;集合&quot;（collection）。如果 API 调用并不涉及资源（如计算，翻译等操作）的话，可以用动词。比如：<code>GET /calculate?param1=11&amp;param2=33</code> 。</li>
<li><strong>不用大写字母，建议用中杠 - 不用下杠 _</strong> 。比如邀请码写成 <code>invitation-code</code>而不是 <s>invitation_code</s> 。</li>
<li><strong>善用版本化 API</strong>。当我们的 API 发生了重大改变而不兼容前期版本的时候，我们可以通过 URL 来实现版本化，比如 <code>http://api.example.com/v1</code>、<code>http://apiv1.example.com</code> 。版本不必非要是数字，只是数字用的最多，日期、季节都可以作为版本标识符，项目团队达成共识就可。</li>
<li><strong>接口尽量使用名词，避免使用动词。</strong> RESTful API 操作（HTTP Method）的是资源（名词）而不是动作（动词）。</li>
</ol>
<p>Talk is cheap！来举个实际的例子来说明一下吧！现在有这样一个 API 提供班级（class）的信息，还包括班级中的学生和教师的信息，则它的路径应该设计成下面这样。</p>
<div><pre><code>GET    /classes：列出所有班级
POST   /classes：新建一个班级
GET    /classes/{classId}：获取某个指定班级的信息
PUT    /classes/{classId}：更新某个指定班级的信息（一般倾向整体更新）
PATCH  /classes/{classId}：更新某个指定班级的信息（一般倾向部分更新）
DELETE /classes/{classId}：删除某个班级
GET    /classes/{classId}/teachers：列出某个指定班级的所有老师的信息
GET    /classes/{classId}/students：列出某个指定班级的所有学生的信息
DELETE /classes/{classId}/teachers/{ID}：删除某个指定班级下的指定的老师的信息
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>反例：</p>
<div><pre><code>/getAllclasses
/createNewclass
/deleteAllActiveclasses
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源:<code>/schools</code>，老师: <code>/schools/teachers</code>，学生: <code>/schools/students</code> 就是二级资源。</p>
<h3 id="过滤信息-filtering"> 过滤信息（Filtering）</h3>
<p>如果我们在查询的时候需要添加特定条件的话，建议使用 url 参数的形式。比如我们要查询 state 状态为 active 并且 name 为 guidegege 的班级：</p>
<div><pre><code>GET    /classes?state=active&amp;name=guidegege
</code></pre>
<div><span>1</span><br></div></div><p>比如我们要实现分页查询：</p>
<div><pre><code>GET    /classes?page=1&amp;size=10 //指定第1页，每页10个数据
</code></pre>
<div><span>1</span><br></div></div><h3 id="状态码-status-codes"> 状态码（Status Codes）</h3>
<p><strong>状态码范围：</strong></p>
<table>
<thead>
<tr>
<th>2xx：成功</th>
<th>3xx：重定向</th>
<th>4xx：客户端错误</th>
<th>5xx：服务器错误</th>
</tr>
</thead>
<tbody>
<tr>
<td>200 成功</td>
<td>301 永久重定向</td>
<td>400 错误请求</td>
<td>500 服务器错误</td>
</tr>
<tr>
<td>201 创建</td>
<td>304 资源未修改</td>
<td>401 未授权</td>
<td>502 网关错误</td>
</tr>
<tr>
<td></td>
<td></td>
<td>403 禁止访问</td>
<td>504 网关超时</td>
</tr>
<tr>
<td></td>
<td></td>
<td>404 未找到</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>405 请求方法不对</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="restful-的极致-hateoas"> RESTful 的极致 HATEOAS</h2>
<blockquote>
<p><strong>RESTful 的极致是 hateoas ，但是这个基本不会在实际项目中用到。</strong></p>
</blockquote>
<p>上面是 RESTful API 最基本的东西，也是我们平时开发过程中最容易实践到的。实际上，RESTful API 最好做到 Hypermedia，即返回结果中提供链接，连向其他 API 方法，使得用户不查文档，也知道下一步应该做什么。</p>
<p>比如，当用户向 <code>api.example.com</code> 的根目录发出请求，会得到这样一个返回结果</p>
<div><pre><code><span>{</span><span>"link"</span><span>:</span> <span>{</span>
  <span>"rel"</span><span>:</span>   <span>"collection https://www.example.com/classes"</span><span>,</span>
  <span>"href"</span><span>:</span>  <span>"https://api.example.com/classes"</span><span>,</span>
  <span>"title"</span><span>:</span> <span>"List of classes"</span><span>,</span>
  <span>"type"</span><span>:</span>  <span>"application/vnd.yourformat+json"</span>
<span>}</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码表示，文档中有一个 <code>link</code> 属性，用户读取这个属性就知道下一步该调用什么 API 了。<code>rel</code> 表示这个 API 与当前网址的关系（collection 关系，并给出该 collection 的网址），<code>href</code> 表示 API 的路径，title 表示 API 的标题，<code>type</code> 表示返回类型 <code>Hypermedia API</code> 的设计被称为<a href="http://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="noopener noreferrer">HATEOAS</a>。</p>
<p>在 Spring 中有一个叫做 HATEOAS 的 API 库，通过它我们可以更轻松的创建出符合 HATEOAS 设计的 API。相关文章：</p>
<ul>
<li><a href="https://blog.aisensiy.me/2017/06/04/spring-boot-and-hateoas/" target="_blank" rel="noopener noreferrer">在 Spring Boot 中使用 HATEOAS</a></li>
<li><a href="https://spring.io/guides/tutorials/rest/" target="_blank" rel="noopener noreferrer">Building REST services with Spring</a> (Spring 官网 )</li>
<li><a href="https://www.baeldung.com/spring-hateoas-tutorial" target="_blank" rel="noopener noreferrer">An Intro to Spring HATEOAS</a></li>
<li><a href="https://github.com/spring-projects/spring-hateoas-examples/tree/master/hypermedia" target="_blank" rel="noopener noreferrer">spring-hateoas-examples</a></li>
<li><a href="https://spring.io/projects/spring-hateoas#learn" target="_blank" rel="noopener noreferrer">Spring HATEOAS</a> (Spring 官网 )</li>
</ul>
<h2 id="参考"> 参考</h2>
<ul>
<li>
<p>https://RESTfulapi.net/</p>
</li>
<li>
<p>https://www.ruanyifeng.com/blog/2014/05/restful_api.html</p>
</li>
<li>
<p>https://juejin.im/entry/59e460c951882542f578f2f0</p>
</li>
<li>
<p>https://phauer.com/2016/testing-RESTful-services-java-best-practices/</p>
</li>
<li>
<p>https://www.seobility.net/en/wiki/REST_API</p>
</li>
<li>
<p>https://dev.to/duomly/rest-api-vs-graphql-comparison-3j6g</p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/2021050713553862.png" type="image/png"/>
    </item>
    <item>
      <title>Java 命名之道</title>
      <link>https://javaguide.cn/system-design/basis/naming/</link>
      <guid>https://javaguide.cn/system-design/basis/naming/</guid>
      <source url="https://javaguide.cn/rss.xml">Java 命名之道</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="java-命名之道"> Java 命名之道</h1>
<p>我还记得我刚工作那一段时间， 项目 Code Review 的时候，我经常因为变量命名不规范而被 “diss”!</p>
<p>究其原因还是自己那会经验不足，而且，大学那会写项目的时候不太注意这些问题，想着只要把功能实现出来就行了。</p>
<p>但是，工作中就不一样，为了代码的可读性、可维护性，项目组对于代码质量的要求还是很高的！</p>
<p>前段时间，项目组新来的一个实习生也经常在 Code Review 因为变量命名不规范而被 “diss”，这让我想到自己刚到公司写代码那会的日子。</p>
<p>于是，我就简单写了这篇关于变量命名规范的文章，希望能对同样有此困扰的小伙伴提供一些帮助。</p>
<p>确实，编程过程中，有太多太多让我们头疼的事情了，比如命名、维护其他人的代码、写测试、与其他人沟通交流等等。</p>
<p>据说之前在 Quora 网站，由接近 5000 名程序员票选出来的最难的事情就是“命名”。</p>
<p>大名鼎鼎的《重构》的作者老马（Martin Fowler）曾经在<a href="https://martinfowler.com/bliki/TwoHardThings.html" target="_blank" rel="noopener noreferrer">TwoHardThings</a>这篇文章中提到过CS 领域有两大最难的事情：一是 <strong>缓存失效</strong> ，一是 <strong>程序命名</strong> 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/marting-naming.png" alt="" /></p>
<p>这个句话实际上也是老马引用别人的，类似的表达还有很多。比如分布式系统领域有两大最难的事情：一是 <strong>保证消息顺序</strong> ，一是 <strong>严格一次传递</strong> 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/20210629104844645.png" alt="" /></p>
<p>今天咱们就单独拎出 “<strong>命名</strong>” 来聊聊！</p>
<p>这篇文章配合我之前发的 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486449&amp;idx=1&amp;sn=c3b502529ff991c7180281bcc22877af&amp;chksm=cea2443af9d5cd2c1c87049ed15ccf6f88275419c7dbe542406166a703b27d0f3ecf2af901f8&amp;token=999884676&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">《编码 5 分钟，命名 2 小时？史上最全的 Java 命名规范参考！》</a> 这篇文章阅读效果更佳哦！</p>
<h2 id="为什么需要重视命名"> 为什么需要重视命名？</h2>
<p>咱们需要先搞懂为什么要重视编程中的命名这一行为，它对于我们的编码工作有着什么意义。</p>
<p><strong>为什么命名很重要呢？</strong> 这是因为 <strong>好的命名即是注释，别人一看到你的命名就知道你的变量、方法或者类是做什么的！</strong></p>
<p>简单来说就是 <strong>别人根据你的命名就能知道你的代码要表达的意思</strong> （不过，前提这个人也要有基本的英语知识，对于一些编程中常见的单词比较熟悉）。</p>
<p>简单举个例子说明一下命名的重要性。</p>
<p>《Clean Code》这本书明确指出：</p>
<blockquote>
<p><strong>好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p>
<p><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong></p>
<p>举个例子：</p>
<p>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可</p>
<div><pre><code><span>// check to see if the employee is eligible for full benefits</span>
<span>if</span> <span>(</span><span>(</span>employee<span>.</span>flags <span>&amp;</span> HOURLY_FLAG<span>)</span> <span>&amp;&amp;</span> <span>(</span>employee<span>.</span>age <span>></span> <span>65</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>应替换为</p>
<div><pre><code><span>if</span> <span>(</span>employee<span>.</span><span>isEligibleForFullBenefits</span><span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<h2 id="常见命名规则以及适用场景"> 常见命名规则以及适用场景</h2>
<p>这里只介绍 3 种最常见的命名规范。</p>
<h3 id="驼峰命名法-camelcase"> 驼峰命名法（CamelCase）</h3>
<p>驼峰命名法应该我们最常见的一个，这种命名方式使用大小写混合的格式来区别各个单词，并且单词之间不使用空格隔开或者连接字符连接的命名方式</p>
<h4 id="大驼峰命名法-uppercamelcase"> 大驼峰命名法（UpperCamelCase）</h4>
<p><strong>类名需要使用大驼峰命名法（UpperCamelCase）</strong></p>
<p>正例：</p>
<div><pre><code><span>ServiceDiscovery</span>、<span>ServiceInstance</span>、<span>LruCacheFactory</span>
</code></pre>
<div><span>1</span><br></div></div><p>反例：</p>
<div><pre><code>serviceDiscovery、<span>Serviceinstance</span>、<span>LRUCacheFactory</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="小驼峰命名法-lowercamelcase"> 小驼峰命名法（lowerCamelCase）</h4>
<p><strong>方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。</strong></p>
<p>正例：</p>
<div><pre><code><span>getUserInfo</span><span>(</span><span>)</span>
<span>createCustomThreadPool</span><span>(</span><span>)</span>
<span>setNameFormat</span><span>(</span><span>String</span> nameFormat<span>)</span>
<span>Uservice</span> userService<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>反例：</p>
<div><pre><code><span>GetUserInfo</span><span>(</span><span>)</span>、<span>CreateCustomThreadPool</span><span>(</span><span>)</span>、<span>setNameFormat</span><span>(</span><span>String</span> <span>NameFormat</span><span>)</span>
<span>Uservice</span> user_service
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="蛇形命名法-snake-case"> 蛇形命名法（snake_case）</h3>
<p><strong>测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）</strong></p>
<p>在蛇形命名法中，各个单词之间通过下划线“_”连接，比如<code>should_get_200_status_code_when_request_is_valid</code>、<code>CLIENT_CONNECT_SERVER_FAILURE</code>。</p>
<p>蛇形命名法的优势是命名所需要的单词比较多的时候，比如我把上面的命名通过小驼峰命名法给大家看一下：“shouldGet200StatusCodeWhenRequestIsValid”。</p>
<p>感觉如何？ 相比于使用蛇形命名法（snake_case）来说是不是不那么易读？</p>
<p>正例：</p>
<div><pre><code><span>@Test</span>
<span>void</span> <span>should_get_200_status_code_when_request_is_valid</span><span>(</span><span>)</span> <span>{</span>
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>反例：</p>
<div><pre><code><span>@Test</span>
<span>void</span> <span>shouldGet200StatusCodeWhenRequestIsValid</span><span>(</span><span>)</span> <span>{</span>
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="串式命名法-kebab-case"> 串式命名法（kebab-case）</h3>
<p>在串式命名法中，各个单词之间通过连接符“-”连接，比如<code>dubbo-registry</code>。</p>
<p>建议项目文件夹名称使用串式命名法（kebab-case），比如 dubbo 项目的各个模块的命名是下面这样的。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/dubbo-naming.png" alt="" /></p>
<h2 id="常见命名规范"> 常见命名规范</h2>
<h3 id="java-语言基本命名规范"> Java 语言基本命名规范</h3>
<p><strong>1、类名需要使用大驼峰命名法（UpperCamelCase）风格。方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。</strong></p>
<p><strong>2、测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）</strong>，比如<code>should_get_200_status_code_when_request_is_valid</code>、<code>CLIENT_CONNECT_SERVER_FAILURE</code>。并且，<strong>测试方法名称要求全部小写，常量以及枚举名称需要全部大写。</strong></p>
<p><strong>3、项目文件夹名称使用串式命名法（kebab-case），比如<code>dubbo-registry</code>。</strong></p>
<p><strong>4、包名统一使用小写，尽量使用单个名词作为包名，各个单词通过 &quot;.&quot; 分隔符连接，并且各个单词必须为单数。</strong></p>
<p>正例： <code>org.apache.dubbo.common.threadlocal</code></p>
<p>反例： <s><code>org.apache_dubbo.Common.threadLocals</code></s></p>
<p><strong>5、抽象类命名使用 Abstract 开头</strong>。</p>
<div><pre><code><span>//为远程传输部分抽象出来的一个抽象类（出处：Dubbo源码）</span>
<span>public</span> <span>abstract</span> <span>class</span> <span>AbstractClient</span> <span>extends</span> <span>AbstractEndpoint</span> <span>implements</span> <span>Client</span> <span>{</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>6、异常类命名使用 Exception 结尾。</strong></p>
<div><pre><code><span>//自定义的 NoSuchMethodException（出处：Dubbo源码）</span>
<span>public</span> <span>class</span> <span>NoSuchMethodException</span> <span>extends</span> <span>RuntimeException</span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>-</span><span>2725364246023268766L</span><span>;</span>

    <span>public</span> <span>NoSuchMethodException</span><span>(</span><span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>NoSuchMethodException</span><span>(</span><span>String</span> msg<span>)</span> <span>{</span>
        <span>super</span><span>(</span>msg<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>7、测试类命名以它要测试的类的名称开始，以 Test 结尾。</strong></p>
<div><pre><code><span>//为 AnnotationUtils 类写的测试类（出处：Dubbo源码）</span>
<span>public</span> <span>class</span> <span>AnnotationUtilsTest</span> <span>{</span>
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>POJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。</p>
<p>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p>
<h3 id="命名易读性规范"> 命名易读性规范</h3>
<p><strong>1、为了能让命名更加易懂和易读，尽量不要缩写/简写单词，除非这些单词已经被公认可以被这样缩写/简写。比如 <code>CustomThreadFactory</code> 不可以被写成 ~~<code>CustomTF</code> 。</strong></p>
<p><strong>2、命名不像函数一样要尽量追求短，可读性强的名字优先于简短的名字，虽然可读性强的名字会比较长一点。</strong> 这个对应我们上面说的第 1 点。</p>
<p><strong>3、避免无意义的命名，你起的每一个名字都要能表明意思。</strong></p>
<p>正例：<code>UserService userService;</code> <code>int userCount</code>;</p>
<p>反例: <s><code>UserService service</code></s> <s><code>int count</code></s></p>
<p><strong>4、避免命名过长（50 个字符以内最好），过长的命名难以阅读并且丑陋。</strong></p>
<p><strong>5、不要使用拼音，更不要使用中文。</strong> 不过像 alibaba 、wuhan、taobao 这种国际通用名词可以当做英文来看待。</p>
<p>正例：discount</p>
<p>反例：<s>dazhe</s></p>
<h2 id="codelf-变量命名神器"> Codelf:变量命名神器?</h2>
<p>这是一个由国人开发的网站，网上有很多人称其为变量命名神器， 我在实际使用了几天之后感觉没那么好用。小伙伴们可以自行体验一下，然后再给出自己的判断。</p>
<p>Codelf 提供了在线网站版本，网址：<a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener noreferrer">https://unbug.github.io/codelf/</a>，具体使用情况如下：</p>
<p>我选择了 Java 编程语言，然后搜索了“序列化”这个关键词，然后它就返回了很多关于序列化的命名。</p>
<p><img src="./pictures/Codelf.png" alt="" /></p>
<p>并且，Codelf 还提供了 VS code 插件，看这个评价，看来大家还是很喜欢这款命名工具的。</p>
<p><img src="./pictures/vscode-codelf.png" alt="" /></p>
<h2 id="相关阅读推荐"> 相关阅读推荐</h2>
<ol>
<li>《阿里巴巴 Java 开发手册》</li>
<li>《Clean Code》</li>
<li>Google Java 代码指南：https://google.github.io/styleguide/javaguide.html#s5.1-identifier-name</li>
<li>告别编码5分钟，命名2小时！史上最全的Java命名规范参考：https://www.cnblogs.com/liqiangchn/p/12000361.html</li>
</ol>
<h2 id="总结"> 总结</h2>
<p>作为一个合格的程序员，小伙伴们应该都知道代码表义的重要性。想要写出高质量代码，好的命名就是第一步！</p>
<p>好的命名对于其他人（包括你自己）理解你的代码有着很大的帮助！你的代码越容易被理解，可维护性就越强，侧面也就说明你的代码设计的也就越好！</p>
<p>在日常编码过程中，我们需要谨记常见命名规范比如类名需要使用大驼峰命名法、不要使用拼音，更不要使用中文......。</p>
<p>另外，国人开发的一个叫做 Codelf 的网站被很多人称为“变量命名神器”，当你为命名而头疼的时候，你可以去参考一下上面提供的一些命名示例。</p>
<p>最后，祝愿大家都不用再为命名而困扰!</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/marting-naming.png" type="image/png"/>
    </item>
    <item>
      <title>Netty 知识点&amp;面试题总结</title>
      <link>https://javaguide.cn/system-design/framework/netty/</link>
      <guid>https://javaguide.cn/system-design/framework/netty/</guid>
      <source url="https://javaguide.cn/rss.xml">Netty 知识点&amp;面试题总结</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="netty-知识点-面试题总结"> Netty 知识点&amp;面试题总结</h1>
<p>这部分内容为我的星球专属，已经整理到了<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7?#" target="_blank" rel="noopener noreferrer">《Java面试进阶指北  打造个人的技术竞争力》</a>中。</p>
<p>欢迎加入我的星球，<a href="https://sourl.cn/v9dbdC" target="_blank" rel="noopener noreferrer">一个纯 Java 面试交流圈子 ！Ready！</a> （点击链接了解星球详细信息，还有专属优惠款可以领取）。</p>
<p><img src="https://img-blog.csdnimg.cn/edc9fdecdfa644e98784a379f46c7a8b.png" alt="" /></p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/edc9fdecdfa644e98784a379f46c7a8b.png" type="image/png"/>
    </item>
    <item>
      <title>MyBatis 常见面试总结</title>
      <link>https://javaguide.cn/system-design/framework/mybatis/mybatis-interview/</link>
      <guid>https://javaguide.cn/system-design/framework/mybatis/mybatis-interview/</guid>
      <source url="https://javaguide.cn/rss.xml">MyBatis 常见面试总结</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="mybatis-常见面试总结"> MyBatis 常见面试总结</h1>
<blockquote>
<p>本篇文章是 JavaGuide 收集自网络，原出处不明。</p>
</blockquote>
<p>MyBatis 技术内幕系列博客，从原理和源码角度，介绍了其内部实现细节，无论是写的好与不好，我确实是用心写了，由于并不是介绍如何使用 MyBatis 的文章，所以，一些参数使用细节略掉了，我们的目标是介绍 MyBatis 的技术架构和重要组成部分，以及基本运行原理。</p>
<p>博客写的很辛苦，但是写出来却不一定好看，所谓开始很兴奋，过程很痛苦，结束很遗憾。要求不高，只要读者能从系列博客中，学习到一点其他博客所没有的技术点，作为作者，我就很欣慰了，我也读别人写的博客，通常对自己当前研究的技术，是很有帮助的。</p>
<p>尽管还有很多可写的内容，但是，我认为再写下去已经没有意义，任何其他小的功能点，都是在已经介绍的基本框架和基本原理下运行的，只有结束，才能有新的开始。写博客也积攒了一些经验，源码多了感觉就是复制黏贴，源码少了又觉得是空谈原理，将来再写博客，我希望是“精炼博文”，好读好懂美观读起来又不累，希望自己能再写一部开源分布式框架原理系列博客。</p>
<p>有胆就来，我出几道 MyBatis 面试题，看你能回答上来几道（都是我出的，可不是网上找的）。</p>
<h4 id="_1、-和-的区别是什么"> 1、#{}和${}的区别是什么？</h4>
<p>注：这道题是面试官面试我同事的。</p>
<p>答：</p>
<ul>
<li><code>${}</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc. Driver</code>。</li>
<li><code>#{}</code>是 sql 的参数占位符，MyBatis 会将 sql 中的<code>#{}</code>替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#{item.name}</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li>
</ul>
<h4 id="_2、xml-映射文件中-除了常见的-select-insert-update-delete-标签之外-还有哪些标签"> 2、Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</h4>
<p>注：这道题是京东面试官面试我时问的。</p>
<p>答：还有很多其他的标签， <code>&lt;resultMap&gt;</code> 、 <code>&lt;parameterMap&gt;</code> 、 <code>&lt;sql&gt;</code> 、 <code>&lt;include&gt;</code> 、 <code>&lt;selectKey&gt;</code> ，加上动态 sql 的 9 个标签， <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 等，其中 <code>&lt;sql&gt;</code> 为 sql 片段标签，通过 <code>&lt;include&gt;</code> 标签引入 sql 片段， <code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签。</p>
<h4 id="_3、最佳实践中-通常一个-xml-映射文件-都会写一个-dao-接口与之对应-请问-这个-dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗"> 3、最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h4>
<p>注：这道题也是京东面试官面试我被问的。</p>
<p>答：Dao 接口，就是人们常说的 <code>Mapper</code> 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 <code>MappedStatement</code> 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 <code>Mapper</code> 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 <code>MappedStatement</code> ，举例： <code>com.mybatis3.mappers. StudentDao.findStudentById</code> ，可以唯一找到 namespace 为 <code>com.mybatis3.mappers. StudentDao</code> 下面 <code>id = findStudentById</code> 的 <code>MappedStatement</code> 。在 MyBatis 中，每一个 <code>&lt;select&gt;</code> 、 <code>&lt;insert&gt;</code> 、 <code>&lt;update&gt;</code> 、 <code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MappedStatement</code> 对象。</p>
<p><s>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</s></p>
<p>Dao 接口里的方法可以重载，但是 Mybatis 的 XML 里面的 ID 不允许重复。</p>
<p>Mybatis 版本 3.3.0，亲测如下：</p>
<div><pre><code><span>/**
 * Mapper接口里面方法重载
 */</span>
<span>public</span> <span>interface</span> <span>StuMapper</span> <span>{</span>

	<span>List</span><span><span>&lt;</span><span>Student</span><span>></span></span> <span>getAllStu</span><span>(</span><span>)</span><span>;</span>

	<span>List</span><span><span>&lt;</span><span>Student</span><span>></span></span> <span>getAllStu</span><span>(</span><span>@Param</span><span>(</span><span>"id"</span><span>)</span> <span>Integer</span> id<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>然后在 <code>StuMapper.xml</code> 中利用 Mybatis 的动态 sql 就可以实现。</p>
<div><pre><code>	<span>&lt;</span>select id<span>=</span><span>"getAllStu"</span> resultType<span>=</span><span>"com.pojo.Student"</span><span>></span>
 		select <span>*</span> from student
		<span><span>&lt;</span>where<span>></span></span>
			<span>&lt;</span><span>if</span> test<span>=</span><span>"id != null"</span><span>></span>
				id <span>=</span> #<span>{</span>id<span>}</span>
			<span>&lt;</span><span>/</span><span>if</span><span>></span>
		<span>&lt;</span><span>/</span>where<span>></span>
 	<span>&lt;</span><span>/</span>select<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>能正常运行，并能得到相应的结果，这样就实现了在 Dao 接口中写重载方法。</p>
<p><strong>Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p>
<p>相关 issue ：<a href="https://github.com/Snailclimb/JavaGuide/issues/1122" target="_blank" rel="noopener noreferrer">更正：Dao 接口里的方法可以重载，但是 Mybatis 的 XML 里面的 ID 不允许重复！</a>。</p>
<p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 <code>MappedStatement</code> 所代表的 sql，然后将 sql 执行结果返回。</p>
<h5 id="补充"> ==补充：==</h5>
<p>Dao 接口方法可以重载，但是需要满足以下条件：</p>
<ol>
<li>仅有一个无参方法和一个有参方法</li>
<li>多个有参方法时，参数数量必须一致。且使用相同的 <code>@Param</code> ，或者使用 <code>param1</code> 这种</li>
</ol>
<p>测试如下：</p>
<p><code>PersonDao.java</code></p>
<div><pre><code><span>Person</span> <span>queryById</span><span>(</span><span>)</span><span>;</span>

<span>Person</span> <span>queryById</span><span>(</span><span>@Param</span><span>(</span><span>"id"</span><span>)</span> <span>Long</span> id<span>)</span><span>;</span>

<span>Person</span> <span>queryById</span><span>(</span><span>@Param</span><span>(</span><span>"id"</span><span>)</span> <span>Long</span> id<span>,</span> <span>@Param</span><span>(</span><span>"name"</span><span>)</span> <span>String</span> name<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>PersonMapper.xml</code></p>
<div><pre><code><span><span><span>&lt;</span>select</span> <span>id</span><span><span>=</span><span>"</span>queryById<span>"</span></span> <span>resultMap</span><span><span>=</span><span>"</span>PersonMap<span>"</span></span><span>></span></span>
    select
      id, name, age, address
    from person
    <span><span><span>&lt;</span>where</span><span>></span></span>
        <span><span><span>&lt;</span>if</span> <span>test</span><span><span>=</span><span>"</span>id != null<span>"</span></span><span>></span></span>
            id = #{id}
        <span><span><span>&lt;/</span>if</span><span>></span></span>
        <span><span><span>&lt;</span>if</span> <span>test</span><span><span>=</span><span>"</span>name != null and name != <span>'</span><span>'</span><span>"</span></span><span>></span></span>
            name = #{name}
        <span><span><span>&lt;/</span>if</span><span>></span></span>
    <span><span><span>&lt;/</span>where</span><span>></span></span>
    limit 1
<span><span><span>&lt;/</span>select</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><code>org.apache.ibatis.scripting.xmltags. DynamicContext. ContextAccessor#getProperty</code> 方法用于获取 <code>&lt;if&gt;</code> 标签中的条件值</p>
<div><pre><code><span>public</span> <span>Object</span> <span>getProperty</span><span>(</span><span>Map</span> context<span>,</span> <span>Object</span> target<span>,</span> <span>Object</span> name<span>)</span> <span>{</span>
  <span>Map</span> map <span>=</span> <span>(</span><span>Map</span><span>)</span> target<span>;</span>

  <span>Object</span> result <span>=</span> map<span>.</span><span>get</span><span>(</span>name<span>)</span><span>;</span>
  <span>if</span> <span>(</span>map<span>.</span><span>containsKey</span><span>(</span>name<span>)</span> <span>||</span> result <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    <span>return</span> result<span>;</span>
  <span>}</span>

  <span>Object</span> parameterObject <span>=</span> map<span>.</span><span>get</span><span>(</span>PARAMETER_OBJECT_KEY<span>)</span><span>;</span>
  <span>if</span> <span>(</span>parameterObject <span>instanceof</span> <span>Map</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>(</span><span>Map</span><span>)</span>parameterObject<span>)</span><span>.</span><span>get</span><span>(</span>name<span>)</span><span>;</span>
  <span>}</span>

  <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><code>parameterObject</code> 为 map，存放的是 Dao 接口中参数相关信息。</p>
<p><code>((Map)parameterObject).get(name)</code> 方法如下</p>
<div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span><span>super</span><span>.</span><span>containsKey</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>BindingException</span><span>(</span><span>"Parameter '"</span> <span>+</span> key <span>+</span> <span>"' not found. Available parameters are "</span> <span>+</span> <span>keySet</span><span>(</span><span>)</span><span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>super</span><span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol>
<li><code>queryById()</code>方法执行时，<code>parameterObject</code>为 null，<code>getProperty</code>方法返回 null 值，<code>&lt;if&gt;</code>标签获取的所有条件值都为 null，所有条件不成立，动态 sql 可以正常执行。</li>
<li><code>queryById(1L)</code>方法执行时，<code>parameterObject</code>为 map，包含了<code>id</code>和<code>param1</code>两个 key 值。当获取<code>&lt;if&gt;</code>标签中<code>name</code>的属性值时，进入<code>((Map)parameterObject).get(name)</code>方法中，map 中 key 不包含<code>name</code>，所以抛出异常。</li>
<li><code>queryById(1L,&quot;1&quot;)</code>方法执行时，<code>parameterObject</code>中包含<code>id</code>,<code>param1</code>,<code>name</code>,<code>param2</code>四个 key 值，<code>id</code>和<code>name</code>属性都可以获取到，动态 sql 正常执行。</li>
</ol>
<h4 id="_4、mybatis-是如何进行分页的-分页插件的原理是什么"> 4、MyBatis 是如何进行分页的？分页插件的原理是什么？</h4>
<p>注：我出的。</p>
<p>答：<strong>(1)</strong> MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；<strong>(2)</strong> 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，<strong>(3)</strong> 也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例： <code>select _ from student</code> ，拦截 sql 后重写为： <code>select t._ from （select \* from student）t limit 0，10</code></p>
<h4 id="_5、简述-mybatis-的插件运行原理-以及如何编写一个插件。"> 5、简述 MyBatis 的插件运行原理，以及如何编写一个插件。</h4>
<p>注：我出的。</p>
<p>答：MyBatis 仅可以编写针对 <code>ParameterHandler</code> 、 <code>ResultSetHandler</code> 、 <code>StatementHandler</code> 、 <code>Executor</code> 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现 MyBatis 的 Interceptor 接口并复写 <code>intercept()</code> 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h4 id="_6、mybatis-执行批量插入-能返回数据库主键列表吗"> 6、MyBatis 执行批量插入，能返回数据库主键列表吗？</h4>
<p>注：我出的。</p>
<p>答：能，JDBC 都能，MyBatis 当然也能。</p>
<h4 id="_7、mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql-的执行原理不"> 7、MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h4>
<p>注：我出的。</p>
<p>答：MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 。</p>
<p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<h4 id="_8、mybatis-是如何将-sql-执行结果封装为目标对象并返回的-都有哪些映射形式"> 8、MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h4>
<p>注：我出的。</p>
<p>答：第一种是使用 <code>&lt;resultMap&gt;</code> 标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h4 id="_9、mybatis-能执行一对一、一对多的关联查询吗-都有哪些实现方式-以及它们之间的区别。"> 9、MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h4>
<p>注：我出的。</p>

<p>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p>
<p>那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是 <code>&lt;resultMap&gt;</code> 标签内的 <code>&lt;id&gt;</code> 子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据 <code>&lt;id&gt;</code> 列值来完成 100 条记录的去重复功能， <code>&lt;id&gt;</code> 可以有多个，代表了联合主键的语意。</p>
<p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p>
<p>举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，MyBatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。</p>
<table>
<thead>
<tr>
<th>t_id</th>
<th>t_name</th>
<th>s_id</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>teacher</td>
<td>38</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>39</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>40</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>41</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>42</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>43</td>
</tr>
</tbody>
</table>
<h4 id="_10、mybatis-是否支持延迟加载-如果支持-它的实现原理是什么"> 10、MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h4>
<p>注：我出的。</p>
<p>答：MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p>
<p>它的原理是，使用 <code>CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code> ，拦截器 <code>invoke()</code> 方法发现 <code>a.getB()</code> 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p>
<h4 id="_11、mybatis-的-xml-映射文件中-不同的-xml-映射文件-id-是否可以重复"> 11、MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h4>
<p>注：我出的。</p>
<p>答：不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p>
<p>原因就是 namespace+id 是作为 <code>Map&lt;String, MappedStatement&gt;</code> 的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p>
<h4 id="_12、mybatis-中如何执行批处理"> 12、MyBatis 中如何执行批处理？</h4>
<p>注：我出的。</p>
<p>答：使用 BatchExecutor 完成批处理。</p>
<h4 id="_13、mybatis-都有哪些-executor-执行器-它们之间的区别是什么"> 13、MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h4>
<p>注：我出的</p>
<p>答：MyBatis 有三种基本的 Executor 执行器，** <code>SimpleExecutor</code> 、 <code>ReuseExecutor</code> 、 <code>BatchExecutor</code> 。**</p>
<p>** <code>SimpleExecutor</code> ：**每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p>
<p>** <code>ReuseExecutor</code> ：**执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p>
<p>** <code>BatchExecutor</code> ：**执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p>
<p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p>
<h4 id="_14、mybatis-中如何指定使用哪一种-executor-执行器"> 14、MyBatis 中如何指定使用哪一种 Executor 执行器？</h4>
<p>注：我出的</p>
<p>答：在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p>
<h4 id="_15、mybatis-是否可以映射-enum-枚举类"> 15、MyBatis 是否可以映射 Enum 枚举类？</h4>
<p>注：我出的</p>
<p>答：MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上。映射方式为自定义一个 <code>TypeHandler</code> ，实现 <code>TypeHandler</code> 的 <code>setParameter()</code> 和 <code>getResult()</code> 接口方法。 <code>TypeHandler</code> 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 <code>setParameter()</code> 和 <code>getResult()</code> 两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</p>
<h4 id="_16、mybatis-映射文件中-如果-a-标签通过-include-引用了-b-标签的内容-请问-b-标签能否定义在-a-标签的后面-还是说必须定义在-a-标签的前面"> 16、MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h4>
<p>注：我出的</p>
<p>答：虽然 MyBatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。</p>
<p>原理是，MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，MyBatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<h4 id="_17、简述-mybatis-的-xml-映射文件和-mybatis-内部数据结构之间的映射关系"> 17、简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</h4>
<p>注：我出的</p>
<p>答：MyBatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中， <code>&lt;parameterMap&gt;</code> 标签会被解析为 <code>ParameterMap</code> 对象，其每个子元素会被解析为 ParameterMapping 对象。 <code>&lt;resultMap&gt;</code> 标签会被解析为 <code>ResultMap</code> 对象，其每个子元素会被解析为 <code>ResultMapping</code> 对象。每一个 <code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code> 标签均会被解析为 <code>MappedStatement</code> 对象，标签内的 sql 会被解析为 BoundSql 对象。</p>
<h4 id="_18、为什么说-mybatis-是半自动-orm-映射工具-它与全自动的区别在哪里"> 18、为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h4>
<p>注：我出的</p>
<p>答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>
<p>面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的 MyBatis 系列博客中都有详细讲解和原理分析。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Spring Boot 自动装配原理</title>
      <link>https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles/</link>
      <guid>https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles/</guid>
      <source url="https://javaguide.cn/rss.xml">Spring Boot 自动装配原理</source>
      <category>框架</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id=""> </h1>
<blockquote>
<p>本文已经收录进  Github 95k+ Star 的Java项目JavaGuide 。JavaGuide项目地址 : https://github.com/Snailclimb/JavaGuide 。</p>
<p>作者：<a href="https://github.com/Miki-byte-1024" target="_blank" rel="noopener noreferrer">Miki-byte-1024</a> &amp; <a href="https://github.com/Snailclimb" target="_blank" rel="noopener noreferrer">Snailclimb</a></p>
</blockquote>
<p>每次问到 Spring Boot， 面试官非常喜欢问这个问题：“讲述一下 SpringBoot 自动装配原理？”。</p>
<p>我觉得我们可以从以下几个方面回答：</p>
<ol>
<li>什么是 SpringBoot 自动装配？</li>
<li>SpringBoot 是如何实现自动装配的？如何实现按需加载？</li>
<li>如何实现一个 Starter？</li>
</ol>
<p>篇幅问题，这篇文章并没有深入，小伙伴们也可以直接使用 debug 的方式去看看 SpringBoot 自动装配部分的源代码。</p>
<h2 id="前言"> 前言</h2>
<p>使用过 Spring 的小伙伴，一定有被 XML 配置统治的恐惧。即使 Spring 后面引入了基于注解的配置，我们在开启某些 Spring 特性或者引入第三方依赖的时候，还是需要用 XML 或 Java 进行显式配置。</p>
<p>举个例子。没有 Spring Boot 的时候，我们写一个 RestFul Web 服务，还首先需要进行如下配置。</p>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>RESTConfiguration</span>
<span>{</span>
    <span>@Bean</span>
    <span>public</span> <span>View</span> <span>jsonTemplate</span><span>(</span><span>)</span> <span>{</span>
        <span>MappingJackson2JsonView</span> view <span>=</span> <span>new</span> <span>MappingJackson2JsonView</span><span>(</span><span>)</span><span>;</span>
        view<span>.</span><span>setPrettyPrint</span><span>(</span><span>true</span><span>)</span><span>;</span>
        <span>return</span> view<span>;</span>
    <span>}</span>

    <span>@Bean</span>
    <span>public</span> <span>ViewResolver</span> <span>viewResolver</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>BeanNameViewResolver</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><code>spring-servlet.xml</code></p>
<div><pre><code><span><span><span>&lt;</span>beans</span> <span>xmlns</span><span><span>=</span><span>"</span>http://www.springframework.org/schema/beans<span>"</span></span>
    <span><span>xmlns:</span>xsi</span><span><span>=</span><span>"</span>http://www.w3.org/2001/XMLSchema-instance<span>"</span></span> <span><span>xmlns:</span>context</span><span><span>=</span><span>"</span>http://www.springframework.org/schema/context<span>"</span></span>
    <span><span>xmlns:</span>mvc</span><span><span>=</span><span>"</span>http://www.springframework.org/schema/mvc<span>"</span></span>
    <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context/ http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/mvc/ http://www.springframework.org/schema/mvc/spring-mvc.xsd<span>"</span></span><span>></span></span>

    <span><span><span>&lt;</span><span>context:</span>component-scan</span> <span>base-package</span><span><span>=</span><span>"</span>com.howtodoinjava.demo<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span><span>mvc:</span>annotation-driven</span> <span>/></span></span>

    <span>&lt;!-- JSON Support --></span>
    <span><span><span>&lt;</span>bean</span> <span>name</span><span><span>=</span><span>"</span>viewResolver<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>org.springframework.web.servlet.view.BeanNameViewResolver<span>"</span></span><span>/></span></span>
    <span><span><span>&lt;</span>bean</span> <span>name</span><span><span>=</span><span>"</span>jsonTemplate<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>org.springframework.web.servlet.view.json.MappingJackson2JsonView<span>"</span></span><span>/></span></span>

<span><span><span>&lt;/</span>beans</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>但是，Spring Boot 项目，我们只需要添加相关依赖，无需配置，通过启动下面的 <code>main</code> 方法即可。</p>
<div><pre><code><span>@SpringBootApplication</span>
<span>public</span> <span>class</span> <span>DemoApplication</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>DemoApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>并且，我们通过 Spring Boot 的全局配置文件 <code>application.properties</code>或<code>application.yml</code>即可对项目进行设置比如更换端口号，配置 JPA 属性等等。</p>
<p><strong>为什么 Spring Boot 使用起来这么酸爽呢？</strong> 这得益于其自动装配。<strong>自动装配可以说是 Spring Boot 的核心，那究竟什么是自动装配呢？</strong></p>
<h2 id="什么是-springboot-自动装配"> 什么是 SpringBoot 自动装配？</h2>
<p>我们现在提到自动装配的时候，一般会和 Spring Boot 联系在一起。但是，实际上 Spring Framework 早就实现了这个功能。Spring Boot 只是在其基础上，通过 SPI 的方式，做了进一步优化。</p>
<blockquote>
<p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p>
</blockquote>
<p>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可。</p>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-data-redis<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。</p>
<p>在我看来，自动装配可以简单理解为：<strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p>
<h2 id="springboot-是如何实现自动装配的"> SpringBoot 是如何实现自动装配的？</h2>
<p>我们先看一下 SpringBoot 的核心注解 <code>SpringBootApplication</code> 。</p>
<div><pre><code><span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>TYPE<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Documented</span>
<span>@Inherited</span>
<span><span>&lt;</span>1<span>.</span><span>></span></span><span>@SpringBootConfiguration</span>
<span><span>&lt;</span>2<span>.</span><span>></span></span><span>@ComponentScan</span>
<span><span>&lt;</span>3<span>.</span><span>></span></span><span>@EnableAutoConfiguration</span>
<span>public</span> <span>@interface</span> <span>SpringBootApplication</span> <span>{</span>

<span>}</span>

<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>TYPE<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Documented</span>
<span>@Configuration</span> <span>//实际上它也是一个配置类</span>
<span>public</span> <span>@interface</span> <span>SpringBootConfiguration</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>大概可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p>
<ul>
<li>
<p><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</p>
</li>
<li>
<p><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</p>
</li>
<li>
<p><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcc73490afbe4c6ba62acde6a94ffdfd~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
</li>
</ul>
<p><code>@EnableAutoConfiguration</code> 是实现自动装配的重要注解，我们以这个注解入手。</p>
<h3 id="enableautoconfiguration-实现自动装配的核心注解"> @EnableAutoConfiguration:实现自动装配的核心注解</h3>
<p><code>EnableAutoConfiguration</code> 只是一个简单地注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类。</p>
<div><pre><code><span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>TYPE<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Documented</span>
<span>@Inherited</span>
<span>@AutoConfigurationPackage</span> <span>//作用：将main包下的所欲组件注册到容器中</span>
<span>@Import</span><span>(</span><span>{</span><span>AutoConfigurationImportSelector</span><span>.</span><span>class</span><span>}</span><span>)</span> <span>//加载自动装配类 xxxAutoconfiguration</span>
<span>public</span> <span>@interface</span> <span>EnableAutoConfiguration</span> <span>{</span>
    <span>String</span> ENABLED_OVERRIDE_PROPERTY <span>=</span> <span>"spring.boot.enableautoconfiguration"</span><span>;</span>

    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>exclude</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>

    <span>String</span><span>[</span><span>]</span> <span>excludeName</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>我们现在重点分析下<code>AutoConfigurationImportSelector</code> 类到底做了什么？</p>
<h3 id="autoconfigurationimportselector-加载自动装配类"> AutoConfigurationImportSelector:加载自动装配类</h3>
<p><code>AutoConfigurationImportSelector</code>类的继承体系如下：</p>
<div><pre><code><span>public</span> <span>class</span> <span>AutoConfigurationImportSelector</span> <span>implements</span> <span>DeferredImportSelector</span><span>,</span> <span>BeanClassLoaderAware</span><span>,</span> <span>ResourceLoaderAware</span><span>,</span> <span>BeanFactoryAware</span><span>,</span> <span>EnvironmentAware</span><span>,</span> <span>Ordered</span> <span>{</span>

<span>}</span>

<span>public</span> <span>interface</span> <span>DeferredImportSelector</span> <span>extends</span> <span>ImportSelector</span> <span>{</span>

<span>}</span>

<span>public</span> <span>interface</span> <span>ImportSelector</span> <span>{</span>
    <span>String</span><span>[</span><span>]</span> <span>selectImports</span><span>(</span><span>AnnotationMetadata</span> var1<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>可以看出，<code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，也就实现了这个接口中的 <code>selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。</p>
<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>String</span><span>[</span><span>]</span> NO_IMPORTS <span>=</span> <span>new</span> <span>String</span><span>[</span><span>0</span><span>]</span><span>;</span>

<span>public</span> <span>String</span><span>[</span><span>]</span> <span>selectImports</span><span>(</span><span>AnnotationMetadata</span> annotationMetadata<span>)</span> <span>{</span>
        <span>// &lt;1>.判断自动装配开关是否打开</span>
        <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span><span>isEnabled</span><span>(</span>annotationMetadata<span>)</span><span>)</span> <span>{</span>
            <span>return</span> NO_IMPORTS<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
          <span>//&lt;2>.获取所有需要装配的bean</span>
            <span>AutoConfigurationMetadata</span> autoConfigurationMetadata <span>=</span> <span>AutoConfigurationMetadataLoader</span><span>.</span><span>loadMetadata</span><span>(</span><span>this</span><span>.</span>beanClassLoader<span>)</span><span>;</span>
            <span>AutoConfigurationImportSelector<span>.</span>AutoConfigurationEntry</span> autoConfigurationEntry <span>=</span> <span>this</span><span>.</span><span>getAutoConfigurationEntry</span><span>(</span>autoConfigurationMetadata<span>,</span> annotationMetadata<span>)</span><span>;</span>
            <span>return</span> <span>StringUtils</span><span>.</span><span>toStringArray</span><span>(</span>autoConfigurationEntry<span>.</span><span>getConfigurations</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>这里我们需要重点关注一下<code>getAutoConfigurationEntry()</code>方法，这个方法主要负责加载自动配置类的。</p>
<p>该方法调用链如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c1200712655443ca4b38500d615bb70~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p>现在我们结合<code>getAutoConfigurationEntry()</code>的源码来详细分析一下：</p>
<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>AutoConfigurationEntry</span> EMPTY_ENTRY <span>=</span> <span>new</span> <span>AutoConfigurationEntry</span><span>(</span><span>)</span><span>;</span>

<span>AutoConfigurationEntry</span> <span>getAutoConfigurationEntry</span><span>(</span><span>AutoConfigurationMetadata</span> autoConfigurationMetadata<span>,</span> <span>AnnotationMetadata</span> annotationMetadata<span>)</span> <span>{</span>
        <span>//&lt;1>.</span>
        <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span><span>isEnabled</span><span>(</span>annotationMetadata<span>)</span><span>)</span> <span>{</span>
            <span>return</span> EMPTY_ENTRY<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>//&lt;2>.</span>
            <span>AnnotationAttributes</span> attributes <span>=</span> <span>this</span><span>.</span><span>getAttributes</span><span>(</span>annotationMetadata<span>)</span><span>;</span>
            <span>//&lt;3>.</span>
            <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> configurations <span>=</span> <span>this</span><span>.</span><span>getCandidateConfigurations</span><span>(</span>annotationMetadata<span>,</span> attributes<span>)</span><span>;</span>
            <span>//&lt;4>.</span>
            configurations <span>=</span> <span>this</span><span>.</span><span>removeDuplicates</span><span>(</span>configurations<span>)</span><span>;</span>
            <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> exclusions <span>=</span> <span>this</span><span>.</span><span>getExclusions</span><span>(</span>annotationMetadata<span>,</span> attributes<span>)</span><span>;</span>
            <span>this</span><span>.</span><span>checkExcludedClasses</span><span>(</span>configurations<span>,</span> exclusions<span>)</span><span>;</span>
            configurations<span>.</span><span>removeAll</span><span>(</span>exclusions<span>)</span><span>;</span>
            configurations <span>=</span> <span>this</span><span>.</span><span>filter</span><span>(</span>configurations<span>,</span> autoConfigurationMetadata<span>)</span><span>;</span>
            <span>this</span><span>.</span><span>fireAutoConfigurationImportEvents</span><span>(</span>configurations<span>,</span> exclusions<span>)</span><span>;</span>
            <span>return</span> <span>new</span> <span>AutoConfigurationImportSelector<span>.</span>AutoConfigurationEntry</span><span>(</span>configurations<span>,</span> exclusions<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><strong>第 1 步</strong>:</p>
<p>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77aa6a3727ea4392870f5cccd09844ab~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p><strong>第 2 步</strong> ：</p>
<p>用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d6ec93bbda1453aa08c52b49516c05a~tplv-k3u1fbpfcp-zoom-1.image" alt="" /></p>
<p><strong>第 3 步</strong></p>
<p>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></p>
<div><pre><code>spring-boot/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories
</code></pre>
<div><span>1</span><br></div></div><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58c51920efea4757aa1ec29c6d5f9e36~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p>从下图可以看到这个文件的配置内容都被我们读取到了。<code>XXXAutoConfiguration</code>的作用就是按需加载组件。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94d6e1a060ac41db97043e1758789026~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p>不光是这个依赖下的<code>META-INF/spring.factories</code>被读取到，所有 Spring Boot Starter 下的<code>META-INF/spring.factories</code>都会被读取到。</p>
<p>所以，你可以清楚滴看到， druid 数据库连接池的 Spring Boot Starter 就创建了<code>META-INF/spring.factories</code>文件。</p>
<p>如果，我们自己要创建一个 Spring Boot Starter，这一步是必不可少的。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68fa66aeee474b0385f94d23bcfe1745~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p><strong>第 4 步</strong> ：</p>
<p>到这里可能面试官会问你:“<code>spring.factories</code>中这么多配置，每次启动都要全部加载么？”。</p>
<p>很明显，这是不现实的。我们 debug 到后面你会发现，<code>configurations</code> 的值变小了。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/267f8231ae2e48d982154140af6437b0~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p>因为，这一步有经历了一遍筛选，<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</p>
<div><pre><code><span>@Configuration</span>
<span>// 检查相关的类：RabbitTemplate 和 Channel是否存在</span>
<span>// 存在才会加载</span>
<span>@ConditionalOnClass</span><span>(</span><span>{</span> <span>RabbitTemplate</span><span>.</span><span>class</span><span>,</span> <span>Channel</span><span>.</span><span>class</span> <span>}</span><span>)</span>
<span>@EnableConfigurationProperties</span><span>(</span><span>RabbitProperties</span><span>.</span><span>class</span><span>)</span>
<span>@Import</span><span>(</span><span>RabbitAnnotationDrivenConfiguration</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>class</span> <span>RabbitAutoConfiguration</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>有兴趣的童鞋可以详细了解下 Spring Boot 提供的条件注解</p>
<ul>
<li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li>
<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下</li>
<li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</li>
<li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li>
<li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li>
<li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li>
<li><code>@ConditionalOnExpression</code>：基于 SpEL 表达式作为判断条件</li>
<li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li>
<li><code>@ConditionalOnJndi</code>：在 JNDI 存在的条件下差在指定的位置</li>
<li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web 项目的条件下</li>
<li><code>@ConditionalOnWebApplication</code>：当前项目是 Web 项 目的条件下</li>
</ul>
<h2 id="如何实现一个-starter"> 如何实现一个 Starter</h2>
<p>光说不练假把式，现在就来撸一个 starter，实现自定义线程池</p>
<p>第一步，创建<code>threadpool-spring-boot-starter</code>工程</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ff0ebe7844f40289eb60213af72c5a6~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p>第二步，引入 Spring Boot 相关依赖</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e14254276604f87b261e5a80a354cc0~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p>第三步，创建<code>ThreadPoolAutoConfiguration</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1843f1d12c5649fba85fd7b4e4a59e39~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p>第四步，在<code>threadpool-spring-boot-starter</code>工程的 resources 包下创建<code>META-INF/spring.factories</code>文件</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97b738321f1542ea8140484d6aaf0728~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p>最后新建工程引入<code>threadpool-spring-boot-starter</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edcdd8595a024aba85b6bb20d0e3fed4~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<p>测试通过！！！</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a265eea4de742a6bbdbbaa75f437307~tplv-k3u1fbpfcp-watermark.image" alt="" /></p>
<h2 id="总结"> 总结</h2>
<p>Spring Boot 通过<code>@EnableAutoConfiguration</code>开启自动装配，通过 SpringFactoriesLoader 最终加载<code>META-INF/spring.factories</code>中的自动配置类实现自动装配，自动配置类其实就是通过<code>@Conditional</code>按需加载的配置类，想要其生效必须引入<code>spring-boot-starter-xxx</code>包实现起步依赖</p>
]]></content:encoded>
      <enclosure url="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcc73490afbe4c6ba62acde6a94ffdfd~tplv-k3u1fbpfcp-watermark.image" type="image/"/>
    </item>
    <item>
      <title>Spring/Spring Boot 常用注解总结！</title>
      <link>https://javaguide.cn/system-design/framework/spring/spring-common-annotations/</link>
      <guid>https://javaguide.cn/system-design/framework/spring/spring-common-annotations/</guid>
      <source url="https://javaguide.cn/rss.xml">Spring/Spring Boot 常用注解总结！</source>
      <category>框架</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="_0-前言"> 0.前言</h3>
<p><em>大家好，我是 Guide 哥！这是我的 221 篇优质原创文章。如需转载，请在文首注明地址，蟹蟹！</em></p>
<p>本文已经收录进我的 75K Star 的 Java 开源项目 JavaGuide：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener noreferrer">https://github.com/Snailclimb/JavaGuide</a>。</p>
<p>可以毫不夸张地说，这篇文章介绍的 Spring/SpringBoot 常用注解基本已经涵盖你工作中遇到的大部分常用的场景。对于每一个注解我都说了具体用法，掌握搞懂，使用 SpringBoot 来开发项目基本没啥大问题了！</p>
<p><strong>为什么要写这篇文章？</strong></p>
<p>最近看到网上有一篇关于 SpringBoot 常用注解的文章被转载的比较多，我看了文章内容之后属实觉得质量有点低，并且有点会误导没有太多实际使用经验的人（这些人又占据了大多数）。所以，自己索性花了大概 两天时间简单总结一下了。</p>
<p><strong>因为我个人的能力和精力有限，如果有任何不对或者需要完善的地方，请帮忙指出！Guide 哥感激不尽！</strong></p>
<h3 id="_1-springbootapplication"> 1. <code>@SpringBootApplication</code></h3>
<p>这里先单独拎出<code>@SpringBootApplication</code> 注解说一下，虽然我们一般不会主动去使用它。</p>
<p><em>Guide 哥：这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。</em></p>
<div><pre><code><span>@SpringBootApplication</span>
<span>public</span> <span>class</span> <span>SpringSecurityJwtGuideApplication</span> <span>{</span>
      <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span><span>java<span>.</span>lang<span>.</span></span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>SpringSecurityJwtGuideApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。</p>
<div><pre><code><span>package</span> <span>org<span>.</span>springframework<span>.</span>boot<span>.</span>autoconfigure</span><span>;</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Documented</span>
<span>@Inherited</span>
<span>@SpringBootConfiguration</span>
<span>@EnableAutoConfiguration</span>
<span>@ComponentScan</span><span>(</span>excludeFilters <span>=</span> <span>{</span>
		<span>@Filter</span><span>(</span>type <span>=</span> <span>FilterType</span><span>.</span>CUSTOM<span>,</span> classes <span>=</span> <span>TypeExcludeFilter</span><span>.</span><span>class</span><span>)</span><span>,</span>
		<span>@Filter</span><span>(</span>type <span>=</span> <span>FilterType</span><span>.</span>CUSTOM<span>,</span> classes <span>=</span> <span>AutoConfigurationExcludeFilter</span><span>.</span><span>class</span><span>)</span> <span>}</span><span>)</span>
<span>public</span> <span>@interface</span> <span>SpringBootApplication</span> <span>{</span>
   <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>

<span>package</span> <span>org<span>.</span>springframework<span>.</span>boot</span><span>;</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Documented</span>
<span>@Configuration</span>
<span>public</span> <span>@interface</span> <span>SpringBootConfiguration</span> <span>{</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>根据 SpringBoot 官网，这三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
<li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描该类所在的包下所有的类。</li>
<li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li>
</ul>
<h3 id="_2-spring-bean-相关"> 2. Spring Bean 相关</h3>
<h4 id="_2-1-autowired"> 2.1. <code>@Autowired</code></h4>
<p>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。</p>
<div><pre><code><span>@Service</span>
<span>public</span> <span>class</span> <span>UserService</span> <span>{</span>
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>

<span>@RestController</span>
<span>@RequestMapping</span><span>(</span><span>"/users"</span><span>)</span>
<span>public</span> <span>class</span> <span>UserController</span> <span>{</span>
   <span>@Autowired</span>
   <span>private</span> <span>UserService</span> userService<span>;</span>
   <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h4 id="_2-2-component-repository-service-controller"> 2.2. <code>@Component</code>,<code>@Repository</code>,<code>@Service</code>, <code>@Controller</code></h4>
<p>我们一般使用 <code>@Autowired</code> 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,可以采用以下注解实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h4 id="_2-3-restcontroller"> 2.3. <code>@RestController</code></h4>
<p><code>@RestController</code>注解是<code>@Controller</code>和<code>@ResponseBody</code>的合集,表示这是个控制器 bean,并且是将函数的返回值直接填入 HTTP 响应体中,是 REST 风格的控制器。</p>
<p><em>Guide 哥：现在都是前后端分离，说实话我已经很久没有用过<code>@Controller</code>。如果你的项目太老了的话，就当我没说。</em></p>
<p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般是用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。<code>@Controller</code> +<code>@ResponseBody</code> 返回 JSON 或 XML 形式数据</p>
<p>关于<code>@RestController</code> 和 <code>@Controller</code>的对比，请看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485544&amp;idx=1&amp;sn=3cc95b88979e28fe3bfe539eb421c6d8&amp;chksm=cea247a3f9d5ceb5e324ff4b8697adc3e828ecf71a3468445e70221cce768d1e722085359907&amp;token=1725092312&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">@RestController vs @Controller</a>。</p>
<h4 id="_2-4-scope"> 2.4. <code>@Scope</code></h4>
<p>声明 Spring Bean 的作用域，使用方法:</p>
<div><pre><code><span>@Bean</span>
<span>@Scope</span><span>(</span><span>"singleton"</span><span>)</span>
<span>public</span> <span>Person</span> <span>personSingleton</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>四种常见的 Spring Bean 的作用域：</strong></p>
<ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li>session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
</ul>
<h4 id="_2-5-configuration"> 2.5. <code>@Configuration</code></h4>
<p>一般用来声明配置类，可以使用 <code>@Component</code>注解替代，不过使用<code>@Configuration</code>注解声明配置类更加语义化。</p>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>AppConfig</span> <span>{</span>
    <span>@Bean</span>
    <span>public</span> <span>TransferService</span> <span>transferService</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>TransferServiceImpl</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="_3-处理常见的-http-请求类型"> 3. 处理常见的 HTTP 请求类型</h3>
<p><strong>5 种常见的请求类型:</strong></p>
<ul>
<li><strong>GET</strong> ：请求从服务器获取特定资源。举个例子：<code>GET /users</code>（获取所有学生）</li>
<li><strong>POST</strong> ：在服务器上创建一个新的资源。举个例子：<code>POST /users</code>（创建学生）</li>
<li><strong>PUT</strong> ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /users/12</code>（更新编号为 12 的学生）</li>
<li><strong>DELETE</strong> ：从服务器删除特定的资源。举个例子：<code>DELETE /users/12</code>（删除编号为 12 的学生）</li>
<li><strong>PATCH</strong> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li>
</ul>
<h4 id="_3-1-get-请求"> 3.1. GET 请求</h4>
<p><code>@GetMapping(&quot;users&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.GET)</code></p>
<div><pre><code><span>@GetMapping</span><span>(</span><span>"/users"</span><span>)</span>
<span>public</span> <span>ResponseEntity</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>User</span><span>></span><span>></span></span> <span>getAllUsers</span><span>(</span><span>)</span> <span>{</span>
 <span>return</span> userRepository<span>.</span><span>findAll</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="_3-2-post-请求"> 3.2. POST 请求</h4>
<p><code>@PostMapping(&quot;users&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.POST)</code></p>
<p>关于<code>@RequestBody</code>注解的使用，在下面的“前后端传值”这块会讲到。</p>
<div><pre><code><span>@PostMapping</span><span>(</span><span>"/users"</span><span>)</span>
<span>public</span> <span>ResponseEntity</span><span><span>&lt;</span><span>User</span><span>></span></span> <span>createUser</span><span>(</span><span>@Valid</span> <span>@RequestBody</span> <span>UserCreateRequest</span> userCreateRequest<span>)</span> <span>{</span>
 <span>return</span> userRespository<span>.</span><span>save</span><span>(</span>userCreateRequest<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="_3-3-put-请求"> 3.3. PUT 请求</h4>
<p><code>@PutMapping(&quot;/users/{userId}&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users/{userId}&quot;,method=RequestMethod.PUT)</code></p>
<div><pre><code><span>@PutMapping</span><span>(</span><span>"/users/{userId}"</span><span>)</span>
<span>public</span> <span>ResponseEntity</span><span><span>&lt;</span><span>User</span><span>></span></span> <span>updateUser</span><span>(</span><span>@PathVariable</span><span>(</span>value <span>=</span> <span>"userId"</span><span>)</span> <span>Long</span> userId<span>,</span>
  <span>@Valid</span> <span>@RequestBody</span> <span>UserUpdateRequest</span> userUpdateRequest<span>)</span> <span>{</span>
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="_3-4-delete-请求"> 3.4. <strong>DELETE 请求</strong></h4>
<p><code>@DeleteMapping(&quot;/users/{userId}&quot;)</code>等价于<code>@RequestMapping(value=&quot;/users/{userId}&quot;,method=RequestMethod.DELETE)</code></p>
<div><pre><code><span>@DeleteMapping</span><span>(</span><span>"/users/{userId}"</span><span>)</span>
<span>public</span> <span>ResponseEntity</span> <span>deleteUser</span><span>(</span><span>@PathVariable</span><span>(</span>value <span>=</span> <span>"userId"</span><span>)</span> <span>Long</span> userId<span>)</span><span>{</span>
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="_3-5-patch-请求"> 3.5. <strong>PATCH 请求</strong></h4>
<p>一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。</p>
<div><pre><code>  <span>@PatchMapping</span><span>(</span><span>"/profile"</span><span>)</span>
  <span>public</span> <span>ResponseEntity</span> <span>updateStudent</span><span>(</span><span>@RequestBody</span> <span>StudentUpdateRequest</span> studentUpdateRequest<span>)</span> <span>{</span>
        studentRepository<span>.</span><span>updateDetail</span><span>(</span>studentUpdateRequest<span>)</span><span>;</span>
        <span>return</span> <span>ResponseEntity</span><span>.</span><span>ok</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_4-前后端传值"> 4. 前后端传值</h3>
<p><strong>掌握前后端传值的正确姿势，是你开始 CRUD 的第一步！</strong></p>
<h4 id="_4-1-pathvariable-和-requestparam"> 4.1. <code>@PathVariable</code> 和 <code>@RequestParam</code></h4>
<p><code>@PathVariable</code>用于获取路径参数，<code>@RequestParam</code>用于获取查询参数。</p>
<p>举个简单的例子：</p>
<div><pre><code><span>@GetMapping</span><span>(</span><span>"/klasses/{klassId}/teachers"</span><span>)</span>
<span>public</span> <span>List</span><span><span>&lt;</span><span>Teacher</span><span>></span></span> <span>getKlassRelatedTeachers</span><span>(</span>
         <span>@PathVariable</span><span>(</span><span>"klassId"</span><span>)</span> <span>Long</span> klassId<span>,</span>
         <span>@RequestParam</span><span>(</span>value <span>=</span> <span>"type"</span><span>,</span> required <span>=</span> <span>false</span><span>)</span> <span>String</span> type <span>)</span> <span>{</span>
<span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果我们请求的 url 是：<code>/klasses/123456/teachers?type=web</code></p>
<p>那么我们服务获取到的数据就是：<code>klassId=123456,type=web</code>。</p>
<h4 id="_4-2-requestbody"> 4.2. <code>@RequestBody</code></h4>
<p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application/json</strong> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>将请求的 body 中的 json 字符串转换为 java 对象。</p>
<p>我用一个简单的例子来给演示一下基本使用！</p>
<p>我们有一个注册的接口：</p>
<div><pre><code><span>@PostMapping</span><span>(</span><span>"/sign-up"</span><span>)</span>
<span>public</span> <span>ResponseEntity</span> <span>signUp</span><span>(</span><span>@RequestBody</span> <span>@Valid</span> <span>UserRegisterRequest</span> userRegisterRequest<span>)</span> <span>{</span>
  userService<span>.</span><span>save</span><span>(</span>userRegisterRequest<span>)</span><span>;</span>
  <span>return</span> <span>ResponseEntity</span><span>.</span><span>ok</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>UserRegisterRequest</code>对象：</p>
<div><pre><code><span>@Data</span>
<span>@AllArgsConstructor</span>
<span>@NoArgsConstructor</span>
<span>public</span> <span>class</span> <span>UserRegisterRequest</span> <span>{</span>
    <span>@NotBlank</span>
    <span>private</span> <span>String</span> userName<span>;</span>
    <span>@NotBlank</span>
    <span>private</span> <span>String</span> password<span>;</span>
    <span>@NotBlank</span>
    <span>private</span> <span>String</span> fullName<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>我们发送 post 请求到这个接口，并且 body 携带 JSON 数据：</p>
<div><pre><code><span>{</span><span>"userName"</span><span>:</span><span>"coder"</span><span>,</span><span>"fullName"</span><span>:</span><span>"shuangkou"</span><span>,</span><span>"password"</span><span>:</span><span>"123456"</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>这样我们的后端就可以直接把 json 格式的数据映射到我们的 <code>UserRegisterRequest</code> 类上。</p>
<p><img src="./images/spring-annotations/@RequestBody.png" alt="" /></p>
<p>👉 需要注意的是：<strong>一个请求方法只可以有一个<code>@RequestBody</code>，但是可以有多个<code>@RequestParam</code>和<code>@PathVariable</code></strong>。 如果你的方法必须要用两个 <code>@RequestBody</code>来接受数据的话，大概率是你的数据库设计或者系统设计出问题了！</p>
<h3 id="_5-读取配置信息"> 5. 读取配置信息</h3>
<p><strong>很多时候我们需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中。</strong></p>
<p><strong>下面我们来看一下 Spring 为我们提供了哪些方式帮助我们从配置文件中读取这些配置信息。</strong></p>
<p>我们的数据源<code>application.yml</code>内容如下：</p>
<div><pre><code><span>wuhan2020</span><span>:</span> 2020年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！

<span>my-profile</span><span>:</span>
  <span>name</span><span>:</span> Guide哥
  <span>email</span><span>:</span> koushuangbwcx@163.com

<span>library</span><span>:</span>
  <span>location</span><span>:</span> 湖北武汉加油中国加油
  <span>books</span><span>:</span>
    <span>-</span> <span>name</span><span>:</span> 天才基本法
      <span>description</span><span>:</span> 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。
    <span>-</span> <span>name</span><span>:</span> 时间的秩序
      <span>description</span><span>:</span> 为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。
    <span>-</span> <span>name</span><span>:</span> 了不起的我
      <span>description</span><span>:</span> 如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？ 如何走出人生的艰难时刻？
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="_5-1-value-常用"> 5.1. <code>@Value</code>(常用)</h4>
<p>使用 <code>@Value(&quot;${property}&quot;)</code> 读取比较简单的配置信息：</p>
<div><pre><code><span>@Value</span><span>(</span><span>"${wuhan2020}"</span><span>)</span>
<span>String</span> wuhan2020<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="_5-2-configurationproperties-常用"> 5.2. <code>@ConfigurationProperties</code>(常用)</h4>
<p>通过<code>@ConfigurationProperties</code>读取配置信息并与 bean 绑定。</p>
<div><pre><code><span>@Component</span>
<span>@ConfigurationProperties</span><span>(</span>prefix <span>=</span> <span>"library"</span><span>)</span>
<span>class</span> <span>LibraryProperties</span> <span>{</span>
    <span>@NotEmpty</span>
    <span>private</span> <span>String</span> location<span>;</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Book</span><span>></span></span> books<span>;</span>

    <span>@Setter</span>
    <span>@Getter</span>
    <span>@ToString</span>
    <span>static</span> <span>class</span> <span>Book</span> <span>{</span>
        <span>String</span> name<span>;</span>
        <span>String</span> description<span>;</span>
    <span>}</span>
  省略getter<span>/</span>setter
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>你可以像使用普通的 Spring bean 一样，将其注入到类中使用。</p>
<h4 id="_5-3-propertysource-不常用"> 5.3. <code>@PropertySource</code>（不常用）</h4>
<p><code>@PropertySource</code>读取指定 properties 文件</p>
<div><pre><code><span>@Component</span>
<span>@PropertySource</span><span>(</span><span>"classpath:website.properties"</span><span>)</span>

<span>class</span> <span>WebSite</span> <span>{</span>
    <span>@Value</span><span>(</span><span>"${url}"</span><span>)</span>
    <span>private</span> <span>String</span> url<span>;</span>

  省略getter<span>/</span>setter
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>更多内容请查看我的这篇文章：《<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486181&amp;idx=2&amp;sn=10db0ae64ef501f96a5b0dbc4bd78786&amp;chksm=cea2452ef9d5cc384678e456427328600971180a77e40c13936b19369672ca3e342c26e92b50&amp;token=816772476&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">10 分钟搞定 SpringBoot 如何优雅读取配置文件？</a>》 。</p>
<h3 id="_6-参数校验"> 6. 参数校验</h3>
<p><strong>数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。</strong></p>
<p><strong>JSR(Java Specification Requests）</strong> 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了，非常方便！</p>
<p>校验的时候我们实际用的是 <strong>Hibernate Validator</strong> 框架。Hibernate Validator 是 Hibernate 团队最初的数据校验框架，Hibernate Validator 4.x 是 Bean Validation 1.0（JSR 303）的参考实现，Hibernate Validator 5.x 是 Bean Validation 1.1（JSR 349）的参考实现，目前最新版的 Hibernate Validator 6.x 是 Bean Validation 2.0（JSR 380）的参考实现。</p>
<p>SpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。如下图所示（通过 idea 插件—Maven Helper 生成）：</p>
<p><strong>注</strong>：更新版本的 spring-boot-starter-web 依赖中不再有 hibernate-validator 包（如2.3.11.RELEASE），需要自己引入 <code>spring-boot-starter-validation</code> 依赖。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2021/03/c7bacd12-1c1a-4e41-aaaf-4cad840fc073.png" alt="" /></p>
<p>非 SpringBoot 项目需要自行引入相关依赖包，这里不多做讲解，具体可以查看我的这篇文章：《<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485783&amp;idx=1&amp;sn=a407f3b75efa17c643407daa7fb2acd6&amp;chksm=cea2469cf9d5cf8afbcd0a8a1c9cc4294d6805b8e01bee6f76bb2884c5bc15478e91459def49&amp;token=292197051&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">如何在 Spring/Spring Boot 中做参数校验？你需要了解的都在这里！</a>》。</p>
<p>👉 需要注意的是： <strong>所有的注解，推荐使用 JSR 注解，即<code>javax.validation.constraints</code>，而不是<code>org.hibernate.validator.constraints</code></strong></p>
<h4 id="_6-1-一些常用的字段验证的注解"> 6.1. 一些常用的字段验证的注解</h4>
<ul>
<li><code>@NotEmpty</code> 被注释的字符串的不能为 null 也不能为空</li>
<li><code>@NotBlank</code> 被注释的字符串非 null，并且必须包含一个非空白字符</li>
<li><code>@Null</code> 被注释的元素必须为 null</li>
<li><code>@NotNull</code> 被注释的元素必须不为 null</li>
<li><code>@AssertTrue</code> 被注释的元素必须为 true</li>
<li><code>@AssertFalse</code> 被注释的元素必须为 false</li>
<li><code>@Pattern(regex=,flag=)</code>被注释的元素必须符合指定的正则表达式</li>
<li><code>@Email</code> 被注释的元素必须是 Email 格式。</li>
<li><code>@Min(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@Max(value)</code>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@DecimalMin(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@Size(max=, min=)</code>被注释的元素的大小必须在指定的范围内</li>
<li><code>@Digits(integer, fraction)</code>被注释的元素必须是一个数字，其值必须在可接受的范围内</li>
<li><code>@Past</code>被注释的元素必须是一个过去的日期</li>
<li><code>@Future</code> 被注释的元素必须是一个将来的日期</li>
<li>......</li>
</ul>
<h4 id="_6-2-验证请求体-requestbody"> 6.2. 验证请求体(RequestBody)</h4>
<div><pre><code><span>@Data</span>
<span>@AllArgsConstructor</span>
<span>@NoArgsConstructor</span>
<span>public</span> <span>class</span> <span>Person</span> <span>{</span>

    <span>@NotNull</span><span>(</span>message <span>=</span> <span>"classId 不能为空"</span><span>)</span>
    <span>private</span> <span>String</span> classId<span>;</span>

    <span>@Size</span><span>(</span>max <span>=</span> <span>33</span><span>)</span>
    <span>@NotNull</span><span>(</span>message <span>=</span> <span>"name 不能为空"</span><span>)</span>
    <span>private</span> <span>String</span> name<span>;</span>

    <span>@Pattern</span><span>(</span>regexp <span>=</span> <span>"((^Man$|^Woman$|^UGM$))"</span><span>,</span> message <span>=</span> <span>"sex 值不在可选范围"</span><span>)</span>
    <span>@NotNull</span><span>(</span>message <span>=</span> <span>"sex 不能为空"</span><span>)</span>
    <span>private</span> <span>String</span> sex<span>;</span>

    <span>@Email</span><span>(</span>message <span>=</span> <span>"email 格式不正确"</span><span>)</span>
    <span>@NotNull</span><span>(</span>message <span>=</span> <span>"email 不能为空"</span><span>)</span>
    <span>private</span> <span>String</span> email<span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>我们在需要验证的参数上加上了<code>@Valid</code>注解，如果验证失败，它将抛出<code>MethodArgumentNotValidException</code>。</p>
<div><pre><code><span>@RestController</span>
<span>@RequestMapping</span><span>(</span><span>"/api"</span><span>)</span>
<span>public</span> <span>class</span> <span>PersonController</span> <span>{</span>

    <span>@PostMapping</span><span>(</span><span>"/person"</span><span>)</span>
    <span>public</span> <span>ResponseEntity</span><span><span>&lt;</span><span>Person</span><span>></span></span> <span>getPerson</span><span>(</span><span>@RequestBody</span> <span>@Valid</span> <span>Person</span> person<span>)</span> <span>{</span>
        <span>return</span> <span>ResponseEntity</span><span>.</span><span>ok</span><span>(</span><span>)</span><span>.</span><span>body</span><span>(</span>person<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="_6-3-验证请求参数-path-variables-和-request-parameters"> 6.3. 验证请求参数(Path Variables 和 Request Parameters)</h4>
<p><strong>一定一定不要忘记在类上加上 <code>@Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</strong></p>
<div><pre><code><span>@RestController</span>
<span>@RequestMapping</span><span>(</span><span>"/api"</span><span>)</span>
<span>@Validated</span>
<span>public</span> <span>class</span> <span>PersonController</span> <span>{</span>

    <span>@GetMapping</span><span>(</span><span>"/person/{id}"</span><span>)</span>
    <span>public</span> <span>ResponseEntity</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>getPersonByID</span><span>(</span><span>@Valid</span> <span>@PathVariable</span><span>(</span><span>"id"</span><span>)</span> <span>@Max</span><span>(</span>value <span>=</span> <span>5</span><span>,</span>message <span>=</span> <span>"超过 id 的范围了"</span><span>)</span> <span>Integer</span> id<span>)</span> <span>{</span>
        <span>return</span> <span>ResponseEntity</span><span>.</span><span>ok</span><span>(</span><span>)</span><span>.</span><span>body</span><span>(</span>id<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>更多关于如何在 Spring 项目中进行参数校验的内容，请看《<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485783&amp;idx=1&amp;sn=a407f3b75efa17c643407daa7fb2acd6&amp;chksm=cea2469cf9d5cf8afbcd0a8a1c9cc4294d6805b8e01bee6f76bb2884c5bc15478e91459def49&amp;token=292197051&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">如何在 Spring/Spring Boot 中做参数校验？你需要了解的都在这里！</a>》这篇文章。</p>
<h3 id="_7-全局处理-controller-层异常"> 7. 全局处理 Controller 层异常</h3>
<p>介绍一下我们 Spring 项目必备的全局处理 Controller 层异常。</p>
<p><strong>相关注解：</strong></p>
<ol>
<li><code>@ControllerAdvice</code> :注解定义全局异常处理类</li>
<li><code>@ExceptionHandler</code> :注解声明异常处理方法</li>
</ol>
<p>如何使用呢？拿我们在第 5 节参数校验这块来举例子。如果方法参数不对的话就会抛出<code>MethodArgumentNotValidException</code>，我们来处理这个异常。</p>
<div><pre><code><span>@ControllerAdvice</span>
<span>@ResponseBody</span>
<span>public</span> <span>class</span> <span>GlobalExceptionHandler</span> <span>{</span>

    <span>/**
     * 请求参数异常处理
     */</span>
    <span>@ExceptionHandler</span><span>(</span><span>MethodArgumentNotValidException</span><span>.</span><span>class</span><span>)</span>
    <span>public</span> <span>ResponseEntity</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>handleMethodArgumentNotValidException</span><span>(</span><span>MethodArgumentNotValidException</span> ex<span>,</span> <span>HttpServletRequest</span> request<span>)</span> <span>{</span>
       <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>更多关于 Spring Boot 异常处理的内容，请看我的这两篇文章：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485568&amp;idx=2&amp;sn=c5ba880fd0c5d82e39531fa42cb036ac&amp;chksm=cea2474bf9d5ce5dcbc6a5f6580198fdce4bc92ef577579183a729cb5d1430e4994720d59b34&amp;token=2133161636&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot 处理异常的几种常见姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486379&amp;idx=2&amp;sn=48c29ae65b3ed874749f0803f0e4d90e&amp;chksm=cea24460f9d5cd769ed53ad7e17c97a7963a89f5350e370be633db0ae8d783c3a3dbd58c70f8&amp;token=1054498516&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">使用枚举简单封装一个优雅的 Spring Boot 全局异常处理！</a></li>
</ol>
<h3 id="_8-jpa-相关"> 8. JPA 相关</h3>
<h4 id="_8-1-创建表"> 8.1. 创建表</h4>
<p><code>@Entity</code>声明一个类对应一个数据库实体。</p>
<p><code>@Table</code> 设置表名</p>
<div><pre><code><span>@Entity</span>
<span>@Table</span><span>(</span>name <span>=</span> <span>"role"</span><span>)</span>
<span>public</span> <span>class</span> <span>Role</span> <span>{</span>
    <span>@Id</span>
    <span>@GeneratedValue</span><span>(</span>strategy <span>=</span> <span>GenerationType</span><span>.</span>IDENTITY<span>)</span>
    <span>private</span> <span>Long</span> id<span>;</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>String</span> description<span>;</span>
    省略getter<span>/</span>setter<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="_8-2-创建主键"> 8.2. 创建主键</h4>
<p><code>@Id</code> ：声明一个字段为主键。</p>
<p>使用<code>@Id</code>声明之后，我们还需要定义主键的生成策略。我们可以使用 <code>@GeneratedValue</code> 指定主键生成策略。</p>
<p><strong>1.通过 <code>@GeneratedValue</code>直接使用 JPA 内置提供的四种主键生成策略来指定主键生成策略。</strong></p>
<div><pre><code><span>@Id</span>
<span>@GeneratedValue</span><span>(</span>strategy <span>=</span> <span>GenerationType</span><span>.</span>IDENTITY<span>)</span>
<span>private</span> <span>Long</span> id<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>JPA 使用枚举定义了 4 种常见的主键生成策略，如下：</p>
<p><em>Guide 哥：枚举替代常量的一种用法</em></p>
<div><pre><code><span>public</span> <span>enum</span> <span>GenerationType</span> <span>{</span>

    <span>/**
     * 使用一个特定的数据库表格来保存主键
     * 持久化引擎通过关系数据库的一张特定的表格来生成主键,
     */</span>
    TABLE<span>,</span>

    <span>/**
     *在某些数据库中,不支持主键自增长,比如Oracle、PostgreSQL其提供了一种叫做"序列(sequence)"的机制生成主键
     */</span>
    SEQUENCE<span>,</span>

    <span>/**
     * 主键自增长
     */</span>
    IDENTITY<span>,</span>

    <span>/**
     *把主键生成策略交给持久化引擎(persistence engine),
     *持久化引擎会根据数据库在以上三种主键生成 策略中选择其中一种
     */</span>
    AUTO
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p><code>@GeneratedValue</code>注解默认使用的策略是<code>GenerationType.AUTO</code></p>
<div><pre><code><span>public</span> <span>@interface</span> <span>GeneratedValue</span> <span>{</span>

    <span>GenerationType</span> <span>strategy</span><span>(</span><span>)</span> <span>default</span> AUTO<span>;</span>
    <span>String</span> <span>generator</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>一般使用 MySQL 数据库的话，使用<code>GenerationType.IDENTITY</code>策略比较普遍一点（分布式系统的话需要另外考虑使用分布式 ID）。</p>
<p><strong>2.通过 <code>@GenericGenerator</code>声明一个主键策略，然后 <code>@GeneratedValue</code>使用这个策略</strong></p>
<div><pre><code><span>@Id</span>
<span>@GeneratedValue</span><span>(</span>generator <span>=</span> <span>"IdentityIdGenerator"</span><span>)</span>
<span>@GenericGenerator</span><span>(</span>name <span>=</span> <span>"IdentityIdGenerator"</span><span>,</span> strategy <span>=</span> <span>"identity"</span><span>)</span>
<span>private</span> <span>Long</span> id<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>等价于：</p>
<div><pre><code><span>@Id</span>
<span>@GeneratedValue</span><span>(</span>strategy <span>=</span> <span>GenerationType</span><span>.</span>IDENTITY<span>)</span>
<span>private</span> <span>Long</span> id<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>jpa 提供的主键生成策略有如下几种：</p>
<div><pre><code><span>public</span> <span>class</span> <span>DefaultIdentifierGeneratorFactory</span>
		<span>implements</span> <span>MutableIdentifierGeneratorFactory</span><span>,</span> <span>Serializable</span><span>,</span> <span>ServiceRegistryAwareService</span> <span>{</span>

	<span>@SuppressWarnings</span><span>(</span><span>"deprecation"</span><span>)</span>
	<span>public</span> <span>DefaultIdentifierGeneratorFactory</span><span>(</span><span>)</span> <span>{</span>
		<span>register</span><span>(</span> <span>"uuid2"</span><span>,</span> <span>UUIDGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span>
		<span>register</span><span>(</span> <span>"guid"</span><span>,</span> <span>GUIDGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span>			<span>// can be done with UUIDGenerator + strategy</span>
		<span>register</span><span>(</span> <span>"uuid"</span><span>,</span> <span>UUIDHexGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span>			<span>// "deprecated" for new use</span>
		<span>register</span><span>(</span> <span>"uuid.hex"</span><span>,</span> <span>UUIDHexGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span> 	<span>// uuid.hex is deprecated</span>
		<span>register</span><span>(</span> <span>"assigned"</span><span>,</span> <span>Assigned</span><span>.</span><span>class</span> <span>)</span><span>;</span>
		<span>register</span><span>(</span> <span>"identity"</span><span>,</span> <span>IdentityGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span>
		<span>register</span><span>(</span> <span>"select"</span><span>,</span> <span>SelectGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span>
		<span>register</span><span>(</span> <span>"sequence"</span><span>,</span> <span>SequenceStyleGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span>
		<span>register</span><span>(</span> <span>"seqhilo"</span><span>,</span> <span>SequenceHiLoGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span>
		<span>register</span><span>(</span> <span>"increment"</span><span>,</span> <span>IncrementGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span>
		<span>register</span><span>(</span> <span>"foreign"</span><span>,</span> <span>ForeignGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span>
		<span>register</span><span>(</span> <span>"sequence-identity"</span><span>,</span> <span>SequenceIdentityGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span>
		<span>register</span><span>(</span> <span>"enhanced-sequence"</span><span>,</span> <span>SequenceStyleGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span>
		<span>register</span><span>(</span> <span>"enhanced-table"</span><span>,</span> <span>TableGenerator</span><span>.</span><span>class</span> <span>)</span><span>;</span>
	<span>}</span>

	<span>public</span> <span>void</span> <span>register</span><span>(</span><span>String</span> strategy<span>,</span> <span>Class</span> generatorClass<span>)</span> <span>{</span>
		LOG<span>.</span><span>debugf</span><span>(</span> <span>"Registering IdentifierGenerator strategy [%s] -> [%s]"</span><span>,</span> strategy<span>,</span> generatorClass<span>.</span><span>getName</span><span>(</span><span>)</span> <span>)</span><span>;</span>
		<span>final</span> <span>Class</span> previous <span>=</span> generatorStrategyToClassNameMap<span>.</span><span>put</span><span>(</span> strategy<span>,</span> generatorClass <span>)</span><span>;</span>
		<span>if</span> <span>(</span> previous <span>!=</span> <span>null</span> <span>)</span> <span>{</span>
			LOG<span>.</span><span>debugf</span><span>(</span> <span>"    - overriding [%s]"</span><span>,</span> previous<span>.</span><span>getName</span><span>(</span><span>)</span> <span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h4 id="_8-3-设置字段类型"> 8.3. 设置字段类型</h4>
<p><code>@Column</code> 声明字段。</p>
<p><strong>示例：</strong></p>
<p>设置属性 userName 对应的数据库字段名为 user_name，长度为 32，非空</p>
<div><pre><code><span>@Column</span><span>(</span>name <span>=</span> <span>"user_name"</span><span>,</span> nullable <span>=</span> <span>false</span><span>,</span> length<span>=</span><span>32</span><span>)</span>
<span>private</span> <span>String</span> userName<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>设置字段类型并且加默认值，这个还是挺常用的。</p>
<div><pre><code><span>@Column</span><span>(</span>columnDefinition <span>=</span> <span>"tinyint(1) default 1"</span><span>)</span>
<span>private</span> <span>Boolean</span> enabled<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="_8-4-指定不持久化特定字段"> 8.4. 指定不持久化特定字段</h4>
<p><code>@Transient</code> ：声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库 。</p>
<p>如果我们想让<code>secrect</code> 这个字段不被持久化，可以使用 <code>@Transient</code>关键字声明。</p>
<div><pre><code><span>@Entity</span><span>(</span>name<span>=</span><span>"USER"</span><span>)</span>
<span>public</span> <span>class</span> <span>User</span> <span>{</span>

    <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
    <span>@Transient</span>
    <span>private</span> <span>String</span> secrect<span>;</span> <span>// not persistent because of @Transient</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>除了 <code>@Transient</code>关键字声明， 还可以采用下面几种方法：</p>
<div><pre><code><span>static</span> <span>String</span> secrect<span>;</span> <span>// not persistent because of static</span>
<span>final</span> <span>String</span> secrect <span>=</span> <span>"Satish"</span><span>;</span> <span>// not persistent because of final</span>
<span>transient</span> <span>String</span> secrect<span>;</span> <span>// not persistent because of transient</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>一般使用注解的方式比较多。</p>
<h4 id="_8-5-声明大字段"> 8.5. 声明大字段</h4>
<p><code>@Lob</code>:声明某个字段为大字段。</p>
<div><pre><code><span>@Lob</span>
<span>private</span> <span>String</span> content<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>更详细的声明：</p>
<div><pre><code><span>@Lob</span>
<span>//指定 Lob 类型数据的获取策略， FetchType.EAGER 表示非延迟加载，而 FetchType.LAZY 表示延迟加载 ；</span>
<span>@Basic</span><span>(</span>fetch <span>=</span> <span>FetchType</span><span>.</span>EAGER<span>)</span>
<span>//columnDefinition 属性指定数据表对应的 Lob 字段类型</span>
<span>@Column</span><span>(</span>name <span>=</span> <span>"content"</span><span>,</span> columnDefinition <span>=</span> <span>"LONGTEXT NOT NULL"</span><span>)</span>
<span>private</span> <span>String</span> content<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="_8-6-创建枚举类型的字段"> 8.6. 创建枚举类型的字段</h4>
<p>可以使用枚举类型的字段，不过枚举字段要用<code>@Enumerated</code>注解修饰。</p>
<div><pre><code><span>public</span> <span>enum</span> <span>Gender</span> <span>{</span>
    <span>MALE</span><span>(</span><span>"男性"</span><span>)</span><span>,</span>
    <span>FEMALE</span><span>(</span><span>"女性"</span><span>)</span><span>;</span>

    <span>private</span> <span>String</span> value<span>;</span>
    <span>Gender</span><span>(</span><span>String</span> str<span>)</span><span>{</span>
        value<span>=</span>str<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span>@Entity</span>
<span>@Table</span><span>(</span>name <span>=</span> <span>"role"</span><span>)</span>
<span>public</span> <span>class</span> <span>Role</span> <span>{</span>
    <span>@Id</span>
    <span>@GeneratedValue</span><span>(</span>strategy <span>=</span> <span>GenerationType</span><span>.</span>IDENTITY<span>)</span>
    <span>private</span> <span>Long</span> id<span>;</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>String</span> description<span>;</span>
    <span>@Enumerated</span><span>(</span><span>EnumType</span><span>.</span>STRING<span>)</span>
    <span>private</span> <span>Gender</span> gender<span>;</span>
    省略getter<span>/</span>setter<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>数据库里面对应存储的是 MALE/FEMALE。</p>
<h4 id="_8-7-增加审计功能"> 8.7. 增加审计功能</h4>
<p>只要继承了 <code>AbstractAuditBase</code>的类都会默认加上下面四个字段。</p>
<div><pre><code><span>@Data</span>
<span>@AllArgsConstructor</span>
<span>@NoArgsConstructor</span>
<span>@MappedSuperclass</span>
<span>@EntityListeners</span><span>(</span>value <span>=</span> <span>AuditingEntityListener</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>abstract</span> <span>class</span> <span>AbstractAuditBase</span> <span>{</span>

    <span>@CreatedDate</span>
    <span>@Column</span><span>(</span>updatable <span>=</span> <span>false</span><span>)</span>
    <span>@JsonIgnore</span>
    <span>private</span> <span>Instant</span> createdAt<span>;</span>

    <span>@LastModifiedDate</span>
    <span>@JsonIgnore</span>
    <span>private</span> <span>Instant</span> updatedAt<span>;</span>

    <span>@CreatedBy</span>
    <span>@Column</span><span>(</span>updatable <span>=</span> <span>false</span><span>)</span>
    <span>@JsonIgnore</span>
    <span>private</span> <span>String</span> createdBy<span>;</span>

    <span>@LastModifiedBy</span>
    <span>@JsonIgnore</span>
    <span>private</span> <span>String</span> updatedBy<span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>我们对应的审计功能对应地配置类可能是下面这样的（Spring Security 项目）:</p>
<div><pre><code>
<span>@Configuration</span>
<span>@EnableJpaAuditing</span>
<span>public</span> <span>class</span> <span>AuditSecurityConfiguration</span> <span>{</span>
    <span>@Bean</span>
    <span>AuditorAware</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>auditorAware</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>(</span><span>)</span> <span>-></span> <span>Optional</span><span>.</span><span>ofNullable</span><span>(</span><span>SecurityContextHolder</span><span>.</span><span>getContext</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>map</span><span>(</span><span>SecurityContext</span><span>::</span><span>getAuthentication</span><span>)</span>
                <span>.</span><span>filter</span><span>(</span><span>Authentication</span><span>::</span><span>isAuthenticated</span><span>)</span>
                <span>.</span><span>map</span><span>(</span><span>Authentication</span><span>::</span><span>getName</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>简单介绍一下上面涉及到的一些注解：</p>
<ol>
<li>
<p><code>@CreatedDate</code>: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</p>
</li>
<li>
<p><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值</p>
<p><code>@LastModifiedDate</code>、<code>@LastModifiedBy</code>同理。</p>
</li>
</ol>
<p><code>@EnableJpaAuditing</code>：开启 JPA 审计功能。</p>
<h4 id="_8-8-删除-修改数据"> 8.8. 删除/修改数据</h4>
<p><code>@Modifying</code> 注解提示 JPA 该操作是修改操作,注意还要配合<code>@Transactional</code>注解使用。</p>
<div><pre><code><span>@Repository</span>
<span>public</span> <span>interface</span> <span>UserRepository</span> <span>extends</span> <span>JpaRepository</span><span><span>&lt;</span><span>User</span><span>,</span> <span>Integer</span><span>></span></span> <span>{</span>

    <span>@Modifying</span>
    <span>@Transactional</span><span>(</span>rollbackFor <span>=</span> <span>Exception</span><span>.</span><span>class</span><span>)</span>
    <span>void</span> <span>deleteByUserName</span><span>(</span><span>String</span> userName<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="_8-9-关联关系"> 8.9. 关联关系</h4>
<ul>
<li><code>@OneToOne</code> 声明一对一关系</li>
<li><code>@OneToMany</code> 声明一对多关系</li>
<li><code>@ManyToOne</code> 声明多对一关系</li>
<li><code>@MangToMang</code> 声明多对多关系</li>
</ul>
<p>更多关于 Spring Boot JPA 的文章请看我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485689&amp;idx=1&amp;sn=061b32c2222869932be5631fb0bb5260&amp;chksm=cea24732f9d5ce24a356fb3675170e7843addbfcc79ee267cfdb45c83fc7e90babf0f20d22e1&amp;token=292197051&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">一文搞懂如何在 Spring Boot 正确中使用 JPA</a> 。</p>
<h3 id="_9-事务-transactional"> 9. 事务 <code>@Transactional</code></h3>
<p>在要开启事务的方法上使用<code>@Transactional</code>注解即可!</p>
<div><pre><code><span>@Transactional</span><span>(</span>rollbackFor <span>=</span> <span>Exception</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>void</span> <span>save</span><span>(</span><span>)</span> <span>{</span>
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>我们知道 Exception 分为运行时异常 RuntimeException 和非运行时异常。在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<p><code>@Transactional</code> 注解一般可以作用在<code>类</code>或者<code>方法</code>上。</p>
<ul>
<li><strong>作用于类</strong>：当把<code>@Transactional</code> 注解放在类上时，表示所有该类的 public 方法都配置相同的事务属性信息。</li>
<li><strong>作用于方法</strong>：当类配置了<code>@Transactional</code>，方法也配置了<code>@Transactional</code>，方法的事务会覆盖类的事务配置信息。</li>
</ul>
<p>更多关于 Spring 事务的内容请查看：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484943&amp;idx=1&amp;sn=46b9082af4ec223137df7d1c8303ca24&amp;chksm=cea249c4f9d5c0d2b8212a17252cbfb74e5fbe5488b76d829827421c53332326d1ec360f5d63&amp;token=1082669959&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">可能是最漂亮的 Spring 事务管理详解</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486483&amp;idx=2&amp;sn=77be488e206186803531ea5d7164ec53&amp;chksm=cea243d8f9d5cacecaa5c5daae4cde4c697b9b5b21f96dfc6cce428cfcb62b88b3970c26b9c2&amp;token=816772476&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">一口气说出 6 种 @Transactional 注解失效场景</a></li>
</ol>
<h3 id="_10-json-数据处理"> 10. json 数据处理</h3>
<h4 id="_10-1-过滤-json-数据"> 10.1. 过滤 json 数据</h4>
<p><strong><code>@JsonIgnoreProperties</code> 作用在类上用于过滤掉特定字段不返回或者不解析。</strong></p>
<div><pre><code><span>//生成json时将userRoles属性过滤</span>
<span>@JsonIgnoreProperties</span><span>(</span><span>{</span><span>"userRoles"</span><span>}</span><span>)</span>
<span>public</span> <span>class</span> <span>User</span> <span>{</span>

    <span>private</span> <span>String</span> userName<span>;</span>
    <span>private</span> <span>String</span> fullName<span>;</span>
    <span>private</span> <span>String</span> password<span>;</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>UserRole</span><span>></span></span> userRoles <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong><code>@JsonIgnore</code>一般用于类的属性上，作用和上面的<code>@JsonIgnoreProperties</code> 一样。</strong></p>
<div><pre><code>
<span>public</span> <span>class</span> <span>User</span> <span>{</span>

    <span>private</span> <span>String</span> userName<span>;</span>
    <span>private</span> <span>String</span> fullName<span>;</span>
    <span>private</span> <span>String</span> password<span>;</span>
   <span>//生成json时将userRoles属性过滤</span>
    <span>@JsonIgnore</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>UserRole</span><span>></span></span> userRoles <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="_10-2-格式化-json-数据"> 10.2. 格式化 json 数据</h4>
<p><code>@JsonFormat</code>一般用来格式化 json 数据。</p>
<p>比如：</p>
<div><pre><code><span>@JsonFormat</span><span>(</span>shape<span>=</span><span>JsonFormat<span>.</span>Shape</span><span>.</span>STRING<span>,</span> pattern<span>=</span><span>"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"</span><span>,</span> timezone<span>=</span><span>"GMT"</span><span>)</span>
<span>private</span> <span>Date</span> date<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="_10-3-扁平化对象"> 10.3. 扁平化对象</h4>
<div><pre><code><span>@Getter</span>
<span>@Setter</span>
<span>@ToString</span>
<span>public</span> <span>class</span> <span>Account</span> <span>{</span>
    <span>private</span> <span>Location</span> location<span>;</span>
    <span>private</span> <span>PersonInfo</span> personInfo<span>;</span>

  <span>@Getter</span>
  <span>@Setter</span>
  <span>@ToString</span>
  <span>public</span> <span>static</span> <span>class</span> <span>Location</span> <span>{</span>
     <span>private</span> <span>String</span> provinceName<span>;</span>
     <span>private</span> <span>String</span> countyName<span>;</span>
  <span>}</span>
  <span>@Getter</span>
  <span>@Setter</span>
  <span>@ToString</span>
  <span>public</span> <span>static</span> <span>class</span> <span>PersonInfo</span> <span>{</span>
    <span>private</span> <span>String</span> userName<span>;</span>
    <span>private</span> <span>String</span> fullName<span>;</span>
  <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>未扁平化之前：</p>
<div><pre><code><span>{</span>
    <span>"location"</span><span>:</span> <span>{</span>
        <span>"provinceName"</span><span>:</span><span>"湖北"</span><span>,</span>
        <span>"countyName"</span><span>:</span><span>"武汉"</span>
    <span>}</span><span>,</span>
    <span>"personInfo"</span><span>:</span> <span>{</span>
        <span>"userName"</span><span>:</span> <span>"coder1234"</span><span>,</span>
        <span>"fullName"</span><span>:</span> <span>"shaungkou"</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>使用<code>@JsonUnwrapped</code> 扁平对象之后：</p>
<div><pre><code><span>@Getter</span>
<span>@Setter</span>
<span>@ToString</span>
<span>public</span> <span>class</span> <span>Account</span> <span>{</span>
    <span>@JsonUnwrapped</span>
    <span>private</span> <span>Location</span> location<span>;</span>
    <span>@JsonUnwrapped</span>
    <span>private</span> <span>PersonInfo</span> personInfo<span>;</span>
    <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>{</span>
  <span>"provinceName"</span><span>:</span><span>"湖北"</span><span>,</span>
  <span>"countyName"</span><span>:</span><span>"武汉"</span><span>,</span>
  <span>"userName"</span><span>:</span> <span>"coder1234"</span><span>,</span>
  <span>"fullName"</span><span>:</span> <span>"shaungkou"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_11-测试相关"> 11. 测试相关</h3>
<p><strong><code>@ActiveProfiles</code>一般作用于测试类上， 用于声明生效的 Spring 配置文件。</strong></p>
<div><pre><code><span>@SpringBootTest</span><span>(</span>webEnvironment <span>=</span> RANDOM_PORT<span>)</span>
<span>@ActiveProfiles</span><span>(</span><span>"test"</span><span>)</span>
<span>@Slf4j</span>
<span>public</span> <span>abstract</span> <span>class</span> <span>TestBase</span> <span>{</span>
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong><code>@Test</code>声明一个方法为测试方法</strong></p>
<p><strong><code>@Transactional</code>被声明的测试方法的数据会回滚，避免污染测试数据。</strong></p>
<p><strong><code>@WithMockUser</code> Spring Security 提供的，用来模拟一个真实用户，并且可以赋予权限。</strong></p>
<div><pre><code>    <span>@Test</span>
    <span>@Transactional</span>
    <span>@WithMockUser</span><span>(</span>username <span>=</span> <span>"user-id-18163138155"</span><span>,</span> authorities <span>=</span> <span>"ROLE_TEACHER"</span><span>)</span>
    <span>void</span> <span>should_import_student_success</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><em>暂时总结到这里吧！虽然花了挺长时间才写完，不过可能还是会一些常用的注解的被漏掉，所以，我将文章也同步到了 Github 上去，Github 地址： 欢迎完善！</em></p>
<p>本文已经收录进我的 75K Star 的 Java 开源项目 JavaGuide：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener noreferrer">https://github.com/Snailclimb/JavaGuide</a>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Spring 设计模式总结</title>
      <link>https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary/</link>
      <guid>https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary/</guid>
      <source url="https://javaguide.cn/rss.xml">Spring 设计模式总结</source>
      <category>框架</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见。我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下，由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的设计模式。</p>
<p>Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p>
<h2 id="控制反转-ioc-和依赖注入-di"> 控制反转(IoC)和依赖注入(DI)</h2>
<p><strong>IoC(Inversion of Control,控制反转)</strong> 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容器管理对象，你只管使用即可)，从而降低代码之间的耦合度。<strong>IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ioc-patterns.png" alt="ioc-patterns" /></p>
<p><strong>Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p>
<p>在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答：<a href="https://www.zhihu.com/question/23277575/answer/169698662" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/23277575/answer/169698662</a>  ，非常不错。</p>
<p><strong>控制反转怎么理解呢?</strong> 举个例子：&quot;对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中&quot;。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权反转，这就是控制反转名字的由来。</p>
<p><strong>DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。</strong></p>
<h2 id="工厂设计模式"> 工厂设计模式</h2>
<p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>
<p><strong>两者对比：</strong></p>
<ul>
<li><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>ApplicationContext</code> 来说会占用更少的内存，程序启动速度更快。</li>
<li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</li>
</ul>
<p>ApplicationContext的三个实现类：</p>
<ol>
<li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li>
<li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li>
<li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li>
</ol>
<p>Example:</p>
<div><pre><code><span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span></span><span>ApplicationContext</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span>support<span>.</span></span><span>FileSystemXmlApplicationContext</span><span>;</span>
 
<span>public</span> <span>class</span> <span>App</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>ApplicationContext</span> context <span>=</span> <span>new</span> <span>FileSystemXmlApplicationContext</span><span>(</span>
				<span>"C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml"</span><span>)</span><span>;</span>
 
		<span>HelloApplicationContext</span> obj <span>=</span> <span>(</span><span>HelloApplicationContext</span><span>)</span> context<span>.</span><span>getBean</span><span>(</span><span>"helloApplicationContext"</span><span>)</span><span>;</span>
		obj<span>.</span><span>getMsg</span><span>(</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="单例设计模式"> 单例设计模式</h2>
<p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p>
<p><strong>使用单例模式的好处:</strong></p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p>
<ul>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<p><strong>Spring 实现单例的方式：</strong></p>
<ul>
<li>xml : <code>&lt;bean id=&quot;userService&quot; class=&quot;top.snailclimb.UserService&quot; scope=&quot;singleton&quot;/&gt;</code></li>
<li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li>
</ul>
<p><strong>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下</strong></p>
<div><pre><code><span>// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span>
<span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> singletonObjects <span>=</span> <span>new</span> <span>ConcurrentHashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span><span>(</span><span>64</span><span>)</span><span>;</span>

<span>public</span> <span>Object</span> <span>getSingleton</span><span>(</span><span>String</span> beanName<span>,</span> <span>ObjectFactory</span><span><span>&lt;</span><span>?</span><span>></span></span> singletonFactory<span>)</span> <span>{</span>
        <span>Assert</span><span>.</span><span>notNull</span><span>(</span>beanName<span>,</span> <span>"'beanName' must not be null"</span><span>)</span><span>;</span>
        <span>synchronized</span> <span>(</span><span>this</span><span>.</span>singletonObjects<span>)</span> <span>{</span>
            <span>// 检查缓存中是否存在实例  </span>
            <span>Object</span> singletonObject <span>=</span> <span>this</span><span>.</span>singletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>
            <span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span><span>)</span> <span>{</span>
                <span>//...省略了很多代码</span>
                <span>try</span> <span>{</span>
                    singletonObject <span>=</span> singletonFactory<span>.</span><span>getObject</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                <span>//...省略了很多代码</span>
                <span>// 如果实例对象在不存在，我们注册到单例注册表中。</span>
                <span>addSingleton</span><span>(</span>beanName<span>,</span> singletonObject<span>)</span><span>;</span>
            <span>}</span>
            <span>return</span> <span>(</span>singletonObject <span>!=</span> NULL_OBJECT <span>?</span> singletonObject <span>:</span> <span>null</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>//将对象添加到单例注册表</span>
    <span>protected</span> <span>void</span> <span>addSingleton</span><span>(</span><span>String</span> beanName<span>,</span> <span>Object</span> singletonObject<span>)</span> <span>{</span>
            <span>synchronized</span> <span>(</span><span>this</span><span>.</span>singletonObjects<span>)</span> <span>{</span>
                <span>this</span><span>.</span>singletonObjects<span>.</span><span>put</span><span>(</span>beanName<span>,</span> <span>(</span>singletonObject <span>!=</span> <span>null</span> <span>?</span> singletonObject <span>:</span> NULL_OBJECT<span>)</span><span>)</span><span>;</span>

            <span>}</span>
        <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id="代理设计模式"> 代理设计模式</h2>
<h3 id="代理模式在-aop-中的应用"> 代理模式在 AOP 中的应用</h3>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg" alt="SpringAOPProcess" /></p>
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h3 id="spring-aop-和-aspectj-aop-有什么区别"> Spring AOP 和 AspectJ AOP 有什么区别?</h3>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ  相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h2 id="模板方法"> 模板方法</h2>
<p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Template</span> <span>{</span>
    <span>//这是我们的模板方法</span>
    <span>public</span> <span>final</span> <span>void</span> <span>TemplateMethod</span><span>(</span><span>)</span><span>{</span>
        <span>PrimitiveOperation1</span><span>(</span><span>)</span><span>;</span>  
        <span>PrimitiveOperation2</span><span>(</span><span>)</span><span>;</span>
        <span>PrimitiveOperation3</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>protected</span> <span>void</span>  <span>PrimitiveOperation1</span><span>(</span><span>)</span><span>{</span>
        <span>//当前类实现</span>
    <span>}</span>
    
    <span>//被子类实现的方法</span>
    <span>protected</span> <span>abstract</span> <span>void</span> <span>PrimitiveOperation2</span><span>(</span><span>)</span><span>;</span>
    <span>protected</span> <span>abstract</span> <span>void</span> <span>PrimitiveOperation3</span><span>(</span><span>)</span><span>;</span>

<span>}</span>
<span>public</span> <span>class</span> <span>TemplateImpl</span> <span>extends</span> <span>Template</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>PrimitiveOperation2</span><span>(</span><span>)</span> <span>{</span>
        <span>//当前类实现</span>
    <span>}</span>
    
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>PrimitiveOperation3</span><span>(</span><span>)</span> <span>{</span>
        <span>//当前类实现</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p>
<h2 id="观察者模式"> 观察者模式</h2>
<p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p>
<h3 id="spring-事件驱动模型中的三种角色"> Spring 事件驱动模型中的三种角色</h3>
<h4 id="事件角色"> 事件角色</h4>
<p><code>ApplicationEvent</code> (<code>org.springframework.context</code>包下)充当事件的角色,这是一个抽象类，它继承了<code>java.util.EventObject</code>并实现了 <code>java.io.Serializable</code>接口。</p>
<p>Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自<code>ApplicationContextEvent</code>)：</p>
<ul>
<li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li>
<li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li>
<li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li>
<li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件。</li>
</ul>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ApplicationEvent-Subclass.png" alt="ApplicationEvent-Subclass" /></p>
<h4 id="事件监听者角色"> 事件监听者角色</h4>
<p><code>ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code>onApplicationEvent（）</code>方法来处理<code>ApplicationEvent</code>。<code>ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code>ApplicationEvent</code>就可以了。所以，在 Spring中我们只要实现 <code>ApplicationListener</code> 接口的 <code>onApplicationEvent()</code> 方法即可完成监听事件</p>
<div><pre><code><span>package</span> <span>org<span>.</span>springframework<span>.</span>context</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>EventListener</span><span>;</span>
<span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>ApplicationListener</span><span><span>&lt;</span><span>E</span> <span>extends</span> <span>ApplicationEvent</span><span>></span></span> <span>extends</span> <span>EventListener</span> <span>{</span>
    <span>void</span> <span>onApplicationEvent</span><span>(</span><span>E</span> var1<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="事件发布者角色"> 事件发布者角色</h4>
<p><code>ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>ApplicationEventPublisher</span> <span>{</span>
    <span>default</span> <span>void</span> <span>publishEvent</span><span>(</span><span>ApplicationEvent</span> event<span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>publishEvent</span><span>(</span><span>(</span><span>Object</span><span>)</span>event<span>)</span><span>;</span>
    <span>}</span>

    <span>void</span> <span>publishEvent</span><span>(</span><span>Object</span> var1<span>)</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>ApplicationEventPublisher</code> 接口的<code>publishEvent（）</code>这个方法在<code>AbstractApplicationContext</code>类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过<code>ApplicationEventMulticaster</code>来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</p>
<h3 id="spring-的事件流程总结"> Spring 的事件流程总结</h3>
<ol>
<li>定义一个事件: 实现一个继承自 <code>ApplicationEvent</code>，并且写相应的构造函数；</li>
<li>定义一个事件监听者：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法；</li>
<li>使用事件发布者发布消息:  可以通过 <code>ApplicationEventPublisher</code> 的 <code>publishEvent()</code> 方法发布消息。</li>
</ol>
<p>Example:</p>
<div><pre><code><span>// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span>
<span>public</span> <span>class</span> <span>DemoEvent</span> <span>extends</span> <span>ApplicationEvent</span><span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>1L</span><span>;</span>

    <span>private</span> <span>String</span> message<span>;</span>

    <span>public</span> <span>DemoEvent</span><span>(</span><span>Object</span> source<span>,</span><span>String</span> message<span>)</span><span>{</span>
        <span>super</span><span>(</span>source<span>)</span><span>;</span>
        <span>this</span><span>.</span>message <span>=</span> message<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getMessage</span><span>(</span><span>)</span> <span>{</span>
         <span>return</span> message<span>;</span>
          <span>}</span>

    
<span>// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span>
<span>@Component</span>
<span>public</span> <span>class</span> <span>DemoListener</span> <span>implements</span> <span>ApplicationListener</span><span><span>&lt;</span><span>DemoEvent</span><span>></span></span><span>{</span>

    <span>//使用onApplicationEvent接收消息</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onApplicationEvent</span><span>(</span><span>DemoEvent</span> event<span>)</span> <span>{</span>
        <span>String</span> msg <span>=</span> event<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"接收到的信息是："</span><span>+</span>msg<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
<span>// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span>
<span>@Component</span>
<span>public</span> <span>class</span> <span>DemoPublisher</span> <span>{</span>

    <span>@Autowired</span>
    <span>ApplicationContext</span> applicationContext<span>;</span>

    <span>public</span> <span>void</span> <span>publish</span><span>(</span><span>String</span> message<span>)</span><span>{</span>
        <span>//发布事件</span>
        applicationContext<span>.</span><span>publishEvent</span><span>(</span><span>new</span> <span>DemoEvent</span><span>(</span><span>this</span><span>,</span> message<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>当调用 <code>DemoPublisher</code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish(&quot;你好&quot;)</code> ，控制台就会打印出:<code>接收到的信息是：你好</code> 。</p>
<h2 id="适配器模式"> 适配器模式</h2>
<p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p>
<h3 id="spring-aop中的适配器模式"> spring AOP中的适配器模式</h3>
<p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code> 。Advice 常用的类型有：<code>BeforeAdvice</code>（目标方法调用前,前置通知）、<code>AfterAdvice</code>（目标方法调用后,后置通知）、<code>AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。Spring预定义的通知要通过对应的适配器，适配成 <code>MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</p>
<h3 id="spring-mvc中的适配器模式"> spring MVC中的适配器模式</h3>
<p>在Spring MVC中，<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由<code>HandlerAdapter</code> 适配器处理。<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</p>
<p><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code> 直接获取对应类型的 <code>Controller</code>，需要的自行来判断，像下面这段代码一样：</p>
<div><pre><code><span>if</span><span>(</span>mappedHandler<span>.</span><span>getHandler</span><span>(</span><span>)</span> <span>instanceof</span> <span>MultiActionController</span><span>)</span><span>{</span>  
   <span>(</span><span>(</span><span>MultiActionController</span><span>)</span>mappedHandler<span>.</span><span>getHandler</span><span>(</span><span>)</span><span>)</span><span>.</span>xxx  
<span>}</span><span>else</span> <span>if</span><span>(</span>mappedHandler<span>.</span><span>getHandler</span><span>(</span><span>)</span> <span>instanceof</span> XXX<span>)</span><span>{</span>  
    <span>.</span><span>.</span><span>.</span>  
<span>}</span><span>else</span> <span>if</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>{</span>  
   <span>.</span><span>.</span><span>.</span>  
<span>}</span>  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>假如我们再增加一个 <code>Controller</code>类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p>
<h2 id="装饰者模式"> 装饰者模式</h2>
<p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code>InputStream</code>家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code>InputStream</code> 代码的情况下扩展了它的功能。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Decorator.jpg" alt="装饰者模式示意图" /></p>
<p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code>或者 <code>Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责</p>
<h2 id="总结"> 总结</h2>
<p>Spring 框架中用到了哪些设计模式？</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>......</li>
</ul>
<h2 id="参考"> 参考</h2>
<ul>
<li>《Spring技术内幕》</li>
<li><a href="https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/" target="_blank" rel="noopener noreferrer">https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/</a></li>
<li><a href="http://blog.yeamin.top/2018/03/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Spring%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener noreferrer">http://blog.yeamin.top/2018/03/27/单例模式-Spring单例实现原理分析/</a></li>
<li><a href="https://www.tutorialsteacher.com/ioc/inversion-of-control" target="_blank" rel="noopener noreferrer">https://www.tutorialsteacher.com/ioc/inversion-of-control</a></li>
<li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html" target="_blank" rel="noopener noreferrer">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html</a></li>
<li><a href="https://juejin.im/post/5a8eb261f265da4e9e307230" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5a8eb261f265da4e9e307230</a></li>
<li><a href="https://juejin.im/post/5ba28986f265da0abc2b6084" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5ba28986f265da0abc2b6084</a></li>
</ul>
<h2 id="公众号"> 公众号</h2>
<p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p>
<p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本后台回复 <strong>&quot;Java面试突击&quot;</strong> 即可免费领取！</p>
<p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/167598cd2e17b8ec.png" alt="我的公众号" /></p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ioc-patterns.png" type="image/png"/>
    </item>
    <item>
      <title>Spring常见问题总结</title>
      <link>https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary/</link>
      <guid>https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary/</guid>
      <source url="https://javaguide.cn/rss.xml">Spring常见问题总结</source>
      <category>框架</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>这篇文章主要是想通过一些问题，加深大家对于 Spring 的理解，所以不会涉及太多的代码！</p>
<p>下面的很多问题我自己在使用 Spring 的过程中也并没有注意，自己也是临时查阅了很多资料和书籍补上的。网上也有一些很多关于 Spring 常见问题/面试题整理的文章，我感觉大部分都是互相 copy，而且很多问题也不是很好，有些回答也存在问题。所以，自己花了一周的业余时间整理了一下，希望对大家有帮助。</p>
<h2 id="什么是-spring-框架"> 什么是 Spring 框架?</h2>
<p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<p>Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！</p>
<blockquote>
<p>题外话 ： 语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。</p>
</blockquote>
<p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。</p>
<p>比如说 Spring 自带 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p>
<p><img src="https://img-blog.csdnimg.cn/38ef122122de4375abcd27c3de8f60b4.png" alt="" /></p>
<p>Spring 最核心的思想就是不重新造轮子，开箱即用！</p>
<p>Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！</p>
<ul>
<li>Spring 官网：<a href="https://spring.io/" target="_blank" rel="noopener noreferrer">https://spring.io/</a></li>
<li>Github 地址： https://github.com/spring-projects/spring-framework</li>
</ul>
<h2 id="列举一些重要的-spring-模块"> 列举一些重要的 Spring 模块？</h2>
<p>下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/e0c60b4606711fc4a0b6faf03230247a.png" alt="Spring主要模块" /></p>
<p><strong>Spring Core</strong></p>
<p>核心模块， Spring 其他所有的功能基本都需要依赖于该类库，主要提供 IoC 依赖注入功能的支持。</p>
<p><strong>Spring Aspects</strong></p>
<p>该模块为与 AspectJ 的集成提供支持。</p>
<p><strong>Spring AOP</strong></p>
<p>提供了面向切面的编程实现。</p>
<p><strong>Spring Data Access/Integration ：</strong></p>
<p>Spring Data Access/Integration 由 5 个模块组成：</p>
<ul>
<li>spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li>
<li>spring-tx : 提供对事务的支持。</li>
<li>spring-orm : 提供对 Hibernate 等 ORM 框架的支持。</li>
<li>spring-oxm ： 提供对 Castor 等 OXM 框架的支持。</li>
<li>spring-jms : Java 消息服务。</li>
</ul>
<p><strong>Spring Web</strong></p>
<p>Spring Web 由 4 个模块组成：</p>
<ul>
<li>spring-web ：对 Web 功能的实现提供一些最基础的支持。</li>
<li>spring-webmvc ： 提供对 Spring MVC 的实现。</li>
<li>spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li>
<li>spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.</li>
</ul>
<p><strong>Spring Test</strong></p>
<p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p>
<p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p>
<h2 id="spring-ioc-aop"> Spring IOC &amp; AOP</h2>
<h3 id="谈谈自己对于-spring-ioc-的了解"> 谈谈自己对于 Spring IoC 的了解</h3>
<p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spirng 特有，在其他语言中也有应用。</p>
<p><strong>为什么叫控制反转？</strong></p>
<ul>
<li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/frc-365faceb5697f04f31399937c059c162.png" alt="" /></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<p>相关阅读：</p>
<ul>
<li><a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener noreferrer">IoC 源码阅读</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486938&amp;idx=1&amp;sn=c99ef0233f39a5ffc1b98c81e02dfcd4&amp;chksm=cea24211f9d5cb07fa901183ba4d96187820713a72387788408040822ffb2ed575d28e953ce7&amp;token=1736772241&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">面试被问了几百遍的 IoC 和 AOP ，还在傻傻搞不清楚？</a></li>
</ul>
<h3 id="谈谈自己对于-aop-的了解"> 谈谈自己对于 AOP 的了解</h3>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/926dfc549b06d280a37397f9fd49bf9d.jpg" alt="SpringAOPProcess" /></p>
<p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<h3 id="spring-aop-和-aspectj-aop-有什么区别"> Spring AOP 和 AspectJ AOP 有什么区别？</h3>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>
<h2 id="spring-bean"> Spring bean</h2>
<h3 id="什么是-bean"> 什么是 bean？</h3>
<p>简单来说，bean 代指的就是那些被 IoC 容器所管理的对象。</p>
<p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p>
<div><pre><code><span>&lt;!-- Constructor-arg with 'value' attribute --></span>
<span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>...<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>...<span>"</span></span><span>></span></span>
   <span><span><span>&lt;</span>constructor-arg</span> <span>value</span><span><span>=</span><span>"</span>...<span>"</span></span><span>/></span></span>
<span><span><span>&lt;/</span>bean</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。</p>
<p><img src="https://img-blog.csdnimg.cn/062b422bd7ac4d53afd28fb74b2bc94d.png" alt="" /></p>
<p><code>org.springframework.beans</code>和 <code>org.springframework.context</code> 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看</p>
<h3 id="bean-的作用域有哪些"> bean 的作用域有哪些?</h3>
<p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</li>
<li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>
</ul>
<p><strong>如何配置 bean 的作用域呢？</strong></p>
<p>xml 方式：</p>
<div><pre><code><span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>...<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>...<span>"</span></span> <span>scope</span><span><span>=</span><span>"</span>singleton<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>bean</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>注解方式：</p>
<div><pre><code><span>@Bean</span>
<span>@Scope</span><span>(</span>value <span>=</span> <span>ConfigurableBeanFactory</span><span>.</span>SCOPE_PROTOTYPE<span>)</span>
<span>public</span> <span>Person</span> <span>personPrototype</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="单例-bean-的线程安全问题了解吗"> 单例 bean 的线程安全问题了解吗？</h3>
<p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>在 bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
</ol>
<p>不过，大部分 bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， bean 是线程安全的。</p>
<h3 id="component-和-bean-的区别是什么"> @Component 和 @Bean 的区别是什么？</h3>
<ol>
<li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<p><code>@Bean</code>注解使用示例：</p>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>AppConfig</span> <span>{</span>
    <span>@Bean</span>
    <span>public</span> <span>TransferService</span> <span>transferService</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>TransferServiceImpl</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面的代码相当于下面的 xml 配置</p>
<div><pre><code><span><span><span>&lt;</span>beans</span><span>></span></span>
    <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>transferService<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>com.acme.TransferServiceImpl<span>"</span></span><span>/></span></span>
<span><span><span>&lt;/</span>beans</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<div><pre><code><span>@Bean</span>
<span>public</span> <span>OneService</span> <span>getService</span><span>(</span>status<span>)</span> <span>{</span>
    <span>case</span> <span>(</span>status<span>)</span>  <span>{</span>
        when <span>1</span><span>:</span>
                <span>return</span> <span>new</span> <span>serviceImpl1</span><span>(</span><span>)</span><span>;</span>
        when <span>2</span><span>:</span>
                <span>return</span> <span>new</span> <span>serviceImpl2</span><span>(</span><span>)</span><span>;</span>
        when <span>3</span><span>:</span>
                <span>return</span> <span>new</span> <span>serviceImpl3</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="将一个类声明为-bean-的注解有哪些"> 将一个类声明为 bean 的注解有哪些?</h3>
<p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h3 id="bean-的生命周期"> bean 的生命周期?</h3>
<blockquote>
<p>下面的内容整理自：<a href="https://yemengying.com/2016/07/14/spring-bean-life-cycle/" target="_blank" rel="noopener noreferrer">https://yemengying.com/2016/07/14/spring-bean-life-cycle/</a> ，除了这篇文章，再推荐一篇很不错的文章 ：<a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/zrtqsk/p/3735273.html</a> 。</p>
</blockquote>
<ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p>图示：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/24bc2bad3ce28144d60d9e0a2edf6c7f.jpg" alt="Spring Bean 生命周期" /></p>
<p>与之比较类似的中文版本:</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/b5d264565657a5395c2781081a7483e1.jpg" alt="Spring Bean 生命周期" /></p>
<h2 id="spring-mvc"> Spring MVC</h2>
<h3 id="说说自己对于-spring-mvc-了解"> 说说自己对于 Spring MVC 了解?</h3>
<p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210809181452421.png" alt="" /></p>
<p>网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于 MVC 同样是众多设计模式中的一种。<strong><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener noreferrer">java-design-patterns</a></strong> 项目中就有关于 MVC 的相关介绍。</p>
<p><img src="https://img-blog.csdnimg.cn/159b3d3e70dd45e6afa81bf06d09264e.png" alt="" /></p>
<p>想要真正理解 Spring MVC，我们先来看看 Model 1 和 Model 2 这两个没有 Spring MVC 的时代。</p>
<p><strong>Model 1 时代</strong></p>
<p>很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。</p>
<p>这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/mvc-mode1.png" alt="mvc-mode1" /></p>
<p><strong>Model 2 时代</strong></p>
<p>学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View）+Servlet（Controller） ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。</p>
<ul>
<li>Model:系统涉及的数据，也就是 dao 和 bean。</li>
<li>View：展示模型中的数据，只是用来展示。</li>
<li>Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/mvc-model2.png" alt="" /></p>
<p>Model2 模式下还存在很多问题，Model2 的抽象和封装程度还远远不够，使用 Model2 进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。</p>
<p>于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 Struts2，但是 Struts2 比较笨重。</p>
<p><strong>Spring MVC 时代</strong></p>
<p>随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p>
<p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p>
<h3 id="springmvc-工作原理了解吗"> SpringMVC 工作原理了解吗?</h3>
<p><strong>Spring MVC 原理如下图所示：</strong></p>
<blockquote>
<p>SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/de6d2b213f112297298f3e223bf08f28.png" alt="" /></p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h2 id="spring-框架中用到了哪些设计模式"> Spring 框架中用到了哪些设计模式？</h2>
<p>关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485303&amp;idx=1&amp;sn=9e4626a1e3f001f9b0d84a6fa0cff04a&amp;chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&amp;token=255050878&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">《面试官:“谈谈 Spring 中都用到了那些设计模式?”。》</a> 。</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>......</li>
</ul>
<h2 id="spring-事务"> Spring 事务</h2>
<p>Spring/SpringBoot 模块下专门有一篇是讲 Spring 事务的，总结的非常详细，通俗易懂。</p>
<h3 id="spring-管理事务的方式有几种"> Spring 管理事务的方式有几种？</h3>
<ul>
<li><strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li>
<li><strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li>
</ul>
<h3 id="spring-事务中哪几种事务传播行为"> Spring 事务中哪几种事务传播行为?</h3>
<p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p>正确的事务传播行为可能的值如下:</p>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>
<p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p>
<p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<p>这个使用的很少。</p>
<p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<h3 id="spring-事务中的隔离级别有哪几种"> Spring 事务中的隔离级别有哪几种?</h3>
<p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p>
<div><pre><code><span>public</span> <span>enum</span> <span>Isolation</span> <span>{</span>

    <span>DEFAULT</span><span>(</span><span>TransactionDefinition</span><span>.</span>ISOLATION_DEFAULT<span>)</span><span>,</span>

    <span>READ_UNCOMMITTED</span><span>(</span><span>TransactionDefinition</span><span>.</span>ISOLATION_READ_UNCOMMITTED<span>)</span><span>,</span>

    <span>READ_COMMITTED</span><span>(</span><span>TransactionDefinition</span><span>.</span>ISOLATION_READ_COMMITTED<span>)</span><span>,</span>

    <span>REPEATABLE_READ</span><span>(</span><span>TransactionDefinition</span><span>.</span>ISOLATION_REPEATABLE_READ<span>)</span><span>,</span>

    <span>SERIALIZABLE</span><span>(</span><span>TransactionDefinition</span><span>.</span>ISOLATION_SERIALIZABLE<span>)</span><span>;</span>

    <span>private</span> <span>final</span> <span>int</span> value<span>;</span>

    <span>Isolation</span><span>(</span><span>int</span> value<span>)</span> <span>{</span>
        <span>this</span><span>.</span>value <span>=</span> value<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>value</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>value<span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>下面我依次对每一种事务隔离级别进行介绍：</p>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="transactional-rollbackfor-exception-class-注解了解吗"> @Transactional(rollbackFor = Exception.class)注解了解吗？</h3>
<p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<h2 id="jpa"> JPA</h2>
<h3 id="如何使用-jpa-在数据库中非持久化一个字段"> 如何使用 JPA 在数据库中非持久化一个字段？</h3>
<p>假如我们有下面一个类：</p>
<div><pre><code><span>@Entity</span><span>(</span>name<span>=</span><span>"USER"</span><span>)</span>
<span>public</span> <span>class</span> <span>User</span> <span>{</span>

    <span>@Id</span>
    <span>@GeneratedValue</span><span>(</span>strategy <span>=</span> <span>GenerationType</span><span>.</span>AUTO<span>)</span>
    <span>@Column</span><span>(</span>name <span>=</span> <span>"ID"</span><span>)</span>
    <span>private</span> <span>Long</span> id<span>;</span>

    <span>@Column</span><span>(</span>name<span>=</span><span>"USER_NAME"</span><span>)</span>
    <span>private</span> <span>String</span> userName<span>;</span>

    <span>@Column</span><span>(</span>name<span>=</span><span>"PASSWORD"</span><span>)</span>
    <span>private</span> <span>String</span> password<span>;</span>

    <span>private</span> <span>String</span> secrect<span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p>
<div><pre><code><span>static</span> <span>String</span> transient1<span>;</span> <span>// not persistent because of static</span>
<span>final</span> <span>String</span> transient2 <span>=</span> <span>"Satish"</span><span>;</span> <span>// not persistent because of final</span>
<span>transient</span> <span>String</span> transient3<span>;</span> <span>// not persistent because of transient</span>
<span>@Transient</span>
<span>String</span> transient4<span>;</span> <span>// not persistent because of @Transient</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li>《Spring 技术内幕》</li>
<li><a href="http://www.cnblogs.com/wmyskxz/p/8820371.html" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/wmyskxz/p/8820371.html</a></li>
<li><a href="https://www.journaldev.com/2696/spring-interview-questions-and-answers" target="_blank" rel="noopener noreferrer">https://www.journaldev.com/2696/spring-interview-questions-and-answers</a></li>
<li><a href="https://www.edureka.co/blog/interview-questions/spring-interview-questions/" target="_blank" rel="noopener noreferrer">https://www.edureka.co/blog/interview-questions/spring-interview-questions/</a></li>
<li>https://www.cnblogs.com/clwydjgs/p/9317849.html</li>
<li><a href="https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/" target="_blank" rel="noopener noreferrer">https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/</a></li>
<li><a href="http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/" target="_blank" rel="noopener noreferrer">http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/</a></li>
<li><a href="https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/38ef122122de4375abcd27c3de8f60b4.png" type="image/png"/>
    </item>
    <item>
      <title>Spring 事务总结</title>
      <link>https://javaguide.cn/system-design/framework/spring/spring-transaction/</link>
      <guid>https://javaguide.cn/system-design/framework/spring/spring-transaction/</guid>
      <source url="https://javaguide.cn/rss.xml">Spring 事务总结</source>
      <category>框架</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>大家好，我是 Guide 哥，前段时间答应读者的 <strong>Spring 事务</strong>分析总结终于来了。这部分内容比较重要，不论是对于工作还是面试，但是网上比较好的参考资料比较少。</p>
<p>如果本文有任何不对或者需要完善的地方，请帮忙指出！Guide 哥感激不尽！</p>
<h2 id="_1-什么是事务"> 1. 什么是事务？</h2>
<p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p><em>Guide 哥：大家应该都能背上面这句话了，下面我结合我们日常的真实开发来谈一谈。</em></p>
<p>我们系统的每个业务方法可能包括了多个原子性的数据库操作，比如下面的 <code>savePerson()</code> 方法中就有两个原子性的数据库操作。这些原子性的数据库操作是有依赖的，它们要么都执行，要不就都不执行。</p>
<div><pre><code>	<span>public</span> <span>void</span> <span>savePerson</span><span>(</span><span>)</span> <span>{</span>
		personDao<span>.</span><span>save</span><span>(</span>person<span>)</span><span>;</span>
		personDetailDao<span>.</span><span>save</span><span>(</span>personDetail<span>)</span><span>;</span>
	<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>另外，需要格外注意的是：<strong>事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的<code>innodb</code>引擎。但是，如果把数据库引擎变为 <code>myisam</code>，那么程序也就不再支持事务了！</strong></p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：</p>
<ol>
<li>
<p>将小明的余额减少 1000 元</p>
</li>
<li>
<p>将小红的余额增加 1000 元。</p>
</li>
</ol>
<p>万一在这两个操作之间突然出现错误比如银行系统崩溃或者网络故障，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<div><pre><code><span>public</span> <span>class</span> <span>OrdersService</span> <span>{</span>
	<span>private</span> <span>AccountDao</span> accountDao<span>;</span>

	<span>public</span> <span>void</span> <span>setOrdersDao</span><span>(</span><span>AccountDao</span> accountDao<span>)</span> <span>{</span>
		<span>this</span><span>.</span>accountDao <span>=</span> accountDao<span>;</span>
	<span>}</span>

  <span>@Transactional</span><span>(</span>propagation <span>=</span> <span>Propagation</span><span>.</span>REQUIRED<span>,</span>
                isolation <span>=</span> <span>Isolation</span><span>.</span>DEFAULT<span>,</span> readOnly <span>=</span> <span>false</span><span>,</span> timeout <span>=</span> <span>-</span><span>1</span><span>)</span>
	<span>public</span> <span>void</span> <span>accountMoney</span><span>(</span><span>)</span> <span>{</span>
    <span>//小红账户多1000</span>
		accountDao<span>.</span><span>addMoney</span><span>(</span><span>1000</span><span>,</span>xiaohong<span>)</span><span>;</span>
		<span>//模拟突然出现的异常，比如银行中可能为突然停电等等</span>
    <span>//如果没有配置事务管理的话会造成，小红账户多了1000而小明账户没有少钱</span>
		<span>int</span> i <span>=</span> <span>10</span> <span>/</span> <span>0</span><span>;</span>
		<span>//小王账户少1000</span>
		accountDao<span>.</span><span>reduceMoney</span><span>(</span><span>1000</span><span>,</span>xiaoming<span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>另外，数据库事务的 ACID 四大特性是事务的基础，下面简单来了解一下。</p>
<h2 id="_2-事务的特性-acid-了解么"> 2. 事务的特性（ACID）了解么?</h2>
<p><img src="./images/spring-transaction/bda7231b-ab05-4e23-95ee-89ac90ac7fcf.png" alt="" /></p>
<ul>
<li><strong>原子性（Atomicity）：</strong> 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>一致性（Consistency）：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li><strong>隔离性（Isolation）：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p>参考 ：<a href="https://zh.wikipedia.org/wiki/ACID" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/ACID</a> 。</p>
<h2 id="_3-详谈-spring-对事务的支持"> 3. 详谈 Spring 对事务的支持</h2>
<p><strong>再提醒一次：你的程序是否支持事务首先取决于数据库 ，比如使用 MySQL 的话，如果你选择的是 innodb 引擎，那么恭喜你，是可以支持事务的。但是，如果你的 MySQL 数据库使用的是 myisam 引擎的话，那不好意思，从根上就是不支持事务的。</strong></p>
<p>这里再多提一下一个非常重要的知识点： <strong>MySQL 怎么保证原子性的？</strong></p>
<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<h3 id="_3-1-spring-支持两种方式的事务管理"> 3.1. Spring 支持两种方式的事务管理</h3>
<h4 id="_1-编程式事务管理"> 1).编程式事务管理</h4>
<p>通过 <code>TransactionTemplate</code>或者<code>TransactionManager</code>手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</p>
<p>使用<code>TransactionTemplate</code> 进行编程式事务管理的示例代码如下：</p>
<div><pre><code><span>@Autowired</span>
<span>private</span> <span>TransactionTemplate</span> transactionTemplate<span>;</span>
<span>public</span> <span>void</span> <span>testTransaction</span><span>(</span><span>)</span> <span>{</span>

        transactionTemplate<span>.</span><span>execute</span><span>(</span><span>new</span> <span>TransactionCallbackWithoutResult</span><span>(</span><span>)</span> <span>{</span>
            <span>@Override</span>
            <span>protected</span> <span>void</span> <span>doInTransactionWithoutResult</span><span>(</span><span>TransactionStatus</span> transactionStatus<span>)</span> <span>{</span>

                <span>try</span> <span>{</span>

                    <span>// ....  业务代码</span>
                <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span><span>{</span>
                    <span>//回滚</span>
                    transactionStatus<span>.</span><span>setRollbackOnly</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>

            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>使用 <code>TransactionManager</code> 进行编程式事务管理的示例代码如下：</p>
<div><pre><code><span>@Autowired</span>
<span>private</span> <span>PlatformTransactionManager</span> transactionManager<span>;</span>

<span>public</span> <span>void</span> <span>testTransaction</span><span>(</span><span>)</span> <span>{</span>

  <span>TransactionStatus</span> status <span>=</span> transactionManager<span>.</span><span>getTransaction</span><span>(</span><span>new</span> <span>DefaultTransactionDefinition</span><span>(</span><span>)</span><span>)</span><span>;</span>
          <span>try</span> <span>{</span>
               <span>// ....  业务代码</span>
              transactionManager<span>.</span><span>commit</span><span>(</span>status<span>)</span><span>;</span>
          <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
              transactionManager<span>.</span><span>rollback</span><span>(</span>status<span>)</span><span>;</span>
          <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="_2-声明式事务管理"> 2)声明式事务管理</h4>
<p>推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）。</p>
<p>使用 <code>@Transactional</code>注解进行事务管理的示例代码如下：</p>
<div><pre><code><span>@Transactional</span><span>(</span>propagation<span>=</span>propagation<span>.</span>PROPAGATION_REQUIRED<span>)</span>
<span>public</span> <span>void</span> aMethod <span>{</span>
  <span>//do something</span>
  <span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>
  <span>C</span> c <span>=</span> <span>new</span> <span>C</span><span>(</span><span>)</span><span>;</span>
  b<span>.</span><span>bMethod</span><span>(</span><span>)</span><span>;</span>
  c<span>.</span><span>cMethod</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="_3-2-spring-事务管理接口介绍"> 3.2. Spring 事务管理接口介绍</h3>
<p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p>
<ul>
<li><strong><code>PlatformTransactionManager</code></strong>： （平台）事务管理器，Spring 事务策略的核心。</li>
<li><strong><code>TransactionDefinition</code></strong>： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li>
<li><strong><code>TransactionStatus</code></strong>： 事务运行状态。</li>
</ul>
<p>我们可以把 <strong><code>PlatformTransactionManager</code></strong> 接口可以被看作是事务上层的管理者，而 <strong><code>TransactionDefinition</code></strong> 和 <strong><code>TransactionStatus</code></strong> 这两个接口可以看作是事务的描述。</p>
<p><strong><code>PlatformTransactionManager</code></strong> 会根据 <strong><code>TransactionDefinition</code></strong> 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 <strong><code>TransactionStatus</code></strong> 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p>
<h4 id="_3-2-1-platformtransactionmanager-事务管理接口"> 3.2.1. PlatformTransactionManager:事务管理接口</h4>
<p><strong>Spring 并不直接管理事务，而是提供了多种事务管理器</strong> 。Spring 事务管理器的接口是： <strong><code>PlatformTransactionManager</code></strong> 。</p>
<p>通过这个接口，Spring 为各个平台如 JDBC(<code>DataSourceTransactionManager</code>)、Hibernate(<code>HibernateTransactionManager</code>)、JPA(<code>JpaTransactionManager</code>)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
<p><strong><code>PlatformTransactionManager</code> 接口的具体实现如下:</strong></p>
<p><img src="./images/spring-transaction/ae964c2c-7289-441c-bddd-511161f51ee1.png" alt="" /></p>
<p><code>PlatformTransactionManager</code>接口中定义了三个方法：</p>
<div><pre><code><span>package</span> <span>org<span>.</span>springframework<span>.</span>transaction</span><span>;</span>

<span>import</span> <span>org<span>.</span>springframework<span>.</span>lang<span>.</span></span><span>Nullable</span><span>;</span>

<span>public</span> <span>interface</span> <span>PlatformTransactionManager</span> <span>{</span>
    <span>//获得事务</span>
    <span>TransactionStatus</span> <span>getTransaction</span><span>(</span><span>@Nullable</span> <span>TransactionDefinition</span> var1<span>)</span> <span>throws</span> <span>TransactionException</span><span>;</span>
    <span>//提交事务</span>
    <span>void</span> <span>commit</span><span>(</span><span>TransactionStatus</span> var1<span>)</span> <span>throws</span> <span>TransactionException</span><span>;</span>
    <span>//回滚事务</span>
    <span>void</span> <span>rollback</span><span>(</span><span>TransactionStatus</span> var1<span>)</span> <span>throws</span> <span>TransactionException</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>这里多插一嘴。为什么要定义或者说抽象出来<code>PlatformTransactionManager</code>这个接口呢？</strong></p>
<p>主要是因为要将事务管理行为抽象出来，然后不同的平台去实现它，这样我们可以保证提供给外部的行为不变，方便我们扩展。我前段时间分享过：<strong>“为什么我们要用接口？”</strong></p>
<p><img src="./images/spring-transaction/接口使用原因.png" alt="" /></p>
<h4 id="_3-2-2-transactiondefinition-事务属性"> 3.2.2. TransactionDefinition:事务属性</h4>
<p>事务管理器接口 <strong><code>PlatformTransactionManager</code></strong> 通过 <strong><code>getTransaction(TransactionDefinition definition)</code></strong> 方法来得到一个事务，这个方法里面的参数是 <strong><code>TransactionDefinition</code></strong> 类 ，这个类就定义了一些基本的事务属性。</p>
<p>那么什么是 <strong>事务属性</strong> 呢？</p>
<p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。</p>
<p>事务属性包含了 5 个方面：</p>
<p><img src="./images/spring-transaction/a616b84d-9eea-4ad1-b4fc-461ff05e951d.png" alt="" /></p>
<p><code>TransactionDefinition</code> 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等。</p>
<div><pre><code><span>package</span> <span>org<span>.</span>springframework<span>.</span>transaction</span><span>;</span>

<span>import</span> <span>org<span>.</span>springframework<span>.</span>lang<span>.</span></span><span>Nullable</span><span>;</span>

<span>public</span> <span>interface</span> <span>TransactionDefinition</span> <span>{</span>
    <span>int</span> PROPAGATION_REQUIRED <span>=</span> <span>0</span><span>;</span>
    <span>int</span> PROPAGATION_SUPPORTS <span>=</span> <span>1</span><span>;</span>
    <span>int</span> PROPAGATION_MANDATORY <span>=</span> <span>2</span><span>;</span>
    <span>int</span> PROPAGATION_REQUIRES_NEW <span>=</span> <span>3</span><span>;</span>
    <span>int</span> PROPAGATION_NOT_SUPPORTED <span>=</span> <span>4</span><span>;</span>
    <span>int</span> PROPAGATION_NEVER <span>=</span> <span>5</span><span>;</span>
    <span>int</span> PROPAGATION_NESTED <span>=</span> <span>6</span><span>;</span>
    <span>int</span> ISOLATION_DEFAULT <span>=</span> <span>-</span><span>1</span><span>;</span>
    <span>int</span> ISOLATION_READ_UNCOMMITTED <span>=</span> <span>1</span><span>;</span>
    <span>int</span> ISOLATION_READ_COMMITTED <span>=</span> <span>2</span><span>;</span>
    <span>int</span> ISOLATION_REPEATABLE_READ <span>=</span> <span>4</span><span>;</span>
    <span>int</span> ISOLATION_SERIALIZABLE <span>=</span> <span>8</span><span>;</span>
    <span>int</span> TIMEOUT_DEFAULT <span>=</span> <span>-</span><span>1</span><span>;</span>
    <span>// 返回事务的传播行为，默认值为 REQUIRED。</span>
    <span>int</span> <span>getPropagationBehavior</span><span>(</span><span>)</span><span>;</span>
    <span>//返回事务的隔离级别，默认值是 DEFAULT</span>
    <span>int</span> <span>getIsolationLevel</span><span>(</span><span>)</span><span>;</span>
    <span>// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span>
    <span>int</span> <span>getTimeout</span><span>(</span><span>)</span><span>;</span>
    <span>// 返回是否为只读事务，默认值为 false</span>
    <span>boolean</span> <span>isReadOnly</span><span>(</span><span>)</span><span>;</span>

    <span>@Nullable</span>
    <span>String</span> <span>getName</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h4 id="_3-2-3-transactionstatus-事务状态"> 3.2.3. TransactionStatus:事务状态</h4>
<p><code>TransactionStatus</code>接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。</p>
<p><code>PlatformTransactionManager.getTransaction(…)</code>方法返回一个 <code>TransactionStatus</code> 对象。</p>
<p><strong>TransactionStatus 接口接口内容如下：</strong></p>
<div><pre><code><span>public</span> <span>interface</span> <span>TransactionStatus</span><span>{</span>
    <span>boolean</span> <span>isNewTransaction</span><span>(</span><span>)</span><span>;</span> <span>// 是否是新的事务</span>
    <span>boolean</span> <span>hasSavepoint</span><span>(</span><span>)</span><span>;</span> <span>// 是否有恢复点</span>
    <span>void</span> <span>setRollbackOnly</span><span>(</span><span>)</span><span>;</span>  <span>// 设置为只回滚</span>
    <span>boolean</span> <span>isRollbackOnly</span><span>(</span><span>)</span><span>;</span> <span>// 是否为只回滚</span>
    <span>boolean</span> isCompleted<span>;</span> <span>// 是否已完成</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_3-3-事务属性详解"> 3.3. 事务属性详解</h3>
<p><em>实际业务开发中，大家一般都是使用 <code>@Transactional</code> 注解来开启事务，很多人并不清楚这个参数里面的参数是什么意思，有什么用。为了更好的在项目中使用事务管理，强烈推荐好好阅读一下下面的内容。</em></p>
<h4 id="_3-3-1-事务传播行为"> 3.3.1. 事务传播行为</h4>
<p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p><strong>举个例子！</strong></p>
<p>我们在 A 类的<code>aMethod（）</code>方法中调用了 B 类的 <code>bMethod()</code> 方法。这个时候就涉及到业务层方法之间互相调用的事务问题。如果我们的 <code>bMethod()</code>如果发生异常需要回滚，如何配置事务传播行为才能让 <code>aMethod()</code>也跟着回滚呢？这个时候就需要事务传播行为的知识了，如果你不知道的话一定要好好看一下。</p>
<div><pre><code><span>Class</span> <span>A</span> <span>{</span>
    <span>@Transactional</span><span>(</span>propagation<span>=</span>propagation<span>.</span>xxx<span>)</span>
    <span>public</span> <span>void</span> aMethod <span>{</span>
        <span>//do something</span>
        <span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>
        b<span>.</span><span>bMethod</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>Class</span> <span>B</span> <span>{</span>
    <span>@Transactional</span><span>(</span>propagation<span>=</span>propagation<span>.</span>xxx<span>)</span>
    <span>public</span> <span>void</span> bMethod <span>{</span>
       <span>//do something</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量：</p>
<div><pre><code><span>public</span> <span>interface</span> <span>TransactionDefinition</span> <span>{</span>
    <span>int</span> PROPAGATION_REQUIRED <span>=</span> <span>0</span><span>;</span>
    <span>int</span> PROPAGATION_SUPPORTS <span>=</span> <span>1</span><span>;</span>
    <span>int</span> PROPAGATION_MANDATORY <span>=</span> <span>2</span><span>;</span>
    <span>int</span> PROPAGATION_REQUIRES_NEW <span>=</span> <span>3</span><span>;</span>
    <span>int</span> PROPAGATION_NOT_SUPPORTED <span>=</span> <span>4</span><span>;</span>
    <span>int</span> PROPAGATION_NEVER <span>=</span> <span>5</span><span>;</span>
    <span>int</span> PROPAGATION_NESTED <span>=</span> <span>6</span><span>;</span>
    <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>不过如此，为了方便使用，Spring 会相应地定义了一个枚举类：<code>Propagation</code></p>
<div><pre><code><span>package</span> <span>org<span>.</span>springframework<span>.</span>transaction<span>.</span>annotation</span><span>;</span>

<span>import</span> <span>org<span>.</span>springframework<span>.</span>transaction<span>.</span></span><span>TransactionDefinition</span><span>;</span>

<span>public</span> <span>enum</span> <span>Propagation</span> <span>{</span>

	<span>REQUIRED</span><span>(</span><span>TransactionDefinition</span><span>.</span>PROPAGATION_REQUIRED<span>)</span><span>,</span>

	<span>SUPPORTS</span><span>(</span><span>TransactionDefinition</span><span>.</span>PROPAGATION_SUPPORTS<span>)</span><span>,</span>

	<span>MANDATORY</span><span>(</span><span>TransactionDefinition</span><span>.</span>PROPAGATION_MANDATORY<span>)</span><span>,</span>

	<span>REQUIRES_NEW</span><span>(</span><span>TransactionDefinition</span><span>.</span>PROPAGATION_REQUIRES_NEW<span>)</span><span>,</span>

	<span>NOT_SUPPORTED</span><span>(</span><span>TransactionDefinition</span><span>.</span>PROPAGATION_NOT_SUPPORTED<span>)</span><span>,</span>

	<span>NEVER</span><span>(</span><span>TransactionDefinition</span><span>.</span>PROPAGATION_NEVER<span>)</span><span>,</span>

	<span>NESTED</span><span>(</span><span>TransactionDefinition</span><span>.</span>PROPAGATION_NESTED<span>)</span><span>;</span>


	<span>private</span> <span>final</span> <span>int</span> value<span>;</span>

	<span>Propagation</span><span>(</span><span>int</span> value<span>)</span> <span>{</span>
		<span>this</span><span>.</span>value <span>=</span> value<span>;</span>
	<span>}</span>

	<span>public</span> <span>int</span> <span>value</span><span>(</span><span>)</span> <span>{</span>
		<span>return</span> <span>this</span><span>.</span>value<span>;</span>
	<span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p><strong>正确的事务传播行为可能的值如下</strong> ：</p>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。也就是说：</p>
<ol>
<li>如果外部方法没有开启事务的话，<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li>
<li>如果外部方法开启事务并且被<code>Propagation.REQUIRED</code>的话，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。</li>
</ol>
<p>举个例子：如果我们上面的<code>aMethod()</code>和<code>bMethod()</code>使用的都是<code>PROPAGATION_REQUIRED</code>传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。</p>
<div><pre><code><span>Class</span> <span>A</span> <span>{</span>
    <span>@Transactional</span><span>(</span>propagation<span>=</span>propagation<span>.</span>PROPAGATION_REQUIRED<span>)</span>
    <span>public</span> <span>void</span> aMethod <span>{</span>
        <span>//do something</span>
        <span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>
        b<span>.</span><span>bMethod</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>Class</span> <span>B</span> <span>{</span>
    <span>@Transactional</span><span>(</span>propagation<span>=</span>propagation<span>.</span>PROPAGATION_REQUIRED<span>)</span>
    <span>public</span> <span>void</span> bMethod <span>{</span>
       <span>//do something</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p>举个例子：如果我们上面的<code>bMethod()</code>使用<code>PROPAGATION_REQUIRES_NEW</code>事务传播行为修饰，<code>aMethod</code>还是用<code>PROPAGATION_REQUIRED</code>修饰的话。如果<code>aMethod()</code>发生异常回滚，<code>bMethod()</code>不会跟着回滚，因为 <code>bMethod()</code>开启了独立的事务。但是，如果 <code>bMethod()</code>抛出了未被捕获的异常并且这个异常满足事务回滚规则的话,<code>aMethod()</code>同样也会回滚，因为这个异常被 <code>aMethod()</code>的事务管理机制检测到了。</p>
<div><pre><code><span>Class</span> <span>A</span> <span>{</span>
    <span>@Transactional</span><span>(</span>propagation<span>=</span>propagation<span>.</span>PROPAGATION_REQUIRED<span>)</span>
    <span>public</span> <span>void</span> aMethod <span>{</span>
        <span>//do something</span>
        <span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>
        b<span>.</span><span>bMethod</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>Class</span> <span>B</span> <span>{</span>
    <span>@Transactional</span><span>(</span>propagation<span>=</span>propagation<span>.</span>REQUIRES_NEW<span>)</span>
    <span>public</span> <span>void</span> bMethod <span>{</span>
       <span>//do something</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong>:</p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。也就是说：</p>
<ol>
<li>在外部方法未开启事务的情况下<code>Propagation.NESTED</code>和<code>Propagation.REQUIRED</code>作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</li>
<li>如果外部方法开启事务的话，<code>Propagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。</li>
</ol>
<p>这里还是简单举个例子：</p>
<p>如果 <code>aMethod()</code> 回滚的话，<code>bMethod()</code>和<code>bMethod2()</code>都要回滚，而<code>bMethod()</code>回滚的话，并不会造成 <code>aMethod()</code> 和<code>bMethod()2</code>回滚。</p>
<div><pre><code><span>Class</span> <span>A</span> <span>{</span>
    <span>@Transactional</span><span>(</span>propagation<span>=</span>propagation<span>.</span>PROPAGATION_REQUIRED<span>)</span>
    <span>public</span> <span>void</span> aMethod <span>{</span>
        <span>//do something</span>
        <span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>
        b<span>.</span><span>bMethod</span><span>(</span><span>)</span><span>;</span>
        b<span>.</span><span>bMethod2</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>Class</span> <span>B</span> <span>{</span>
    <span>@Transactional</span><span>(</span>propagation<span>=</span>propagation<span>.</span>PROPAGATION_NESTED<span>)</span>
    <span>public</span> <span>void</span> bMethod <span>{</span>
       <span>//do something</span>
    <span>}</span>
    <span>@Transactional</span><span>(</span>propagation<span>=</span>propagation<span>.</span>PROPAGATION_NESTED<span>)</span>
    <span>public</span> <span>void</span> bMethod2 <span>{</span>
       <span>//do something</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<p>这个使用的很少，就不举例子来说了。</p>
<p><strong>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚，这里不对照案例讲解了，使用的很少。</strong></p>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p>更多关于事务传播行为的内容请看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486668&amp;idx=2&amp;sn=0381e8c836442f46bdc5367170234abb&amp;chksm=cea24307f9d5ca11c96943b3ccfa1fc70dc97dd87d9c540388581f8fe6d805ff548dff5f6b5b&amp;token=1776990505&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">《太难了~面试官让我结合案例讲讲自己对 Spring 事务传播行为的理解。》</a></p>
<h4 id="_3-3-2-事务隔离级别"> 3.3.2 事务隔离级别</h4>
<p><code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</p>
<div><pre><code><span>public</span> <span>interface</span> <span>TransactionDefinition</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
    <span>int</span> ISOLATION_DEFAULT <span>=</span> <span>-</span><span>1</span><span>;</span>
    <span>int</span> ISOLATION_READ_UNCOMMITTED <span>=</span> <span>1</span><span>;</span>
    <span>int</span> ISOLATION_READ_COMMITTED <span>=</span> <span>2</span><span>;</span>
    <span>int</span> ISOLATION_REPEATABLE_READ <span>=</span> <span>4</span><span>;</span>
    <span>int</span> ISOLATION_SERIALIZABLE <span>=</span> <span>8</span><span>;</span>
    <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p>
<div><pre><code><span>public</span> <span>enum</span> <span>Isolation</span> <span>{</span>

	<span>DEFAULT</span><span>(</span><span>TransactionDefinition</span><span>.</span>ISOLATION_DEFAULT<span>)</span><span>,</span>

	<span>READ_UNCOMMITTED</span><span>(</span><span>TransactionDefinition</span><span>.</span>ISOLATION_READ_UNCOMMITTED<span>)</span><span>,</span>

	<span>READ_COMMITTED</span><span>(</span><span>TransactionDefinition</span><span>.</span>ISOLATION_READ_COMMITTED<span>)</span><span>,</span>

	<span>REPEATABLE_READ</span><span>(</span><span>TransactionDefinition</span><span>.</span>ISOLATION_REPEATABLE_READ<span>)</span><span>,</span>

	<span>SERIALIZABLE</span><span>(</span><span>TransactionDefinition</span><span>.</span>ISOLATION_SERIALIZABLE<span>)</span><span>;</span>

	<span>private</span> <span>final</span> <span>int</span> value<span>;</span>

	<span>Isolation</span><span>(</span><span>int</span> value<span>)</span> <span>{</span>
		<span>this</span><span>.</span>value <span>=</span> value<span>;</span>
	<span>}</span>

	<span>public</span> <span>int</span> <span>value</span><span>(</span><span>)</span> <span>{</span>
		<span>return</span> <span>this</span><span>.</span>value<span>;</span>
	<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>下面我依次对每一种事务隔离级别进行介绍：</p>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<p>因为平时使用 MySQL 数据库比较多，这里再多提一嘴！</p>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> @<span>@tx_isolation</span><span>;</span>
<span>+</span><span>-----------------+</span>
<span>|</span> @<span>@tx_isolation</span>  <span>|</span>
<span>+</span><span>-----------------+</span>
<span>|</span> <span>REPEATABLE</span><span>-</span><span>READ</span> <span>|</span>
<span>+</span><span>-----------------+</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><s>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</s></p>
<p>🐛问题更正：<strong>MySQL InnoDB的REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 Next-Key Locks。</strong></p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEAaTABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
<p>🌈拓展一下(以下内容摘自《MySQL技术内幕：InnoDB存储引擎(第2版)》7.7章)：</p>
<blockquote>
<p>InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的ACID要求又有了提高。另外，在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE。</p>
</blockquote>
<h4 id="_3-3-3-事务超时属性"> 3.3.3. 事务超时属性</h4>
<p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 <code>TransactionDefinition</code> 中以 int 的值来表示超时时间，其单位是秒，默认值为-1。</p>
<h4 id="_3-3-4-事务只读属性"> 3.3.4. 事务只读属性</h4>
<div><pre><code><span>package</span> <span>org<span>.</span>springframework<span>.</span>transaction</span><span>;</span>

<span>import</span> <span>org<span>.</span>springframework<span>.</span>lang<span>.</span></span><span>Nullable</span><span>;</span>

<span>public</span> <span>interface</span> <span>TransactionDefinition</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
    <span>// 返回是否为只读事务，默认值为 false</span>
    <span>boolean</span> <span>isReadOnly</span><span>(</span><span>)</span><span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。</p>
<p>很多人就会疑问了，为什么我一个数据查询操作还要启用事务支持呢？</p>
<p>拿 MySQL 的 innodb 举例子，根据官网 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html" target="_blank" rel="noopener noreferrer">https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html</a> 描述：</p>
<blockquote>
<p>MySQL 默认对每一个新建立的连接都启用了<code>autocommit</code>模式。在该模式下，每一个发送到 MySQL 服务器的<code>sql</code>语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。</p>
</blockquote>
<p>但是，如果你给方法加上了<code>Transactional</code>注解的话，这个方法执行的所有<code>sql</code>会被放在一个事务中。如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的什么收益。</p>
<p>如果不加<code>Transactional</code>，每条<code>sql</code>会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。</p>
<p>分享一下关于事务只读属性，其他人的解答：</p>
<ol>
<li>如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；</li>
<li>如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持</li>
</ol>
<h4 id="_3-3-5-事务回滚规则"> 3.3.5. 事务回滚规则</h4>
<p>这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（RuntimeException 的子类）时才会回滚，Error 也会导致事务回滚，但是，在遇到检查型（Checked）异常时不会回滚。</p>
<p><img src="./images/spring-transaction/f6c6f0aa-0f26-49e1-84b3-7f838c7379d1.png" alt="" /></p>
<p>如果你想要回滚你定义的特定的异常类型的话，可以这样：</p>
<div><pre><code><span>@Transactional</span><span>(</span>rollbackFor<span>=</span> <span>MyException</span><span>.</span><span>class</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="_3-4-transactional-注解使用详解"> 3.4. @Transactional 注解使用详解</h3>
<h4 id="_1-transactional-的作用范围"> 1) <code>@Transactional</code> 的作用范围</h4>
<ol>
<li><strong>方法</strong> ：推荐将注解使用于方法上，不过需要注意的是：<strong>该注解只能应用到 public 方法上，否则不生效。</strong></li>
<li><strong>类</strong> ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li>
<li><strong>接口</strong> ：不推荐在接口上使用。</li>
</ol>
<h4 id="_2-transactional-的常用配置参数"> 2) <code>@Transactional</code> 的常用配置参数</h4>
<p><code>@Transactional</code>注解源码如下，里面包含了基本事务属性的配置：</p>
<div><pre><code><span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>TYPE<span>,</span> <span>ElementType</span><span>.</span>METHOD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Inherited</span>
<span>@Documented</span>
<span>public</span> <span>@interface</span> <span>Transactional</span> <span>{</span>

	<span>@AliasFor</span><span>(</span><span>"transactionManager"</span><span>)</span>
	<span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>

	<span>@AliasFor</span><span>(</span><span>"value"</span><span>)</span>
	<span>String</span> <span>transactionManager</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>

	<span>Propagation</span> <span>propagation</span><span>(</span><span>)</span> <span>default</span> <span>Propagation</span><span>.</span>REQUIRED<span>;</span>

	<span>Isolation</span> <span>isolation</span><span>(</span><span>)</span> <span>default</span> <span>Isolation</span><span>.</span>DEFAULT<span>;</span>

	<span>int</span> <span>timeout</span><span>(</span><span>)</span> <span>default</span> <span>TransactionDefinition</span><span>.</span>TIMEOUT_DEFAULT<span>;</span>

	<span>boolean</span> <span>readOnly</span><span>(</span><span>)</span> <span>default</span> <span>false</span><span>;</span>

	<span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Throwable</span><span>></span></span><span>[</span><span>]</span> <span>rollbackFor</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>

	<span>String</span><span>[</span><span>]</span> <span>rollbackForClassName</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>

	<span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Throwable</span><span>></span></span><span>[</span><span>]</span> <span>noRollbackFor</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>

	<span>String</span><span>[</span><span>]</span> <span>noRollbackForClassName</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p><strong><code>@Transactional</code> 的常用配置参数总结（只列出了 5 个我平时比较常用的）：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">propagation</td>
<td style="text-align:left">事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过</td>
</tr>
<tr>
<td style="text-align:left">isolation</td>
<td style="text-align:left">事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过</td>
</tr>
<tr>
<td style="text-align:left">timeout</td>
<td style="text-align:left">事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td>
</tr>
<tr>
<td style="text-align:left">readOnly</td>
<td style="text-align:left">指定事务是否为只读事务，默认值为 false。</td>
</tr>
<tr>
<td style="text-align:left">rollbackFor</td>
<td style="text-align:left">用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</td>
</tr>
</tbody>
</table>
<h4 id="_3-transactional-事务注解原理"> 3)<code>@Transactional</code> 事务注解原理</h4>
<p>面试中在问 AOP 的时候可能会被问到的一个问题。简单说下吧！</p>
<p>我们知道，<strong><code>@Transactional</code> 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。</strong></p>
<p>多提一嘴：<code>createAopProxy()</code> 方法 决定了是使用 JDK 还是 Cglib 来做动态代理，源码如下：</p>
<div><pre><code><span>public</span> <span>class</span> <span>DefaultAopProxyFactory</span> <span>implements</span> <span>AopProxyFactory</span><span>,</span> <span>Serializable</span> <span>{</span>

	<span>@Override</span>
	<span>public</span> <span>AopProxy</span> <span>createAopProxy</span><span>(</span><span>AdvisedSupport</span> config<span>)</span> <span>throws</span> <span>AopConfigException</span> <span>{</span>
		<span>if</span> <span>(</span>config<span>.</span><span>isOptimize</span><span>(</span><span>)</span> <span>||</span> config<span>.</span><span>isProxyTargetClass</span><span>(</span><span>)</span> <span>||</span> <span>hasNoUserSuppliedProxyInterfaces</span><span>(</span>config<span>)</span><span>)</span> <span>{</span>
			<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetClass <span>=</span> config<span>.</span><span>getTargetClass</span><span>(</span><span>)</span><span>;</span>
			<span>if</span> <span>(</span>targetClass <span>==</span> <span>null</span><span>)</span> <span>{</span>
				<span>throw</span> <span>new</span> <span>AopConfigException</span><span>(</span><span>"TargetSource cannot determine target class: "</span> <span>+</span>
						<span>"Either an interface or a target is required for proxy creation."</span><span>)</span><span>;</span>
			<span>}</span>
			<span>if</span> <span>(</span>targetClass<span>.</span><span>isInterface</span><span>(</span><span>)</span> <span>||</span> <span>Proxy</span><span>.</span><span>isProxyClass</span><span>(</span>targetClass<span>)</span><span>)</span> <span>{</span>
				<span>return</span> <span>new</span> <span>JdkDynamicAopProxy</span><span>(</span>config<span>)</span><span>;</span>
			<span>}</span>
			<span>return</span> <span>new</span> <span>ObjenesisCglibAopProxy</span><span>(</span>config<span>)</span><span>;</span>
		<span>}</span>
		<span>else</span> <span>{</span>
			<span>return</span> <span>new</span> <span>JdkDynamicAopProxy</span><span>(</span>config<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>如果一个类或者一个类中的 public 方法上被标注<code>@Transactional</code> 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被<code>@Transactional</code> 注解的 public 方法的时候，实际调用的是，<code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p>
<blockquote>
<p><code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法内部实际调用的是 <code>TransactionAspectSupport</code> 类的 <code>invokeWithinTransaction()</code>方法。由于新版本的 Spring 对这部分重写很大，而且用到了很多响应式编程的知识，这里就不列源码了。</p>
</blockquote>
<h4 id="_4-spring-aop-自调用问题"> 4) Spring AOP 自调用问题</h4>
<p>若同一类中的其他没有 <code>@Transactional</code> 注解的方法内部调用有 <code>@Transactional</code> 注解的方法，有<code>@Transactional</code> 注解的方法的事务会失效。</p>
<p>这是由于<code>Spring AOP</code>代理的原因造成的，因为只有当 <code>@Transactional</code> 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</p>
<p><code>MyService</code> 类中的<code>method1()</code>调用<code>method2()</code>就会导致<code>method2()</code>的事务失效。</p>
<div><pre><code><span>@Service</span>
<span>public</span> <span>class</span> <span>MyService</span> <span>{</span>

<span>private</span> <span>void</span> <span>method1</span><span>(</span><span>)</span> <span>{</span>
     <span>method2</span><span>(</span><span>)</span><span>;</span>
     <span>//......</span>
<span>}</span>
<span>@Transactional</span>
 <span>public</span> <span>void</span> <span>method2</span><span>(</span><span>)</span> <span>{</span>
     <span>//......</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>解决办法就是避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。</p>
<h4 id="_5-transactional-的使用注意事项总结"> 5) <code>@Transactional</code> 的使用注意事项总结</h4>
<ol>
<li><code>@Transactional</code> 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；</li>
<li>避免同一个类中调用 <code>@Transactional</code> 注解的方法，这样会导致事务失效；</li>
<li>正确的设置 <code>@Transactional</code> 的 <code>rollbackFor</code> 和 <code>propagation</code> 属性，否则事务可能会回滚失败;</li>
<li>被 <code>@Transactional</code> 注解的方法所在的类必须被 Spring 管理，否则不生效；</li>
<li>底层使用的数据库必须支持事务机制，否则不生效；</li>
<li>......</li>
</ol>
<h2 id="_4-reference"> 4. Reference</h2>
<ol>
<li>
<p>[总结]Spring 事务管理中@Transactional 的参数:<a href="http://www.mobabel.net/spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%ADtransactional%E7%9A%84%E5%8F%82%E6%95%B0/" target="_blank" rel="noopener noreferrer">http://www.mobabel.net/spring 事务管理中 transactional 的参数/</a></p>
</li>
<li>
<p>Spring 官方文档：<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html</a></p>
</li>
<li>
<p>《Spring5 高级编程》</p>
</li>
<li>
<p>透彻的掌握 Spring 中@transactional 的使用: <a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html" target="_blank" rel="noopener noreferrer">https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html</a></p>
</li>
<li>
<p>Spring 事务的传播特性：<a href="https://github.com/love-somnus/Spring/wiki/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7" target="_blank" rel="noopener noreferrer">https://github.com/love-somnus/Spring/wiki/Spring 事务的传播特性</a></p>
</li>
<li>
<p><a href="https://segmentfault.com/a/1190000013341344" target="_blank" rel="noopener noreferrer">Spring 事务传播行为详解</a> ：<a href="https://segmentfault.com/a/1190000013341344" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000013341344</a></p>
</li>
<li>
<p>全面分析 Spring 的编程式事务管理及声明式事务管理：<a href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html" target="_blank" rel="noopener noreferrer">https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html</a></p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>认证授权基础</title>
      <link>https://javaguide.cn/system-design/security/basis-of-authority-certification/</link>
      <guid>https://javaguide.cn/system-design/security/basis-of-authority-certification/</guid>
      <source url="https://javaguide.cn/rss.xml">认证授权基础</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="认证授权基础"> 认证授权基础</h1>
<h2 id="认证-authentication-和授权-authorization-的区别是什么"> 认证 (Authentication) 和授权 (Authorization)的区别是什么？</h2>
<p>这是一个绝大多数人都会混淆的问题。首先先从读音上来认识这两个名词，很多人都会把它俩的读音搞混，所以我建议你先先去查一查这两个单词到底该怎么读，他们的具体含义是什么。</p>
<p>说简单点就是：</p>
<ul>
<li><strong>认证 (Authentication)：</strong> 你是谁。</li>
<li><strong>授权 (Authorization)：</strong> 你有权限干什么。</li>
</ul>
<p>稍微正式点（啰嗦点）的说法就是 ：</p>
<ul>
<li><strong>Authentication（认证）</strong> 是验证您的身份的凭据（例如用户名/用户 ID 和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。</li>
<li><strong>Authorization（授权）</strong> 发生在 <strong>Authentication（认证）</strong> 之后。授权嘛，光看意思大家应该就明白，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如 admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。</li>
</ul>
<p>认证 ：</p>
<p><img src="https://img-blog.csdnimg.cn/20210604160908352.png" alt="" /></p>
<p>授权：</p>
<p><img src="https://img-blog.csdnimg.cn/20210604161032412.png" alt="" /></p>
<p>这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。</p>
<h2 id="rbac-模型了解吗"> RBAC 模型了解吗？</h2>
<p>系统权限控制最常采用的访问控制模型就是 <strong>RBAC 模型</strong> 。</p>
<p><strong>什么是 RBAC 呢？</strong></p>
<p>RBAC 即基于角色的权限访问控制（Role-Based Access Control）。这是一种通过角色关联权限，角色同时又关联用户的授权的方式。</p>
<p>简单地说：一个用户可以拥有若干角色，每一个角色又可以被分配若干权限，这样就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-9/RBAC.png" alt="RBAC" /></p>
<p><strong>在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。</strong></p>
<p>本系统的权限设计相关的表如下（一共 5 张表，2 张用户建立表之间的联系）：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/数据库设计-权限.png" alt="" /></p>
<p>通过这个权限模型，我们可以创建不同的角色并为不同的角色分配不同的权限范围（菜单）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-7/权限管理模块.png" alt="" /></p>
<p>通常来说，如果系统对于权限控制要求比较严格的话，一般都会选择使用 RBAC 模型来做权限控制。</p>
<h2 id="什么是-cookie-cookie-的作用是什么"> 什么是 Cookie ? Cookie 的作用是什么?</h2>
<p><img src="https://img-blog.csdnimg.cn/20210615162505880.png" alt="" /></p>
<p><code>Cookie</code> 和 <code>Session</code> 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p>维基百科是这样定义 <code>Cookie</code> 的：</p>
<blockquote>
<p><code>Cookies</code> 是某些网站为了辨别用户身份而储存在用户本地终端上的数据（通常经过加密）。</p>
</blockquote>
<p>简单来说： <strong><code>Cookie</code> 存放在客户端，一般用来保存用户信息</strong>。</p>
<p>下面是 <code>Cookie</code> 的一些应用案例：</p>
<ol>
<li>我们在 <code>Cookie</code> 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了。除此之外，<code>Cookie</code> 还能保存用户首选项，主题和其他设置信息。</li>
<li>使用 <code>Cookie</code> 保存 <code>Session</code> 或者 <code>Token</code> ，向后端发送请求的时候带上 <code>Cookie</code>，这样后端就能取到 <code>Session</code> 或者 <code>Token</code> 了。这样就能记录用户当前的状态了，因为 HTTP 协议是无状态的。</li>
<li><code>Cookie</code> 还可以用来记录和分析用户行为。举个简单的例子你在网上购物的时候，因为 HTTP 协议是没有状态的，如果服务器想要获取你在某个页面的停留状态或者看了哪些商品，一种常用的实现方式就是将这些信息存放在 <code>Cookie</code></li>
<li>......</li>
</ol>
<h2 id="如何在项目中使用-cookie-呢"> 如何在项目中使用 Cookie 呢？</h2>
<p>我这里以 Spring Boot 项目为例。</p>
<p><strong>1)设置 <code>Cookie</code> 返回给客户端</strong></p>
<div><pre><code><span>@GetMapping</span><span>(</span><span>"/change-username"</span><span>)</span>
<span>public</span> <span>String</span> <span>setCookie</span><span>(</span><span>HttpServletResponse</span> response<span>)</span> <span>{</span>
    <span>// 创建一个 cookie</span>
    <span>Cookie</span> cookie <span>=</span> <span>new</span> <span>Cookie</span><span>(</span><span>"username"</span><span>,</span> <span>"Jovan"</span><span>)</span><span>;</span>
    <span>//设置 cookie过期时间</span>
    cookie<span>.</span><span>setMaxAge</span><span>(</span><span>7</span> <span>*</span> <span>24</span> <span>*</span> <span>60</span> <span>*</span> <span>60</span><span>)</span><span>;</span> <span>// expires in 7 days</span>
    <span>//添加到 response 中</span>
    response<span>.</span><span>addCookie</span><span>(</span>cookie<span>)</span><span>;</span>

    <span>return</span> <span>"Username is changed!"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>2) 使用 Spring 框架提供的 <code>@CookieValue</code> 注解获取特定的 cookie 的值</strong></p>
<div><pre><code><span>@GetMapping</span><span>(</span><span>"/"</span><span>)</span>
<span>public</span> <span>String</span> <span>readCookie</span><span>(</span><span>@CookieValue</span><span>(</span>value <span>=</span> <span>"username"</span><span>,</span> defaultValue <span>=</span> <span>"Atta"</span><span>)</span> <span>String</span> username<span>)</span> <span>{</span>
    <span>return</span> <span>"Hey! My username is "</span> <span>+</span> username<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>3) 读取所有的 <code>Cookie</code> 值</strong></p>
<div><pre><code><span>@GetMapping</span><span>(</span><span>"/all-cookies"</span><span>)</span>
<span>public</span> <span>String</span> <span>readAllCookies</span><span>(</span><span>HttpServletRequest</span> request<span>)</span> <span>{</span>

    <span>Cookie</span><span>[</span><span>]</span> cookies <span>=</span> request<span>.</span><span>getCookies</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>cookies <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>Arrays</span><span>.</span><span>stream</span><span>(</span>cookies<span>)</span>
                <span>.</span><span>map</span><span>(</span>c <span>-></span> c<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>"="</span> <span>+</span> c<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>joining</span><span>(</span><span>", "</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>return</span> <span>"No cookies"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>更多关于如何在 Spring Boot 中使用 <code>Cookie</code> 的内容可以查看这篇文章：<a href="https://attacomsian.com/blog/cookies-spring-boot%E3%80%82" target="_blank" rel="noopener noreferrer">How to use cookies in Spring Boot</a> 。</p>
<h2 id="cookie-和-session-有什么区别"> Cookie 和 Session 有什么区别？</h2>
<p><strong><code>Session</code> 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 <code>Session</code> 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p><code>Cookie</code> 数据保存在客户端(浏览器端)，<code>Session</code> 数据保存在服务器端。相对来说 <code>Session</code> 安全性更高。如果使用 <code>Cookie</code> 的一些敏感信息不要写入 <code>Cookie</code> 中，最好能将 <code>Cookie</code> 信息加密然后使用到的时候再去服务器端解密。</p>
<p><strong>那么，如何使用 <code>Session</code> 进行身份验证？</strong></p>
<h2 id="如何使用-session-cookie-方案进行身份验证"> 如何使用 Session-Cookie 方案进行身份验证？</h2>
<p>很多时候我们都是通过 <code>SessionID</code> 来实现特定的用户，<code>SessionID</code> 一般会选择存放在 Redis 中。举个例子：</p>
<ol>
<li>用户成功登陆系统，然后返回给客户端具有 <code>SessionID</code> 的 <code>Cookie</code></li>
<li>当用户向后端发起请求的时候会把 <code>SessionID</code> 带上，这样后端就知道你的身份状态了。</li>
</ol>
<p>关于这种认证方式更详细的过程如下：</p>
<p><img src="./images/basis-of-authority-certification/session-cookie.png" alt="" /></p>
<ol>
<li>用户向服务器发送用户名、密码、验证码用于登陆系统。</li>
<li>服务器验证通过后，服务器为用户创建一个 <code>Session</code>，并将 <code>Session</code> 信息存储起来。</li>
<li>服务器向用户返回一个 <code>SessionID</code>，写入用户的 <code>Cookie</code>。</li>
<li>当用户保持登录状态时，<code>Cookie</code> 将与每个后续请求一起被发送出去。</li>
<li>服务器可以将存储在 <code>Cookie</code> 上的 <code>SessionID</code> 与存储在内存中或者数据库中的 <code>Session</code> 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。</li>
</ol>
<p>使用 <code>Session</code> 的时候需要注意下面几个点：</p>
<ol>
<li>依赖 <code>Session</code> 的关键业务一定要确保客户端开启了 <code>Cookie</code>。</li>
<li>注意 <code>Session</code> 的过期时间。</li>
</ol>
<p>另外，Spring Session 提供了一种跨多个应用程序或实例管理用户会话信息的机制。如果想详细了解可以查看下面几篇很不错的文章：</p>
<ul>
<li><a href="https://codeboje.de/spring-Session-tutorial/" target="_blank" rel="noopener noreferrer">Getting Started with Spring Session</a></li>
<li><a href="https://www.baeldung.com/spring-Session" target="_blank" rel="noopener noreferrer">Guide to Spring Session</a></li>
<li><a href="https://medium.com/@gvnix/sticky-Sessions-with-spring-Session-redis-bdc6f7438cc3" target="_blank" rel="noopener noreferrer">Sticky Sessions with Spring Session &amp; Redis</a></li>
</ul>
<h2 id="多服务器节点下-session-cookie-方案如何做"> 多服务器节点下 Session-Cookie 方案如何做？</h2>
<p>Session-Cookie 方案在单体环境是一个非常好的身份认证方案。但是，当服务器水平拓展成多节点时，Session-Cookie 方案就要面临挑战了。</p>
<p>举个例子：假如我们部署了两份相同的服务 A，B，用户第一次登陆的时候 ，Nginx 通过负载均衡机制将用户请求转发到 A 服务器，此时用户的 Session 信息保存在 A 服务器。结果，用户第二次访问的时候 Nginx 将请求路由到 B 服务器，由于 B 服务器没有保存 用户的 Session 信息，导致用户需要重新进行登陆。</p>
<p><strong>我们应该如何避免上面这种情况的出现呢？</strong></p>
<p>有几个方案可供大家参考：</p>
<ol>
<li>某个用户的所有请求都通过特性的哈希策略分配给同一个服务器处理。这样的话，每个服务器都保存了一部分用户的 Session 信息。服务器宕机，其保存的所有 Session 信息就完全丢失了。</li>
<li>每一个服务器保存的 Session 信息都是互相同步的，也就是说每一个服务器都保存了全量的 Session 信息。每当一个服务器的 Session 信息发生变化，我们就将其同步到其他服务器。这种方案成本太大，并且，节点越多时，同步成本也越高。</li>
<li>单独使用一个所有服务器都能访问到的数据节点（比如缓存）来存放 Session 信息。为了保证高可用，数据节点尽量要避免是单点。</li>
</ol>
<h2 id="如果没有-cookie-的话-session-还能用吗"> 如果没有 Cookie 的话 Session 还能用吗？</h2>
<p>这是一道经典的面试题！</p>
<p>一般是通过 <code>Cookie</code> 来保存 <code>SessionID</code> ，假如你使用了 <code>Cookie</code> 保存 <code>SessionID</code> 的方案的话， 如果客户端禁用了 <code>Cookie</code>，那么 <code>Session</code> 就无法正常工作。</p>
<p>但是，并不是没有 <code>Cookie</code> 之后就不能用 <code>Session</code> 了，比如你可以将 <code>SessionID</code> 放在请求的 <code>url</code> 里面<code>https://javaguide.cn/?Session_id=xxx</code> 。这种方案的话可行，但是安全性和用户体验感降低。当然，为了你也可以对 <code>SessionID</code> 进行一次加密之后再传入后端。</p>
<h2 id="为什么-cookie-无法防止-csrf-攻击-而-token-可以"> 为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？</h2>
<p>**CSRF（Cross Site Request Forgery）**一般被翻译为 <strong>跨站请求伪造</strong> 。那么什么是 <strong>跨站请求伪造</strong> 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子：</p>
<p>小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了 10000 元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p>
<div><pre><code>&lt;a src=http://www.mybank.com/Transfer?bankId=11&amp;money=10000>科学理财，年盈利率过万&lt;/>
</code></pre>
<div><span>1</span><br></div></div><p>上面也提到过，进行 <code>Session</code> 认证的时候，我们一般使用 <code>Cookie</code> 来存储 <code>SessionId</code>,当我们登陆后后端生成一个 <code>SessionId</code> 放在 Cookie 中返回给客户端，服务端通过 Redis 或者其他存储工具记录保存着这个 <code>SessionId</code>，客户端登录以后每次请求都会带上这个 <code>SessionId</code>，服务端通过这个 <code>SessionId</code> 来标示你这个人。如果别人通过 <code>Cookie</code> 拿到了 <code>SessionId</code> 后就可以代替你的身份访问系统了。</p>
<p><code>Session</code> 认证中 <code>Cookie</code> 中的 <code>SessionId</code> 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。</p>
<p>但是，我们使用 <code>Token</code> 的话就不会存在这个问题，在我们登录成功获得 <code>Token</code> 之后，一般会选择存放在 <code>localStorage</code> （浏览器本地存储）中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 <code>Token</code>,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 <code>Token</code> 的，所以这个请求将是非法的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210615161108272.png" alt="" /></p>
<p>需要注意的是不论是 <code>Cookie</code> 还是 <code>Token</code> 都无法避免 <strong>跨站脚本攻击（Cross Site Scripting）XSS</strong> 。</p>
<blockquote>
<p>跨站脚本攻击（Cross Site Scripting）缩写为 CSS 但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，有人将跨站脚本攻击缩写为 XSS。</p>
</blockquote>
<p>XSS 中攻击者会用各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本盗用信息比如 <code>Cookie</code> 。</p>
<p>推荐阅读：<a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener noreferrer">如何防止 CSRF 攻击？—美团技术团队</a></p>
<h2 id="什么是-token-什么是-jwt"> 什么是 Token?什么是 JWT?</h2>
<p>我们在前面的问题中探讨了使用 <code>Session</code> 来鉴别用户的身份，并且给出了几个 Spring Session 的案例分享。 我们知道 <code>Session</code> 信息需要保存一份在服务器端。这种方式会带来一些麻烦，比如需要我们保证保存 <code>Session</code> 信息服务器的可用性、不适合移动端（依赖 <code>Cookie</code>）等等。</p>
<p>有没有一种不需要自己存放 <code>Session</code> 信息就能实现身份验证的方式呢？使用 <code>Token</code> 即可！<strong>JWT</strong> （JSON Web Token） 就是这种方式的实现，通过这种方式服务器端就不需要保存 <code>Session</code> 数据了，只用在客户端保存服务端返回给客户的 <code>Token</code> 就可以了，扩展性得到提升。</p>
<p><strong>JWT 本质上就一段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。</strong></p>
<p>下面是 <a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener noreferrer">RFC 7519</a> 对 JWT 做的较为正式的定义。</p>
<blockquote>
<p>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. ——<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener noreferrer">JSON Web Token (JWT)</a></p>
</blockquote>
<p>JWT 由 3 部分构成:</p>
<ol>
<li><strong>Header</strong> : 描述 JWT 的元数据，定义了生成签名的算法以及 <code>Token</code> 的类型。</li>
<li><strong>Payload</strong> : 用来存放实际需要传递的数据</li>
<li><strong>Signature（签名）</strong> ：服务器通过<code>Payload</code>、<code>Header</code>和一个密钥(<code>secret</code>)使用 <code>Header</code> 里面指定的签名算法（默认是 HMAC SHA256）生成。</li>
</ol>
<h2 id="如何基于-token-进行身份验证"> 如何基于 Token 进行身份验证？</h2>
<p>在基于 Token 进行身份验证的的应用程序中，服务器通过<code>Payload</code>、<code>Header</code>和一个密钥(<code>secret</code>)创建令牌（<code>Token</code>）并将 <code>Token</code> 发送给客户端，客户端将 <code>Token</code> 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization 字段中：<code>Authorization: Bearer Token</code>。</p>
<p><img src="./images/basis-of-authority-certification/jwt.png" alt="jwt" /></p>
<ol>
<li>用户向服务器发送用户名和密码用于登陆系统。</li>
<li>身份验证服务响应并返回了签名的 JWT，上面包含了用户是谁的内容。</li>
<li>用户以后每次向后端发请求都在 <code>Header</code> 中带上 JWT。</li>
<li>服务端检查 JWT 并从中获取用户相关信息。</li>
</ol>
<h2 id="什么是-sso"> 什么是 SSO?</h2>
<p>SSO(Single Sign On)即单点登录说的是用户登陆多个子系统的其中一个就有权访问与其相关的其他系统。举个例子我们在登陆了京东金融之后，我们同时也成功登陆京东的京东超市、京东国际、京东生鲜等子系统。</p>
<p><img src="./images/basis-of-authority-certification/sso.png" alt="sso" /></p>
<h2 id="什么是-oauth-2-0"> 什么是 OAuth 2.0？</h2>
<p>OAuth 是一个行业的标准授权协议，主要用来授权第三方应用获取有限的权限。而 OAuth 2.0 是对 OAuth 1.0 的完全重新设计，OAuth 2.0 更快，更容易实现，OAuth 1.0 已经被废弃。详情请见：<a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener noreferrer">rfc6749</a>。</p>
<p>实际上它就是一种授权机制，它的最终目的是为第三方应用颁发一个有时效性的令牌 Token，使得第三方应用能够通过该令牌获取相关的资源。</p>
<p>OAuth 2.0 比较常用的场景就是第三方登录，当你的网站接入了第三方登录的时候一般就是使用的 OAuth 2.0 协议。</p>
<p>另外，现在 OAuth 2.0 也常见于支付场景（微信支付、支付宝支付）和开发平台（微信开放平台、阿里开放平台等等）。</p>
<p>微信支付账户相关参数：</p>
<p><img src="./images/basis-of-authority-certification/微信支付-fnglfdlgdfj.png" alt="" /></p>
<p>下图是 <a href="https://api.slack.com/legacy/oauth" target="_blank" rel="noopener noreferrer">Slack OAuth 2.0 第三方登录</a>的示意图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210615151716340.png" alt="" /></p>
<p><strong>推荐阅读：</strong></p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener noreferrer">OAuth 2.0 的一个简单解释</a></li>
<li><a href="https://deepzz.com/post/what-is-oauth2-protocol.html" target="_blank" rel="noopener noreferrer">10 分钟理解什么是 OAuth 2.0 协议</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noopener noreferrer">OAuth 2.0 的四种方式</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/github-oauth.html" target="_blank" rel="noopener noreferrer">GitHub OAuth 第三方登录示例教程</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/20210604160908352.png" type="image/png"/>
    </item>
    <item>
      <title>JWT 身份认证优缺点分析以及常见问题解决方案</title>
      <link>https://javaguide.cn/system-design/security/jwt%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <guid>https://javaguide.cn/system-design/security/jwt%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <source url="https://javaguide.cn/rss.xml">JWT 身份认证优缺点分析以及常见问题解决方案</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="jwt-身份认证优缺点分析以及常见问题解决方案"> JWT 身份认证优缺点分析以及常见问题解决方案</h1>
<p>之前分享了一个使用 Spring Security 实现 JWT 身份认证的 Demo，文章地址：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485622&amp;idx=1&amp;sn=e9750ed63c47457ba1896db8dfceac6a&amp;chksm=cea2477df9d5ce6b7af20e582c6c60b7408a6459b05b849394c45f04664d1651510bdee029f7&amp;token=684071313&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">适合初学者入门 Spring Security With JWT 的 Demo</a>。 Demo 非常简单，没有介绍到 JWT 存在的一些问题。所以，单独抽了一篇文章出来介绍。为了完成这篇文章，我查阅了很多资料和文献，我觉得应该对大家有帮助。</p>
<p>相关阅读：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485626&amp;idx=1&amp;sn=3247aa9000693dd692de8a04ccffeec1&amp;chksm=cea24771f9d5ce675ea0203633a95b68bfe412dc6a9d05f22d221161147b76161d1b470d54b3&amp;token=684071313&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">《一问带你区分清楚Authentication,Authorization以及Cookie、Session、Token》</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485622&amp;idx=1&amp;sn=e9750ed63c47457ba1896db8dfceac6a&amp;chksm=cea2477df9d5ce6b7af20e582c6c60b7408a6459b05b849394c45f04664d1651510bdee029f7&amp;token=684071313&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">适合初学者入门 Spring Security With JWT 的 Demo</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485640&amp;idx=1&amp;sn=0ff147808318d53b371f16bb730c96ef&amp;chksm=cea24703f9d5ce156ba67662f6f3f482330e8e6ebd9d44c61bf623083e9b941d8a180db6b0ea&amp;token=1533246333&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">Spring Boot 使用 JWT 进行身份和权限验证</a></li>
</ul>
<h2 id="token-认证的优势"> Token 认证的优势</h2>
<p>相比于 Session 认证的方式来说，使用 token 进行身份认证主要有下面四个优势：</p>
<h3 id="_1-无状态"> 1.无状态</h3>
<p>token 自身包含了身份验证所需要的所有信息，使得我们的服务器不需要存储 Session 信息，这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。但是，也正是由于 token 的无状态，也导致了它最大的缺点：当后端在token 有效期内废弃一个 token 或者更改它的权限的话，不会立即生效，一般需要等到有效期过后才可以。另外，当用户 Logout 的话，token 也还有效。除非，我们在后端增加额外的处理逻辑。</p>
<h3 id="_2-有效避免了csrf-攻击"> 2.有效避免了CSRF 攻击</h3>
<p><strong>CSRF（Cross Site Request Forgery）</strong> 一般被翻译为 <strong>跨站请求伪造</strong>，属于网络攻击领域范围。相比于 SQL 脚本注入、XSS等安全攻击方式，CSRF 的知名度并没有它们高。但是,它的确是每个系统都要考虑的安全隐患，就连技术帝国 Google 的 Gmail 在早些年也被曝出过存在  CSRF 漏洞，这给 Gmail 的用户造成了很大的损失。</p>
<p>那么究竟什么是  <strong>跨站请求伪造</strong> 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子：</p>
<p>小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>src</span><span><span>=</span><span>"</span>http://www.mybank.com/Transfer?bankId=11&amp;money=10000<span>"</span></span><span>></span></span>科学理财，年盈利率过万<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>导致这个问题很大的原因就是： Session 认证中 Cookie 中的 session_id 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。</p>
<p><strong>那为什么 token 不会存在这种问题呢？</strong></p>
<p>我是这样理解的：一般情况下我们使用 JWT 的话，在我们登录成功获得 token 之后，一般会选择存放在  local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 token 的，所以这个请求将是非法的。</p>
<p>但是这样会存在  XSS 攻击中被盗的风险，为了避免 XSS 攻击，你可以选择将 token 存储在标记为<code>httpOnly</code>  的cookie 中。但是，这样又导致了你必须自己提供CSRF保护。</p>
<p>具体采用上面哪种方式存储 token 呢，大部分情况下存放在  local storage 下都是最好的选择，某些情况下可能需要存放在标记为<code>httpOnly</code>  的cookie 中会更好。</p>
<h3 id="_3-适合移动端应用"> 3.适合移动端应用</h3>
<p>使用 Session 进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到 Cookie（需要 Cookie 保存 SessionId），所以不适合移动端。</p>
<p>但是，使用 token 进行身份认证就不会存在这种问题，因为只要 token 可以被客户端存储就能够使用，而且 token 还可以跨语言使用。</p>
<h3 id="_4-单点登录友好"> 4.单点登录友好</h3>
<p>使用 Session 进行身份认证的话，实现单点登录，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 token 进行认证的话， token 被保存在客户端，不会存在这些问题。</p>
<h2 id="token-认证常见问题以及解决办法"> Token 认证常见问题以及解决办法</h2>
<h3 id="_1-注销登录等场景下-token-还有效"> 1.注销登录等场景下 token 还有效</h3>
<p>与之类似的具体相关场景有：</p>
<ol>
<li>退出登录;</li>
<li>修改密码;</li>
<li>服务端修改了某个用户具有的权限或者角色；</li>
<li>用户的帐户被删除/暂停。</li>
<li>用户由管理员注销；</li>
</ol>
<p>这个问题不存在于 Session  认证方式中，因为在  Session  认证方式中，遇到这种情况的话服务端删除对应的 Session 记录即可。但是，使用 token 认证的方式就不好解决了。我们也说过了，token 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的。那么，我们如何解决这个问题呢？查阅了很多资料，总结了下面几种方案：</p>
<ul>
<li><strong>将 token 存入内存数据库</strong>：将 token 存入 DB 中，redis 内存数据库在这里是不错的选择。如果需要让某个 token 失效就直接从 redis 中删除这个 token 即可。但是，这样会导致每次使用 token 发送请求都要先从 DB 中查询 token 是否存在的步骤，而且违背了 JWT 的无状态原则。</li>
<li><strong>黑名单机制</strong>：和上面的方式类似，使用内存数据库比如 redis 维护一个黑名单，如果想让某个 token 失效的话就直接将这个 token 加入到 <strong>黑名单</strong> 即可。然后，每次使用 token 进行请求的话都会先判断这个 token 是否存在于黑名单中。</li>
<li><strong>修改密钥 (Secret)</strong> : 我们为每个用户都创建一个专属密钥，如果我们想让某个 token 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大，比如：1) 如果服务是分布式的，则每次发出新的 token 时都必须在多台机器同步密钥。为此，你需要将密钥存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。 2) 如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的。</li>
<li><strong>保持令牌的有效期限短并经常轮换</strong> ：很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。</li>
</ul>
<p>对于修改密码后 token 还有效问题的解决还是比较容易的，说一种我觉得比较好的方式：<strong>使用用户的密码的哈希值对 token 进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。</strong></p>
<h3 id="_2-token-的续签问题"> 2.token 的续签问题</h3>
<p>token 有效期一般都建议设置的不太长，那么 token 过期后如何认证，如何实现动态刷新 token，避免用户经常需要重新登录？</p>
<p>我们先来看看在 Session 认证中一般的做法：<strong>假如 session 的有效期30分钟，如果 30 分钟内用户有访问，就把 session 有效期延长30分钟。</strong></p>
<ol>
<li><strong>类似于 Session 认证中的做法</strong>：这种方案满足于大部分场景。假设服务端给的 token 有效期设置为30分钟，服务端每次进行校验时，如果发现 token 的有效期马上快过期了，服务端就重新生成 token 给客户端。客户端每次请求都检查新旧token，如果不一致，则更新本地的token。这种做法的问题是仅仅在快过期的时候请求才会更新 token ,对客户端不是很友好。</li>
<li><strong>每次请求都返回新 token</strong> :这种方案的的思路很简单，但是，很明显，开销会比较大。</li>
<li><strong>token 有效期设置到半夜</strong> ：这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</li>
<li><strong>用户登录返回两个 token</strong> ：第一个是 accessToken ，它的过期时间 token 本身的过期时间比如半个小时，另外一个是 refreshToken 它的过期时间更长一点比如为1天。客户端登录后，将 accessToken和refreshToken 保存在本地，每次访问将 accessToken 传给服务端。服务端校验 accessToken 的有效性，如果过期的话，就将 refreshToken 传给服务端。如果有效，服务端就生成新的 accessToken 给客户端。否则，客户端就重新登录即可。该方案的不足是：1) 需要客户端来配合；2) 用户注销的时候需要同时保证两个 token 都无效；3) 重新请求获取 token 的过程中会有短暂 token 不可用的情况（可以通过在客户端设置定时器，当accessToken 快过期的时候，提前去通过 refreshToken 获取新的accessToken）。</li>
</ol>
<h2 id="总结"> 总结</h2>
<p>JWT 最适合的场景是不需要服务端保存用户状态的场景，如果考虑到 token 注销和 token 续签的场景话，没有特别好的解决方案，大部分解决方案都给 token 加上了状态，这就有点类似 Session 认证了。</p>
<h2 id="reference"> Reference</h2>
<ul>
<li><a href="https://learnku.com/articles/17883?order_by=vote_count&amp;" target="_blank" rel="noopener noreferrer">JWT 超详细分析</a></li>
<li>https://medium.com/devgorilla/how-to-log-out-when-using-jwt-a8c7823e8a6</li>
<li>https://medium.com/@agungsantoso/csrf-protection-with-json-web-tokens-83e0f2fcbcc</li>
<li><a href="https://stackoverflow.com/questions/21978658/invalidating-json-web-tokens" target="_blank" rel="noopener noreferrer">Invalidating JSON Web Tokens</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>SSO 单点登录</title>
      <link>https://javaguide.cn/system-design/security/sso-intro/</link>
      <guid>https://javaguide.cn/system-design/security/sso-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">SSO 单点登录</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="sso-单点登录"> SSO 单点登录</h1>
<blockquote>
<p>本文授权转载自 ： https://ken.io/note/sso-design-implement 作者：ken.io</p>
<p>相关推荐阅读：<strong><a href="https://www.imooc.com/article/286710" target="_blank" rel="noopener noreferrer">系统的讲解 - SSO单点登录</a></strong></p>
</blockquote>
<h2 id="一、前言"> 一、前言</h2>
<h3 id="_1、sso说明"> 1、SSO说明</h3>
<p>SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。https://baike.baidu.com/item/SSO/3451380</p>
<p>例如访问在网易账号中心（https://reg.163.com/ ）登录之后
访问以下站点都是登录状态</p>
<ul>
<li>网易直播 <a href="https://v.163.com/" target="_blank" rel="noopener noreferrer">https://v.163.com</a></li>
<li>网易博客 <a href="https://blog.163.com/" target="_blank" rel="noopener noreferrer">https://blog.163.com</a></li>
<li>网易花田 <a href="https://love.163.com/" target="_blank" rel="noopener noreferrer">https://love.163.com</a></li>
<li>网易考拉 <a href="https://www.kaola.com/" target="_blank" rel="noopener noreferrer">https://www.kaola.com</a></li>
<li>网易Lofter <a href="http://www.lofter.com/" target="_blank" rel="noopener noreferrer">http://www.lofter.com</a></li>
</ul>
<h3 id="_2、单点登录系统的好处"> 2、单点登录系统的好处</h3>
<ol>
<li><strong>用户角度</strong> :用户能够做到一次登录多次使用，无需记录多套用户名和密码，省心。</li>
<li><strong>系统管理员角度</strong> : 管理员只需维护好一个统一的账号中心就可以了，方便。</li>
<li><strong>新系统开发角度:</strong> 新系统开发时只需直接对接统一的账号中心即可，简化开发流程，省时。</li>
</ol>
<h3 id="_3、设计目标"> 3、设计目标</h3>
<p>本篇文章也主要是为了探讨如何设计&amp;实现一个SSO系统</p>
<p>以下为需要实现的核心功能：</p>
<ul>
<li>单点登录</li>
<li>单点登出</li>
<li>支持跨域单点登录</li>
<li>支持跨域单点登出</li>
</ul>
<h2 id="二、sso设计与实现"> 二、SSO设计与实现</h2>
<h3 id="_1、核心应用与依赖"> 1、核心应用与依赖</h3>
<p><img src="https://img.ken.io/blog/sso/sso-system.png-kblb.png" alt="单点登录（SSO）设计" /></p>
<table>
<thead>
<tr>
<th>应用/模块/对象</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>前台站点</td>
<td>需要登录的站点</td>
</tr>
<tr>
<td>SSO站点-登录</td>
<td>提供登录的页面</td>
</tr>
<tr>
<td>SSO站点-登出</td>
<td>提供注销登录的入口</td>
</tr>
<tr>
<td>SSO服务-登录</td>
<td>提供登录服务</td>
</tr>
<tr>
<td>SSO服务-登录状态</td>
<td>提供登录状态校验/登录信息查询的服务</td>
</tr>
<tr>
<td>SSO服务-登出</td>
<td>提供用户注销登录的服务</td>
</tr>
<tr>
<td>数据库</td>
<td>存储用户账户信息</td>
</tr>
<tr>
<td>缓存</td>
<td>存储用户的登录信息，通常使用Redis</td>
</tr>
</tbody>
</table>
<h3 id="_2、用户登录状态的存储与校验"> 2、用户登录状态的存储与校验</h3>
<p>常见的Web框架对于<a href="https://ken.io/note/session-principle-skill" target="_blank" rel="noopener noreferrer">Session</a>的实现都是生成一个SessionId存储在浏览器Cookie中。然后将Session内容存储在服务器端内存中，这个 ken.io 在之前<a href="https://ken.io/note/session-principle-skill" target="_blank" rel="noopener noreferrer">Session工作原理</a>中也提到过。整体也是借鉴这个思路。
用户登录成功之后，生成AuthToken交给客户端保存。如果是浏览器，就保存在Cookie中。如果是手机App就保存在App本地缓存中。本篇主要探讨基于Web站点的SSO。
用户在浏览需要登录的页面时，客户端将AuthToken提交给SSO服务校验登录状态/获取用户登录信息</p>
<p>对于登录信息的存储，建议采用Redis，使用Redis集群来存储登录信息，既可以保证高可用，又可以线性扩充。同时也可以让SSO服务满足负载均衡/可伸缩的需求。</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AuthToken</td>
<td>直接使用UUID/GUID即可，如果有验证AuthToken合法性需求，可以将UserName+时间戳加密生成，服务端解密之后验证合法性</td>
</tr>
<tr>
<td>登录信息</td>
<td>通常是将UserId，UserName缓存起来</td>
</tr>
</tbody>
</table>
<h3 id="_3、用户登录-登录校验"> 3、用户登录/登录校验</h3>
<ul>
<li>登录时序图</li>
</ul>
<p><img src="https://img.ken.io/blog/sso/sso-login-sequence.png-kbrb.png" alt="SSO系统设计-登录时序图" /></p>
<p>按照上图，用户登录后AuthToken保存在Cookie中。 domain=test.com
浏览器会将domain设置成 .test.com，
这样访问所有*.test.com的web站点，都会将AuthToken携带到服务器端。
然后通过SSO服务，完成对用户状态的校验/用户登录信息的获取</p>
<ul>
<li>登录信息获取/登录状态校验</li>
</ul>
<p><img src="https://img.ken.io/blog/sso/sso-logincheck-sequence.png-kbrb.png" alt="SSO系统设计-登录信息获取/登录状态校验" /></p>
<h3 id="_4、用户登出"> 4、用户登出</h3>
<p>用户登出时要做的事情很简单：</p>
<ol>
<li>服务端清除缓存（Redis）中的登录状态</li>
<li>客户端清除存储的AuthToken</li>
</ol>
<ul>
<li>登出时序图</li>
</ul>
<p><img src="https://img.ken.io/blog/sso/sso-logout-sequence.png-kbrb.png" alt="SSO系统设计-用户登出" /></p>
<h3 id="_5、跨域登录、登出"> 5、跨域登录、登出</h3>
<p>前面提到过，核心思路是客户端存储AuthToken，服务器端通过Redis存储登录信息。由于客户端是将AuthToken存储在Cookie中的。所以跨域要解决的问题，就是如何解决Cookie的跨域读写问题。</p>
<blockquote>
<p><strong>Cookie是不能跨域的</strong> ，比如我一个</p>
</blockquote>
<p>解决跨域的核心思路就是：</p>
<ul>
<li>登录完成之后通过回调的方式，将AuthToken传递给主域名之外的站点，该站点自行将AuthToken保存在当前域下的Cookie中。</li>
<li>登出完成之后通过回调的方式，调用非主域名站点的登出页面，完成设置Cookie中的AuthToken过期的操作。</li>
<li>跨域登录（主域名已登录）</li>
</ul>
<p><img src="https://img.ken.io/blog/sso/sso-crossdomain-login-loggedin-sequence.png-kbrb.png" alt="SSO系统设计-跨域登录（主域名已登录）" /></p>
<ul>
<li>跨域登录（主域名未登录）</li>
</ul>
<p><img src="https://img.ken.io/blog/sso/sso-crossdomain-login-unlogin-sequence.png-kbrb.png" alt="SSO系统设计-跨域登录（主域名未登录）" /></p>
<ul>
<li>跨域登出</li>
</ul>
<p><img src="https://img.ken.io/blog/sso/sso-crossdomain-logout-sequence.png-kbrb.png" alt="SSO系统设计-跨域登出" /></p>
<h2 id="三、备注"> 三、备注</h2>
<ul>
<li>关于方案</li>
</ul>
<p>这次设计方案更多是提供实现思路。如果涉及到APP用户登录等情况，在访问SSO服务时，增加对APP的签名验证就好了。当然，如果有无线网关，验证签名不是问题。</p>
<ul>
<li>关于时序图</li>
</ul>
<p>时序图中并没有包含所有场景，ken.io只列举了核心/主要场景，另外对于一些不影响理解思路的消息能省就省了。</p>
]]></content:encoded>
      <enclosure url="https://img.ken.io/blog/sso/sso-system.png-kblb.png" type="image/png"/>
    </item>
    <item>
      <title>Spring Cloud 入门</title>
      <link>https://javaguide.cn/system-design/framework/springcloud/springcloud-intro/</link>
      <guid>https://javaguide.cn/system-design/framework/springcloud/springcloud-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">Spring Cloud 入门</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="spring-cloud-入门"> Spring Cloud 入门</h1>
<blockquote>
<p>本文基于 Spring Cloud Netflix 。Spring Cloud Alibaba 也是非常不错的选择哦！</p>
<p>授权转载自：https://juejin.im/post/5de2553e5188256e885f4fa3</p>
</blockquote>
<p>首先我给大家看一张图，如果大家对这张图有些地方不太理解的话，我希望你们看完我这篇文章会恍然大悟。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/spring-cloud总体架构.jpg" alt="Spring Cloud 总体架构" /></p>
<h2 id="什么是spring-cloud"> 什么是Spring Cloud</h2>
<blockquote>
<p>构建分布式系统不仅复杂而且容易出错。Spring Cloud 为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序。Spring Cloud 构建于 Spring Boot 之上，使得开发者很容易入手并快速应用于生产中。</p>
</blockquote>
<p>官方果然官方，介绍都这么有板有眼的。</p>
<p>我所理解的 <code>Spring Cloud</code> 就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 <strong>服务发现注册</strong> 、<strong>配置中心</strong> 、<strong>消息总线</strong> 、<strong>负载均衡</strong> 、<strong>断路器</strong> 、<strong>数据监控</strong> 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</p>
<h2 id="spring-cloud-的版本"> Spring Cloud 的版本</h2>
<p>当然这个只是个题外话。</p>
<p><code>Spring Cloud</code> 的版本号并不是我们通常见的数字版本号，而是一些很奇怪的单词。这些单词均为英国伦敦地铁站的站名。同时根据字母表的顺序来对应版本时间顺序，比如：最早 的 <code>Release</code> 版本 <code>Angel</code>，第二个 <code>Release</code> 版本 <code>Brixton</code>（英国地名），然后是 <code>Camden</code>、 <code>Dalston</code>、<code>Edgware</code>、<code>Finchley</code>、<code>Greenwich</code>、<code>Hoxton</code>。</p>
<h2 id="spring-cloud-的服务发现框架-eureka"> Spring Cloud 的服务发现框架——Eureka</h2>
<blockquote>
<p><code>Eureka</code>是基于<code>REST</code>（代表性状态转移）的服务，主要在 <code>AWS</code> 云中用于定位服务，以实现负载均衡和中间层服务器的故障转移。我们称此服务为<code>Eureka</code>服务器。Eureka还带有一个基于 <code>Java</code> 的客户端组件 <code>Eureka Client</code>，它使与服务的交互变得更加容易。客户端还具有一个内置的负载平衡器，可以执行基本的循环负载平衡。在 <code>Netflix</code>，更复杂的负载均衡器将 <code>Eureka</code> 包装起来，以基于流量，资源使用，错误条件等多种因素提供加权负载均衡，以提供出色的弹性。</p>
</blockquote>
<p>总的来说，<code>Eureka</code> 就是一个服务发现框架。何为服务，何又为发现呢？</p>
<p>举一个生活中的例子，就比如我们平时租房子找中介的事情。</p>
<p>在没有中介的时候我们需要一个一个去寻找是否有房屋要出租的房东，这显然会非常的费力，一你找凭一个人的能力是找不到很多房源供你选择，再者你也懒得这么找下去(找了这么久，没有合适的只能将就)。<strong>这里的我们就相当于微服务中的 <code>Consumer</code> ，而那些房东就相当于微服务中的 <code>Provider</code> 。消费者 <code>Consumer</code> 需要调用提供者 <code>Provider</code> 提供的一些服务，就像我们现在需要租他们的房子一样。</strong></p>
<p>但是如果只是租客和房东之间进行寻找的话，他们的效率是很低的，房东找不到租客赚不到钱，租客找不到房东住不了房。所以，后来房东肯定就想到了广播自己的房源信息(比如在街边贴贴小广告)，这样对于房东来说已经完成他的任务(将房源公布出去)，但是有两个问题就出现了。第一、其他不是租客的都能收到这种租房消息，这在现实世界没什么，但是在计算机的世界中就会出现 <strong>资源消耗</strong> 的问题了。第二、租客这样还是很难找到你，试想一下我需要租房，我还需要东一个西一个地去找街边小广告，麻不麻烦？</p>
<p>那怎么办呢？我们当然不会那么傻乎乎的，第一时间就是去找 <strong>中介</strong> 呀，它为我们提供了统一房源的地方，我们消费者只需要跑到它那里去找就行了。而对于房东来说，他们也只需要把房源在中介那里发布就行了。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/4d161e2950414113834f2f0a8fc2c16c-new-imaged17347a0-e653-4830-9542-3d7ae4305b2b.png" alt="" /></p>
<p>那么现在，我们的模式就是这样的了。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/24382ce6bbd44932ac38b1accade12d1-new-image2ff8affc-6f1d-49de-a8c3-801e7bad2b11.png" alt="" /></p>
<p>但是，这个时候还会出现一些问题。</p>
<ol>
<li>房东注册之后如果不想卖房子了怎么办？我们是不是需要让房东 <strong>定期续约</strong> ？如果房东不进行续约是不是要将他们从中介那里的注册列表中 <strong>移除</strong> 。</li>
<li>租客是不是也要进行 <strong>注册</strong> 呢？不然合同乙方怎么来呢？</li>
<li>中介可不可以做 <strong>连锁店</strong> 呢？如果这一个店因为某些不可抗力因素而无法使用，那么我们是否可以换一个连锁店呢？</li>
</ol>
<p>针对上面的问题我们来重新构建一下上面的模式图</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/租房-中介模式图.jpg" alt="租房-中介模式图" /></p>
<p>好了，举完这个🌰我们就可以来看关于 <code>Eureka</code> 的一些基础概念了，你会发现这东西理解起来怎么这么简单。👊👊👊</p>
<p><strong>服务发现</strong>：其实就是一个“中介”，整个过程中有三个角色：<strong>服务提供者(出租房子的)、服务消费者(租客)、服务中介(房屋中介)</strong>。</p>
<p><strong>服务提供者</strong>： 就是提供一些自己能够执行的一些服务给外界。</p>
<p><strong>服务消费者</strong>： 就是需要使用一些服务的“用户”。</p>
<p><strong>服务中介</strong>： 其实就是服务提供者和服务消费者之间的“桥梁”，服务提供者可以把自己注册到服务中介那里，而服务消费者如需要消费一些服务(使用一些功能)就可以在服务中介中寻找注册在服务中介的服务提供者。</p>
<p><strong>服务注册 Register</strong>：</p>
<p>官方解释：当 <code>Eureka</code> 客户端向 <code>Eureka Server</code> 注册时，它提供自身的<strong>元数据</strong>，比如IP地址、端口，运行状况指示符URL，主页等。</p>
<p>结合中介理解：房东 (提供者 <code>Eureka Client Provider</code>)在中介 (服务器 <code>Eureka Server</code>) 那里登记房屋的信息，比如面积，价格，地段等等(元数据 <code>metaData</code>)。</p>
<p><strong>服务续约 Renew</strong>：</p>
<p>官方解释：<strong><code>Eureka</code> 客户会每隔30秒(默认情况下)发送一次心跳来续约</strong>。 通过续约来告知 <code>Eureka Server</code> 该 <code>Eureka</code> 客户仍然存在，没有出现问题。 正常情况下，如果 <code>Eureka Server</code> 在90秒没有收到 <code>Eureka</code> 客户的续约，它会将实例从其注册表中删除。</p>
<p>结合中介理解：房东 (提供者 <code>Eureka Client Provider</code>) 定期告诉中介 (服务器 <code>Eureka Server</code>) 我的房子还租(续约) ，中介 (服务器<code>Eureka Server</code>) 收到之后继续保留房屋的信息。</p>
<p><strong>获取注册列表信息 Fetch Registries</strong>：</p>
<p>官方解释：<code>Eureka</code> 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 <code>Eureka</code> 客户端的缓存信息不同, <code>Eureka</code> 客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，<code>Eureka</code> 客户端则会重新获取整个注册表信息。 <code>Eureka</code> 服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。<code>Eureka</code> 客户端和 <code>Eureka</code> 服务器可以使用JSON / XML格式进行通讯。在默认的情况下 <code>Eureka</code> 客户端使用压缩 <code>JSON</code> 格式来获取注册列表的信息。</p>
<p>结合中介理解：租客(消费者 <code>Eureka Client Consumer</code>) 去中介 (服务器 <code>Eureka Server</code>) 那里获取所有的房屋信息列表 (客户端列表 <code>Eureka Client List</code>) ，而且租客为了获取最新的信息会定期向中介 (服务器 <code>Eureka Server</code>) 那里获取并更新本地列表。</p>
<p><strong>服务下线 Cancel</strong>：</p>
<p>官方解释：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：<code>DiscoveryManager.getInstance().shutdownComponent();</code></p>
<p>结合中介理解：房东 (提供者 <code>Eureka Client Provider</code>) 告诉中介  (服务器 <code>Eureka Server</code>) 我的房子不租了，中介之后就将注册的房屋信息从列表中剔除。</p>
<p><strong>服务剔除 Eviction</strong>：</p>
<p>官方解释：在默认的情况下，<strong>当Eureka客户端连续90秒(3个续约周期)没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除</strong>，即服务剔除。</p>
<p>结合中介理解：房东(提供者 <code>Eureka Client Provider</code>) 会定期联系 中介  (服务器 <code>Eureka Server</code>) 告诉他我的房子还租(续约)，如果中介  (服务器 <code>Eureka Server</code>) 长时间没收到提供者的信息，那么中介会将他的房屋信息给下架(服务剔除)。</p>
<p>下面就是 <code>Netflix</code> 官方给出的 <code>Eureka</code> 架构图，你会发现和我们前面画的中介图别无二致。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/5d723c49eca1468ab7b89af06743023c-new-imageb8aa3d41-fad4-4b38-add9-c304930ab285.png" alt="Eureka架构图" /></p>
<p>当然，可以充当服务发现的组件有很多：<code>Zookeeper</code> ，<code>Consul</code> ， <code>Eureka</code> 等。</p>
<p>更多关于 <code>Eureka</code> 的知识(自我保护，初始注册策略等等)可以自己去官网查看，或者查看我的另一篇文章 <a href="https://juejin.im/post/5dd497e3f265da0ba7718018" target="_blank" rel="noopener noreferrer">深入理解 Eureka</a>。</p>
<h2 id="负载均衡之-ribbon"> 负载均衡之 Ribbon</h2>
<h3 id="什么是-resttemplate"> 什么是 <code>RestTemplate</code>?</h3>
<p>不是讲 <code>Ribbon</code> 么？怎么扯到了 <code>RestTemplate</code> 了？你先别急，听我慢慢道来。</p>
<p>我不听我不听我不听🙉🙉🙉。</p>
<p>我就说一句！<strong><code>RestTemplate</code>是<code>Spring</code>提供的一个访问Http服务的客户端类</strong>，怎么说呢？就是微服务之间的调用是使用的 <code>RestTemplate</code> 。比如这个时候我们 消费者B 需要调用 提供者A 所提供的服务我们就需要这么写。如我下面的伪代码。</p>
<div><pre><code><span>@Autowired</span>
<span>private</span> <span>RestTemplate</span> restTemplate<span>;</span>
<span>// 这里是提供者A的ip地址，但是如果使用了 Eureka 那么就应该是提供者A的名称</span>
<span>private</span> <span>static</span> <span>final</span> <span>String</span> SERVICE_PROVIDER_A <span>=</span> <span>"http://localhost:8081"</span><span>;</span>

<span>@PostMapping</span><span>(</span><span>"/judge"</span><span>)</span>
<span>public</span> <span>boolean</span> <span>judge</span><span>(</span><span>@RequestBody</span> <span>Request</span> request<span>)</span> <span>{</span>
    <span>String</span> url <span>=</span> SERVICE_PROVIDER_A <span>+</span> <span>"/service1"</span><span>;</span>
    <span>return</span> restTemplate<span>.</span><span>postForObject</span><span>(</span>url<span>,</span> request<span>,</span> <span>Boolean</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>如果你对源码感兴趣的话，你会发现上面我们所讲的 <code>Eureka</code> 框架中的 <strong>注册</strong>、<strong>续约</strong> 等，底层都是使用的 <code>RestTemplate</code> 。</p>
<h3 id="为什么需要-ribbon"> 为什么需要 Ribbon？</h3>
<p><code>Ribbon</code>  是 <code>Netflix</code> 公司的一个开源的负载均衡 项目，是一个客户端/进程内负载均衡器，<strong>运行在消费者端</strong>。</p>
<p>我们再举个🌰，比如我们设计了一个秒杀系统，但是为了整个系统的 <strong>高可用</strong> ，我们需要将这个系统做一个集群，而这个时候我们消费者就可以拥有多个秒杀系统的调用途径了，如下图。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/秒杀系统-ribbon.jpg" style="zoom:50%;" />
<p>如果这个时候我们没有进行一些 <strong>均衡操作</strong> ，如果我们对 <code>秒杀系统1</code> 进行大量的调用，而另外两个基本不请求，就会导致 <code>秒杀系统1</code> 崩溃，而另外两个就变成了傀儡，那么我们为什么还要做集群，我们高可用体现的意义又在哪呢？</p>
<p>所以 <code>Ribbon</code> 出现了，注意我们上面加粗的几个字——<strong>运行在消费者端</strong>。指的是，<code>Ribbon</code> 是运行在消费者端的负载均衡器，如下图。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/秒杀系统-ribbon2.jpg" style="zoom:50%;" />
<p>其工作原理就是 <code>Consumer</code> 端获取到了所有的服务列表之后，在其<strong>内部</strong>使用<strong>负载均衡算法</strong>，进行对多个系统的调用。</p>
<h3 id="nginx-和-ribbon-的对比"> Nginx 和 Ribbon 的对比</h3>
<p>提到 <strong>负载均衡</strong> 就不得不提到大名鼎鼎的 <code>Nignx</code> 了，而和 <code>Ribbon</code> 不同的是，它是一种<strong>集中式</strong>的负载均衡器。</p>
<p>何为集中式呢？简单理解就是 <strong>将所有请求都集中起来，然后再进行负载均衡</strong>。如下图。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/nginx-vs-ribbon1.jpg" style="zoom:50%;" />
<p>我们可以看到 <code>Nginx</code> 是接收了所有的请求进行负载均衡的，而对于 <code>Ribbon</code> 来说它是在消费者端进行的负载均衡。如下图。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/nginx-vs-ribbon2.jpg" style="zoom:50%;" />
<blockquote>
<p>请注意 <code>Request</code> 的位置，在 <code>Nginx</code> 中请求是先进入负载均衡器，而在 <code>Ribbon</code> 中是先在客户端进行负载均衡才进行请求的。</p>
</blockquote>
<h3 id="ribbon-的几种负载均衡算法"> Ribbon 的几种负载均衡算法</h3>
<p>负载均衡，不管 <code>Nginx</code> 还是 <code>Ribbon</code> 都需要其算法的支持，如果我没记错的话 <code>Nginx</code> 使用的是 轮询和加权轮询算法。而在 <code>Ribbon</code> 中有更多的负载均衡调度算法，其默认是使用的 <code>RoundRobinRule</code> 轮询策略。</p>
<ul>
<li><strong><code>RoundRobinRule</code></strong>：轮询策略。<code>Ribbon</code> 默认采用的策略。若经过一轮轮询没有找到可用的 <code>provider</code>，其最多轮询 10 轮。若最终还没有找到，则返回 <code>null</code>。</li>
<li><strong><code>RandomRule</code></strong>: 随机策略，从所有可用的 <code>provider</code> 中随机选择一个。</li>
<li><strong><code>RetryRule</code></strong>: 重试策略。先按照 <code>RoundRobinRule</code> 策略获取 <code>provider</code>，若获取失败，则在指定的时限内重试。默认的时限为 500 毫秒。</li>
</ul>
<p>🐦🐦🐦 还有很多，这里不一一举🌰了，你最需要知道的是默认轮询算法，并且可以更换默认的负载均衡算法，只需要在配置文件中做出修改就行。</p>
<div><pre><code><span>providerName</span><span>:</span>
  <span>ribbon</span><span>:</span>
    <span>NFLoadBalancerRuleClassName</span><span>:</span> com.netflix.loadbalancer.RandomRule
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当然，在 <code>Ribbon</code> 中你还可以<strong>自定义负载均衡算法</strong>，你只需要实现 <code>IRule</code> 接口，然后修改配置文件或者自定义 <code>Java Config</code> 类。</p>
<h2 id="什么是-open-feign"> 什么是 Open Feign</h2>
<p>有了 <code>Eureka</code>  ，<code>RestTemplate</code> ，<code>Ribbon</code>，  我们就可以愉快地进行服务间的调用了，但是使用 <code>RestTemplate</code> 还是不方便，我们每次都要进行这样的调用。</p>
<div><pre><code><span>@Autowired</span>
<span>private</span> <span>RestTemplate</span> restTemplate<span>;</span>
<span>// 这里是提供者A的ip地址，但是如果使用了 Eureka 那么就应该是提供者A的名称</span>
<span>private</span> <span>static</span> <span>final</span> <span>String</span> SERVICE_PROVIDER_A <span>=</span> <span>"http://localhost:8081"</span><span>;</span>

<span>@PostMapping</span><span>(</span><span>"/judge"</span><span>)</span>
<span>public</span> <span>boolean</span> <span>judge</span><span>(</span><span>@RequestBody</span> <span>Request</span> request<span>)</span> <span>{</span>
    <span>String</span> url <span>=</span> SERVICE_PROVIDER_A <span>+</span> <span>"/service1"</span><span>;</span>
    <span>// 是不是太麻烦了？？？每次都要 url、请求、返回类型的 </span>
    <span>return</span> restTemplate<span>.</span><span>postForObject</span><span>(</span>url<span>,</span> request<span>,</span> <span>Boolean</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这样每次都调用 <code>RestRemplate</code> 的 <code>API</code> 是否太麻烦，我能不能像<strong>调用原来代码一样进行各个服务间的调用呢？</strong></p>
<p>💡💡💡聪明的小朋友肯定想到了，那就用 <strong>映射</strong> 呀，就像域名和IP地址的映射。我们可以将被调用的服务代码映射到消费者端，这样我们就可以 **“无缝开发” **啦。</p>
<blockquote>
<p><code>OpenFeign</code> 也是运行在消费者端的，使用 <code>Ribbon</code> 进行负载均衡，所以 <code>OpenFeign</code> 直接内置了 <code>Ribbon</code>。</p>
</blockquote>
<p>在导入了 <code>Open Feign</code> 之后我们就可以进行愉快编写  <code>Consumer</code> 端代码了。</p>
<div><pre><code><span>// 使用 @FeignClient 注解来指定提供者的名字</span>
<span>@FeignClient</span><span>(</span>value <span>=</span> <span>"eureka-client-provider"</span><span>)</span>
<span>public</span> <span>interface</span> <span>TestClient</span> <span>{</span>
    <span>// 这里一定要注意需要使用的是提供者那端的请求相对路径，这里就相当于映射了</span>
    <span>@RequestMapping</span><span>(</span>value <span>=</span> <span>"/provider/xxx"</span><span>,</span>
    method <span>=</span> <span>RequestMethod</span><span>.</span>POST<span>)</span>
    <span>CommonResponse</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Plan</span><span>></span><span>></span></span> <span>getPlans</span><span>(</span><span>@RequestBody</span> planGetRequest request<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>然后我们在 <code>Controller</code> 就可以像原来调用 <code>Service</code> 层代码一样调用它了。</p>
<div><pre><code><span>@RestController</span>
<span>public</span> <span>class</span> <span>TestController</span> <span>{</span>
    <span>// 这里就相当于原来自动注入的 Service</span>
    <span>@Autowired</span>
    <span>private</span> <span>TestClient</span> testClient<span>;</span>
    <span>// controller 调用 service 层代码</span>
    <span>@RequestMapping</span><span>(</span>value <span>=</span> <span>"/test"</span><span>,</span> method <span>=</span> <span>RequestMethod</span><span>.</span>POST<span>)</span>
    <span>public</span> <span>CommonResponse</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Plan</span><span>></span><span>></span></span> <span>get</span><span>(</span><span>@RequestBody</span> planGetRequest request<span>)</span> <span>{</span>
        <span>return</span> testClient<span>.</span><span>getPlans</span><span>(</span>request<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="必不可少的-hystrix"> 必不可少的 Hystrix</h2>
<h3 id="什么是-hystrix之熔断和降级"> 什么是 Hystrix之熔断和降级</h3>
<blockquote>
<p>在分布式环境中，不可避免地会有许多服务依赖项中的某些失败。Hystrix是一个库，可通过添加等待时间容限和容错逻辑来帮助您控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项来实现此目的，所有这些都可以提高系统的整体弹性。</p>
</blockquote>
<p>总体来说 <code>Hystrix</code> 就是一个能进行 <strong>熔断</strong> 和 <strong>降级</strong> 的库，通过使用它能提高整个系统的弹性。</p>
<p>那么什么是 熔断和降级 呢？再举个🌰，此时我们整个微服务系统是这样的。服务A调用了服务B，服务B再调用了服务C，但是因为某些原因，服务C顶不住了，这个时候大量请求会在服务C阻塞。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/Hystrix1.jpg" style="zoom:50%;" />
<p>服务C阻塞了还好，毕竟只是一个系统崩溃了。但是请注意这个时候因为服务C不能返回响应，那么服务B调用服务C的的请求就会阻塞，同理服务B阻塞了，那么服务A也会阻塞崩溃。</p>
<blockquote>
<p>请注意，为什么阻塞会崩溃。因为这些请求会消耗占用系统的线程、IO 等资源，消耗完你这个系统服务器不就崩了么。</p>
</blockquote>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/Hystrix2.jpg" style="zoom:50%;" />
<p>这就叫 <strong>服务雪崩</strong>。妈耶，上面两个 <strong>熔断</strong> 和 <strong>降级</strong> 你都没给我解释清楚，你现在又给我扯什么 <strong>服务雪崩</strong> ？😫😫😫</p>
<p>别急，听我慢慢道来。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/513d7e7f6d574fd799195d05556f4aa7-new-image9265b6bd-41ca-4e62-86f3-4341e5bdbe6c.png" alt="" /></p>
<p>不听我也得讲下去！</p>
<p>所谓 <strong>熔断</strong> 就是服务雪崩的一种有效解决方案。当指定时间窗内的请求失败率达到设定阈值时，系统将通过 <strong>断路器</strong> 直接将此请求链路断开。</p>
<p>也就是我们上面服务B调用服务C在指定时间窗内，调用的失败率到达了一定的值，那么 <code>Hystrix</code> 则会自动将 服务B与C 之间的请求都断了，以免导致服务雪崩现象。</p>
<p>其实这里所讲的 <strong>熔断</strong> 就是指的 <code>Hystrix</code> 中的 <strong>断路器模式</strong> ，你可以使用简单的 <code>@HystrixCommand</code> 注解来标注某个方法，这样 <code>Hystrix</code> 就会使用 <strong>断路器</strong> 来“包装”这个方法，每当调用时间超过指定时间时(默认为1000ms)，断路器将会中断对这个方法的调用。</p>
<p>当然你可以对这个注解的很多属性进行设置，比如设置超时时间，像这样。</p>
<div><pre><code><span>@HystrixCommand</span><span>(</span>
    commandProperties <span>=</span> <span>{</span><span>@HystrixProperty</span><span>(</span>name <span>=</span> <span>"execution.isolation.thread.timeoutInMilliseconds"</span><span>,</span>value <span>=</span> <span>"1200"</span><span>)</span><span>}</span>
<span>)</span>
<span>public</span> <span>List</span><span><span>&lt;</span><span>Xxx</span><span>></span></span> <span>getXxxx</span><span>(</span><span>)</span> <span>{</span>
    <span>// ...省略代码逻辑</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>但是，我查阅了一些博客，发现他们都将 <strong>熔断</strong> 和 <strong>降级</strong> 的概念混淆了，以我的理解，<strong>降级是为了更好的用户体验，当一个方法调用异常时，通过执行另一种代码逻辑来给用户友好的回复</strong>。这也就对应着 <code>Hystrix</code> 的 <strong>后备处理</strong> 模式。你可以通过设置 <code>fallbackMethod</code> 来给一个方法设置备用的代码逻辑。比如这个时候有一个热点新闻出现了，我们会推荐给用户查看详情，然后用户会通过id去查询新闻的详情，但是因为这条新闻太火了(比如最近什么*易对吧)，大量用户同时访问可能会导致系统崩溃，那么我们就进行 <strong>服务降级</strong> ，一些请求会做一些降级处理比如当前人数太多请稍后查看等等。</p>
<div><pre><code><span>// 指定了后备方法调用</span>
<span>@HystrixCommand</span><span>(</span>fallbackMethod <span>=</span> <span>"getHystrixNews"</span><span>)</span>
<span>@GetMapping</span><span>(</span><span>"/get/news"</span><span>)</span>
<span>public</span> <span>News</span> <span>getNews</span><span>(</span><span>@PathVariable</span><span>(</span><span>"id"</span><span>)</span> <span>int</span> id<span>)</span> <span>{</span>
    <span>// 调用新闻系统的获取新闻api 代码逻辑省略</span>
<span>}</span>
<span>// </span>
<span>public</span> <span>News</span> <span>getHystrixNews</span><span>(</span><span>@PathVariable</span><span>(</span><span>"id"</span><span>)</span> <span>int</span> id<span>)</span> <span>{</span>
    <span>// 做服务降级</span>
    <span>// 返回当前人数太多，请稍后查看</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="什么是hystrix之其他"> 什么是Hystrix之其他</h3>
<p>我在阅读 《Spring微服务实战》这本书的时候还接触到了一个 <strong>舱壁模式</strong> 的概念。在不使用舱壁模式的情况下，服务A调用服务B，这种调用默认的是 <strong>使用同一批线程来执行</strong> 的，而在一个服务出现性能问题的时候，就会出现所有线程被刷爆并等待处理工作，同时阻塞新请求，最终导致程序崩溃。而舱壁模式会将远程资源调用隔离在他们自己的线程池中，以便可以控制单个表现不佳的服务，而不会使该程序崩溃。</p>
<p>具体其原理我推荐大家自己去了解一下，本篇文章中对 <strong>舱壁模式</strong> 不做过多解释。当然还有 <strong><code>Hystrix</code> 仪表盘</strong>，它是<strong>用来实时监控 <code>Hystrix</code> 的各项指标信息的</strong>，这里我将这个问题也抛出去，希望有不了解的可以自己去搜索一下。</p>
<h2 id="微服务网关-zuul"> 微服务网关——Zuul</h2>
<blockquote>
<p>ZUUL 是从设备和 web 站点到 Netflix 流应用后端的所有请求的前门。作为边界服务应用，ZUUL 是为了实现动态路由、监视、弹性和安全性而构建的。它还具有根据情况将请求路由到多个 Amazon Auto Scaling Groups（亚马逊自动缩放组，亚马逊的一种云计算方式） 的能力</p>
</blockquote>
<p>在上面我们学习了 <code>Eureka</code> 之后我们知道了 <em>服务提供者</em>  是 <em>消费者</em> 通过 <code>Eureka Server</code> 进行访问的，即 <code>Eureka Server</code> 是 <em>服务提供者</em> 的统一入口。那么整个应用中存在那么多 <em>消费者</em> 需要用户进行调用，这个时候用户该怎样访问这些 <em>消费者工程</em> 呢？当然可以像之前那样直接访问这些工程。但这种方式没有统一的消费者工程调用入口，不便于访问与管理，而 Zuul 就是这样的一个对于 <em>消费者</em> 的统一入口。</p>
<blockquote>
<p>如果学过前端的肯定都知道 Router 吧，比如 Flutter 中的路由，Vue，React中的路由，用了 Zuul 你会发现在路由功能方面和前端配置路由基本是一个理。😄 我偶尔撸撸 Flutter。</p>
</blockquote>
<p>大家对网关应该很熟吧，简单来讲网关是系统唯一对外的入口，介于客户端与服务器端之间，用于对请求进行<strong>鉴权</strong>、<strong>限流</strong>、 <strong>路由</strong>、<strong>监控</strong>等功能。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zuul-sj22o93nfdsjkdsf.jpg" style="zoom:50%;" />
<p>没错，网关有的功能，<code>Zuul</code> 基本都有。而 <code>Zuul</code> 中最关键的就是 <strong>路由和过滤器</strong> 了，在官方文档中 <code>Zuul</code> 的标题就是</p>
<blockquote>
<p>Router and Filter : Zuul</p>
</blockquote>
<h3 id="zuul-的路由功能"> Zuul 的路由功能</h3>
<h4 id="简单配置"> 简单配置</h4>
<p>本来想给你们复制一些代码，但是想了想，因为各个代码配置比较零散，看起来也比较零散，我决定还是给你们画个图来解释吧。</p>
<blockquote>
<p>请不要因为我这么好就给我点赞 👍 。 疯狂暗示。</p>
</blockquote>
<p>比如这个时候我们已经向 <code>Eureka Server</code> 注册了两个 <code>Consumer</code> 、三个 <code>Provicer</code> ，这个时候我们再加个 <code>Zuul</code> 网关应该变成这样子了。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zuul-sj22o93nfdsjkdsf2312.jpg" style="zoom:50%;" />
<p>emmm，信息量有点大，我来解释一下。关于前面的知识我就不解释了😐。</p>
<p>首先，<code>Zuul</code> 需要向 <code>Eureka</code> 进行注册，注册有啥好处呢？</p>
<p>你傻呀，<code>Consumer</code> 都向 <code>Eureka Server</code> 进行注册了，我网关是不是只要注册就能拿到所有 <code>Consumer</code> 的信息了？</p>
<p>拿到信息有什么好处呢？</p>
<p>我拿到信息我是不是可以获取所有的 <code>Consumer</code> 的元数据(名称，ip，端口)？</p>
<p>拿到这些元数据有什么好处呢？拿到了我们是不是直接可以做<strong>路由映射</strong>？比如原来用户调用 <code>Consumer1</code> 的接口 <code>localhost:8001/studentInfo/update</code> 这个请求，我们是不是可以这样进行调用了呢？<code>localhost:9000/consumer1/studentInfo/update</code> 呢？你这样是不是恍然大悟了？</p>
<blockquote>
<p>这里的url为了让更多人看懂所以没有使用 restful 风格。</p>
</blockquote>
<p>上面的你理解了，那么就能理解关于 <code>Zuul</code> 最基本的配置了，看下面。</p>
<div><pre><code><span>server</span><span>:</span>
  <span>port</span><span>:</span> <span>9000</span>
<span>eureka</span><span>:</span>
  <span>client</span><span>:</span>
    <span>service-url</span><span>:</span>
      <span># 这里只要注册 Eureka 就行了</span>
      <span>defaultZone</span><span>:</span> http<span>:</span>//localhost<span>:</span>9997/eureka
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>然后在启动类上加入 <code>@EnableZuulProxy</code> 注解就行了。没错，就是那么简单😃。</p>
<h4 id="统一前缀"> 统一前缀</h4>
<p>这个很简单，就是我们可以在前面加一个统一的前缀，比如我们刚刚调用的是 <code>localhost:9000/consumer1/studentInfo/update</code>，这个时候我们在 <code>yaml</code> 配置文件中添加如下。</p>
<div><pre><code><span>zuul</span><span>:</span>
  <span>prefix</span><span>:</span> /zuul
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这样我们就需要通过 <code>localhost:9000/zuul/consumer1/studentInfo/update</code> 来进行访问了。</p>
<h4 id="路由策略配置"> 路由策略配置</h4>
<p>你会发现前面的访问方式(直接使用服务名)，需要将微服务名称暴露给用户，会存在安全性问题。所以，可以自定义路径来替代微服务名称，即自定义路由策略。</p>
<div><pre><code><span>zuul</span><span>:</span>
  <span>routes</span><span>:</span>
    <span>consumer1</span><span>:</span> /FrancisQ1/<span>**</span>
    <span>consumer2</span><span>:</span> /FrancisQ2/<span>**</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个时候你就可以使用 <code></code>localhost:9000/zuul/FrancisQ1/studentInfo/update` 进行访问了。</p>
<h4 id="服务名屏蔽"> 服务名屏蔽</h4>
<p>这个时候你别以为你好了，你可以试试，在你配置完路由策略之后使用微服务名称还是可以访问的，这个时候你需要将服务名屏蔽。</p>
<div><pre><code><span>zuul</span><span>:</span>
  <span>ignore-services</span><span>:</span> <span>"*"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="路径屏蔽"> 路径屏蔽</h4>
<p><code>Zuul</code> 还可以指定屏蔽掉的路径 URI，即只要用户请求中包含指定的 URI 路径，那么该请求将无法访问到指定的服务。通过该方式可以限制用户的权限。</p>
<div><pre><code><span>zuul</span><span>:</span>
  <span>ignore-patterns</span><span>:</span> <span>**/auto/**</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这样关于 auto 的请求我们就可以过滤掉了。</p>
<blockquote>
<p>** 代表匹配多级任意路径</p>
<p>*代表匹配一级任意路径</p>
</blockquote>
<h4 id="敏感请求头屏蔽"> 敏感请求头屏蔽</h4>
<p>默认情况下，像 <code>Cookie</code>、<code>Set-Cookie</code> 等敏感请求头信息会被 <code>zuul</code> 屏蔽掉，我们可以将这些默认屏蔽去掉，当然，也可以添加要屏蔽的请求头。</p>
<h3 id="zuul-的过滤功能"> Zuul 的过滤功能</h3>
<p>如果说，路由功能是 <code>Zuul</code> 的基操的话，那么<strong>过滤器</strong>就是 <code>Zuul</code>的利器了。毕竟所有请求都经过网关(Zuul)，那么我们可以进行各种过滤，这样我们就能实现 <strong>限流</strong>，<strong>灰度发布</strong>，<strong>权限控制</strong> 等等。</p>
<h4 id="简单实现一个请求时间日志打印"> 简单实现一个请求时间日志打印</h4>
<p>要实现自己定义的 <code>Filter</code> 我们只需要继承 <code>ZuulFilter</code> 然后将这个过滤器类以 <code>@Component</code> 注解加入 Spring 容器中就行了。</p>
<p>在给你们看代码之前我先给你们解释一下关于过滤器的一些注意点。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zuul-sj22o93nfdsjkdsf2312244.jpg" style="zoom:50%;" />
<p>过滤器类型：<code>Pre</code>、<code>Routing</code>、<code>Post</code>。前置<code>Pre</code>就是在请求之前进行过滤，<code>Routing</code>路由过滤器就是我们上面所讲的路由策略，而<code>Post</code>后置过滤器就是在 <code>Response</code> 之前进行过滤的过滤器。你可以观察上图结合着理解，并且下面我会给出相应的注释。</p>
<div><pre><code><span>// 加入Spring容器</span>
<span>@Component</span>
<span>public</span> <span>class</span> <span>PreRequestFilter</span> <span>extends</span> <span>ZuulFilter</span> <span>{</span>
    <span>// 返回过滤器类型 这里是前置过滤器</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>filterType</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>FilterConstants</span><span>.</span>PRE_TYPE<span>;</span>
    <span>}</span>
    <span>// 指定过滤顺序 越小越先执行，这里第一个执行</span>
    <span>// 当然不是只真正第一个 在Zuul内置中有其他过滤器会先执行</span>
    <span>// 那是写死的 比如 SERVLET_DETECTION_FILTER_ORDER = -3</span>
    <span>@Override</span>
    <span>public</span> <span>int</span> <span>filterOrder</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>// 什么时候该进行过滤</span>
    <span>// 这里我们可以进行一些判断，这样我们就可以过滤掉一些不符合规定的请求等等</span>
    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>shouldFilter</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>// 如果过滤器允许通过则怎么进行处理</span>
    <span>@Override</span>
    <span>public</span> <span>Object</span> <span>run</span><span>(</span><span>)</span> <span>throws</span> <span>ZuulException</span> <span>{</span>
        <span>// 这里我设置了全局的RequestContext并记录了请求开始时间</span>
        <span>RequestContext</span> ctx <span>=</span> <span>RequestContext</span><span>.</span><span>getCurrentContext</span><span>(</span><span>)</span><span>;</span>
        ctx<span>.</span><span>set</span><span>(</span><span>"startTime"</span><span>,</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code><span>// lombok的日志</span>
<span>@Slf4j</span>
<span>// 加入 Spring 容器</span>
<span>@Component</span>
<span>public</span> <span>class</span> <span>AccessLogFilter</span> <span>extends</span> <span>ZuulFilter</span> <span>{</span>
    <span>// 指定该过滤器的过滤类型</span>
    <span>// 此时是后置过滤器</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>filterType</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>FilterConstants</span><span>.</span>POST_TYPE<span>;</span>
    <span>}</span>
    <span>// SEND_RESPONSE_FILTER_ORDER 是最后一个过滤器</span>
    <span>// 我们此过滤器在它之前执行</span>
    <span>@Override</span>
    <span>public</span> <span>int</span> <span>filterOrder</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>FilterConstants</span><span>.</span>SEND_RESPONSE_FILTER_ORDER <span>-</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>shouldFilter</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>// 过滤时执行的策略</span>
    <span>@Override</span>
    <span>public</span> <span>Object</span> <span>run</span><span>(</span><span>)</span> <span>throws</span> <span>ZuulException</span> <span>{</span>
        <span>RequestContext</span> context <span>=</span> <span>RequestContext</span><span>.</span><span>getCurrentContext</span><span>(</span><span>)</span><span>;</span>
        <span>HttpServletRequest</span> request <span>=</span> context<span>.</span><span>getRequest</span><span>(</span><span>)</span><span>;</span>
        <span>// 从RequestContext获取原先的开始时间 并通过它计算整个时间间隔</span>
        <span>Long</span> startTime <span>=</span> <span>(</span><span>Long</span><span>)</span> context<span>.</span><span>get</span><span>(</span><span>"startTime"</span><span>)</span><span>;</span>
        <span>// 这里我可以获取HttpServletRequest来获取URI并且打印出来</span>
        <span>String</span> uri <span>=</span> request<span>.</span><span>getRequestURI</span><span>(</span><span>)</span><span>;</span>
        <span>long</span> duration <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span> <span>-</span> startTime<span>;</span>
        log<span>.</span><span>info</span><span>(</span><span>"uri: "</span> <span>+</span> uri <span>+</span> <span>", duration: "</span> <span>+</span> duration <span>/</span> <span>100</span> <span>+</span> <span>"ms"</span><span>)</span><span>;</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>上面就简单实现了请求时间日志打印功能，你有没有感受到 <code>Zuul</code> 过滤功能的强大了呢？</p>
<p>没有？好的、那我们再来。</p>
<h4 id="令牌桶限流"> 令牌桶限流</h4>
<p>当然不仅仅是令牌桶限流方式，<code>Zuul</code> 只要是限流的活它都能干，这里我只是简单举个🌰。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zuui-令牌桶限流.jpg" alt="令牌桶限流" style="zoom:50%;" />
<p>我先来解释一下什么是 <strong>令牌桶限流</strong> 吧。</p>
<p>首先我们会有个桶，如果里面没有满那么就会以一定 <strong>固定的速率</strong> 会往里面放令牌，一个请求过来首先要从桶中获取令牌，如果没有获取到，那么这个请求就拒绝，如果获取到那么就放行。很简单吧，啊哈哈、</p>
<p>下面我们就通过 <code>Zuul</code> 的前置过滤器来实现一下令牌桶限流。</p>
<div><pre><code><span>package</span> <span>com<span>.</span>lgq<span>.</span>zuul<span>.</span>filter</span><span>;</span>

<span>import</span> <span>com<span>.</span>google<span>.</span>common<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>RateLimiter</span><span>;</span>
<span>import</span> <span>com<span>.</span>netflix<span>.</span>zuul<span>.</span></span><span>ZuulFilter</span><span>;</span>
<span>import</span> <span>com<span>.</span>netflix<span>.</span>zuul<span>.</span>context<span>.</span></span><span>RequestContext</span><span>;</span>
<span>import</span> <span>com<span>.</span>netflix<span>.</span>zuul<span>.</span>exception<span>.</span></span><span>ZuulException</span><span>;</span>
<span>import</span> <span>lombok<span>.</span>extern<span>.</span>slf4j<span>.</span></span><span>Slf4j</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>cloud<span>.</span>netflix<span>.</span>zuul<span>.</span>filters<span>.</span>support<span>.</span></span><span>FilterConstants</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>stereotype<span>.</span></span><span>Component</span><span>;</span>

<span>@Component</span>
<span>@Slf4j</span>
<span>public</span> <span>class</span> <span>RouteFilter</span> <span>extends</span> <span>ZuulFilter</span> <span>{</span>
    <span>// 定义一个令牌桶，每秒产生2个令牌，即每秒最多处理2个请求</span>
    <span>private</span> <span>static</span> <span>final</span> <span>RateLimiter</span> RATE_LIMITER <span>=</span> <span>RateLimiter</span><span>.</span><span>create</span><span>(</span><span>2</span><span>)</span><span>;</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>filterType</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>FilterConstants</span><span>.</span>PRE_TYPE<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>filterOrder</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>-</span><span>5</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>Object</span> <span>run</span><span>(</span><span>)</span> <span>throws</span> <span>ZuulException</span> <span>{</span>
        log<span>.</span><span>info</span><span>(</span><span>"放行"</span><span>)</span><span>;</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>shouldFilter</span><span>(</span><span>)</span> <span>{</span>
        <span>RequestContext</span> context <span>=</span> <span>RequestContext</span><span>.</span><span>getCurrentContext</span><span>(</span><span>)</span><span>;</span>
        <span>if</span><span>(</span><span>!</span>RATE_LIMITER<span>.</span><span>tryAcquire</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            log<span>.</span><span>warn</span><span>(</span><span>"访问量超载"</span><span>)</span><span>;</span>
            <span>// 指定当前请求未通过过滤</span>
            context<span>.</span><span>setSendZuulResponse</span><span>(</span><span>false</span><span>)</span><span>;</span>
            <span>// 向客户端返回响应码429，请求数量过多</span>
            context<span>.</span><span>setResponseStatusCode</span><span>(</span><span>429</span><span>)</span><span>;</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>这样我们就能将请求数量控制在一秒两个，有没有觉得很酷？</p>
<h3 id="关于-zuul-的其他"> 关于 Zuul  的其他</h3>
<p><code>Zuul</code> 的过滤器的功能肯定不止上面我所实现的两种，它还可以实现 <strong>权限校验</strong>，包括我上面提到的 <strong>灰度发布</strong> 等等。</p>
<p>当然，<code>Zuul</code> 作为网关肯定也存在 <strong>单点问题</strong> ，如果我们要保证 <code>Zuul</code> 的高可用，我们就需要进行 <code>Zuul</code> 的集群配置，这个时候可以借助额外的一些负载均衡器比如 <code>Nginx</code> 。</p>
<p>##Spring Cloud配置管理——Config</p>
<h3 id="为什么要使用进行配置管理"> 为什么要使用进行配置管理？</h3>
<p>当我们的微服务系统开始慢慢地庞大起来，那么多 <code>Consumer</code> 、<code>Provider</code> 、<code>Eureka Server</code> 、<code>Zuul</code> 系统都会持有自己的配置，这个时候我们在项目运行的时候可能需要更改某些应用的配置，如果我们不进行配置的统一管理，我们只能<strong>去每个应用下一个一个寻找配置文件然后修改配置文件再重启应用</strong>。</p>
<p>首先对于分布式系统而言我们就不应该去每个应用下去分别修改配置文件，再者对于重启应用来说，服务无法访问所以直接抛弃了可用性，这是我们更不愿见到的。</p>
<p>那么有没有一种方法<strong>既能对配置文件统一地进行管理，又能在项目运行时动态修改配置文件呢？</strong></p>
<p>那就是我今天所要介绍的 <code>Spring Cloud Config</code> 。</p>
<blockquote>
<p>能进行配置管理的框架不止 <code>Spring Cloud Config</code> 一种，大家可以根据需求自己选择（<code>disconf</code>，阿波罗等等）。而且对于 <code>Config</code> 来说有些地方实现的不是那么尽人意。</p>
</blockquote>
<h3 id="config-是什么"> Config 是什么</h3>
<blockquote>
<p><code>Spring Cloud Config</code> 为分布式系统中的外部化配置提供服务器和客户端支持。使用 <code>Config</code> 服务器，可以在中心位置管理所有环境中应用程序的外部属性。</p>
</blockquote>
<p>简单来说，<code>Spring Cloud Config</code> 就是能将各个 应用/系统/模块 的配置文件存放到 <strong>统一的地方然后进行管理</strong>(Git 或者 SVN)。</p>
<p>你想一下，我们的应用是不是只有启动的时候才会进行配置文件的加载，那么我们的 <code>Spring Cloud Config</code> 就暴露出一个接口给启动应用来获取它所想要的配置文件，应用获取到配置文件然后再进行它的初始化工作。就如下图。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/config-ksksks.jpg" style="zoom:50%;" />
<p>当然这里你肯定还会有一个疑问，如果我在应用运行时去更改远程配置仓库(Git)中的对应配置文件，那么依赖于这个配置文件的已启动的应用会不会进行其相应配置的更改呢？</p>
<p>答案是不会的。</p>
<p>什么？那怎么进行动态修改配置文件呢？这不是出现了 <strong>配置漂移</strong> 吗？你个渣男😡，你又骗我！</p>
<p>别急嘛，你可以使用 <code>Webhooks</code> ，这是  <code>github</code> 提供的功能，它能确保远程库的配置文件更新后客户端中的配置信息也得到更新。</p>
<p>噢噢，这还差不多。我去查查怎么用。</p>
<p>慢着，听我说完，<code>Webhooks</code> 虽然能解决，但是你了解一下会发现它根本不适合用于生产环境，所以基本不会使用它的。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/1ada747175704ecba3507074847002d0-new-imagee5249fee-c5ee-4472-9983-f1bd5801387c.png" alt="" /></p>
<p>而一般我们会使用 <code>Bus</code> 消息总线 + <code>Spring Cloud Config</code> 进行配置的动态刷新。</p>
<h2 id="引出-spring-cloud-bus"> 引出 Spring Cloud Bus</h2>
<blockquote>
<p>用于将服务和服务实例与分布式消息系统链接在一起的事件总线。在集群中传播状态更改很有用（例如配置更改事件）。</p>
</blockquote>
<p>你可以简单理解为 <code>Spring Cloud Bus</code> 的作用就是<strong>管理和广播分布式系统中的消息</strong>，也就是消息引擎系统中的广播模式。当然作为 <strong>消息总线</strong> 的 <code>Spring Cloud Bus</code> 可以做很多事而不仅仅是客户端的配置刷新功能。</p>
<p>而拥有了 <code>Spring Cloud Bus</code> 之后，我们只需要创建一个简单的请求，并且加上 <code>@ResfreshScope</code> 注解就能进行配置的动态修改了，下面我画了张图供你理解。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/springcloud-bus-s213dsfsd.jpg" style="zoom:50%;" />
<h2 id="总结"> 总结</h2>
<p>这篇文章中我带大家初步了解了 <code>Spring Cloud</code> 的各个组件，他们有</p>
<ul>
<li><code>Eureka</code> 服务发现框架</li>
<li><code>Ribbon</code> 进程内负载均衡器</li>
<li><code>Open Feign</code> 服务调用映射</li>
<li><code>Hystrix</code> 服务降级熔断器</li>
<li><code>Zuul</code> 微服务网关</li>
<li><code>Config</code> 微服务统一配置中心</li>
<li><code>Bus</code> 消息总线</li>
</ul>
<p>如果你能这个时候能看懂文首那张图，也就说明了你已经对 <code>Spring Cloud</code> 微服务有了一定的架构认识。</p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/spring-cloud总体架构.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>数据脱敏</title>
      <link>https://javaguide.cn/system-design/security/%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/</link>
      <guid>https://javaguide.cn/system-design/security/%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/</guid>
      <source url="https://javaguide.cn/rss.xml">数据脱敏</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="数据脱敏"> 数据脱敏</h1>
<p>数据脱敏说的就是我们根据特定的规则对敏感信息数据进行变形，比如我们把手机号、身份证号某些位数使用 * 来代替。</p>
]]></content:encoded>
    </item>
    <item>
      <title>CHINER:干掉 PowerDesigner，这个国产数据库建模工具很强！</title>
      <link>https://javaguide.cn/tools/database/chiner/</link>
      <guid>https://javaguide.cn/tools/database/chiner/</guid>
      <source url="https://javaguide.cn/rss.xml">CHINER:干掉 PowerDesigner，这个国产数据库建模工具很强！</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>大家好，我是 Guide！</p>
<p>今天给小伙伴们分享一个我平时经常使用的国产数据库建模工具，非常好用！</p>
<p>这个数据库建模工具的名字叫做 <strong>CHINER</strong> [kaɪˈnər] 。可能大部分小伙伴都没有听过这个工具，不过，相信大部分小伙伴应该都听说过 CHINER 的前身 <strong>PDMan</strong>。</p>
<p>CHINER 是 CHINESE Entity Relation 的缩写，翻译过来就是国产实体关系图工具，中文名称为：<strong>元数建模</strong>，也作:&quot;<strong>CHINER[元数建模]</strong>&quot;公开使用。</p>
<p>CHINER 对 PDMan 的架构设计进行了大幅改善，并对 PDMan 做到高度兼容。</p>
<p>CHINER 的界面简单，功能简洁，非常容易上手。并且，可以直接导入 PowerDesigner 文件、PDMan 文件，还可以直接从数据库或者 DDL 语句直接导入。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/c877cb96e03e4de8920dd22a79d6fba1.png" alt="" /></p>
<p>CHINER 的技术栈：React+Electron+Java 。</p>
<ul>
<li>Gitee 地址：https://gitee.com/robergroup/chiner 。</li>
<li>操作手册： https://www.yuque.com/chiner/docs/manual 。</li>
</ul>
<h2 id="快速体验"> 快速体验</h2>
<h3 id="下载安装"> 下载安装</h3>
<p>CHINER 提供了 <strong>Windows</strong> 、<strong>Mac</strong> 、<strong>Linux</strong> 下的一键安装包，我们直接下载即可。</p>
<blockquote>
<p>下载地址：https://gitee.com/robergroup/chiner/releases</p>
</blockquote>
<p>需要注意的是：如果你当前使用的 Chrome 浏览器的话，无法直接点击链接下载。你可以更换浏览器下载或者右键链接选择链接存储为...。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/de3f014d52254bc3b181bd601fada431.png" alt="" /></p>
<p>打开软件之后，界面如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211016084319216.png" alt="" /></p>
<p>我这里以电商项目参考模板来演示 CHINER 的基本操作。</p>
<h3 id="模块化管理"> 模块化管理</h3>
<p>电商项目比较复杂，我们可以将其拆分为一个一个独立的模块（表分组），每个模块下有数据表，视图，关系图，数据字典。</p>
<p>像这个电商项目就创建了 3 个模块：消费端、商家端、平台端。</p>
<p><img src="https://img-blog.csdnimg.cn/c23a46c0a32442e38962c1ec63a59ecc.png" alt="" /></p>
<p>不过，对于一些比较简单的项目比如博客系统、企业管理系统直接使用简单模式即可。</p>
<h3 id="数据库表管理"> 数据库表管理</h3>
<p>右键数据表即可创建新的数据库表，点击指定的数据库表即可对指定的数据库表进行设计。</p>
<p><img src="https://img-blog.csdnimg.cn/d106ad816e7f429b95a1050c8a8ee734.png" alt="" /></p>
<p>并且，数据表字段可以直接关联数据字典。</p>
<p><img src="https://img-blog.csdnimg.cn/7dc3085aeded4cac8da6d22ee596101a.png" alt="" /></p>
<p>如果需要创建视图的话，直接右键视图即可。视图是从一个或多个表导出的虚拟的表，其内容由查询定义。具有普通表的结构，但是不实现数据存储。</p>
<p><img src="https://img-blog.csdnimg.cn/6983993063e743ef93a0ad13f39edb4a.png" alt="" /></p>
<p>数据库视图可以方便我们进行查询。不过，数据库视图会影响数据库性能，通常不建议使用。</p>
<h3 id="关系图"> 关系图</h3>
<p>我平时在项目中比较常见的 <strong>ER 关联关系图</strong> ，可以使用 CHINER 进行手动维护。</p>
<p>如果你需要添加新的数据库表到关系图的话，直接拖拽指定的数据库表到右边的关系图展示界面即可。另外，表与表之间的关联也需要你手动对相关联的字段进行连接。</p>
<p><img src="https://img-blog.csdnimg.cn/7f7d0ae74e3f42068c9f084d1ff39af1.png" alt="" /></p>
<p>手动进行维护，说实话还是比较麻烦的，也比较容易出错。</p>
<p>像 <a href="https://www.navicat.com.cn/products/navicat-data-modeler" target="_blank" rel="noopener noreferrer">Navicat Data Modeler</a> 在这方面就强多了，它可以自动生成 ER 图。</p>
<p><img src="https://img-blog.csdnimg.cn/08740807c2d746a3ab44d939b79d4d8f.png" alt="" /></p>
<h3 id="数据库表代码模板"> 数据库表代码模板</h3>
<p>支持直接生成对应表的 SQL 代码（支持 MySQL、Oracle、SQL Server、PostgreSQL 等数据库）并且还提供了 Java 和 C# 的 JavaBean。</p>
<p><img src="https://img-blog.csdnimg.cn/ab758108b5e540f0bcff0a09f0513636.png" alt="" /></p>
<h3 id="导出数据库表"> 导出数据库表</h3>
<p>你可以选择导出 DDL、Word 文档、数据字典 SQL、当前关系图的图片。</p>
<p><img src="https://img-blog.csdnimg.cn/1497089d38a7416db1fd6da7c01b41ea.png" alt="" /></p>
<h3 id="数据库逆向"> 数据库逆向</h3>
<p>你还可以连接数据库，逆向解析数据库。</p>
<p><img src="https://img-blog.csdnimg.cn/e93ee1d31f0f4cf894e330eee1420b89.png" alt="" /></p>
<p>数据库连接成功之后，我们点击右上角的菜单 <code>导入—&gt; 从数据库导入</code> 即可。</p>
<p><img src="https://img-blog.csdnimg.cn/377f8aef4f4e4b17afda532362bdbeae.png" alt="" /></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/c877cb96e03e4de8920dd22a79d6fba1.png" type="image/png"/>
    </item>
    <item>
      <title>Java定时任务大揭秘</title>
      <link>https://javaguide.cn/system-design/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link>
      <guid>https://javaguide.cn/system-design/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid>
      <source url="https://javaguide.cn/rss.xml">Java定时任务大揭秘</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="java定时任务大揭秘"> Java定时任务大揭秘</h1>
<h2 id="为什么需要定时任务"> 为什么需要定时任务？</h2>
<p>我们来看一下几个非常常见的业务场景：</p>
<ol>
<li>某系统凌晨要进行数据备份。</li>
<li>某电商平台，用户下单半个小时未支付的情况下需要自动取消订单。</li>
<li>某媒体聚合平台，每 10 分钟动态抓取某某网站的数据为自己所用。</li>
<li>某博客平台，支持定时发送文章。</li>
<li>某基金平台，每晚定时计算用户当日收益情况并推送给用户最新的数据。</li>
<li>......</li>
</ol>
<p>这些场景往往都要求我们在某个特定的时间去做某个事情。</p>
<h2 id="单机定时任务技术选型"> 单机定时任务技术选型</h2>
<h3 id="timer"> Timer</h3>
<p><code>java.util.Timer</code>是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。</p>
<p><code>Timer</code> 内部使用一个叫做 <code>TaskQueue</code> 的类存放定时任务，它是一个基于最小堆实现的优先级队列。<code>TaskQueue</code> 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可！</p>
<p><code>Timer</code> 使用起来比较简单，通过下面的方式我们就能创建一个 1s 之后执行的定时任务。</p>
<div><pre><code><span>// 示例代码：</span>
<span>TimerTask</span> task <span>=</span> <span>new</span> <span>TimerTask</span><span>(</span><span>)</span> <span>{</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"当前时间: "</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span> <span>+</span> <span>"n"</span> <span>+</span>
                <span>"线程名称: "</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"当前时间: "</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span> <span>+</span> <span>"n"</span> <span>+</span>
        <span>"线程名称: "</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>Timer</span> timer <span>=</span> <span>new</span> <span>Timer</span><span>(</span><span>"Timer"</span><span>)</span><span>;</span>
<span>long</span> delay <span>=</span> <span>1000L</span><span>;</span>
timer<span>.</span><span>schedule</span><span>(</span>task<span>,</span> delay<span>)</span><span>;</span>


<span>//输出：</span>
当前时间<span>:</span> <span>Fri</span> <span>May</span> <span>28</span> <span>15</span><span>:</span><span>18</span><span>:</span><span>47</span> CST <span>2021</span>n线程名称<span>:</span> main
当前时间<span>:</span> <span>Fri</span> <span>May</span> <span>28</span> <span>15</span><span>:</span><span>18</span><span>:</span><span>48</span> CST <span>2021</span>n线程名称<span>:</span> <span>Timer</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>不过其缺陷较多，比如一个 <code>Timer</code> 一个线程，这就导致 <code>Timer</code> 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（<code>Timer</code> 只捕获了 <code>InterruptedException</code> ）。</p>
<p><code>Timer</code> 类上的有一段注释是这样写的：</p>
<div><pre><code> <span>*</span> <span>This</span> <span>class</span> does not offer real<span>-</span>time guarantees<span>:</span> it schedules
 <span>*</span> tasks using the <span><span>&lt;</span>tt<span>></span></span><span>Object</span><span>.</span><span>wait</span><span>(</span><span>long</span><span>)</span><span>&lt;</span><span>/</span>tt<span>></span> method<span>.</span>
 <span>*</span><span>Java</span> <span>5.0</span> introduced the <span>{</span><span>@code</span> java<span>.</span>util<span>.</span>concurrent<span>}</span> <span>package</span> <span>and</span>
 <span>*</span> one of the concurrency utilities therein is the <span>{</span><span>@link</span>
 <span>*</span> <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span>ScheduledThreadPoolExecutor</span>
 <span>*</span> <span>ScheduledThreadPoolExecutor</span><span>}</span> which is a thread pool <span>for</span> repeatedly
 <span>*</span> executing tasks at a given rate or <span><span>delay<span>.</span></span>  It</span> is effectively a more
 <span>*</span> versatile replacement <span>for</span> the <span>{</span><span>@code</span> <span>Timer</span><span>}</span><span>/</span><span>{</span><span>@code</span> <span>TimerTask</span><span>}</span>
 <span>*</span> combination<span>,</span> as it allows multiple service threads<span>,</span> accepts various
 <span>*</span> time units<span>,</span> and doesn't require subclassing <span>{</span><span>@code</span> <span>TimerTask</span><span>}</span> <span>(</span>just
 <span>*</span> implement <span>{</span><span>@code</span> <span>Runnable</span><span>}</span><span>)</span><span>.</span>  <span>Configuring</span> <span>{</span><span>@code</span>
 <span>*</span> <span>ScheduledThreadPoolExecutor</span><span>}</span> <span>with</span> <span>one</span> thread makes it equivalent <span>to</span>
 <span>*</span> <span>{</span><span>@code</span> <span>Timer</span><span>}</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>大概的意思就是： <code>ScheduledThreadPoolExecutor</code> 支持多线程执行定时任务并且功能更强大，是 <code>Timer</code> 的替代品。</p>
<h3 id="scheduledexecutorservice"> ScheduledExecutorService</h3>
<p><code>ScheduledExecutorService</code> 是一个接口，有多个实现类，比较常用的是 <code>ScheduledThreadPoolExecutor</code> 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/20210607154324712.png" alt="" /></p>
<p><code>ScheduledThreadPoolExecutor</code> 本身就是一个线程池，支持任务并发执行。并且，其内部使用 <code>DelayQueue</code> 作为任务队列。</p>
<div><pre><code><span>// 示例代码：</span>
<span>TimerTask</span> repeatedTask <span>=</span> <span>new</span> <span>TimerTask</span><span>(</span><span>)</span> <span>{</span>
    <span>@SneakyThrows</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"当前时间: "</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span> <span>+</span> <span>"n"</span> <span>+</span>
                <span>"线程名称: "</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"当前时间: "</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span> <span>+</span> <span>"n"</span> <span>+</span>
        <span>"线程名称: "</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>ScheduledExecutorService</span> executor <span>=</span> <span>Executors</span><span>.</span><span>newScheduledThreadPool</span><span>(</span><span>3</span><span>)</span><span>;</span>
<span>long</span> delay  <span>=</span> <span>1000L</span><span>;</span>
<span>long</span> period <span>=</span> <span>1000L</span><span>;</span>
executor<span>.</span><span>scheduleAtFixedRate</span><span>(</span>repeatedTask<span>,</span> delay<span>,</span> period<span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>)</span><span>;</span>
<span>Thread</span><span>.</span><span>sleep</span><span>(</span>delay <span>+</span> period <span>*</span> <span>5</span><span>)</span><span>;</span>
executor<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
<span>//输出：</span>
当前时间<span>:</span> <span>Fri</span> <span>May</span> <span>28</span> <span>15</span><span>:</span><span>40</span><span>:</span><span>46</span> CST <span>2021</span>n线程名称<span>:</span> main
当前时间<span>:</span> <span>Fri</span> <span>May</span> <span>28</span> <span>15</span><span>:</span><span>40</span><span>:</span><span>47</span> CST <span>2021</span>n线程名称<span>:</span> pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>1</span>
当前时间<span>:</span> <span>Fri</span> <span>May</span> <span>28</span> <span>15</span><span>:</span><span>40</span><span>:</span><span>48</span> CST <span>2021</span>n线程名称<span>:</span> pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>1</span>
当前时间<span>:</span> <span>Fri</span> <span>May</span> <span>28</span> <span>15</span><span>:</span><span>40</span><span>:</span><span>49</span> CST <span>2021</span>n线程名称<span>:</span> pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>2</span>
当前时间<span>:</span> <span>Fri</span> <span>May</span> <span>28</span> <span>15</span><span>:</span><span>40</span><span>:</span><span>50</span> CST <span>2021</span>n线程名称<span>:</span> pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>2</span>
当前时间<span>:</span> <span>Fri</span> <span>May</span> <span>28</span> <span>15</span><span>:</span><span>40</span><span>:</span><span>51</span> CST <span>2021</span>n线程名称<span>:</span> pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>2</span>
当前时间<span>:</span> <span>Fri</span> <span>May</span> <span>28</span> <span>15</span><span>:</span><span>40</span><span>:</span><span>52</span> CST <span>2021</span>n线程名称<span>:</span> pool<span>-</span><span>1</span><span>-</span>thread<span>-</span><span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>不论是使用 <code>Timer</code> 还是 <code>ScheduledExecutorService</code> 都无法使用 Cron 表达式指定任务执行的具体时间。</p>
<h3 id="spring-task"> Spring Task</h3>
<p><img src="https://img-blog.csdnimg.cn/20210528145056880.png" alt="" /></p>
<p>我们直接通过 Spring 提供的 <code>@Scheduled</code> 注解即可定义定时任务，非常方便！</p>
<div><pre><code><span>/**
 * cron：使用Cron表达式。　每分钟的1，2秒运行
 */</span>
<span>@Scheduled</span><span>(</span>cron <span>=</span> <span>"1-2 * * * * ? "</span><span>)</span>
<span>public</span> <span>void</span> <span>reportCurrentTimeWithCronExpression</span><span>(</span><span>)</span> <span>{</span>
  log<span>.</span><span>info</span><span>(</span><span>"Cron Expression: The time is now {}"</span><span>,</span> dateFormat<span>.</span><span>format</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>我在大学那会做的一个 SSM 的企业级项目，就是用的 Spring Task 来做的定时任务。</p>
<p>并且，Spring Task 还是支持 <strong>Cron 表达式</strong> 的。Cron 表达式主要用于定时作业(定时任务)系统定义执行时间或执行频率的表达式，非常厉害，你可以通过 Cron 表达式进行设置定时任务每天或者每个月什么时候执行等等操作。咱们要学习定时任务的话，Cron 表达式是一定是要重点关注的。推荐一个在线 Cron 表达式生成器：<a href="http://cron.qqe2.com/" target="_blank" rel="noopener noreferrer">http://cron.qqe2.com/</a> 。</p>
<p>但是，Spring 自带的定时调度只支持单机，并且提供的功能比较单一。之前写过一篇文章:<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485563&amp;idx=1&amp;sn=7419341f04036a10b141b74624a3f8c9&amp;chksm=cea247b0f9d5cea6440759e6d49b4e77d06f4c99470243a10c1463834e873ca90266413fbc92&amp;token=2133161636&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">《5 分钟搞懂如何在 Spring Boot 中 Schedule Tasks》</a> ，不了解的小伙伴可以参考一下。</p>
<p>Spring Task 底层是基于 JDK 的 <code>ScheduledThreadPoolExecutor</code> 线程池来实现的。</p>
<p><strong>优缺点总结：</strong></p>
<ul>
<li>优点： 简单，轻量，支持 Cron 表达式</li>
<li>缺点 ：功能单一</li>
</ul>
<h3 id="时间轮"> 时间轮</h3>
<p>Kafka、Dubbo、ZooKeeper、Netty 、Caffeine 、Akka 中都有对时间轮的实现。</p>
<p>时间轮简单来说就是一个环形的队列（底层一般基于数组实现），队列中的每一个元素（时间格）都可以存放一个定时任务列表。</p>
<p>时间轮中的每个时间格代表了时间轮的基本时间跨度或者说时间精度，加入时间一秒走一个时间格的话，那么这个时间轮的最高精度就是 1 秒（也就是说 3 s 和 3.9s 会在同一个时间格中）。</p>
<p>下图是一个有 12 个时间格的时间轮，转完一圈需要 12 s。当我们需要新建一个 3s 后执行的定时任务，只需要将定时任务放在下标为 3 的时间格中即可。当我们需要新建一个 9s 后执行的定时任务，只需要将定时任务放在下标为 9 的时间格中即可。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/20210607171334861.png" alt="" /></p>
<p>那当我们需要创建一个 13s 后执行的定时任务怎么办呢？这个时候可以引入一叫做 <strong>圈数/轮数</strong> 的概念，也就是说这个任务还是放在下标为 3 的时间格中， 不过它的圈数为 2 。</p>
<p>除了增加圈数这种方法之外，还有一种 <strong>多层次时间轮</strong> （类似手表），Kafka 采用的就是这种方案。</p>
<p>针对下图的时间轮，我来举一个例子便于大家理解。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/20210607193042151.png" alt="" /></p>
<p>上图的时间轮，第 1 层的时间精度为 1 ，第 2 层的时间精度为 20 ，第 3 层的时间精度为 400。假如我们需要添加一个 350s 后执行的任务 A 的话（当前时间是 0s），这个任务会被放在第 2 层（因为第二层的时间跨度为 20*20=400&gt;350）的第 350/20=17 个时间格子。</p>
<p>当第一层转了 17 圈之后，时间过去了 340s ，第 2 层的指针此时来到第 17 个时间格子。此时，第 2 层第 17 个格子的任务会被移动到第 1 层。</p>
<p>任务 A 当前是 10s 之后执行，因此它会被移动到第 1 层的第 10 个时间格子。</p>
<p>这里在层与层之间的移动也叫做时间轮的升降级。参考手表来理解就好！</p>
<p><img src="https://img-blog.csdnimg.cn/20210607195206797.png" alt="" /></p>
<p><strong>时间轮比较适合任务数量比较多的定时任务场景，它的任务写入和执行的时间复杂度都是 0（1）。</strong></p>
<h2 id="分布式定时任务技术选型"> 分布式定时任务技术选型</h2>
<p>上面提到的一些定时任务的解决方案都是在单机下执行的，适用于比较简单的定时任务场景比如每天凌晨备份一次数据。</p>
<p>如果我们需要一些高级特性比如支持任务在分布式场景下的分片和高可用的话，我们就需要用到分布式任务调度框架了。</p>
<p>通常情况下，一个定时任务的执行往往涉及到下面这些角色：</p>
<ul>
<li><strong>任务</strong> ： 首先肯定是要执行的任务，这个任务就是具体的业务逻辑比如定时发送文章。</li>
<li><strong>调度器</strong> ：其次是调度中心，调度中心主要负责任务管理，会分配任务给执行器。</li>
<li><strong>执行器</strong> ： 最后就是执行器，执行器接收调度器分派的任务并执行。</li>
</ul>
<h3 id="quartz"> Quartz</h3>
<p><img src="https://img-blog.csdnimg.cn/2021052814502425.png" alt="" /></p>
<p>一个很火的开源任务调度框架，完全由<code>Java</code>写成。<code>Quartz</code> 可以说是 Java 定时任务领域的老大哥或者说参考标准，其他的任务调度框架基本都是基于 <code>Quartz</code> 开发的，比如当当网的<code>elastic-job</code>就是基于<code>quartz</code>二次开发之后的分布式调度解决方案。</p>
<p>使用 <code>Quartz</code> 可以很方便地与 <code>Spring</code> 集成，并且支持动态添加任务和集群。但是，<code>Quartz</code> 使用起来也比较麻烦，API 繁琐。</p>
<p>并且，<code>Quzrtz</code> 并没有内置 UI 管理控制台，不过你可以使用 <a href="https://github.com/zhaopeiym/quartzui" target="_blank" rel="noopener noreferrer">quartzui</a> 这个开源项目来解决这个问题。</p>
<p>另外，<code>Quartz</code> 虽然也支持分布式任务。但是，它是在数据库层面，通过数据库的锁机制做的，有非常多的弊端比如系统侵入性严重、节点负载不均衡。有点伪分布式的味道。</p>
<p><strong>优缺点总结：</strong></p>
<ul>
<li>优点： 可以与 <code>Spring</code> 集成，并且支持动态添加任务和集群。</li>
<li>缺点 ：分布式支持不友好，没有内置 UI 管理控制台、使用麻烦（相比于其他同类型框架来说）</li>
</ul>
<h3 id="elastic-job"> Elastic-Job</h3>
<p><img src="https://img-blog.csdnimg.cn/20210528144508114.png" alt="" /></p>
<p><code>Elastic-Job</code> 是当当网开源的一个基于<code>Quartz</code>和<code>ZooKeeper</code>的分布式调度解决方案，由两个相互独立的子项目 <code>Elastic-Job-Lite</code> 和 <code>Elastic-Job-Cloud</code> 组成，一般我们只要使用 <code>Elastic-Job-Lite</code> 就好。</p>
<p><code>ElasticJob</code> 支持任务在分布式场景下的分片和高可用、任务可视化管理等功能。</p>
<p><img src="https://img-blog.csdnimg.cn/20210608080437356.png" alt="" /></p>
<p>ElasticJob-Lite 的架构设计如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-a8f63f828666d43009d5d3497bcbd2cfb61.png" alt="" /></p>
<p>从上图可以看出，<code>Elastic-Job</code> 没有调度中心这一概念，而是使用 <code>ZooKeeper</code> 作为注册中心，注册中心负责协调分配任务到不同的节点上。</p>
<p>Elastic-Job 中的定时调度都是由执行器自行触发，这种设计也被称为去中心化设计（调度和处理都是执行器单独完成）。</p>
<div><pre><code><span>@Component</span>
<span>@ElasticJobConf</span><span>(</span>name <span>=</span> <span>"dayJob"</span><span>,</span> cron <span>=</span> <span>"0/10 * * * * ?"</span><span>,</span> shardingTotalCount <span>=</span> <span>2</span><span>,</span>
        shardingItemParameters <span>=</span> <span>"0=AAAA,1=BBBB"</span><span>,</span> description <span>=</span> <span>"简单任务"</span><span>,</span> failover <span>=</span> <span>true</span><span>)</span>
<span>public</span> <span>class</span> <span>TestJob</span> <span>implements</span> <span>SimpleJob</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>ShardingContext</span> shardingContext<span>)</span> <span>{</span>
        log<span>.</span><span>info</span><span>(</span><span>"TestJob任务名：【{}】, 片数：【{}】, param=【{}】"</span><span>,</span> shardingContext<span>.</span><span>getJobName</span><span>(</span><span>)</span><span>,</span> shardingContext<span>.</span><span>getShardingTotalCount</span><span>(</span><span>)</span><span>,</span>
                shardingContext<span>.</span><span>getShardingParameter</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>相关地址：</strong></p>
<ul>
<li>Github 地址：https://github.com/apache/shardingsphere-elasticjob。</li>
<li>官方网站：https://shardingsphere.apache.org/elasticjob/index_zh.html 。</li>
</ul>
<p><strong>优缺点总结：</strong></p>
<ul>
<li>优点 ：可以与 <code>Spring</code> 集成、支持分布式、支持集群、性能不错</li>
<li>缺点 ：依赖了额外的中间件比如 Zookeeper（复杂度增加，可靠性降低、维护成本变高）</li>
</ul>
<h3 id="xxl-job"> XXL-JOB</h3>
<p><img src="https://img-blog.csdnimg.cn/20210528144611728.png" alt="" /></p>
<p><code>XXL-JOB</code> 于 2015 年开源，是一款优秀的轻量级分布式任务调度框架，支持任务可视化管理、弹性扩容缩容、任务失败重试和告警、任务分片等功能，</p>
<p><img src="https://img-blog.csdnimg.cn/20210608080550433.png" alt="" /></p>
<p>根据 <code>XXL-JOB</code> 官网介绍，其解决了很多 <code>Quartz</code> 的不足。</p>
<p><img src="https://img-blog.csdnimg.cn/20210607202503193.png" alt="" /></p>
<p><code>XXL-JOB</code> 的架构设计如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b8ecc6acf651f112c4dfae98243d72adea3.png" alt="" /></p>
<p>从上图可以看出，<code>XXL-JOB</code> 由 <strong>调度中心</strong> 和 <strong>执行器</strong> 两大部分组成。调度中心主要负责任务管理、执行器管理以及日志管理。执行器主要是接收调度信号并处理。另外，调度中心进行任务调度时，是通过自研 RPC 来实现的。</p>
<p>不同于 <code>Elastic-Job</code> 的去中心化设计， <code>XXL-JOB</code> 的这种设计也被称为中心化设计（调度中心调度多个执行器执行任务）。</p>
<p>和 <code>Quzrtz</code> 类似 <code>XXL-JOB</code> 也是基于数据库锁调度任务，存在性能瓶颈。不过，一般在任务量不是特别大的情况下，没有什么影响的，可以满足绝大部分公司的要求。</p>
<p>不要被 <code>XXL-JOB</code> 的架构图给吓着了，实际上，我们要用 <code>XXL-JOB</code> 的话，只需要重写 <code>IJobHandler</code> 自定义任务执行逻辑就可以了，非常易用！</p>
<div><pre><code><span>@JobHandler</span><span>(</span>value<span>=</span><span>"myApiJobHandler"</span><span>)</span>
<span>@Component</span>
<span>public</span> <span>class</span> <span>MyApiJobHandler</span> <span>extends</span> <span>IJobHandler</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>ReturnT</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>execute</span><span>(</span><span>String</span> param<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>//......</span>
        <span>return</span> <span>ReturnT</span><span>.</span>SUCCESS<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>还可以直接基于注解定义任务。</p>
<div><pre><code><span>@XxlJob</span><span>(</span><span>"myAnnotationJobHandler"</span><span>)</span>
<span>public</span> <span>ReturnT</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>myAnnotationJobHandler</span><span>(</span><span>String</span> param<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
  <span>//......</span>
  <span>return</span> <span>ReturnT</span><span>.</span>SUCCESS<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src="https://img-blog.csdnimg.cn/20210607200728212.png" alt="" /></p>
<p><strong>相关地址：</strong></p>
<ul>
<li>Github 地址：https://github.com/xuxueli/xxl-job/。</li>
<li>官方介绍：https://www.xuxueli.com/xxl-job/ 。</li>
</ul>
<p><strong>优缺点总结：</strong></p>
<ul>
<li>优点：开箱即用（学习成本比较低）、与 Spring 集成、支持分布式、支持集群、内置了 UI 管理控制台。</li>
<li>缺点：不支持动态添加任务（如果一定想要动态创建任务也是支持的，参见：<a href="https://github.com/xuxueli/xxl-job/issues/277" target="_blank" rel="noopener noreferrer">xxl-job issue277</a>）。</li>
</ul>
<h3 id="powerjob"> PowerJob</h3>
<p><img src="https://img-blog.csdnimg.cn/20210528145009701.png" alt="" /></p>
<p>非常值得关注的一个分布式任务调度框架，分布式任务调度领域的新星。目前，已经有很多公司接入比如 OPPO、京东、中通、思科。</p>
<p>这个框架的诞生也挺有意思的，PowerJob 的作者当时在阿里巴巴实习过，阿里巴巴那会使用的是内部自研的 SchedulerX（阿里云付费产品）。实习期满之后，PowerJob 的作者离开了阿里巴巴。想着说自研一个 SchedulerX，防止哪天 SchedulerX 满足不了需求，于是 PowerJob 就诞生了。</p>
<p>更多关于 PowerJob 的故事，小伙伴们可以去看看 PowerJob 作者的视频 <a href="https://www.bilibili.com/video/BV1SK411A7F3/" target="_blank" rel="noopener noreferrer">《我和我的任务调度中间件》</a>。简单点概括就是：“游戏没啥意思了，我要扛起了新一代分布式任务调度与计算框架的大旗！”。</p>
<p>由于 SchedulerX 属于人民币产品，我这里就不过多介绍。PowerJob 官方也对比过其和 QuartZ、XXL-JOB 以及 SchedulerX。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-795f5e9b0d875063717b1ee6a08f2ff1c01.png" alt="" /></p>
<h2 id="总结"> 总结</h2>
<p>这篇文章中，我主要介绍了：</p>
<ul>
<li><strong>定时任务的相关概念</strong> ：为什么需要定时任务、定时任务中的核心角色、分布式定时任务。</li>
<li><strong>定时任务的技术选型</strong> ： XXL-JOB 2015 年推出，已经经过了很多年的考验。XXL-JOB 轻量级，并且使用起来非常简单。虽然存在性能瓶颈，但是，在绝大多数情况下，对于企业的基本需求来说是没有影响的。PowerJob 属于分布式任务调度领域里的新星，其稳定性还有待继续考察。ElasticJob 由于在架构设计上是基于 Zookeeper ，而 XXL-JOB 是基于数据库，性能方面的话，ElasticJob 略胜一筹。</li>
</ul>
<p>这篇文章并没有介绍到实际使用，但是，并不代表实际使用不重要。我在写这篇文章之前，已经动手写过相应的 Demo。像 Quartz，我在大学那会就用过。不过，当时用的是 Spring 。为了能够更好地体验，我自己又在 Spring Boot 上实际体验了一下。如果你并没有实际使用某个框架，就直接说它并不好用的话，是站不住脚的。</p>
<p>最后，这篇文章要感谢艿艿的帮助，写这篇文章的时候向艿艿询问过一些问题。推荐一篇艿艿写的偏实战类型的硬核文章：<a href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247490679&amp;idx=1&amp;sn=25374dbdcca95311d41be5d7b7db454d&amp;chksm=fa4963c6cd3eead055bb9cd10cca13224bb35d0f7373a27aa22a55495f71e24b8273a7603314&amp;scene=27#wechat_redirect" target="_blank" rel="noopener noreferrer">《Spring Job？Quartz？XXL-Job？年轻人才做选择，艿艿全莽~》</a> 。</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/20210607154324712.png" type="image/png"/>
    </item>
    <item>
      <title>DBeaver:开源数据库管理工具</title>
      <link>https://javaguide.cn/tools/database/dbeaver/</link>
      <guid>https://javaguide.cn/tools/database/dbeaver/</guid>
      <source url="https://javaguide.cn/rss.xml">DBeaver:开源数据库管理工具</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="dbeaver-开源数据库管理工具。"> DBeaver:开源数据库管理工具。</h1>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247489523&amp;idx=1&amp;sn=4e96972842bdcea2e05cb267d17c5e8e&amp;chksm=cea25838f9d5d12e45a9939370eccf2bff7177038e70437ea0e01d64030118852ee66ae72284&amp;token=2000865596&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">《再见，Navicat！同事安利的这个IDEA的兄弟，真香！》</a>    这篇文章发了之后很多人抱怨Datagrip 的占用内存太大，很多人推荐了  DBeaver 这款开源免费的数据库管理工具。于是，我昨夜简单体验了一下 DBeaver ，然后写了这篇文章。</p>
<h2 id="dbeaver-概览"> DBeaver 概览</h2>
<p>DBeaver 是一个基于 Java 开发 ，并且支持几乎所有的数据库产品的开源数据库管理工具。</p>
<p>DBeaver 社区版不光支持关系型数据库比如MySQL、PostgreSQL、MariaDB、SQLite、Oracle、Db2、SQL Server，还比如 SQLite、H2这些内嵌数据库。还支持常见的全文搜索引擎比如 Elasticsearch 和 Solr、大数据相关的工具比如Hive和 Spark。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/未命名拼图.jpg" alt="DBeaver 支持的数据库概览" /></p>
<p>甚至说，DBeaver 的商业版本还支持各种 NoSQL  数据库。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200803074546854.png" alt="DBeaver 的商业版本还支持各种 NoSQL  数据库" /></p>
<h2 id="使用"> 使用</h2>
<p><strong>DBeaver 虽然小巧，但是功能还是十分强大的。基本的表设计、SQL执行、ER图、数据导入导出等等常用功能都不在话下。</strong></p>
<p><strong>我下面只简单演示一下基本的数据库的创建以及表的创建。</strong></p>
<h3 id="下载安装"> 下载安装</h3>
<p>官方网提供的下载地址：https://dbeaver.io/download/ ，你可以根据自己的操作系统选择合适的版本进行下载安装。</p>
<p>比较简单，这里就不演示了。</p>
<h3 id="连接数据库"> 连接数据库</h3>
<p><strong>1.选择自己想要的连接的数据库，然后点击下一步即可（第一次连接可能需要下载相关驱动）。</strong></p>
<p>我这里以MySQL为例。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200803082419586.png" alt="image-20200803082419586" /></p>
<p><strong>2.输入数据库的地址、用户名和密码等信息，然后点击完成即可连接</strong></p>
<p>点击完成之前，你可以先通过左下方的测试连接来看一下数据库是否可以被成功连接上。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200803082107033.png" alt="" /></p>
<h3 id="新建数据库"> 新建数据库</h3>
<p>右键-&gt; 新建数据库（MySQL 用户记得使用 utf8mb4而不是 utf8）</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200812200954000.png" alt="" /></p>
<h3 id="数据库表相关操作"> 数据库表相关操作</h3>
<h4 id="新建表"> 新建表</h4>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200812201130467.png" alt="" /></p>
<h4 id="新建列"> 新建列</h4>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200812203427352.png" alt="" /></p>
<h4 id="创建约束-主键、唯一键"> 创建约束（主键、唯一键）</h4>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200812202618448.png" alt="" /></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200812204054048.png" alt="" /></p>
<h4 id="插入数据"> 插入数据</h4>
<p>我们通过 SQL 编辑器插入数据：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200812205208540.png" alt="" /></p>
<div><pre><code>INSERT into <span>user</span><span>(</span>id<span>,</span>name<span>,</span>phone<span>,</span>password<span>)</span> values <span>(</span><span>'A00001'</span><span>,</span><span>'guide哥'</span><span>,</span><span>'181631312315'</span><span>,</span><span>'123456'</span><span>)</span><span>;</span> 
INSERT into <span>user</span><span>(</span>id<span>,</span>name<span>,</span>phone<span>,</span>password<span>)</span> values <span>(</span><span>'A00002'</span><span>,</span><span>'guide哥2'</span><span>,</span><span>'181631312313'</span><span>,</span><span>'123456'</span><span>)</span><span>;</span>
INSERT into <span>user</span><span>(</span>id<span>,</span>name<span>,</span>phone<span>,</span>password<span>)</span> values <span>(</span><span>'A00003'</span><span>,</span><span>'guide哥3'</span><span>,</span><span>'181631312312'</span><span>,</span><span>'123456'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="总结"> 总结</h2>
<p>总的来说，简单体验之后感觉还是很不错的，占用内存也确实比 DataGrip 确实要小很多。</p>
<p>各位小伙伴可以自行体验一下。毕竟免费并且开源，还是很香的！</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%8B%BC%E5%9B%BE.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>DataGrip:IDEA官方的这个数据库管理神器真香！</title>
      <link>https://javaguide.cn/tools/database/datagrip/</link>
      <guid>https://javaguide.cn/tools/database/datagrip/</guid>
      <source url="https://javaguide.cn/rss.xml">DataGrip:IDEA官方的这个数据库管理神器真香！</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Atzuge | https://www.cnblogs.com/zuge/p/7397255.html</p>
</blockquote>
<p>DataGrip 是由 JetBrains 公司（就是那个出品 Intellij IDEA 的公司,JetBrains出品，必属精品）推出的数据库管理软件。如果你不爱折腾的话，这家公司出品的很多 IDE 都是你的最佳选择，比如你进行 Python 开发的可以选择 JetBrains 全家桶中的 PyCharm 。</p>
<p><strong>DataGrip 支持几乎所有主流的关系数据库产品，如 DB2、Derby、H2、MySQL、Oracle、PostgreSQL、SQL Server、Sqllite 及 Sybase 等，并且提供了简单易用的界面，开发者上手几乎不会遇到任何困难。</strong></p>
<p>我相信，当你第一眼看到 DataGrip 以后，会有一种惊艳的感觉，就好比你第一眼看到一个姑娘，就是那么一瞥，你对自己说，就是她了！废话不多说，来看看 DataGrip 的常用功能。</p>
<h2 id="下载"> 下载</h2>
<p>DataGrip 下载链接如下 <a href="https://www.jetbrains.com/datagrip/download" target="_blank" rel="noopener noreferrer">https://www.jetbrains.com/datagrip/download</a>。安装过程也很简单，双击安装，下一步，中间会让你选择主题，本人选择的是经典的 Darcula，安装完成后，启动，界面如下</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1201/1a20c170-1d14-3f98-a418-4b951c6548c4.png" alt="" /></p>
<h2 id="配置-data-source"> 配置 Data Source</h2>
<p>相信使用过 IDEA 的同学看到这个界面都会感到很亲切。<code>File-&gt;DataSource</code> ：配置数据源。</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1203/d6311108-d7a2-3ece-9cd7-613dd27688cf.png" alt="" />
DataGrip 支持主流的数据库。你也可以在 Database 视图中展开绿色的+号，添加数据库连接</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1217/3298f379-102f-3dc7-ad30-20cfb5d6126d.jpg" alt="" />
选择需要连接的数据库类型</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1219/93e106e6-8e06-3eb5-b507-fe6ee88a2ac8.png" alt="" /></p>
<p>在面板中，左上部分列出了已经建立的数据库连接，点击各项，右侧会展示当前连接的配置信息，General 面板中，可以配置数据库连接的信息，如主机、用户名、密码等，不同数据库配置信息不完全相同，填入数据库 URL，注意，URL 后有个选项，可以选择直接填入 url，那么就不需要单独填主机名、端口等信息了。</p>
<p>Driver 部分显示数据库驱动信息，如果还没有下载过驱动，底部会有个警告，提示缺少驱动</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1236/9879937b-3abf-300d-8b00-23a848f5db04.png" alt="" />
点击 Driver 后的数据库类型，会跳转到驱动下载页面，点击 download，下载完会显示驱动包</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1242/76cdb03e-b8a0-33dd-8dc3-3f2b5c5f5e57.png" alt="" /></p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1246/1496c2e6-e180-3fd4-bf4a-cab8a601ce59.png" alt="" />
如果下载的驱动有问题，可以手动添加本地驱动包，在试用过程中，创建 Oracle 连接时，下载的驱动包就有问题，提示缺少 class，点击右侧绿色的+号，选择本地下载好的 jar 包，通过右侧上下箭头，将导入的 jar 包移到最上位置就 OK 了</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1248/1684afeb-e45e-328a-aeab-44ced763b1f9.png" alt="" /></p>
<p>点击 Test Connection，查看配置是否正确，接下来就可以使用了。</p>
<h2 id="常用设置"> 常用设置</h2>
<p>打开 DataGrip，选择 <code>File-&gt;Settings</code>，当前面板显示了常用设置项</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1252/e074472a-ee46-317d-a18b-63e6c251f919.png" alt="" />
基本上默认设置就足够了，要更改设置也很简单，左侧菜单已经分类好了，第一项是数据库相关的配置，第二项是配置外观的，在这里可以修改主题，key map 修改快捷键，editor 配置编辑器相关设置，在这里可以修改编辑器字体，展开 edit 项: <code>Editor-&gt;Color &amp; Fonts-&gt;Font</code></p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1256/080b78d6-c01b-346b-adb7-840b792372f8.png" alt="" />
需要将当前主题保存一下，点击 save as，起个名，选择重命名后的主题就能修改了，这里我选择习惯的 Conurier New 字体，大小为 14 号，点击右下角的 apply，点击 OK</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1258/c0d34593-f845-3e44-ba9b-7ba9fcdd8183.png" alt="点击查看原始大小图片" /></p>
<p>其他的没啥好设置的了。</p>
<h2 id="数据库常用操作"> 数据库常用操作</h2>
<p>接下来，我们来使用 DataGrip 完成数据库的常用操作，包括查询数据、修改数据，创建数据库、表等。</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1263/6b0ffcc8-5829-326c-815b-80a476e19c2c.png" alt="点击查看原始大小图片" />
左上区域显示了当前数据库连接，展开后会显示数据库表等信息，如果展开后没有任何信息，需要选中数据库连接，点击上面的旋转图标同步一下，下方有个 More Schema 选项，点击可以切换不同的 schema。</p>
<h3 id="sql-语句编写"> sql 语句编写</h3>
<p>右键选中的数据库连接，选择 open console，就可以在右侧的控制台中书写 sql 语句了。</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1265/f2fc1c17-288a-3991-887b-716f59f8dab5.png" alt="img" /></p>
<p><strong>DataGrip 的智能提示非常爽，无论是标准的 sql 关键字，还是表名、字段名，甚至数据库特定的字段，都能提示，不得不感叹这智能提示太强大了，Intellij IDEA 的智能提示也是秒杀 eclipse。</strong></p>
<p>写完 sql 语句后，可以选中，电子左上侧绿色箭头执行</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1273/bebf5996-5c3e-37a8-8065-33243f8a5265.png" alt="" />
也可以使用快捷键 <code>Ctrl+Enter</code>，选中情况下，会直接执行该 sql，未选中情况下，如果控制台中有多条 sql，会提示你要执行哪条 sql。</p>
<p>之前习惯了 dbvisualizer 中的操作，dbvisualizer 中光标停留在当前 sql 上(sql 以分号结尾)，按下<code>Ctrl+.</code>快捷键会自动执行当前 sql，其实 DataGrip 也能设置，在 <code>setting-&gt;Database-General</code>中</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1283/b4c05671-600a-3305-af48-3112ef44bf17.png" alt="" />
语句执行时默认是提示，改成 smallest statement 后，光标停留在当前语句时，按下 Ctrl+Enter 就会直接执行当前语句。</p>
<p>语句的执行结果在底部显示</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1291/e6fc6a18-da4d-32b6-8c8e-670248b372b5.png" alt="" />
如果某列的宽度太窄，可以鼠标点击该列的任意一个，使用快捷键<code>Ctrl+Shift+左右箭头</code>可以调整宽度，如果要调整所有列的宽度，可以点击左上角红框部分，选择所有行，使用快捷键<code>Ctrl+Shift+左右箭头调整</code></p>
<h3 id="修改数据"> 修改数据</h3>
<p>添加行、删除行也很方便，上部的+、-按钮能直接添加行或删除选中的行，编辑列同样也很方便，双击要修改的列，输入修改后的值，鼠标在其他部分点击就完成修改了</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1295/0bc1c527-2d48-369b-bcf5-acada66255b9.png" alt="" />
有的时候我们要把某个字段置为 null，不是空字符串&quot;&quot;，DataGrip 也提供了渐变的操作，直接在列上右键，选择 set null</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1297/6fc97e37-fb7f-3c01-a146-c9fba9e7cfa3.png" alt="" />
对于需要多窗口查看结果的，即希望查询结果在新的 tab 中展示，可以点击 pin tab 按钮，那新查询将不会再当前 tab 中展示，而是新打开一个 tab</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1301/3eb0023a-740b-3f80-8014-464d885d7dbc.png" alt="" /></p>
<p>旁边的 output 控制台显示了执行 sql 的日志信息，能看到 sql 执行的时间等信息</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1299/83fa531c-91b4-3a02-b02f-296195f51058.png" alt="" />
我就问这么吊的工具，还有谁！！！</p>
<h3 id="新建表"> 新建表</h3>
<p>要新建表也是相当简单、智能，选中数据库连接，点击绿色+号下选择 table</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1303/25102ef8-ac5b-303b-9c06-ee4308ffac9e.png" alt="" />
在新打开的窗口中，可以填写表信息</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1306/f00179e9-0fe9-351d-9455-66537440f5cc.png" alt="" />
我就问你看到这个窗口兴奋不兴奋！！！</p>
<p>顶部可以填写表名、表注释，中间可以点击右侧绿色+号添加列，列类型 type 也是能自动补全，default 右侧的消息框图标点击后能对列添加注释，旁边的几个 tab 可以设置索引及外键</p>
<p>所有这些操作的 DDL 都会直接在底部显示</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1310/32c24402-023f-3cad-a2dd-c8a42ace32d1.png" alt="" />
我就问你怕不怕</p>
<p>表建完后，可以点击下图中的 table 图标，打开表查看视图</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1312/9894cfcf-48b6-382d-ab2e-57e6be6a2a5f.png" alt="" />
可以查看表的数据，也能查看 DDL 语句</p>
<h3 id="数据库导出"> 数据库导出</h3>
<p>这些基本功能的设计、体验，已经惊艳到我了，接下来就是数据的导出。</p>
<p>DataGrip 的导出功能也是相当强大</p>
<p>选择需要导出数据的表，右键，Dump Data To File</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1315/6520ee08-7ef1-3463-be63-9e8c96861df5.png" alt="" />
即可以导出 insert、update 形式的 sql 语句，也能导出为 html、csv、json 格式的数据</p>
<p>也可以在查询结果视图中导出</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1317/354a6ef4-9ea4-3a32-bc1e-53e02c7f0231.png" alt="" />
点击右上角下载图标，在弹出窗口中可以选择不同的导出方式，如 sql insert、sql update、csv 格式等</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1319/3a9da4d9-0b91-3dc6-b3c1-176b8eaea63b.png" alt="" /></p>
<p>如果是导出到 csv 格式，还能控制导出的格式</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1321/2893f834-9098-322f-8253-5741ab6893cb.png" alt="" /></p>
<p>导出后用 excel 打开是这种结果</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1323/5b5956d0-6cad-3c06-83f4-1a715fa94654.png" alt="" />
除了能导出数据外，还能导入数据</p>
<p>选择表，右键-&gt;Import from File，选择要导入的文件</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0119/1325/6926c5c8-be4d-3ebc-b8cb-9737e6838ed3.png" alt="" />
注意，导出的时候如果勾选了左侧的两个 header 选项，导入的时候如果有 header，也要勾选，不然会提示列个数不匹配</p>
<h2 id="小技巧"> 小技巧</h2>
<h3 id="导航-全局搜索"> 导航+全局搜索</h3>
<h4 id="关键字导航"> 关键字导航</h4>
<p>当在 datagrip 的文本编辑区域编写 sql 时，按住键盘 Ctrl 键不放，同时鼠标移动到 sql 关键字上，比如表名、字段名称、或者是函数名上，鼠标会变成手型，关键字会变蓝，并加了下划线，点击，会自动定位到左侧对象树，并选中点击的对象</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/5964/c29da366-7d43-3aa0-9bce-042285f8771e.png" alt="" /></p>
<h4 id="快速导航到指定的表、视图、函数等"> 快速导航到指定的表、视图、函数等</h4>
<p>在 datagrip 中，使用 Ctrl+N 快捷键，弹出一个搜索框，输入需要导航的名称，回车即可</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/5966/d9ca4280-67a1-3d26-b2aa-796b70cf3e95.png" alt="" /></p>
<h4 id="全局搜索"> 全局搜索</h4>
<p>连续两次按下 shift 键，或者鼠标点击右上角的搜索图标，弹出搜索框，搜索任何你想搜索的东西</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/5970/d6bfaa7f-0713-3938-8efc-6c86f354c05e.png" alt="" /></p>
<h4 id="结果集搜索"> 结果集搜索</h4>
<p>在查询结果集视图区域点击鼠标，按下 Ctrl+F 快捷键，弹出搜索框，输入搜索内容，支持正则表达式、过滤结果</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/5978/7c84cc4f-2337-3767-9a06-4db2747fde40.png" alt="" /></p>
<h4 id="导航到关联数据"> 导航到关联数据</h4>
<p>表之间会有外检关联，查询的时候，能直接定位到关联数据，或者被关联数据，例如 user1 表有个外检字段 classroom 指向 classroom 表的主键 id，在查询 classroom 表数据的时候，可以在 id 字段上右键，go to，referencing data</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/5982/a9dc35f0-12a9-3bfe-aa68-c5396d628253.png" alt="" />
选择要显示第一条数据还是显示所有数据</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/5984/421da02c-cd94-33cc-9fbc-cd854991090c.png" alt="" />
会自动打开关联表的数据</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/5986/fcde71af-c071-38d2-affd-d08dab7483d5.png" alt="" />
相反，查询字表的数据时，也能自动定位到父表</p>
<h3 id="数据转换"> 数据转换</h3>
<h4 id="结果集数据过滤"> 结果集数据过滤</h4>
<p>对于使用 table edit（对象树中选中表，右键-&gt;table editor）打开的结果集，可以使用条件继续过滤结果集，如下图所示，可以在结果集左上角输入款中输入 where 条件过滤</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/5994/bbbb92b4-0e49-33cf-8448-cf59e1992986.png" alt="" />
也可以对着需要过滤数据的列右键，filter by 过滤</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/5990/84a2bcc7-8722-311e-8b30-0a75618281a6.png" alt="" /></p>
<h4 id="行转列"> 行转列</h4>
<p>对于字段比较多的表，查看数据要左右推动，可以切换成列显示，在结果集视图区域使用 Ctrl+Q 快捷键</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/5992/4a242dd4-c1e4-3b6f-9204-1468e767906a.png" alt="" /></p>
<h4 id="变量重命名"> 变量重命名</h4>
<p>鼠标点击需要重命名的变量，按下 Shift+F6 快捷键，弹出重命名对话框，输入新的名称</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/5996/2587d544-9641-3635-a987-2755bac6a760.png" alt="" /></p>
<h4 id="自动检测无法解析的对象"> 自动检测无法解析的对象</h4>
<p>如果表名、字段名不存在，datagrip 会自动提示，此时对着有问题的表名或字段名，按下 Alt+Enter，会自动提示是否创建表或添加字段</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/5998/bb21ae31-209d-3f44-9604-fbf78209e926.png" alt="" /></p>
<h4 id="权限定字段名"> 权限定字段名</h4>
<p>对于查询使用表别名的，而字段中没有使用别名前缀的，datagrip 能自动添加前缀，鼠标停留在需要添加别名前缀的字段上，使用 Alt+Enter 快捷键</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/6000/38babb30-fcef-3db6-9b06-efb040f3ee12.png" alt="" /></p>
<h3 id="格式化"> 格式化</h3>
<h4 id="通配符自动展开"> *通配符自动展开</h4>
<p>查询的时候我们会使用 select <em>查询所有列，这是不好的习惯，datagrip 能快速展开列，光标定位到</em>后面，按下 Alt+Enter 快捷键</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/6002/a1b9a749-c223-3197-a073-2f4fc15f30f9.png" alt="" /></p>
<h4 id="大写自动转换"> 大写自动转换</h4>
<p>sql 使用大写形式是个好的习惯，如果使用了小写，可以将光标停留在需要转换的字段或表名上，使用 Ctrl+shift+U 快捷键自动转换</p>
<h4 id="sql-格式化"> sql 格式化</h4>
<p>选中需要格式化的 sql 代码，使用 Ctrl+Alt+L 快捷键</p>
<p>datagrip 提供了一个功能强大的编辑器，实现了 notpad++的列编辑模式</p>
<h3 id="列编辑"> 列编辑</h3>
<h4 id="多光标模式"> 多光标模式</h4>
<p>在编辑 sql 的时候，可能需要同时输入或同时删除一些字符，按下 alt+shift，同时鼠标在不同的位置点击，会出现多个光标</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/6004/cf942465-18ba-3d0a-92c0-2fef52635990.png" alt="" /></p>
<h4 id="代码注释"> 代码注释</h4>
<p>选中要注释的代码，按下 Ctrl+/或 Ctrl+shift+/快捷键，能注释代码，或取消注释</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/6006/daa4c7e7-548a-3b46-a787-e335d001aa1a.png" alt="" /></p>
<h4 id="列编辑-2"> 列编辑</h4>
<p>按住键盘 Alt 键，同时按下鼠标左键拖动，能选择多列，拷贝黏贴等操作</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/6008/4fd42813-8602-3520-8d63-446c22e942de.png" alt="" /></p>
<h3 id="历史记录"> 历史记录</h3>
<h4 id="代码历史"> 代码历史</h4>
<p>在文本编辑器中，邮件，local history，show history，可以查看使用过的 sql 历史</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/6010/cc243a75-f7ef-366b-b184-f5635855d9f6.png" alt="" /></p>
<h4 id="命令历史"> 命令历史</h4>
<p><img src="http://dl2.iteye.com/upload/attachment/0121/6012/cf962c1c-0dfe-3241-b137-fef4eac9f1f0.png" alt="" /></p>
]]></content:encoded>
      <enclosure url="http://dl2.iteye.com/upload/attachment/0119/1201/1a20c170-1d14-3f98-a418-4b951c6548c4.png" type="image/png"/>
    </item>
    <item>
      <title>screw:一键生成数据库文档，堪称数据库界的Swagger</title>
      <link>https://javaguide.cn/tools/database/screw/</link>
      <guid>https://javaguide.cn/tools/database/screw/</guid>
      <source url="https://javaguide.cn/rss.xml">screw:一键生成数据库文档，堪称数据库界的Swagger</source>
      <category>数据库</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>在项目中，我们经常需要整理数据库表结构文档。</p>
<p>一般情况下，我们都是手动整理数据库表结构文档，当表结构有变动的时候，自己手动进行维护。</p>
<p>数据库表少的时候还好，数据库表多了之后，手动整理和维护数据库表结构文档简直不要太麻烦，而且，还非常容易出错！</p>
<p><strong>有没有什么好用的工具帮助我们自动生成数据库表结构文档呢？</strong></p>
<p>当然有！Github 上就有一位朋友开源了一款数据库表结构文档自动生成工具—— <strong>screw</strong> 。</p>
<p>项目地址： https://github.com/pingfangushi/screw 。</p>
<p><img src="https://img-blog.csdnimg.cn/cc9556dbe0494e449b7c913f3eb8fe9e.png" alt="" /></p>
<p>screw 翻译过来的意思就是螺丝钉，作者希望这个工具能够像螺丝钉一样切实地帮助到我们的开发工作。</p>
<p>目前的话，screw 已经支持市面上大部分常见的数据库比如 MySQL、MariaDB、Oracle、SqlServer、PostgreSQL、TiDB。</p>
<p>另外，screw 使用起来也非常简单，根据官网提示，不用 10 分钟就能成功在本地使用起来！</p>
<h2 id="快速入门"> 快速入门</h2>
<p>为了验证 screw 自动生成数据库表结构文档的效果，我们首先创建一个简单的存放博客数据的数据库表。</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> <span>`</span>blog<span>`</span> <span>(</span>
  <span>`</span>id<span>`</span> <span>bigint</span><span>(</span><span>20</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>AUTO_INCREMENT</span> <span>COMMENT</span> <span>'主键'</span><span>,</span>
  <span>`</span>title<span>`</span> <span>varchar</span><span>(</span><span>255</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>COMMENT</span> <span>'博客标题'</span><span>,</span>
  <span>`</span>content<span>`</span> <span>longtext</span> <span>NOT</span> <span>NULL</span> <span>COMMENT</span> <span>'博客内容'</span><span>,</span>
  <span>`</span>description<span>`</span> <span>varchar</span><span>(</span><span>255</span><span>)</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'博客简介'</span><span>,</span>
  <span>`</span>cover<span>`</span> <span>varchar</span><span>(</span><span>255</span><span>)</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'博客封面图片地址'</span><span>,</span>
  <span>`</span>views<span>`</span> <span>int</span><span>(</span><span>11</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>'0'</span> <span>COMMENT</span> <span>'博客阅读次数'</span><span>,</span>
  <span>`</span>user_id<span>`</span> <span>bigint</span><span>(</span><span>20</span><span>)</span> <span>DEFAULT</span> <span>'0'</span> <span>COMMENT</span> <span>'发表博客的用户ID'</span><span>,</span>
  <span>`</span>channel_id<span>`</span> <span>bigint</span><span>(</span><span>20</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>COMMENT</span> <span>'博客分类ID'</span><span>,</span>
  <span>`</span>recommend<span>`</span> <span>bit</span><span>(</span><span>1</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> b<span>'0'</span> <span>COMMENT</span> <span>'是否推荐'</span><span>,</span>
  <span>`</span><span>top</span><span>`</span> <span>bit</span><span>(</span><span>1</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> b<span>'0'</span> <span>COMMENT</span> <span>'是否置顶'</span><span>,</span>
  <span>`</span><span>comment</span><span>`</span> <span>bit</span><span>(</span><span>1</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> b<span>'1'</span> <span>COMMENT</span> <span>'是否开启评论'</span><span>,</span>
  <span>`</span>created_at<span>`</span> <span>timestamp</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>CURRENT_TIMESTAMP</span> <span>COMMENT</span> <span>'创建时间'</span><span>,</span>
  <span>`</span>updated_at<span>`</span> <span>timestamp</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>CURRENT_TIMESTAMP</span> <span>COMMENT</span> <span>'更新时间'</span><span>,</span>
  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>`</span>id<span>`</span><span>)</span>
<span>)</span> <span>ENGINE</span><span>=</span><span>InnoDB</span> <span>AUTO_INCREMENT</span><span>=</span><span>16</span> <span>DEFAULT</span> <span>CHARSET</span><span>=</span>utf8mb4 <span>COMMENT</span><span>=</span><span>'博客'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="基于-java-代码"> 基于 Java 代码</h3>
<h4 id="引入依赖"> 引入依赖</h4>
<p>创建一个普通的 Maven 项目即可！然后引入 screw、HikariCP、MySQL 这 3 个依赖。</p>
<div><pre><code><span>&lt;!--screw--></span>
<span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>cn.smallbun.screw<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>screw-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>1.0.5<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
<span>&lt;!-- HikariCP --></span>
<span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.zaxxer<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>HikariCP<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>3.4.5<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
<span>&lt;!--MySQL--></span>
<span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>mysql<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>mysql-connector-java<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>8.0.20<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>你可以通过下面的地址在 mvnrepository 获取最新版本的 screw。</p>
<blockquote>
<p>https://mvnrepository.com/artifact/cn.smallbun.screw/screw-core</p>
</blockquote>
<h4 id="编写代码"> 编写代码</h4>
<p>生成数据库文档的代码的整个代码逻辑还是比较简单的，我们只需要经过下面 5 步即可：</p>
<div><pre><code><span>// 1.获取数据源</span>
<span>DataSource</span> dataSource <span>=</span> <span>getDataSource</span><span>(</span><span>)</span><span>;</span>
<span>// 2.获取数据库文档生成配置（文件路径、文件类型）</span>
<span>EngineConfig</span> engineConfig <span>=</span> <span>getEngineConfig</span><span>(</span><span>)</span><span>;</span>
<span>// 3.获取数据库表的处理配置，可忽略</span>
<span>ProcessConfig</span> processConfig <span>=</span> <span>getProcessConfig</span><span>(</span><span>)</span><span>;</span>
<span>// 4.Screw 完整配置</span>
<span>Configuration</span> config <span>=</span> <span>getScrewConfig</span><span>(</span>dataSource<span>,</span> engineConfig<span>,</span> processConfig<span>)</span><span>;</span>
<span>// 5.执行生成数据库文档</span>
<span>new</span> <span>DocumentationExecute</span><span>(</span>config<span>)</span><span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>1、获取数据库源</strong></p>
<p>对数据库以及数据库连接池进行相关配置。务必将数据库相关的配置修改成你自己的。</p>
<div><pre><code><span>/**
 * 获取数据库源
 */</span>
<span>private</span> <span>static</span> <span>DataSource</span> <span>getDataSource</span><span>(</span><span>)</span> <span>{</span>
    <span>//数据源</span>
    <span>HikariConfig</span> hikariConfig <span>=</span> <span>new</span> <span>HikariConfig</span><span>(</span><span>)</span><span>;</span>
    hikariConfig<span>.</span><span>setDriverClassName</span><span>(</span><span>"com.mysql.cj.jdbc.Driver"</span><span>)</span><span>;</span>
    hikariConfig<span>.</span><span>setJdbcUrl</span><span>(</span><span>"jdbc:mysql://127.0.0.1:3306/javaguide-blog"</span><span>)</span><span>;</span>
    hikariConfig<span>.</span><span>setUsername</span><span>(</span><span>"root"</span><span>)</span><span>;</span>
    hikariConfig<span>.</span><span>setPassword</span><span>(</span><span>"123456"</span><span>)</span><span>;</span>
    <span>//设置可以获取tables remarks信息</span>
    hikariConfig<span>.</span><span>addDataSourceProperty</span><span>(</span><span>"useInformationSchema"</span><span>,</span> <span>"true"</span><span>)</span><span>;</span>
    hikariConfig<span>.</span><span>setMinimumIdle</span><span>(</span><span>2</span><span>)</span><span>;</span>
    hikariConfig<span>.</span><span>setMaximumPoolSize</span><span>(</span><span>5</span><span>)</span><span>;</span>
    <span>return</span> <span>new</span> <span>HikariDataSource</span><span>(</span>hikariConfig<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong>2、获取文件生成配置</strong></p>
<p>这一步会指定数据库文档生成的位置、文件类型以及文件名称。</p>
<div><pre><code><span>/**
 * 获取文件生成配置
 */</span>
<span>private</span> <span>static</span> <span>EngineConfig</span> <span>getEngineConfig</span><span>(</span><span>)</span> <span>{</span>
    <span>//生成配置</span>
    <span>return</span> <span>EngineConfig</span><span>.</span><span>builder</span><span>(</span><span>)</span>
            <span>//生成文件路径</span>
            <span>.</span><span>fileOutputDir</span><span>(</span><span>"/Users/guide/Documents/代码示例/screw-demo/doc"</span><span>)</span>
            <span>//打开目录</span>
            <span>.</span><span>openOutputDir</span><span>(</span><span>true</span><span>)</span>
            <span>//文件类型</span>
            <span>.</span><span>fileType</span><span>(</span><span>EngineFileType</span><span>.</span>HTML<span>)</span>
            <span>//生成模板实现</span>
            <span>.</span><span>produceType</span><span>(</span><span>EngineTemplateType</span><span>.</span>freemarker<span>)</span>
            <span>//自定义文件名称</span>
            <span>.</span><span>fileName</span><span>(</span><span>"数据库结构文档"</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>如果不配置生成文件路径的话，默认也会存放在项目的 <code>doc</code> 目录下。</p>
<p>另外，我们这里指定生成的文件格式为 HTML。除了 HTML 之外，screw 还支持 Word 、Markdown 这两种文件格式。</p>
<p>不太建议生成 Word 格式,比较推荐 Markdown 格式。</p>
<p><strong>3、获取数据库表的处理配置</strong></p>
<p>这一步你可以指定只生成哪些表：</p>
<div><pre><code><span>/**
 * 获取数据库表的处理配置，可忽略
 */</span>
<span>private</span> <span>static</span> <span>ProcessConfig</span> <span>getProcessConfig</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>ProcessConfig</span><span>.</span><span>builder</span><span>(</span><span>)</span>
      <span>// 指定只生成 blog 表</span>
      <span>.</span><span>designatedTableName</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>Collections</span><span>.</span><span>singletonList</span><span>(</span><span>"blog"</span><span>)</span><span>)</span><span>)</span>
      <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>还可以指定忽略生成哪些表：</p>
<div><pre><code><span>private</span> <span>static</span> <span>ProcessConfig</span> <span>getProcessConfig</span><span>(</span><span>)</span> <span>{</span>
    <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span> ignoreTableName <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    ignoreTableName<span>.</span><span>add</span><span>(</span><span>"test_user"</span><span>)</span><span>;</span>
    ignoreTableName<span>.</span><span>add</span><span>(</span><span>"test_group"</span><span>)</span><span>;</span>
    <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span> ignorePrefix <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    ignorePrefix<span>.</span><span>add</span><span>(</span><span>"test_"</span><span>)</span><span>;</span>
    <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span> ignoreSuffix <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    ignoreSuffix<span>.</span><span>add</span><span>(</span><span>"_test"</span><span>)</span><span>;</span>
    <span>return</span> <span>ProcessConfig</span><span>.</span><span>builder</span><span>(</span><span>)</span>
            <span>//忽略表名</span>
            <span>.</span><span>ignoreTableName</span><span>(</span>ignoreTableName<span>)</span>
            <span>//忽略表前缀</span>
            <span>.</span><span>ignoreTablePrefix</span><span>(</span>ignorePrefix<span>)</span>
            <span>//忽略表后缀</span>
            <span>.</span><span>ignoreTableSuffix</span><span>(</span>ignoreSuffix<span>)</span>
            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>这一步也可以省略。如果不指定 <code>ProcessConfig</code> 的话，就会按照默认配置来！</p>
<p><strong>4、生成 screw 完整配置</strong></p>
<p>根据前面 3 步，生成 screw 完整配置。</p>
<div><pre><code><span>private</span> <span>static</span> <span>Configuration</span> <span>getScrewConfig</span><span>(</span><span>DataSource</span> dataSource<span>,</span> <span>EngineConfig</span> engineConfig<span>,</span> <span>ProcessConfig</span> processConfig<span>)</span> <span>{</span>
    <span>return</span> <span>Configuration</span><span>.</span><span>builder</span><span>(</span><span>)</span>
            <span>//版本</span>
            <span>.</span><span>version</span><span>(</span><span>"1.0.0"</span><span>)</span>
            <span>//描述</span>
            <span>.</span><span>description</span><span>(</span><span>"数据库设计文档生成"</span><span>)</span>
            <span>//数据源</span>
            <span>.</span><span>dataSource</span><span>(</span>dataSource<span>)</span>
            <span>//生成配置</span>
            <span>.</span><span>engineConfig</span><span>(</span>engineConfig<span>)</span>
            <span>//生成配置</span>
            <span>.</span><span>produceConfig</span><span>(</span>processConfig<span>)</span>
            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>5、执行生成数据库文档</strong></p>
<p><img src="https://img-blog.csdnimg.cn/ab2c9ee575304dcdb3c6c231c9eadd17.png" alt="" /></p>
<p>下图就是生成的 HTML 格式的数据库设计文档。</p>
<p><img src="https://img-blog.csdnimg.cn/6ac5a73f27ed4314960fa7671c479525.png" alt="" /></p>
<h3 id="基于-maven-插件"> 基于 Maven 插件</h3>
<p>除了基于 Java 代码这种方式之外，你还可以通过 screw 提供的 Maven 插件来生成数据库文档。方法也非常简单！</p>
<p><strong>1、配置 Maven 插件</strong></p>
<p>务必将数据库相关的配置修改成你自己的。</p>
<div><pre><code><span><span><span>&lt;</span>build</span><span>></span></span>
    <span><span><span>&lt;</span>plugins</span><span>></span></span>
        <span><span><span>&lt;</span>plugin</span><span>></span></span>
            <span><span><span>&lt;</span>groupId</span><span>></span></span>cn.smallbun.screw<span><span><span>&lt;/</span>groupId</span><span>></span></span>
            <span><span><span>&lt;</span>artifactId</span><span>></span></span>screw-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
            <span><span><span>&lt;</span>version</span><span>></span></span>1.0.5<span><span><span>&lt;/</span>version</span><span>></span></span>
            <span><span><span>&lt;</span>dependencies</span><span>></span></span>
                <span>&lt;!-- HikariCP --></span>
                <span><span><span>&lt;</span>dependency</span><span>></span></span>
                    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.zaxxer<span><span><span>&lt;/</span>groupId</span><span>></span></span>
                    <span><span><span>&lt;</span>artifactId</span><span>></span></span>HikariCP<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
                    <span><span><span>&lt;</span>version</span><span>></span></span>3.4.5<span><span><span>&lt;/</span>version</span><span>></span></span>
                <span><span><span>&lt;/</span>dependency</span><span>></span></span>
                <span>&lt;!--mysql driver--></span>
                <span><span><span>&lt;</span>dependency</span><span>></span></span>
                    <span><span><span>&lt;</span>groupId</span><span>></span></span>mysql<span><span><span>&lt;/</span>groupId</span><span>></span></span>
                    <span><span><span>&lt;</span>artifactId</span><span>></span></span>mysql-connector-java<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
                    <span><span><span>&lt;</span>version</span><span>></span></span>8.0.20<span><span><span>&lt;/</span>version</span><span>></span></span>
                <span><span><span>&lt;/</span>dependency</span><span>></span></span>
            <span><span><span>&lt;/</span>dependencies</span><span>></span></span>
            <span><span><span>&lt;</span>configuration</span><span>></span></span>
                <span>&lt;!--username--></span>
                <span><span><span>&lt;</span>username</span><span>></span></span>root<span><span><span>&lt;/</span>username</span><span>></span></span>
                <span>&lt;!--password--></span>
                <span><span><span>&lt;</span>password</span><span>></span></span>123456<span><span><span>&lt;/</span>password</span><span>></span></span>
                <span>&lt;!--driver--></span>
                <span><span><span>&lt;</span>driverClassName</span><span>></span></span>com.mysql.cj.jdbc.Driver<span><span><span>&lt;/</span>driverClassName</span><span>></span></span>
                <span>&lt;!--jdbc url--></span>
                <span><span><span>&lt;</span>jdbcUrl</span><span>></span></span>jdbc:mysql://127.0.0.1:3306/javaguide-blog<span><span><span>&lt;/</span>jdbcUrl</span><span>></span></span>
                <span>&lt;!--生成文件类型--></span>
                <span><span><span>&lt;</span>fileType</span><span>></span></span>MD<span><span><span>&lt;/</span>fileType</span><span>></span></span>
                <span>&lt;!--打开文件输出目录--></span>
                <span><span><span>&lt;</span>openOutputDir</span><span>></span></span>true<span><span><span>&lt;/</span>openOutputDir</span><span>></span></span>
                <span>&lt;!--生成模板--></span>
                <span><span><span>&lt;</span>produceType</span><span>></span></span>freemarker<span><span><span>&lt;/</span>produceType</span><span>></span></span>
                <span>&lt;!--文档名称 为空时:将采用[数据库名称-描述-版本号]作为文档名称--></span>
                <span><span><span>&lt;</span>fileName</span><span>></span></span>数据库结构文档<span><span><span>&lt;/</span>fileName</span><span>></span></span>
                <span>&lt;!--描述--></span>
                <span><span><span>&lt;</span>description</span><span>></span></span>数据库设计文档生成<span><span><span>&lt;/</span>description</span><span>></span></span>
                <span>&lt;!--版本--></span>
                <span><span><span>&lt;</span>version</span><span>></span></span>${project.version}<span><span><span>&lt;/</span>version</span><span>></span></span>
                <span>&lt;!--标题--></span>
                <span><span><span>&lt;</span>title</span><span>></span></span>数据库文档<span><span><span>&lt;/</span>title</span><span>></span></span>
            <span><span><span>&lt;/</span>configuration</span><span>></span></span>
            <span><span><span>&lt;</span>executions</span><span>></span></span>
                <span><span><span>&lt;</span>execution</span><span>></span></span>
                    <span><span><span>&lt;</span>phase</span><span>></span></span>compile<span><span><span>&lt;/</span>phase</span><span>></span></span>
                    <span><span><span>&lt;</span>goals</span><span>></span></span>
                        <span><span><span>&lt;</span>goal</span><span>></span></span>run<span><span><span>&lt;/</span>goal</span><span>></span></span>
                    <span><span><span>&lt;/</span>goals</span><span>></span></span>
                <span><span><span>&lt;/</span>execution</span><span>></span></span>
            <span><span><span>&lt;/</span>executions</span><span>></span></span>
        <span><span><span>&lt;/</span>plugin</span><span>></span></span>
    <span><span><span>&lt;/</span>plugins</span><span>></span></span>
<span><span><span>&lt;/</span>build</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><p><strong>2、手动执行生成数据库文档</strong></p>
<p><img src="https://img-blog.csdnimg.cn/9d711f5efba54b44b526cbf5e0173b3d.png" alt="" /></p>
<p>我们这里指定生成的是 Markdown 格式。</p>
<p><img src="https://img-blog.csdnimg.cn/d9debd83fa644b9b8fbd44ac3340530a.png" alt="" /></p>
<p>下图就是生成的 Markdown 格式的数据库设计文档，效果还是非常不错的！</p>
<p><img src="https://img-blog.csdnimg.cn/654d93c2faae4a47bd4b8b8a4f5d8376.png" alt="" /></p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/cc9556dbe0494e449b7c913f3eb8fe9e.png" type="image/png"/>
    </item>
    <item>
      <title>Docker 基本概念解读</title>
      <link>https://javaguide.cn/tools/docker/docker-intro/</link>
      <guid>https://javaguide.cn/tools/docker/docker-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">Docker 基本概念解读</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="docker-基本概念解读"> Docker 基本概念解读</h1>
<p><strong>本文只是对 Docker 的概念做了较为详细的介绍，并不涉及一些像 Docker 环境的安装以及 Docker 的一些常见操作和命令。</strong></p>
<h2 id="一-认识容器"> 一 认识容器</h2>
<p><strong>Docker 是世界领先的软件容器平台</strong>，所以想要搞懂 Docker 的概念我们必须先从容器开始说起。</p>
<h3 id="_1-1-什么是容器"> 1.1 什么是容器?</h3>
<h4 id="先来看看容器较为官方的解释"> 先来看看容器较为官方的解释</h4>
<p><strong>一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。</strong></p>
<ul>
<li><strong>容器镜像是轻量的、可执行的独立软件包</strong> ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li>
<li><strong>容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。</strong></li>
<li><strong>容器赋予了软件独立性</strong>，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li>
</ul>
<h4 id="再来看看容器较为通俗的解释"> 再来看看容器较为通俗的解释</h4>
<p><strong>如果需要通俗地描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/container.png" alt="认识容器" /></p>
<h3 id="_1-2-图解物理机-虚拟机与容器"> 1.2 图解物理机,虚拟机与容器</h3>
<p>关于虚拟机与容器的对比在后面会详细介绍到，这里只是通过网上的图片加深大家对于物理机、虚拟机与容器这三者的理解(下面的图片来源于网络)。</p>
<p><strong>物理机：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/物理机图解.png" alt="物理机" /></p>
<p><strong>虚拟机：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/虚拟机图解.png" alt="虚拟机" /></p>
<p><strong>容器：</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211110104003678.png" alt="" /></p>
<p>通过上面这三张抽象图，我们可以大概通过类比概括出： <strong>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</strong></p>
<hr>
<p><strong>相信通过上面的解释大家对于容器这个既陌生又熟悉的概念有了一个初步的认识，下面我们就来谈谈 Docker 的一些概念。</strong></p>
<h2 id="二-再来谈谈-docker-的一些概念"> 二 再来谈谈 Docker 的一些概念</h2>
<h3 id="_2-1-什么是-docker"> 2.1 什么是 Docker?</h3>
<p>说实话关于 Docker 是什么并太好说，下面我通过四点向你说明 Docker 到底是个什么东西。</p>
<ul>
<li><strong>Docker 是世界领先的软件容器平台。</strong></li>
<li><strong>Docker</strong> 使用 Google 公司推出的 <strong>Go 语言</strong> 进行开发实现，基于 <strong>Linux 内核</strong> 提供的 CGroup 功能和 namespace 来实现的，以及 AUFS 类的 <strong>UnionFS</strong> 等技术，<strong>对进程进行封装隔离，属于操作系统层面的虚拟化技术。</strong> 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</li>
<li><strong>Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。</strong></li>
<li><strong>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</strong></li>
</ul>
<h3 id="_2-2-docker-思想"> 2.2 Docker 思想</h3>
<ul>
<li><strong>集装箱</strong></li>
<li><strong>标准化：</strong> ① 运输方式 ② 存储方式 ③ API 接口</li>
<li><strong>隔离</strong></li>
</ul>
<h3 id="_2-3-docker-容器的特点"> 2.3 Docker 容器的特点</h3>
<ul>
<li><strong>轻量</strong> :  在一台机器上运行的多个 Docker 容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</li>
<li><strong>标准</strong> : Docker 容器基于开放式标准，能够在所有主流 Linux 版本、Microsoft Windows 以及包括 VM、裸机服务器和云在内的任何基础设施上运行。</li>
<li><strong>安全</strong> : Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker 默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</li>
</ul>
<h3 id="_2-4-为什么要用-docker"> 2.4 为什么要用 Docker ?</h3>
<ul>
<li><strong>Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题；——一致的运行环境</strong></li>
<li><strong>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间</strong></li>
<li><strong>避免公用的服务器，资源会容易受到其他用户的影响。——隔离性</strong></li>
<li><strong>善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展</strong></li>
<li><strong>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便</strong></li>
<li><strong>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署</strong></li>
</ul>
<hr>
<h2 id="三-容器-vs-虚拟机"> 三 容器 VS 虚拟机</h2>
<p><strong>每当说起容器，我们不得不将其与虚拟机做一个比较。就我而言，对于两者无所谓谁会取代谁，而是两者可以和谐共存。</strong></p>
<p>简单来说： <strong>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</strong></p>
<h3 id="_3-1-两者对比图"> 3.1 两者对比图</h3>
<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/2e2b95eebf60b6d03f6c1476f4d7c697.png" alt="" /></p>
<h3 id="_3-2-容器与虚拟机总结"> 3.2 容器与虚拟机总结</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/4ef8691d67eb1eb53217099d0a691eb5.png" alt="" /></p>
<ul>
<li>
<p><strong>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。</strong> <strong>多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行</strong> 。与虚拟机相比， <strong>容器占用的空间较少</strong>（容器镜像大小通常只有几十兆），<strong>瞬间就能完成启动</strong> 。</p>
</li>
<li>
<p><strong>虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。</strong> 管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 <strong>占用大量空间</strong> 。而且 VM <strong>启动也十分缓慢</strong> 。</p>
</li>
</ul>
<p>通过 Docker 官网，我们知道了这么多 Docker 的优势，但是大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。<strong>虚拟机更擅长于彻底隔离整个运行环境</strong>。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 <strong>Docker 通常用于隔离不同的应用</strong> ，例如前端，后端以及数据库。</p>
<h3 id="_3-3-容器与虚拟机两者是可以共存的"> 3.3 容器与虚拟机两者是可以共存的</h3>
<p>就我而言，对于两者无所谓谁会取代谁，而是两者可以和谐共存。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/056c87751b9dd7b56f4264240fe96d00.png" alt="" /></p>
<hr>
<h2 id="四-docker-基本概念"> 四 Docker 基本概念</h2>
<p><strong>Docker 中有非常重要的三个基本概念，理解了这三个概念，就理解了 Docker 的整个生命周期。</strong></p>
<ul>
<li><strong>镜像（Image）</strong></li>
<li><strong>容器（Container）</strong></li>
<li><strong>仓库（Repository）</strong></li>
</ul>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/docker基本概念.png" alt="docker基本概念" /></p>
<h3 id="_4-1-镜像-image-一个特殊的文件系统"> 4.1 镜像(Image):一个特殊的文件系统</h3>
<p><strong>操作系统分为内核和用户空间</strong>。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。</p>
<p><strong>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</strong> 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>Docker 设计时，就充分利用 <strong>Union FS</strong> 的技术，将其设计为<strong>分层存储的架构</strong> 。镜像实际是由多层文件系统联合组成。</p>
<p><strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</strong> 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h3 id="_4-2-容器-container-镜像运行时的实体"> 4.2 容器(Container):镜像运行时的实体</h3>
<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</strong> 。</p>
<p><strong>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</strong></p>
<p><strong>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</strong></p>
<p>按照 Docker 最佳实践的要求，<strong>容器不应该向其存储层内写入任何数据</strong> ，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， <strong>使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</strong></p>
<h3 id="_4-3-仓库-repository-集中存放镜像文件的地方"> 4.3 仓库(Repository):集中存放镜像文件的地方</h3>
<p>镜像构建完成后，可以很容易的在当前宿主上运行，但是， <strong>如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</strong></p>
<p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：<strong>镜像仓库是 Docker 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</strong></p>
<p>通常，<strong>一个仓库会包含同一个软件不同版本的镜像</strong>，而<strong>标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签.。</p>
<p><strong>这里补充一下 Docker Registry 公开服务和私有 Docker Registry 的概念：</strong></p>
<p><strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：<a href="https://hub.docker.com/" title="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">https://hub.docker.com/</a> 。官方是这样介绍 Docker Hub 的：</p>
<blockquote>
<p>Docker Hub 是 Docker 官方提供的一项服务，用于与您的团队查找和共享容器镜像。</p>
</blockquote>
<p>比如我们想要搜索自己想要的镜像：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/Screen Shot 2019-11-04 at 8.21.39 PM.png" alt="利用Docker Hub 搜索镜像" /></p>
<p>在 Docker Hub 的搜索结果中，有几项关键的信息有助于我们选择合适的镜像：</p>
<ul>
<li><strong>OFFICIAL Image</strong> ：代表镜像为 Docker 官方提供和维护，相对来说稳定性和安全性较高。</li>
<li><strong>Stars</strong> ：和点赞差不多的意思，类似 GitHub 的 Star。</li>
<li><strong>Dowloads</strong> ：代表镜像被拉取的次数，基本上能够表示镜像被使用的频度。</li>
</ul>
<p>当然，除了直接通过 Docker Hub 网站搜索镜像这种方式外，我们还可以通过 <code>docker search</code> 这个命令搜索 Docker Hub 中的镜像，搜索的结果是一致的。</p>
<div><pre><code>➜  ~ docker search mysql
NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
mysql                             MySQL is a widely used, open-source relation…   <span>8763</span>                <span>[</span>OK<span>]</span>
mariadb                           MariaDB is a community-developed fork of MyS…   <span>3073</span>                <span>[</span>OK<span>]</span>
mysql/mysql-server                Optimized MySQL Server Docker images. Create…   <span>650</span>                                     <span>[</span>OK<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在国内访问<strong>Docker Hub</strong> 可能会比较慢国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://www.tenxcloud.com/" title="时速云镜像库" target="_blank" rel="noopener noreferrer">时速云镜像库</a>、<a href="https://www.163yun.com/product/repo" title="网易云镜像服务" target="_blank" rel="noopener noreferrer">网易云镜像服务</a>、<a href="https://www.daocloud.io/" title="DaoCloud 镜像市场" target="_blank" rel="noopener noreferrer">DaoCloud 镜像市场</a>、<a href="https://www.aliyun.com/product/containerservice?utm_content=se_1292836" title="阿里云镜像库" target="_blank" rel="noopener noreferrer">阿里云镜像库</a>等。</p>
<p>除了使用公开服务外，用户还可以在 <strong>本地搭建私有 Docker Registry</strong> 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p>
<hr>
<h2 id="五-常见命令"> 五 常见命令</h2>
<h3 id="_5-1-基本命令"> 5.1 基本命令</h3>
<div><pre><code>docker version <span># 查看docker版本</span>
docker images <span># 查看所有已下载镜像，等价于：docker image ls 命令</span>
docker container <span>ls</span> <span>#	查看所有容器</span>
docker <span>ps</span> <span>#查看正在运行的容器</span>
docker image prune <span># 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_5-2-拉取镜像"> 5.2 拉取镜像</h3>
<div><pre><code>docker search mysql <span># 查看mysql相关镜像</span>
docker pull mysql:5.7 <span># 拉取mysql镜像</span>
docker image <span>ls</span> <span># 查看所有已下载镜像</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_5-3-删除镜像"> 5.3 删除镜像</h3>
<p>比如我们要删除我们下载的 mysql 镜像。</p>
<p>通过 <code>docker rmi [image]</code> （等价于<code>docker image rm [image]</code>）删除镜像之前首先要确保这个镜像没有被容器引用（可以通过标签名称或者镜像 ID删除）。通过我们前面讲的<code>docker ps</code>命令即可查看。</p>
<div><pre><code>➜  ~ docker <span>ps</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES
c4cd691d9f80        mysql:5.7           <span>"docker-entrypoint.s…"</span>   <span>7</span> weeks ago         Up <span>12</span> days          <span>0.0</span>.0.0:3306-<span>></span><span>3306</span>/tcp, <span>33060</span>/tcp   mysql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到 mysql 正在被 id 为 c4cd691d9f80 的容器引用，我们需要首先通过 <code>docker stop c4cd691d9f80</code> 或者 <code>docker stop mysql</code>暂停这个容器。</p>
<p>然后查看 mysql 镜像的 id</p>
<div><pre><code>➜  ~ docker images
REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE
mysql                   <span>5.7</span>                 f6509bac4980        <span>3</span> months ago        373MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过 IMAGE ID  或者 REPOSITORY 名字即可删除</p>
<div><pre><code>docker rmi f6509bac4980 <span>#  或者 docker rmi mysql </span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="六-build-ship-and-run"> 六 Build Ship and Run</h2>
<p><strong>Docker 的概念以及常见命令基本上已经讲完，我们再来谈谈：Build, Ship, and Run。</strong></p>
<p>如果你搜索 Docker 官网，会发现如下的字样：<strong>“Docker - Build, Ship, and Run Any App, Anywhere”</strong>。那么 Build, Ship, and Run 到底是在干什么呢？</p>
<p><img src="https://img-blog.csdnimg.cn/2419919953764fc690c929d3844f7011.png" alt="" /></p>
<ul>
<li><strong>Build（构建镜像）</strong> ： 镜像就像是集装箱包括文件以及运行环境等等资源。</li>
<li><strong>Ship（运输镜像）</strong> ：主机和仓库间运输，这里的仓库就像是超级码头一样。</li>
<li><strong>Run （运行镜像）</strong> ：运行的镜像就是一个容器，容器就是运行程序的地方。</li>
</ul>
<p><strong>Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将 Docker 称为码头工人或码头装卸工，这和 Docker 的中文翻译搬运工人如出一辙。</strong></p>
<h2 id="七-简单了解一下-docker-底层原理"> 七 简单了解一下 Docker 底层原理</h2>
<h3 id="_7-1-虚拟化技术"> 7.1 虚拟化技术</h3>
<p>首先，Docker <strong>容器虚拟化</strong>技术为基础的软件，那么什么是虚拟化技术呢？</p>
<p>简单点来说，虚拟化技术可以这样定义：</p>
<blockquote>
<p>虚拟化技术是一种资源管理技术，是将计算机的各种[实体资源](https://zh.wikipedia.org/wiki/資源_(計算機科學 &quot;实体资源&quot;))（<a href="https://zh.wikipedia.org/wiki/CPU" title="CPU" target="_blank" rel="noopener noreferrer">CPU</a>、<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98" title="内存" target="_blank" rel="noopener noreferrer">内存</a>、<a href="https://zh.wikipedia.org/wiki/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4" title="磁盘空间" target="_blank" rel="noopener noreferrer">磁盘空间</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E9%81%A9%E9%85%8D%E5%99%A8" title="网络适配器" target="_blank" rel="noopener noreferrer">网络适配器</a>等），予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境。由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些电脑硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和数据存储。</p>
</blockquote>
<h3 id="_7-2-docker-基于-lxc-虚拟容器技术"> 7.2 Docker 基于 LXC 虚拟容器技术</h3>
<p>Docker 技术是基于 LXC（Linux container- Linux 容器）虚拟容器技术的。</p>
<blockquote>
<p>LXC，其名称来自 Linux 软件容器（Linux Containers）的缩写，一种操作系统层虚拟化（Operating system–level virtualization）技术，为 Linux 内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器（Container），内含应用软件本身的代码，以及所需要的操作系统核心和库。通过统一的名字空间和共用 API 来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得 Linux 用户可以容易的创建和管理系统或应用容器。</p>
</blockquote>
<p>LXC 技术主要是借助 Linux 内核中提供的 CGroup 功能和 namespace 来实现的，通过 LXC 可以为软件提供一个独立的操作系统运行环境。</p>
<p><strong>cgroup 和 namespace 介绍：</strong></p>
<ul>
<li>
<p><strong>namespace 是 Linux 内核用来隔离内核资源的方式。</strong> 通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。</p>
<p>（以上关于 namespace 介绍内容来自https://www.cnblogs.com/sparkdev/p/9365405.html ，更多关于 namespace 的呢内容可以查看这篇文章 ）。</p>
</li>
<li>
<p><strong>CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i/o 等等) 的机制。</strong></p>
<p>（以上关于 CGroup 介绍内容来自 https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html ，更多关于 CGroup 的内容可以查看这篇文章 ）。</p>
</li>
</ul>
<p><strong>cgroup 和 namespace 两者对比：</strong></p>
<p>两者都是将进程进行分组，但是两者的作用还是有本质区别。namespace 是为了隔离进程组之间的资源，而 cgroup 是为了对一组进程进行统一的资源监控和限制。</p>
<h2 id="八-总结"> 八 总结</h2>
<p>本文主要把 Docker 中的一些常见概念做了详细的阐述，但是并不涉及 Docker 的安装、镜像的使用、容器的操作等内容。这部分东西，希望读者自己可以通过阅读书籍与官方文档的形式掌握。如果觉得官方文档阅读起来很费力的话，这里推荐一本书籍《Docker 技术入门与实战第二版》。</p>
<h2 id="九-推荐阅读"> 九 推荐阅读</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/53260098" title="10分钟看懂Docker和K8S" target="_blank" rel="noopener noreferrer">10 分钟看懂 Docker 和 K8S</a></li>
<li><a href="https://www.infoq.cn/article/te70FlSyxhltL1Cr7gzM" title="从零开始入门 K8s：详解 K8s 容器基本概念" target="_blank" rel="noopener noreferrer">从零开始入门 K8s：详解 K8s 容器基本概念</a></li>
</ul>
<h2 id="十-参考"> 十 参考</h2>
<ul>
<li><a href="https://segmentfault.com/a/1190000009732550" title="Linux Namespace和Cgroup" target="_blank" rel="noopener noreferrer">Linux Namespace 和 Cgroup</a></li>
<li><a href="https://www.upguard.com/articles/docker-vs-lxc" title="LXC vs Docker: Why Docker is Better" target="_blank" rel="noopener noreferrer">LXC vs Docker: Why Docker is Better</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html" title="CGroup 介绍、应用实例及原理描述" target="_blank" rel="noopener noreferrer">CGroup 介绍、应用实例及原理描述</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/container.png" type="image/png"/>
    </item>
    <item>
      <title>Docker从入门到上手干事</title>
      <link>https://javaguide.cn/tools/docker/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</link>
      <guid>https://javaguide.cn/tools/docker/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</guid>
      <source url="https://javaguide.cn/rss.xml">Docker从入门到上手干事</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="docker从入门到上手干事"> Docker从入门到上手干事</h1>
<h2 id="docker介绍"> Docker介绍</h2>
<h3 id="什么是-docker"> 什么是 Docker？</h3>
<p>说实话关于 Docker 是什么并不太好说，下面我通过四点向你说明 Docker 到底是个什么东西。</p>
<ul>
<li>Docker 是世界领先的软件容器平台，基于 <strong>Go 语言</strong> 进行开发实现。</li>
<li>Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放开发人员。</li>
<li>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</li>
<li>Docker 可以<strong>对进程进行封装隔离，属于操作系统层面的虚拟化技术。</strong> 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</li>
</ul>
<p>官网地址：https://www.docker.com/ 。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/container.png" alt="认识容器" /></p>
<h3 id="为什么要用-docker"> 为什么要用 Docker?</h3>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app），更重要的是容器性能开销极低。</p>
<p>传统的开发流程中，我们的项目通常需要使用 MySQL、Redis、FastDFS 等等环境，这些环境都是需要我们手动去进行下载并配置的，安装配置流程极其复杂，而且不同系统下的操作也不一样。</p>
<p>Docker 的出现完美地解决了这一问题，我们可以在容器中安装 MySQL、Redis 等软件环境，使得应用和环境架构分开，它的优势在于：</p>
<ol>
<li>一致的运行环境，能够更轻松地迁移</li>
<li>对进程进行封装隔离，容器与容器之间互不影响，更高效地利用系统资源</li>
<li>可以通过镜像复制多个一致的容器</li>
</ol>
<p>另外，<a href="https://yeasy.gitbook.io/docker_practice/introduction/why" target="_blank" rel="noopener noreferrer">《Docker 从入门到实践》</a> 这本开源书籍中也已经给出了使用 Docker 的原因。</p>
<p><img src="https://img-blog.csdnimg.cn/20210412220015698.png" alt="" /></p>
<h2 id="docker-的安装"> Docker 的安装</h2>
<h3 id="windows"> Windows</h3>
<p>接下来对 Docker 进行安装，以 Windows 系统为例，访问 Docker 的官网：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4e3146984adaee0067bdc5e9b1d757bb479.png" alt="" /></p>
<p>然后点击<code>Get Started</code>：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-96adfbfebe3e59097c8ba25e55f68ba7908.png" alt="" /></p>
<p>在此处点击<code>Download for Windows</code>即可进行下载。</p>
<p>如果你的电脑是<code>Windows 10 64位专业版</code>的操作系统，则在安装 Docker 之前需要开启一下<code>Hyper-V</code>，开启方式如下。打开控制面板，选择程序：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-73ce678240826de0f49225250a970b4d205.png" alt="" /></p>
<p>点击<code>启用或关闭Windows功能</code>：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9c7a96c332e56b9506325a1f1fdb608a659.png" alt="" /></p>
<p>勾选上<code>Hyper-V</code>，点击确定即可：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-aad4a58c5e917f7185908d6320d7fb06861.png" alt="" /></p>
<p>完成更改后需要重启一下计算机。</p>
<p>开启了<code>Hyper-V</code>后，我们就可以对 Docker 进行安装了，打开安装程序后，等待片刻点击<code>Ok</code>即可：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-62ac3c9184bdc21387755294613ff5054c6.png" alt="" /></p>
<p>安装完成后，我们仍然需要重启计算机，重启后，若提示如下内容：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3585c7d6a4632134ed925493a7d43e14a43.png" alt="" /></p>
<p>它的意思是询问我们是否使用 WSL2，这是基于 Windows 的一个 Linux 子系统，这里我们取消即可，它就会使用我们之前勾选的<code>Hyper-V</code>虚拟机。</p>
<p>因为是图形界面的操作，这里就不介绍 Docker Desktop 的具体用法了。</p>
<h3 id="mac"> Mac</h3>
<p>直接使用 Homebrew 安装即可</p>
<div><pre><code>brew <span>install</span> --cask docker
</code></pre>
<div><span>1</span><br></div></div><h3 id="linux"> Linux</h3>
<p>下面来看看 Linux 中如何安装 Docker，这里以 CentOS7 为例。</p>
<p>在测试或开发环境中，Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，执行这个脚本后就会自动地将一切准备工作做好，并且把 Docker 的稳定版本安装在系统中。</p>
<div><pre><code><span>curl</span> -fsSL get.docker.com -o get-docker.sh
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>sh</span> get-docker.sh --mirror Aliyun
</code></pre>
<div><span>1</span><br></div></div><p>安装完成后直接启动服务：</p>
<div><pre><code>systemctl start docker
</code></pre>
<div><span>1</span><br></div></div><p>推荐设置开机自启，执行指令：</p>
<div><pre><code>systemctl <span>enable</span> docker
</code></pre>
<div><span>1</span><br></div></div><h2 id="docker-中的几个概念"> Docker 中的几个概念</h2>
<p>在正式学习 Docker 之前，我们需要了解 Docker 中的几个核心概念：</p>
<h3 id="镜像"> 镜像</h3>
<p>镜像就是一个只读的模板，镜像可以用来创建 Docker 容器，一个镜像可以创建多个容器</p>
<h3 id="容器"> 容器</h3>
<p>容器是用镜像创建的运行实例，Docker 利用容器独立运行一个或一组应用。它可以被启动、开始、停止、删除，每个容器都是相互隔离的、保证安全的平台。 可以把容器看作是一个简易的 Linux 环境和运行在其中的应用程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的</p>
<h3 id="仓库"> 仓库</h3>
<p>仓库是集中存放镜像文件的场所。仓库和仓库注册服务器是有区别的，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签。 仓库分为公开仓库和私有仓库两种形式，最大的公开仓库是 DockerHub，存放了数量庞大的镜像供用户下载，国内的公开仓库有阿里云、网易云等</p>
<h3 id="总结"> 总结</h3>
<p>通俗点说，一个镜像就代表一个软件；而基于某个镜像运行就是生成一个程序实例，这个程序实例就是容器；而仓库是用来存储 Docker 中所有镜像的。</p>
<p>其中仓库又分为远程仓库和本地仓库，和 Maven 类似，倘若每次都从远程下载依赖，则会大大降低效率，为此，Maven 的策略是第一次访问依赖时，将其下载到本地仓库，第二次、第三次使用时直接用本地仓库的依赖即可，Docker 的远程仓库和本地仓库的作用也是类似的。</p>
<h2 id="docker-初体验"> Docker 初体验</h2>
<p>下面我们来对 Docker 进行一个初步的使用，这里以下载一个 MySQL 的镜像为例<code>(在CentOS7下进行)</code>。</p>
<p>和 GitHub 一样，Docker 也提供了一个 DockerHub 用于查询各种镜像的地址和安装教程，为此，我们先访问 DockerHub：<a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">https://hub.docker.com/</a></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-37d083cc92fe36aad829e975646b9d27fa0.png" alt="" /></p>
<p>在左上角的搜索框中输入<code>MySQL</code>并回车：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ced37002391a059754def9b3a6c2aa4e342.png" alt="" /></p>
<p>可以看到相关 MySQL 的镜像非常多，若右上角有<code>OFFICIAL IMAGE</code>标识，则说明是官方镜像，所以我们点击第一个 MySQL 镜像：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-48ba3fdc99c93a96e18b929195ca8e93c6c.png" alt="" /></p>
<p>右边提供了下载 MySQL 镜像的指令为<code>docker pull MySQL</code>，但该指令始终会下载 MySQL 镜像的最新版本。</p>
<p>若是想下载指定版本的镜像，则点击下面的<code>View Available Tags</code>：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ed601649275c6cfe65bbe422b463c263a64.png" alt="" /></p>
<p>这里就可以看到各种版本的镜像，右边有下载的指令，所以若是想下载 5.7.32 版本的 MySQL 镜像，则执行：</p>
<div><pre><code>docker pull MySQL:5.7.32
</code></pre>
<div><span>1</span><br></div></div><p>然而下载镜像的过程是非常慢的，所以我们需要配置一下镜像源加速下载，访问<code>阿里云</code>官网：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0a46effd262d3db1b613a0db597efa31f34.png" alt="" /></p>
<p>点击控制台：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-60f198e0106be6b43044969d2900272504f.png" alt="" /></p>
<p>然后点击左上角的菜单，在弹窗的窗口中，将鼠标悬停在产品与服务上，并在右侧搜索容器镜像服务，最后点击容器镜像服务：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2f6706a979b405dab01bc44a29bb6b26fc4.png" alt="" /></p>
<p>点击左侧的镜像加速器，并依次执行右侧的配置指令即可。</p>
<div><pre><code><span>sudo</span> <span>mkdir</span> -p /etc/docker
<span>sudo</span> <span>tee</span> /etc/docker/daemon.json <span>&lt;&lt;-</span><span>'EOF'
{
  "registry-mirrors": ["https://679xpnpz.mirror.aliyuncs.com"]
}
EOF</span>
<span>sudo</span> systemctl daemon-reload
<span>sudo</span> systemctl restart docker
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="docker-镜像指令"> Docker 镜像指令</h2>
<p>Docker 需要频繁地操作相关的镜像，所以我们先来了解一下 Docker 中的镜像指令。</p>
<p>若想查看 Docker 中当前拥有哪些镜像，则可以使用 <code>docker images</code> 命令。</p>
<div><pre><code><span>[</span>root@izrcf5u3j3q8xaz ~<span>]</span><span># docker images</span>
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
MySQL         <span>5.7</span>.32    f07dfa83b528   <span>11</span> days ago     448MB
tomcat        latest    feba8d001e3f   <span>2</span> weeks ago     649MB
nginx         latest    ae2feff98a0c   <span>2</span> weeks ago     133MB
hello-world   latest    bf756fb1ae65   <span>12</span> months ago   <span>13</span>.3kB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>其中<code>REPOSITORY</code>为镜像名，<code>TAG</code>为版本标志，<code>IMAGE ID</code>为镜像 id(唯一的)，<code>CREATED</code>为创建时间，注意这个时间并不是我们将镜像下载到 Docker 中的时间，而是镜像创建者创建的时间，<code>SIZE</code>为镜像大小。</p>
<p>该指令能够查询指定镜像名：</p>
<div><pre><code>docker image MySQL
</code></pre>
<div><span>1</span><br></div></div><p>若如此做，则会查询出 Docker 中的所有 MySQL 镜像：</p>
<div><pre><code><span>[</span>root@izrcf5u3j3q8xaz ~<span>]</span><span># docker images MySQL</span>
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
MySQL        <span>5.6</span>       0ebb5600241d   <span>11</span> days ago     302MB
MySQL        <span>5.7</span>.32    f07dfa83b528   <span>11</span> days ago     448MB
MySQL        <span>5.5</span>       d404d78aa797   <span>20</span> months ago   205MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>该指令还能够携带<code>-q</code>参数：<code>docker images -q</code> ， <code>-q</code>表示仅显示镜像的 id：</p>
<div><pre><code><span>[</span>root@izrcf5u3j3q8xaz ~<span>]</span><span># docker images -q</span>
0ebb5600241d
f07dfa83b528
feba8d001e3f
d404d78aa797
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>若是要下载镜像，则使用：</p>
<div><pre><code>docker pull MySQL:5.7
</code></pre>
<div><span>1</span><br></div></div><p><code>docker pull</code>是固定的，后面写上需要下载的镜像名及版本标志；若是不写版本标志，而是直接执行<code>docker pull MySQL</code>，则会下载镜像的最新版本。</p>
<p>一般在下载镜像前我们需要搜索一下镜像有哪些版本才能对指定版本进行下载，使用指令：</p>
<div><pre><code>docker search MySQL
</code></pre>
<div><span>1</span><br></div></div><p><img src="https://oscimg.oschina.net/oscnet/up-559083ae80e7501e86e95fbbad25b6d571a.png" alt="" /></p>
<p>不过该指令只能查看 MySQL 相关的镜像信息，而不能知道有哪些版本，若想知道版本，则只能这样查询：</p>
<div><pre><code>docker search MySQL:5.5
</code></pre>
<div><span>1</span><br></div></div><p><img src="https://oscimg.oschina.net/oscnet/up-68394e25f652964bb042571151c5e0fd2e9.png" alt="" /></p>
<p>若是查询的版本不存在，则结果为空：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-abfdd51b9ad2ced3711268369f52b077b12.png" alt="" /></p>
<p>删除镜像使用指令：</p>
<div><pre><code>docker image <span>rm</span> MySQL:5.5
</code></pre>
<div><span>1</span><br></div></div><p>若是不指定版本，则默认删除的也是最新版本。</p>
<p>还可以通过指定镜像 id 进行删除：</p>
<div><pre><code>docker image <span>rm</span> bf756fb1ae65
</code></pre>
<div><span>1</span><br></div></div><p>然而此时报错了：</p>
<div><pre><code><span>[</span>root@izrcf5u3j3q8xaz ~<span>]</span><span># docker image rm bf756fb1ae65</span>
Error response from daemon: conflict: unable to delete bf756fb1ae65 <span>(</span>must be forced<span>)</span> - image is being used by stopped container d5b6c177c151
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这是因为要删除的<code>hello-world</code>镜像正在运行中，所以无法删除镜像，此时需要强制执行删除：</p>
<div><pre><code>docker image <span>rm</span> -f bf756fb1ae65
</code></pre>
<div><span>1</span><br></div></div><p>该指令会将镜像和通过该镜像执行的容器全部删除，谨慎使用。</p>
<p>Docker 还提供了删除镜像的简化版本：<code>docker rmi 镜像名:版本标志</code> 。</p>
<p>此时我们即可借助<code>rmi</code>和<code>-q</code>进行一些联合操作，比如现在想删除所有的 MySQL 镜像，那么你需要查询出 MySQL 镜像的 id，并根据这些 id 一个一个地执行<code>docker rmi</code>进行删除，但是现在，我们可以这样：</p>
<div><pre><code>docker rmi -f <span><span>$(</span>docker images MySQL -q<span>)</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>首先通过<code>docker images MySQL -q</code>查询出 MySQL 的所有镜像 id，<code>-q</code>表示仅查询 id，并将这些 id 作为参数传递给<code>docker rmi -f</code>指令，这样所有的 MySQL 镜像就都被删除了。</p>
<h2 id="docker-容器指令"> Docker 容器指令</h2>
<p>掌握了镜像的相关指令之后，我们需要了解一下容器的指令，容器是基于镜像的。</p>
<p>若需要通过镜像运行一个容器，则使用：</p>
<div><pre><code>docker run tomcat:8.0-jre8
</code></pre>
<div><span>1</span><br></div></div><p>当然了，运行的前提是你拥有这个镜像，所以先下载镜像：</p>
<div><pre><code>docker pull tomcat:8.0-jre8
</code></pre>
<div><span>1</span><br></div></div><p>下载完成后就可以运行了，运行后查看一下当前运行的容器：<code>docker ps</code> 。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bd48e20ef07b7c91ad16f92821a3dbca5b5.png" alt="" /></p>
<p>其中<code>CONTAINER_ID</code>为容器的 id，<code>IMAGE</code>为镜像名，<code>COMMAND</code>为容器内执行的命令，<code>CREATED</code>为容器的创建时间，<code>STATUS</code>为容器的状态，<code>PORTS</code>为容器内服务监听的端口，<code>NAMES</code>为容器的名称。</p>
<p>通过该方式运行的 tomcat 是不能直接被外部访问的，因为容器具有隔离性，若是想直接通过 8080 端口访问容器内部的 tomcat，则需要对宿主机端口与容器内的端口进行映射：</p>
<div><pre><code>docker run -p <span>8080</span>:8080 tomcat:8.0-jre8
</code></pre>
<div><span>1</span><br></div></div><p>解释一下这两个端口的作用(<code>8080:8080</code>)，第一个 8080 为宿主机端口，第二个 8080 为容器内的端口，外部访问 8080 端口就会通过映射访问容器内的 8080 端口。</p>
<p>此时外部就可以访问 Tomcat 了：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-16d9ff4d29094681f51424ea8d0ee4fd73e.png" alt="" /></p>
<p>若是这样进行映射：</p>
<div><pre><code>docker run -p <span>8088</span>:8080 tomcat:8.0-jre8
</code></pre>
<div><span>1</span><br></div></div><p>则外部需访问 8088 端口才能访问 tomcat，需要注意的是，每次运行的容器都是相互独立的，所以同时运行多个 tomcat 容器并不会产生端口的冲突。</p>
<p>容器还能够以后台的方式运行，这样就不会占用终端：</p>
<div><pre><code>docker run -d -p <span>8080</span>:8080 tomcat:8.0-jre8
</code></pre>
<div><span>1</span><br></div></div><p>启动容器时默认会给容器一个名称，但这个名称其实是可以设置的，使用指令：</p>
<div><pre><code>docker run -d -p <span>8080</span>:8080 --name tomcat01 tomcat:8.0-jre8
</code></pre>
<div><span>1</span><br></div></div><p>此时的容器名称即为 tomcat01，容器名称必须是唯一的。</p>
<p>再来引申一下<code>docker ps</code>中的几个指令参数，比如<code>-a</code>：</p>
<div><pre><code>docker <span>ps</span> -a
</code></pre>
<div><span>1</span><br></div></div><p>该参数会将运行和非运行的容器全部列举出来：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-16d9ff4d29094681f51424ea8d0ee4fd73e.png" alt="" /></p>
<p><code>-q</code>参数将只查询正在运行的容器 id：<code>docker ps -q</code> 。</p>
<div><pre><code><span>[</span>root@izrcf5u3j3q8xaz ~<span>]</span><span># docker ps -q</span>
f3aac8ee94a3
074bf575249b
1d557472a708
4421848ba294
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>若是组合使用，则查询运行和非运行的所有容器 id：<code>docker ps -qa</code> 。</p>
<div><pre><code><span>[</span>root@izrcf5u3j3q8xaz ~<span>]</span><span># docker ps -aq</span>
f3aac8ee94a3
7f7b0e80c841
074bf575249b
a1e830bddc4c
1d557472a708
4421848ba294
b0440c0a219a
c2f5d78c5d1a
5831d1bab2a6
d5b6c177c151
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>接下来是容器的停止、重启指令，因为非常简单，就不过多介绍了。</p>
<div><pre><code>docker start c2f5d78c5d1a
</code></pre>
<div><span>1</span><br></div></div><p>通过该指令能够将已经停止运行的容器运行起来，可以通过容器的 id 启动，也可以通过容器的名称启动。</p>
<div><pre><code>docker restart c2f5d78c5d1a
</code></pre>
<div><span>1</span><br></div></div><p>该指令能够重启指定的容器。</p>
<div><pre><code>docker stop c2f5d78c5d1a
</code></pre>
<div><span>1</span><br></div></div><p>该指令能够停止指定的容器。</p>
<div><pre><code>docker <span>kill</span> c2f5d78c5d1a
</code></pre>
<div><span>1</span><br></div></div><p>该指令能够直接杀死指定的容器。</p>
<p>以上指令都能够通过容器的 id 和容器名称两种方式配合使用。</p>
<hr>
<p>当容器被停止之后，容器虽然不再运行了，但仍然是存在的，若是想删除它，则使用指令：</p>
<div><pre><code>docker <span>rm</span> d5b6c177c151
</code></pre>
<div><span>1</span><br></div></div><p>需要注意的是容器的 id 无需全部写出来，只需唯一标识即可。</p>
<p>若是想删除正在运行的容器，则需要添加<code>-f</code>参数强制删除：</p>
<div><pre><code>docker <span>rm</span> -f d5b6c177c151
</code></pre>
<div><span>1</span><br></div></div><p>若是想删除所有容器，则可以使用组合指令：</p>
<div><pre><code>docker <span>rm</span> -f <span><span>$(</span>docker <span>ps</span> -qa<span>)</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>先通过<code>docker ps -qa</code>查询出所有容器的 id，然后通过<code>docker rm -f</code>进行删除。</p>
<hr>
<p>当容器以后台的方式运行时，我们无法知晓容器的运行状态，若此时需要查看容器的运行日志，则使用指令：</p>
<div><pre><code>docker logs 289cc00dc5ed
</code></pre>
<div><span>1</span><br></div></div><p>这样的方式显示的日志并不是实时的，若是想实时显示，需要使用<code>-f</code>参数：</p>
<div><pre><code>docker logs -f 289cc00dc5ed
</code></pre>
<div><span>1</span><br></div></div><p>通过<code>-t</code>参数还能够显示日志的时间戳，通常与<code>-f</code>参数联合使用：</p>
<div><pre><code>docker logs -ft 289cc00dc5ed
</code></pre>
<div><span>1</span><br></div></div><hr>
<p>查看容器内运行了哪些进程，可以使用指令：</p>
<div><pre><code>docker <span>top</span> 289cc00dc5ed
</code></pre>
<div><span>1</span><br></div></div><p><img src="https://oscimg.oschina.net/oscnet/up-7ec71a682712e56e90490f55c32cf660fd3.png" alt="" /></p>
<p>若是想与容器进行交互，则使用指令：</p>
<div><pre><code>docker <span>exec</span> -it 289cc00dc5ed <span>bash</span>
</code></pre>
<div><span>1</span><br></div></div><p><img src="https://oscimg.oschina.net/oscnet/up-fd17796322f833685ca8ead592d38581898.png" alt="" /></p>
<p>此时终端将会进入容器内部，执行的指令都将在容器中生效，在容器内只能执行一些比较简单的指令，如：ls、cd 等，若是想退出容器终端，重新回到 CentOS 中，则执行<code>exit</code>即可。</p>
<p>现在我们已经能够进入容器终端执行相关操作了，那么该如何向 tomcat 容器中部署一个项目呢？</p>
<div><pre><code>docker <span>cp</span> ./test.html 289cc00dc5ed:/usr/local/tomcat/webapps
</code></pre>
<div><span>1</span><br></div></div><p>通过<code>docker cp</code>指令能够将文件从 CentOS 复制到容器中，<code>./test.html</code>为 CentOS 中的资源路径，<code>289cc00dc5ed</code>为容器 id，<code>/usr/local/tomcat/webapps</code>为容器的资源路径，此时<code>test.html</code>文件将会被复制到该路径下。</p>
<div><pre><code><span>[</span>root@izrcf5u3j3q8xaz ~<span>]</span><span># docker exec -it 289cc00dc5ed bash</span>
root@289cc00dc5ed:/usr/local/tomcat<span># cd webapps</span>
root@289cc00dc5ed:/usr/local/tomcat/webapps<span># ls</span>
test.html
root@289cc00dc5ed:/usr/local/tomcat/webapps<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>若是想将容器内的文件复制到 CentOS 中，则反过来写即可：</p>
<div><pre><code>docker <span>cp</span> 289cc00dc5ed:/usr/local/tomcat/webapps/test.html ./
</code></pre>
<div><span>1</span><br></div></div><p>所以现在若是想要部署项目，则先将项目上传到 CentOS，然后将项目从 CentOS 复制到容器内，此时启动容器即可。</p>
<hr>
<p>虽然使用 Docker 启动软件环境非常简单，但同时也面临着一个问题，我们无法知晓容器内部具体的细节，比如监听的端口、绑定的 ip 地址等等，好在这些 Docker 都帮我们想到了，只需使用指令：</p>
<div><pre><code>docker inspect 923c969b0d91
</code></pre>
<div><span>1</span><br></div></div><p><img src="https://oscimg.oschina.net/oscnet/up-fca74d4350cdfebfc2b06101e1cab411619.png" alt="" /></p>
<h2 id="docker-数据卷"> Docker 数据卷</h2>
<p>学习了容器的相关指令之后，我们来了解一下 Docker 中的数据卷，它能够实现宿主机与容器之间的文件共享，它的好处在于我们对宿主机的文件进行修改将直接影响容器，而无需再将宿主机的文件再复制到容器中。</p>
<p>现在若是想将宿主机中<code>/opt/apps</code>目录与容器中<code>webapps</code>目录做一个数据卷，则应该这样编写指令：</p>
<div><pre><code>docker run -d -p <span>8080</span>:8080 --name tomcat01 -v /opt/apps:/usr/local/tomcat/webapps tomcat:8.0-jre8
</code></pre>
<div><span>1</span><br></div></div><p>然而此时访问 tomcat 会发现无法访问：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-8fa1b23f6ea2567b5938370e7d7f636533f.png" alt="" /></p>
<p>这就说明我们的数据卷设置成功了，Docker 会将容器内的<code>webapps</code>目录与<code>/opt/apps</code>目录进行同步，而此时<code>/opt/apps</code>目录是空的，导致<code>webapps</code>目录也会变成空目录，所以就访问不到了。</p>
<p>此时我们只需向<code>/opt/apps</code>目录下添加文件，就会使得<code>webapps</code>目录也会拥有相同的文件，达到文件共享，测试一下：</p>
<div><pre><code><span>[</span>root@centos-7 opt<span>]</span><span># cd apps/</span>
<span>[</span>root@centos-7 apps<span>]</span><span># vim test.html</span>
<span>[</span>root@centos-7 apps<span>]</span><span># ls</span>
test.html
<span>[</span>root@centos-7 apps<span>]</span><span># cat test.html</span>
<span>&lt;</span>h<span><span>1</span>></span>This is a <span>test</span> html<span>!</span><span>&lt;</span>/h<span><span>1</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在<code>/opt/apps</code>目录下创建了一个 <code>test.html</code> 文件，那么容器内的<code>webapps</code>目录是否会有该文件呢？进入容器的终端：</p>
<div><pre><code><span>[</span>root@centos-7 apps<span>]</span><span># docker exec -it tomcat01 bash</span>
root@115155c08687:/usr/local/tomcat<span># cd webapps/</span>
root@115155c08687:/usr/local/tomcat/webapps<span># ls</span>
test.html
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>容器内确实已经有了该文件，那接下来我们编写一个简单的 Web 应用：</p>
<div><pre><code><span>public</span> <span>class</span> <span>HelloServlet</span> <span>extends</span> <span>HttpServlet</span> <span>{</span>

    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>doGet</span><span>(</span><span>HttpServletRequest</span> req<span>,</span> <span>HttpServletResponse</span> resp<span>)</span> <span>throws</span> <span>ServletException</span><span>,</span> <span>IOException</span> <span>{</span>
        resp<span>.</span><span>getWriter</span><span>(</span><span>)</span><span>.</span><span>println</span><span>(</span><span>"Hello World!"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>doPost</span><span>(</span><span>HttpServletRequest</span> req<span>,</span> <span>HttpServletResponse</span> resp<span>)</span> <span>throws</span> <span>ServletException</span><span>,</span> <span>IOException</span> <span>{</span>
        <span>doGet</span><span>(</span>req<span>,</span>resp<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这是一个非常简单的 Servlet，我们将其打包上传到<code>/opt/apps</code>中，那么容器内肯定就会同步到该文件，此时进行访问：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-712716a8c8c444ba3a77ade8ff27e7c6cf5.png" alt="" /></p>
<p>这种方式设置的数据卷称为自定义数据卷，因为数据卷的目录是由我们自己设置的，Docker 还为我们提供了另外一种设置数据卷的方式：</p>
<div><pre><code>docker run -d -p <span>8080</span>:8080 --name tomcat01 -v aa:/usr/local/tomcat/webapps tomcat:8.0-jre8
</code></pre>
<div><span>1</span><br></div></div><p>此时的<code>aa</code>并不是数据卷的目录，而是数据卷的别名，Docker 会为我们自动创建一个名为<code>aa</code>的数据卷，并且会将容器内<code>webapps</code>目录下的所有内容复制到数据卷中，该数据卷的位置在<code>/var/lib/docker/volumes</code>目录下：</p>
<div><pre><code><span>[</span>root@centos-7 volumes<span>]</span><span># pwd</span>
/var/lib/docker/volumes
<span>[</span>root@centos-7 volumes<span>]</span><span># cd aa/</span>
<span>[</span>root@centos-7 aa<span>]</span><span># ls</span>
_data
<span>[</span>root@centos-7 aa<span>]</span><span># cd _data/</span>
<span>[</span>root@centos-7 _data<span>]</span><span># ls</span>
docs  examples  host-manager  manager  ROOT
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>此时我们只需修改该目录的内容就能能够影响到容器。</p>
<hr>
<p>最后再介绍几个容器和镜像相关的指令：</p>
<div><pre><code>docker commit -m <span>"描述信息"</span> -a <span>"镜像作者"</span> tomcat01 my_tomcat:1.0
</code></pre>
<div><span>1</span><br></div></div><p>该指令能够将容器打包成一个镜像，此时查询镜像：</p>
<div><pre><code><span>[</span>root@centos-7 _data<span>]</span><span># docker images</span>
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
my_tomcat           <span>1.0</span>                 79ab047fade5        <span>2</span> seconds ago       463MB
tomcat              <span>8</span>                   a041be4a5ba5        <span>2</span> weeks ago         533MB
MySQL               latest              db2b37ec6181        <span>2</span> months ago        545MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>若是想将镜像备份出来，则可以使用指令：</p>
<div><pre><code>docker save my_tomcat:1.0 -o my-tomcat-1.0.tar
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>[</span>root@centos-7 ~<span>]</span><span># docker save my_tomcat:1.0 -o my-tomcat-1.0.tar</span>
<span>[</span>root@centos-7 ~<span>]</span><span># ls</span>
anaconda-ks.cfg  initial-setup-ks.cfg  公共  视频  文档  音乐
get-docker.sh    my-tomcat-1.0.tar     模板  图片  下载  桌面
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>若是拥有<code>.tar</code>格式的镜像，该如何将其加载到 Docker 中呢？执行指令：</p>
<div><pre><code>docker load -i my-tomcat-1.0.tar
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>root@centos-7 ~<span>]</span><span># docker load -i my-tomcat-1.0.tar</span>
b28ef0b6fef8: Loading layer <span>[</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>></span><span>]</span>  <span>105</span>.5MB/105.5MB
0b703c74a09c: Loading layer <span>[</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>></span><span>]</span>  <span>23</span>.99MB/23.99MB
<span>..</span><span>..</span><span>..</span>
Loaded image: my_tomcat:1.0
<span>[</span>root@centos-7 ~<span>]</span><span># docker images</span>
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
my_tomcat           <span>1.0</span>                 79ab047fade5        <span>7</span> minutes ago       463MB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/container.png" type="image/png"/>
    </item>
    <item>
      <title>Git 入门</title>
      <link>https://javaguide.cn/tools/git/git-intro/</link>
      <guid>https://javaguide.cn/tools/git/git-intro/</guid>
      <source url="https://javaguide.cn/rss.xml">Git 入门</source>
      <category>开发工具</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="版本控制"> 版本控制</h2>
<h3 id="什么是版本控制"> 什么是版本控制</h3>
<p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。</p>
<h3 id="为什么要版本控制"> 为什么要版本控制</h3>
<p>有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。</p>
<h3 id="本地版本控制系统"> 本地版本控制系统</h3>
<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p>
<p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/本地版本控制系统.png" alt="本地版本控制系统" /></p>
<h3 id="集中化的版本控制系统"> 集中化的版本控制系统</h3>
<p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。</p>
<p>集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/集中化的版本控制系统.png" alt="集中化的版本控制系统" /></p>
<p>这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：</p>
<ul>
<li><strong>单点故障：</strong> 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏又没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</li>
<li><strong>必须联网才能工作：</strong> 受网络状况、带宽影响。</li>
</ul>
<h3 id="分布式版本控制系统"> 分布式版本控制系统</h3>
<p>于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。</p>
<p>这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/分布式版本控制系统.png" alt="分布式版本控制系统" /></p>
<p>分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<p>分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。</p>
<h2 id="认识-git"> 认识 Git</h2>
<h3 id="git-简史"> Git 简史</h3>
<p>Linux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。</p>
<h3 id="git-与其他版本管理系统的主要区别"> Git 与其他版本管理系统的主要区别</h3>
<p>Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。</p>
<p>下面我们主要说一个关于 Git 与其他版本管理系统的主要差别：<strong>对待数据的方式</strong>。</p>
<p><strong>Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。</strong></p>
<p>大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统<strong>将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</strong></p>
<p>具体原理如下图所示，理解起来其实很简单，每当我们提交更新一个文件之后，系统都会记录这个文件做了哪些更新，以增量符号Δ(Delta)表示。</p>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3deltas.png" width="500px"/>
</br>
</div>
<p><strong>我们怎样才能得到一个文件的最终版本呢？</strong></p>
<p>很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。</p>
<p><strong>这种方式有什么问题呢？</strong></p>
<p>比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。</p>
<p>Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。</p>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3snapshots.png" width="500px"/>
</br>
</div>
<h3 id="git-的三种状态"> Git 的三种状态</h3>
<p>Git 有三种状态，你的文件可能处于其中之一：</p>
<ol>
<li><strong>已提交（committed）</strong>：数据已经安全的保存在本地数据库中。</li>
<li><strong>已修改（modified）</strong>：已修改表示修改了文件，但还没保存到数据库中。</li>
<li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
</ol>
<p>由此引入 Git 项目的三个工作区域的概念：<strong>Git 仓库(.git directory)</strong>、<strong>工作目录(Working Directory)</strong> 以及 <strong>暂存区域(Staging Area)</strong> 。</p>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3areas.png" width="500px"/>
</div>
<p><strong>基本的 Git 工作流程如下：</strong></p>
<ol>
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>
</ol>
<h2 id="git-使用快速入门"> Git 使用快速入门</h2>
<h3 id="获取-git-仓库"> 获取 Git 仓库</h3>
<p>有两种取得 Git 项目仓库的方法。</p>
<ol>
<li>在现有目录中初始化仓库: 进入项目目录运行  <code>git init</code>  命令,该命令将创建一个名为 <code>.git</code> 的子目录。</li>
<li>从一个服务器克隆一个现有的 Git 仓库: <code>git clone [url]</code> 自定义本地仓库的名字: <code>git clone [url] directoryname</code></li>
</ol>
<h3 id="记录每次更新到仓库"> 记录每次更新到仓库</h3>
<ol>
<li><strong>检测当前文件状态</strong> : <code>git status</code></li>
<li><strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code> (针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）</li>
<li><strong>忽略文件</strong>：<code>.gitignore</code> 文件</li>
<li><strong>提交更新:</strong> <code>git commit -m &quot;代码提交信息&quot;</code> （每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>）</li>
<li><strong>跳过使用暂存区域更新的方式</strong> : <code>git commit -a -m &quot;代码提交信息&quot;</code>。 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</li>
<li><strong>移除文件</strong> ：<code>git rm filename</code>  （从暂存区域移除，然后提交。）</li>
<li><strong>对文件重命名</strong> ：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)</li>
</ol>
<h3 id="一个好的-git-提交消息"> 一个好的 Git 提交消息</h3>
<p>一个好的 Git 提交消息如下：</p>
<div><pre><code>标题行：用这一行来描述和解释你的这次提交

主体部分可以是很少的几行，来加入更多的细节来解释提交，最好是能给出一些相关的背景或者解释这个提交能修复和解决什么问题。

主体部分当然也可以有几段，但是一定要注意换行和句子不要太长。因为这样在使用 &quot;git log&quot; 的时候会有缩进比较好看。
</code></pre>
</div><p>提交的标题行描述应该尽量的清晰和尽量的一句话概括。这样就方便相关的 Git 日志查看工具显示和其他人的阅读。</p>
<h3 id="推送改动到远程仓库"> 推送改动到远程仓库</h3>
<ul>
<li>
<p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<code>git remote add origin &lt;server&gt;</code> ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code></p>
</li>
<li>
<p>将这些改动提交到远端仓库：<code>git push origin master</code> (可以把 <em>master</em> 换成你想要推送的任何分支)</p>
<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>
</li>
</ul>
<h3 id="远程仓库的移除与重命名"> 远程仓库的移除与重命名</h3>
<ul>
<li>将 test 重命名为 test1：<code>git remote rename test test1</code></li>
<li>移除远程仓库 test1:<code>git remote rm test1</code></li>
</ul>
<h3 id="查看提交历史"> 查看提交历史</h3>
<p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。</p>
<p><strong>可以添加一些参数来查看自己希望看到的内容：</strong></p>
<p>只看某个人的提交记录：</p>
<div><pre><code><span>git</span> log --author<span>=</span>bob
</code></pre>
<div><span>1</span><br></div></div><h3 id="撤销操作"> 撤销操作</h3>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>
<div><pre><code><span>git</span> commit --amend
</code></pre>
<div><span>1</span><br></div></div><p>取消暂存的文件</p>
<div><pre><code><span>git</span> reset filename
</code></pre>
<div><span>1</span><br></div></div><p>撤消对文件的修改:</p>
<div><pre><code><span>git</span> checkout -- filename
</code></pre>
<div><span>1</span><br></div></div><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p>
<div><pre><code><span>git</span> fetch origin
<span>git</span> reset --hard origin/master
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="分支"> 分支</h3>
<p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认”的分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>
<p>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p>
<p>创建一个名字叫做 test 的分支</p>
<div><pre><code><span>git</span> branch <span>test</span>
</code></pre>
<div><span>1</span><br></div></div><p>切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）</p>
<div><pre><code><span>git</span> checkout <span>test</span>
</code></pre>
<div><span>1</span><br></div></div><div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3切换分支.png" width="500px"/>
</div>
<p>你也可以直接这样创建分支并切换过去(上面两条命令的合写)</p>
<div><pre><code><span>git</span> checkout -b feature_x
</code></pre>
<div><span>1</span><br></div></div><p>切换到主分支</p>
<div><pre><code><span>git</span> checkout master
</code></pre>
<div><span>1</span><br></div></div><p>合并分支(可能会有冲突)</p>
<div><pre><code> <span>git</span> merge <span>test</span>
</code></pre>
<div><span>1</span><br></div></div><p>把新建的分支删掉</p>
<div><pre><code><span>git</span> branch -d feature_x
</code></pre>
<div><span>1</span><br></div></div><p>将分支推送到远端仓库（推送成功后其他人可见）：</p>
<div><pre><code><span>git</span> push origin
</code></pre>
<div><span>1</span><br></div></div><h2 id="推荐"> 推荐</h2>
<p><strong>在线演示学习工具：</strong></p>
<p>「补充，来自<a href="https://github.com/Snailclimb/JavaGuide/issues/729" target="_blank" rel="noopener noreferrer">issue729</a>」Learn Git Branching https://oschina.gitee.io/learn-git-branching/ 。该网站可以方便的演示基本的git操作，讲解得明明白白。每一个基本命令的作用和结果。</p>
<p><strong>推荐阅读：</strong></p>
<ul>
<li><a href="https://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener noreferrer">Git - 简明指南</a></li>
<li><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener noreferrer">图解Git</a></li>
<li><a href="https://backlog.com/git-tutorial/cn/intro/intro1_1.html" target="_blank" rel="noopener noreferrer">猴子都能懂得Git入门</a></li>
<li>https://git-scm.com/book/en/v2</li>
<li><a href="https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener noreferrer">Generating a new SSH key and adding it to the ssh-agent</a></li>
<li><a href="https://github.com/torvalds/subsurface-for-dirk/blob/a48494d2fbed58c751e9b7e8fbff88582f9b2d02/README#L88" target="_blank" rel="noopener noreferrer">一个好的 Git 提交消息，出自 Linus 之手</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/本地版本控制系统.png" type="image/png"/>
    </item>
    <item>
      <title>Github 小技巧</title>
      <link>https://javaguide.cn/tools/git/github-tips/</link>
      <guid>https://javaguide.cn/tools/git/github-tips/</guid>
      <source url="https://javaguide.cn/rss.xml">Github 小技巧</source>
      <category>开发工具</category>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>我使用 Github 已经有 6 年多了，今天毫无保留地把自己觉得比较有用的 Github 小技巧送给关注 JavaGuide 的各位小伙伴。</p>
<p>这篇文章肝了很久，就挺用心的，大家看内容就知道了。</p>
<h2 id="一键生成-github-简历-github-年报"> 一键生成 Github 简历 &amp; Github 年报</h2>
<p>通过 <a href="https://resume.github.io/" target="_blank" rel="noopener noreferrer">https://resume.github.io/</a> 这个网站你可以一键生成一个在线的 Github 简历。</p>
<p>当时我参加的校招的时候，个人信息那里就放了一个在线的 Github 简历。我觉得这样会让面试官感觉你是一个内行，会提高一些印象分。</p>
<p>但是，如果你的 Github 没有什么项目的话还是不要放在简历里面了。生成后的效果如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201108192205620.png" alt="Github简历" /></p>
<p>通过 https://www.githubtrends.io/wrapped 这个网站，你可以生成一份 Github 个人年报，这个年报会列举出你在这一年的项目贡献情况、最常使用的编程语言、详细的贡献信息。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/dootask/image-20211226144607457.png" alt="" /></p>
<h2 id="个性化-github-首页"> 个性化 Github 首页</h2>
<p>Github 目前支持在个人主页自定义展示一些内容。展示效果如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210616221212259.png" alt="个性化首页展示效果" /></p>
<p>想要做到这样非常简单，你只需要创建一个和你的 Github 账户同名的仓库，然后自定义<code>README.md</code>的内容即可。</p>
<p>展示在你主页的自定义内容就是<code>README.md</code>的内容（<em>不会 Markdown 语法的小伙伴自行面壁 5 分钟</em>）。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20201107110309341.png" alt="创建一个和你的Github账户同名的仓库" /></p>
<p>这个也是可以玩出花来的！比如说：通过 <a href="https://hellogithub.com/periodical/statistics/click/?target=https://github.com/anuraghazra/github-readme-stats" target="_blank" rel="noopener noreferrer">github-readme-stats</a> 这个开源项目，你可以 README 中展示动态生成的 GitHub 统计信息。展示效果如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210616221312426.png" alt="通过github-readme-stats动态生成GitHub统计信息 " /></p>
<p>关于个性化首页这个就不多提了，感兴趣的小伙伴自行研究一下。</p>
<h2 id="自定义项目徽章"> 自定义项目徽章</h2>
<p>你在 Github 上看到的项目徽章都是通过 <a href="https://shields.io/" target="_blank" rel="noopener noreferrer">https://shields.io/</a> 这个网站生成的。我的 JavaGuide 这个项目的徽章如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201107143136559.png" alt="项目徽章" /></p>
<p>并且，你不光可以生成静态徽章，shield.io 还可以动态读取你项目的状态并生成对应的徽章。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201107143502356.png" alt="自定义项目徽章" /></p>
<p>生成的描述项目状态的徽章效果如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201107143752642.png" alt="描述项目状态的徽章" /></p>
<h2 id="自动为项目添加贡献情况图标"> 自动为项目添加贡献情况图标</h2>
<p>通过 repobeats 这个工具可以为 Github 项目添加如下图所示的项目贡献基本情况图表，挺不错的 👍</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/dootask/repobeats.png" alt="" /></p>
<p>地址：https://repobeats.axiom.co/ 。</p>
<h2 id="github-表情"> Github 表情</h2>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201107162254582.png" alt="Github表情" /></p>
<p>如果你想要在 Github 使用表情的话，可以在这里找找 ：<a href="./www.webfx.com/tools/emoji-cheat-sheet/">www.webfx.com/tools/emoji-cheat-sheet/ </a>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201107162432941.png" alt="在线Github表情" /></p>
<h2 id="高效阅读-github-项目的源代码"> 高效阅读 Github 项目的源代码</h2>
<p>Github 前段时间推出的 Codespaces 可以提供类似 VS Code 的在线 IDE，不过目前还没有完全开发使用。</p>
<p>简单介绍几种我最常用的阅读 Github 项目源代码的方式。</p>
<h3 id="chrome-插件-octotree"> Chrome 插件 Octotree</h3>
<p>这个已经老生常谈了，是我最喜欢的一种方式。使用了 Octotree 之后网页侧边栏会按照树形结构展示项目，为我们带来 IDE 般的阅读源代码的感受。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201107144944798.png" alt="Chrome插件Octotree" /></p>
<h3 id="chrome-插件-sourcegraph"> Chrome 插件 SourceGraph</h3>
<p>我不想将项目 clone 到本地的时候一般就会使用这种方式来阅读项目源代码。SourceGraph 不仅可以让我们在 Github 优雅的查看代码，它还支持一些骚操作，比如：类之间的跳转、代码搜索等功能。</p>
<p>当你下载了这个插件之后，你的项目主页会多出一个小图标如下图所示。点击这个小图标即可在线阅读项目源代码。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201107145749659.png" alt="" /></p>
<p>使用 SourceGraph 阅读代码的就像下面这样，同样是树形结构展示代码，但是我个人感觉没有 Octotree 的手感舒服。不过，SourceGraph 内置了很多插件，而且还支持类之间的跳转！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201107150307314.png" alt="" /></p>
<h3 id="克隆项目到本地"> 克隆项目到本地</h3>
<p>先把项目克隆到本地，然后使用自己喜欢的 IDE 来阅读。可以说是最酸爽的方式了！</p>
<p>如果你想要深入了解某个项目的话，首选这种方式。一个<code>git clone</code> 就完事了。</p>
<h2 id="扩展-github-的功能"> 扩展 Github 的功能</h2>
<p><strong>Enhanced GitHub</strong> 可以让你的 Github 更好用。这个 Chrome 插件可以可视化你的 Github 仓库大小，每个文件的大小并且可以让你快速下载单个文件。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201107160817672.png" alt="" /></p>
<h2 id="自动为-markdown-文件生成目录"> 自动为 Markdown 文件生成目录</h2>
<p>如果你想为 Github 上的 Markdown 文件生成目录的话，通过 VS Code 的 <strong>Markdown Preview Enhanced</strong> 这个插件就可以了。</p>
<p>生成的目录效果如下图所示。你直接点击目录中的链接即可跳转到文章对应的位置，可以优化阅读体验。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/iShot2020-11-07 16.14.14 (1).png" alt="" /></p>
<p>不过，目前 Github 已经自动为 Markdown 文件生成了目录，只是需要通过点击的方式才能显示出来。</p>
<p>![image-20211227093215005](/Users/guide/Library/Application Support/typora-user-images/image-20211227093215005.png)</p>
<h2 id="善用-github-explore"> 善用 Github Explore</h2>
<p>其实，Github 自带的 Explore 是一个非常强大且好用的功能。不过，据我观察，国内很多 Github 用户都不知道这个到底是干啥的。</p>
<p>简单来说，Github Explore 可以为你带来下面这些服务：</p>
<ol>
<li>可以根据你的个人兴趣为你推荐项目；</li>
<li>Githunb Topics 按照类别/话题将一些项目进行了分类汇总。比如 <a href="https://github.com/topics/data-visualization" target="_blank" rel="noopener noreferrer">Data visualization</a> 汇总了数据可视化相关的一些开源项目，<a href="https://github.com/topics/awesome" target="_blank" rel="noopener noreferrer">Awesome Lists</a> 汇总了 Awesome 系列的仓库；</li>
<li>通过 Github Trending 我们可以看到最近比较热门的一些开源项目，我们可以按照语言类型以及时间维度对项目进行筛选；</li>
<li>Github Collections 类似一个收藏夹集合。比如 <a href="https://github.com/collections/teaching-computational-social-science" target="_blank" rel="noopener noreferrer">Teaching materials for computational social science</a> 这个收藏夹就汇总了计算机课程相关的开源资源，<a href="https://github.com/collections/learn-to-code" target="_blank" rel="noopener noreferrer">Learn to Code</a> 这个收藏夹就汇总了对你学习编程有帮助的一些仓库；</li>
<li>......</li>
</ol>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/github-explore.png" alt="" /></p>
<h2 id="github-actions-很强大"> GitHub Actions 很强大</h2>
<p>你可以简单地将 GitHub Actions 理解为 Github 自带的 CI/CD ，通过 GitHub Actions 你可以直接在 GitHub 构建、测试和部署代码，你还可以对代码进行审查、管理 API 、分析项目依赖项。总之，GitHub Actions 可以自动化地帮你完成很多事情。</p>
<p>关于 GitHub Actions 的详细介绍，推荐看一下阮一峰老师写的 <a href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener noreferrer">GitHub Actions 入门教程</a> 。</p>
<p>GitHub Actions 有一个官方市场，上面有非常多别人提交的 Actions ，你可以直接拿来使用。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20211227100147433.png" alt="" /></p>
<h2 id="后记"> 后记</h2>
<p>这一篇文章，我毫无保留地把自己这些年总结的 Github 小技巧分享了出来，真心希望对大家有帮助，真心希望大家一定要利用好 Gihub 这个专属程序员的宝藏。</p>
<p>另外，这篇文章中，我并没有提到 Github 搜索技巧。在我看来，Github 搜索技巧不必要记网上那些文章说的各种命令啥的，真没啥卵用。你会发现你用的最多的还是关键字搜索以及 Github 自带的筛选功能。</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201108192205620.png" type="image/png"/>
    </item>
    <item>
      <title>常用开发工具总结</title>
      <link>https://javaguide.cn/tools/</link>
      <guid>https://javaguide.cn/tools/</guid>
      <source url="https://javaguide.cn/rss.xml">常用开发工具总结</source>
      <pubDate>Wed, 05 Jan 2022 04:07:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="常用开发工具总结"> 常用开发工具总结</h1>
<h2 id="数据库"> 数据库</h2>
<ul>
<li><a href="./database/CHINER.html">CHINER: 干掉 PowerDesigner，这个国产数据库建模工具很强！</a></li>
<li><a href="./database/DBeaver.html">DBeaver:开源数据库管理工具。</a></li>
<li><a href="./database/screw.html">screw:一键生成数据库文档，堪称数据库界的Swagger</a></li>
</ul>
<h2 id="git"> Git</h2>
<ul>
<li><a href="./git/git-intro.html">Git 入门</a></li>
<li><a href="./git/git-intro.html">Github 小技巧</a></li>
</ul>
<h2 id="docker"> Docker</h2>
]]></content:encoded>
    </item>
  </channel>
</rss>